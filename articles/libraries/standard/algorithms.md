---
title: 'Q # Стандартные библиотеки — алгоритмы | Документация Майкрософт'
description: Стандартные библиотеки Q#
author: QuantumWriter
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
uid: microsoft.quantum.libraries.standard.algorithms
ms.openlocfilehash: 1c45808207a2020f603448eba05900cdc40b4916
ms.sourcegitcommit: 5094c0a60cbafdee669c8728b92df281071259b9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/06/2020
ms.locfileid: "77036361"
---
# <a name="quantum-algorithms"></a>Алгоритмы такта #

## <a name="amplitude-amplification"></a>Усиление амплитуды ##

*Усиление амплитуды* — одно из фундаментальных средств тактовых вычислений. Это фундаментальная идея, которая лежит в основе поиска Гровер, оценки амплитуды и многих алгоритмов машинного обучения для тактов.  Существует много вариантов, и в Q # Мы предоставляем общую версию на основе усиления амплитуды очевидным с частичными отражениями, чтобы обеспечить широкую область применения.

Центральной идеей для усиления амплитуды является повысить эффективность вероятность желаемого результата, выполняя последовательность отражений.  Эти отражения поворачивают начальное состояние ближе к желаемому целевому состоянию, которое часто называется помеченным состоянием.  В частности, если вероятность измерения начального состояния до помеченного состояния — $ \син ^ 2 (\сета) $, после применения усиления амплитуды $m $ раз вероятность успеха становится равна $ \син ^ 2 ((2 MБ + 1) \сета) $.  Это означает, что если $ \сета = \ PI/[2 (2n + 1)] $ для некоторого значения $n $, то при повышении амплитуды может повыситься вероятность успеха до $100\\% $ после $n $ итераций усиления амплитуды.  Начиная с $ \сета = \син ^{-1}(\Скрт{\пр (Success)}) $ это означает, что число итераций, необходимых для успешного получения результата, в корне меньше, чем ожидаемое число, необходимое для поиска помеченного состояния, недетерминированного с помощью случайной выборки.

Для каждой итерации усиления амплитуды необходимо указать два оператора отражения. В частности, если $Q $ является итерацией для усиления амплитуды и $P _0 $ является оператором-проектором на начальном подпространстве, а $P _1 $ является проектором на помеченный пробел, то $Q =-(\болдоне-2P_0) (\болдоне-2P_1) $.  Вспомним, что проектор — это Хермитиан оператор, который имеет еиженвалуес $ + $1 и $0 $, и в результате $ (\болдоне-2P_0) $ является единым, так как он имеет еиженвалуес, являющиеся корнями Unity (в данном случае $ \пм $1). В качестве примера рассмотрим вариант поиска Гровер с начальным состоянием $H ^ {\отимес n} \кет{0}$ и помечено состояние $ \кет{м} $, $P _0 = H ^ {\отимес n} \кет{0}\бра{0}H ^ {\отимес n} $ and $P _1 = \кет{м}\бра{м} $.  В большинстве приложений для усиления амплитуды $P _0 $ будет являться проектором на начальное состояние, означающее, что $P _0 = \болдоне-2 \ Сисакет {\ PSI} \ неверное {\ PSI} $ для некоторых векторов $ \кет{\пси} $; Однако для очевидным амплитуда ампликатион $P _0 $ обычно проецируется на множество состояний тактов (т. е. Кратность $1 еиженвалуе $P _0 $ больше $1 $).

Логика, основанная на усилении амплитуды, следует непосредственно за еижен-декомпозицией $Q $.  В частности, основе собственных векторов $Q $ о том, что начальное состояние имеет ненулевую поддержку, может отображаться как линейное $1 сочетание $P основе собственных векторов _0 $ и $P _1 $.  В частности, начальное состояние для усиления амплитуды (при условии, что это $ + $1 еиженвектор $P _0 $) может быть написано как $ $ \кет{\пси} = \фрак{-и}{\скрт{2}} \лефт (e ^ {и\сета} \ Сисакет {\ psi_ +} + e ^ {-и\сета} \ Сисакет {\ psi_-} \ригхт). $ $ где $ \кет{\ psi_ \пм} $ основе собственных векторов из $Q $ с еиженвалуес $e ^ {\pm 2i \ тета} $ и поддерживает только основе собственных векторов $ + $1 _0 из $P $ и $P _1 $.  Тот факт, что еиженвалуес $e ^ {\пм i \сета} $ означает, что оператор $Q $ выполняет поворот в двухмерном пространстве, заданном двумя проекторами, и начальное состояние, где угол поворота равен $2 \ тета $.  Именно поэтому после $m $ итераций $Q $ вероятность успеха равна $ \син ^ 2 ([2 MБ + 1] \сета) $.

Еще одно полезное свойство, которое выходит за пределы этого, заключается в том, что еиженвалуе $ \сета $ напрямую связан с вероятностью того, что первоначальное состояние было бы отмечено (в случае, когда $P _0 $ является проектором только в первоначальном состоянии).  Поскольку $Q еиженфасес $ имеет значение $2 \ тета = 2 \ Sin ^{-1}(\Скрт{\пр (Success)}) $, после применения оценки этапа к $Q $ можно узнать вероятность успеха в единой тактовой процедуре.  Это полезно, так как для изучения вероятности успеха, которая в противном случае потребовалась бы в случае успешного выполнения, требуется не менее чем больше приложений тактовой процедуры.

Q # вводит усиление амплитуды в качестве специализации усиления амплитуды очевидным.  Усиление амплитуды очевидным зарабатывает этот моникер, так как проектор на первоначальной еиженспаце не должен быть проектором в первоначальном состоянии.  В этом смысле протокол очевидным в исходное состояние.  Ключевое приложение усиления амплитуды очевидным — это определенные *линейные комбинации единых* методов моделирования хамилтониан, где начальное состояние неизвестно, но становится запутанными с регистрацией анЦилла в протоколе моделирования.  Если регистр анЦилла должен быть фиксированным значением, скажем $0 $, то такие методы моделирования применяют необходимое единое преобразование к оставшимся Кубитс (называемым системным регистром).  Однако все остальные результаты измерений ведут к сбою.  Усиление амплитуды очевидным позволяет повысить вероятность успеха этого измерения до $100\\% $ с помощью описанной выше причины.  Кроме того, обычное усиление амплитуды соответствует случаю, когда регистр системы пуст.  Именно поэтому Q # использует усиление амплитуды очевидным в качестве основной подпрограммы для усиления амплитуды.

Общая подпрограммы (`AmpAmpObliviousByReflectionPhases`) имеет два регистра, которые вызываются `ancillaRegister` и `systemRegister`. Он также принимает два Oracle для необходимых отражений. `ReflectionOracle` действует только в `ancillaRegister`, пока `ObliviousOracle` работает совместно с обеими регистрами. Входные данные для `ancillaRegister` должны быть инициализированы значением-1 еиженстате первого оператора отражения $ \болдоне-2P_1 $.

Как правило, Oracle готовит состояние в вычислительной базе $ \ket{0...0} $. В нашей реализации `ancillaRegister` состоит из одного кубит (`flagQubit`), управляющего `stateOracle` и остальной части требуемого анЦиллас. `stateOracle` применяется, если `flagQubit` имеет значение $ \кет{1}$.

Он также может предоставлять Oracle `StateOracle` и `ObliviousOracle` вместо отражения с помощью вызова `AmpAmpObliviousByOraclePhases`.

Как уже упоминалось, традиционная усиление амплитуды — это лишь особый случай использования этих подпрограмм, где `ObliviousOracle` является оператором идентификации и нет системных Кубитс (т. е. `systemRegister` пуст). Если вы хотите получить этапы для частичных отражений (например, для поиска Гровер), доступна функция `AmpAmpPhasesStandard`. Пример реализации алгоритма Гровер см. на `DatabaseSearch.qs`.

Мы будем связывать фазы ротации кубит с этапами оператора отражения, как описано в документе [Г.х. Low, I. L. Чжуанский](https://arxiv.org/abs/1707.05391). Используемые фазы фиксированной точки подробно описаны в [Йодер, Low и Чжуанский](https://arxiv.org/abs/1409.3305) вместе с этапами [Low, Йодер и Чжуанский](https://arxiv.org/abs/1603.03996).

В качестве фона можно начать с уровня " [стандартный](https://arxiv.org/abs/quant-ph/0005055) ", а затем перейти к вводу в [очевидным с усилением амплитуды](https://arxiv.org/abs/1312.1414) и, наконец, в [Чжуанский](https://arxiv.org/abs/1610.06546). Хорошим обзором всей области (как она относится к моделированию Хамилтониан) было [Dominic Берри](http://www.dominicberry.org/presentations/Durban.pdf).

## <a name="quantum-fourier-transform"></a>Преобразование Фурье для тактов ##

Преобразование Фурье является фундаментальным инструментом классического анализа и так же важно для вычислений тактов.
Кроме того, эффективность *преобразования Фурье* (Кфт) значительно превосходит то, что возможно на классической машине, делая ее одним из первых средств, которые можно выбрать при проектировании алгоритма такта.

Как приблизительная обобщение Кфт, мы предоставляем операцию <xref:microsoft.quantum.canon.approximateqft>, которая позволяет выполнять дальнейшую оптимизацию путем очистки поворотов, которые не являются строго необходимыми для требуемой точности алгоритма.
Для приблизительного Кфт требуется операция <xref:microsoft.quantum.intrinsic.rfrac> $Z $-вращение, а также <xref:microsoft.quantum.intrinsic.h>ная операция.
Предполагается, что входные и выходные данные кодируются в кодировке с обратным порядком байтов---т. е. кубит с индексом `0` кодируется в самом левом (верхнем) бит двоичного целочисленного представления.
Это соответствует [нотации Сисакет](xref:microsoft.quantum.concepts.dirac), как регистр трех Кубитс в состоянии $ \кет{100}$ соответствует $q _0 $ в состоянии $ \кет{1}$ while $q _1 $ и $q _2 $ — в состоянии $ \кет{0}$.
Параметр аппроксимации $a $ определяет уровень очистки $Z $-поворотов, т. е. $a \ин [0.. n] $.
В этом случае все $Z $-ротации $2 \ PI/2 ^ k $, где $k > $, удаляются из цепи Кфт.
Известно, что для $k \же \ log_2 (n) + \ log_2 (1/\епсилон) + $3. один может быть связан с $\\| \Операторнаме{Кфт}-\Операторнаме{акфт} \\| < \епсилон $.
Здесь $\\| \кдот\\| $ — это норма оператора, который в данном случае является квадратным корнем самого крупного [еиженвалуе](xref:microsoft.quantum.concepts.matrix-advanced) $ (\Операторнаме{Кфт}-\операторнаме{акфт}) (\Операторнаме{Кфт}-\операторнаме{акфт}) ^ \dagger $.

## <a name="arithmetic"></a>Арифметические ##

Как и в случае с арифметическими вычислениями, роль играет в сфере компьютерных вычислений.  Такие алгоритмы, как алгоритм факторинга Шор, методы моделирования тактов, а также многие алгоритмы оракулар полагаются на согласованные арифметические операции.  Большинство подходов к арифметической построению на основе цепей тактовой Adder.  Простейший Adder принимает классическое входное $b $ и добавляет значение в состояние такта, содержащее целое число $ \кет{а} $.  С помощью математического выражения Adder (который, по-вашему, стоит $ \Операторнаме{адд} (b) $ для классического ввода $b $) имеет свойство, которое

$ $ \Операторнаме{адд} (b) \кет{а} = \кет{а + b}.
$ $ Этот базовый канал Adder является более инкрементным, чем Adder.
Его можно преобразовать в Adder с двумя входными тактами через $ $ \Операторнаме{адд}\кет{а}\кет{б} = \кет{а}\кет{а + b}, $ $ использование $n $ контролируемых приложений методах в форме \бегин{алигн} \Операторнаме{адд} \ket{a} \ket{b} & = \Lambda\_{a\_0} \left (\operatorname{Add} (1) \right) \Lambda\_{\_1} \left (\operatorname{Add} (2) \right) \Lambda\_{\_2} \left (\operatorname{Add} (4) \right) \cdots \Lambda\_{a\_{n-1}} \left (\ операторнаме {Add} ({{n-1}}) \ригхт) \кет{а}\кет{б} \\\\ & = \кет{а} \кет{б + a}, \енд{алигн} для $n $-разрядных целых чисел $a $ и $b $ и сложения по модулю $2 ^ n $.  Помните, что нотация $ \Ламбда\_x (A) $ относится для любой операции $A $ к контролируемой версии этой операции с элементом управления кубит $x $ AS.

Аналогичным образом, классический контролируемый способ умножения (Модульная форма, которая необходима для алгоритма факторинга Шор) может быть выполнена с помощью аналогичной серии контролируемых дополнений: \бегин{алигн} \Операторнаме{мулт} (a) \кет{КС}\кет{б} & = \Ламбда\_{x\_0} \лефт (\Операторнаме{адд} (2 ^ 0 а) \right) \Lambda\_{a\_1} \left (\operatorname{Add} (2 ^ 1a) \right) \Lambda\_{\_2} \left (\operatorname{Add} (2 ^ 2 а) \right) \cdots \Lambda\_{x\_{ n-1}} \лефт (\Операторнаме{адд} ({2 ^ {n-1}} a) \ригхт) \кет{КС}\кет{б} \\\\ & = \кет{КС}\кет{б + AX}.
\енд{алигн} на тактовых компьютерах есть тонкость, которую вы можете заметить в определении $ \Операторнаме{мулт} $ выше.  В отличие от добавления, тактовая версия этой цепи сохраняет продукт входных данных во вспомогательном регистре, а не во входном регистре.  В этом примере регистр инициализируется значением $b $, но обычно он начинает удерживать нулевое значение.  Это необходимо в том случае, если в общем нет мультипликативные для общих $a $ и $x $.  Так как все операции над тактами, сохранение измерения, являются обратимыми, нам нужно сохранить достаточно информации, чтобы инвертировать умножение.  По этой причине результат сохраняется в отдельном массиве.  Этот прием необратимой операции, например умножения, в отдельном регистре называется «Беннет хитростью» после Чарли Беннет и является фундаментальным средством как в обратимых, так и в тактовых вычислениях.

Многие тактовые цепи были предложены для сложения, и каждый из них изучает различные компромиссы с точки зрения количества Кубитс (пробел) и количества требуемых операций (времени) шлюза.  Мы рассмотрим два эффективных методах, которые в значительной степени пространства называются Драпер Adder и Беаурегард Adder.

### <a name="draper-adder"></a>Драпер Adder ###

Драпер Adder, вероятно, является одним из самых элегантных методах тактов, так как он напрямую вызывает свойства такта для выполнения сложения.  Понимание Драпер Adder заключается в том, что преобразование Фурье можно использовать для перевода сдвига этапа в Поразрядный сдвиг.  Затем следует применить преобразование Фурье, применить соответствующие сдвиги этапа, а затем отменить преобразование Фурье, чтобы реализовать Adder.  В отличие от многих других методах, Драпер Adder явно использует тактовые эффекты, появившиеся в процессе преобразования Фурье в тактовой форме.  У него нет естественного классического аналога.  Ниже приведены конкретные шаги Драпер Adder.

Предположим, что у вас есть два $n $-битных регистров кубит, в которых хранятся целые числа $a $ и $b $ then для всех $a $ $ $ \Операторнаме{Кфт}\кет{а} = \фрак{1}{\sqrt{2 ^ n}} \сум\_{j = 0} ^ {2 ^ n-1} e ^ {i2\pi (AJ)/2 ^ n} \кет{ж}.
$ $ Если мы определяем $ $ \кет{\фи\_k (a)} = \фрак{1}{\скрт{2}} \лефт (\кет{0} + e ^ {i2\pi a/2 ^ k} \кет{1} \ригхт), $ $ после некоторой переустановки можно увидеть, что $ $ \Операторнаме{Кфт}\кет{а} = \кет{\фи\_1 (a)} \отимес \cdots \otimes \ket{\Phi\_n (a)}.
$ $ Путь к выполнению Adder после этого оказывается ясным, так как сумма входных данных может быть записана как $ $ \кет{а + b} = \Операторнаме{Кфт} ^{-1}\кет{\фи\_1 (a + b)} \отимес \кдотс \отимес \кет{\фи\_n (a + b)}.
$ $ После этого можно добавить целые числа $b $ и $a $, выполнив управляемый поворот на каждом из Кубитс в декомпозиции с использованием битов $b $ в качестве элементов управления.

Это расширение можно упростить, отметив, что для любого целого числа $j $ и вещественное число $x $ $e ^ {i2\pi (x + j)} = e ^ {i2\pi x} $.  Это связано с тем, что если вы поворачиваете $360 ^ {\Цирк} $ градусы ($ 2 \ PI $ радианы) в круге, то сможете точно приступить к работе.  Единственная важная часть $x $ for $e ^ {i2\pi x} $, таким образом, является дробной частью $x $.  В частности, если у нас есть двоичное расширение формы $x = y +0. x\_0x\_2 \ лдотс x\_n $ then $e ^ {i2\pi x} = e ^ {i2\pi (0. x\_0x\_2 \ лдотс x\_{n-1})} $ и, следовательно, $ $ \кет{\фи\_k (a + b)} = \фрак{1}{\скрт{2}} \лефт (\кет{0} + e ^ {i2\pi [a/2 ^ k +0. b\_к\лдотс b\_1]} \кет{1} \ригхт). $ $ Это означает, что при выполнении сложения путем увеличения каждого элемента тензорные факторы при расширении преобразования Фурье $ \кет{а} $ затем число поворотов сокращается по мере $k $ Shrink.  Это значительно сокращает число шлюзов тактов, необходимых в Adder.  Мы обносим преобразование Фурье, этапное Добавление и шаги обратного преобразования Фурье, которые составляют Драпер Adder как $ \Операторнаме{Кфт} ^{-1} \лефт (\фи\\\!\Операторнаме{адд}\ригхт) \Операторнаме{Кфт} $. Ниже показана тактовая цепь, использующая эту упрощение для реализации всего процесса.

![Драпер Adder показан в виде схемы цепи](~/media/draper.png)

Каждый контролируемый $e ^ {I2 \ PI/k} $ в цепи относится к управляемому шлюзу.  Такие шлюзы имеют свойство, связанное с парой Кубитс, в которой они действуют, $ \кет{00}\мапсто \кет{00}$, а $ \кет{11}\мапсто e ^ {I2 \ PI/k} \ Сисакет{11}$.  Эта цепь позволяет нам выполнять сложение без дополнительных Кубитс, кроме тех, которые необходимы для хранения входных и выходных данных.

### <a name="beauregard-adder"></a>Беаурегард Adder ###

Беаурегард Adder — это тактовая Модульная Adder, использующая Драпер Adder для выполнения сложения по модулю $N $ для произвольного положительного целого числа $N $.  Значение тактовой модульной методахи, например Беаурегард Adder, разработано в больших экстентах, от их использования в действии модульного энерговедения в рамках алгоритма Шор для факторинга.  Тактовая Модульная Modular Adder имеет следующее действие для входных данных такта $ \кет{б} $ и классического входного $a $, где $a $ и $b $ представляют собой целые числа mod $N $. Это означает, что они находятся в интервале $ [0, \лдотс, N-1] $.

$ $ \кет{б}\ригхтарров \кет{б + a \текст{mod} N} = \бегин{Касес} \кет{б + a}, & б + a < N\\\\ \кет{б + a-N}, & (b + a) \же N \енд{Касес}.
$$

Беаурегард Adder использует Драпер Adder, или точнее $ \фи\\\!\Операторнаме{адд} $, чтобы добавить $a $ и $b $ in.  Затем она использует ту же операцию для того, чтобы определить, $a + b < N $ путем вычитания $N $ и проверки, если $a + b-N < 0 $.  Эта информация хранится в вспомогательной кубит, а затем добавляется $N $ обратно в регистр, если $a + b < N $.  Затем он завершается невычислением этого вспомогательного бита (этот шаг необходим для того, чтобы анЦилла можно было отменить выделение после вызова Adder).  Цепь для Беаурегард Adder указана ниже.

![Беаурегард Adder показан в виде схемы цепи](~/media/beau.png)

В данном случае \Операторнаме{адд} $ \Фи\\\!$ имеет ту же форму, что и $ \фи\\\!\Операторнаме{адд} $, за исключением того, что в этом контексте входные данные являются классическим, а не тактом.  Это позволяет заменять контролируемые этапы в $ \Фи\\\!\Операторнаме{адд} $ на шлюзы фаз, которые затем можно скомпилировать вместе в меньшее количество операций, чтобы сократить число Кубитс и число шлюзов, необходимое для Adder.

Дополнительные сведения см. в разделе [M. роеттелер, TH. Бет](http://doi.org/10.1007/s00200-008-0072-2 ) и [D. копперсмис](https://arxiv.org/abs/quant-ph/0201067).

### <a name="quantum-phase-estimation"></a>Оценка квантовых фаз ###

Одним из важнейших приложений преобразования Фурье в тактовой ситуации является изучение еиженвалуес операторов, которые называются *оценкой этапа*.
Рассмотрим единое $U $ и состояние $ \кет{\фи} $ таким, что $ \кет{\фи} $ является еиженстате $U $ с неизвестным еиженвалуе $ \фи $, \бегин{екуатион} У\кет {\ фи} = \фи\кет{\фи}.
\енд{екуатион} если у нас есть только доступ к $U $ в качестве Oracle, то мы можем изучить этап $ \фи $, используя, что $Z $ повороты, примененные к цели управляемой операции, передаются обратно в элемент управления.

Предположим, что $V $ является управляемым приложением $U $, таким как \бегин{алигн} V (\кет{0} \отимес \кет{\фи}) & = \кет{0} \отимес \кет{\фи} \\\\ \текстрм{и} V (\кет{1} \отимес \кет{\фи}) & = e ^ {i \Phi} \ket{1} \otimes \ket{\Phi}.
\енд{алигн}, по линейной шкале, \бегин{алигн} V (\кет{+} \отимес \кет{\фи}) & = \фрак{(\кет{0} \отимес \кет{\фи}) + e ^ {i \фи} (\ket{1} \otimes \ket{\Phi})} {\sqrt{2}}.
\енд{алигн} мы можем собираются термины, чтобы найти \бегин{алигн} V (\кет{+} \отимес \кет{\фи}) & = \фрак{\кет{0} + e ^ {i \фи} \кет{1}} {\скрт{2}} \отимес \ket{\Phi} \\\\ & = (R_1 (\Phi) \ket{+}) \otimes \ket{\Phi}, \end{align}, где $R _1 $ является единым, примененным операцией <xref:microsoft.quantum.intrinsic.r1>.
Иначе говоря, результат применения $V $ точно такой же, как применение $R _1 $ с неизвестным углом, несмотря на то, что у нас есть доступ только к $V $ в качестве Oracle.
Таким образом, в оставшейся части этого обсуждения мы рассмотрим оценку этапа в терминах $R _1 (\фи) $, которые мы реализуем с помощью так называемого *этапа киккбакк*.

Так как элемент управления и целевой регистр остаются унтанглед после этого процесса, мы можем повторно использовать $ \кет{\фи} $ в качестве целевого объекта управляемого приложения $U ^ $2 для подготовки второго элемента управления кубит в состоянии $R _1 (2 \фи) \кет{+} $.
Продолжая таким образом, можно получить регистр в формате \бегин{алигн} \кет{\пси} & = \ sum_ {j = 0} ^ n R_1 (2 ^ j \фи) \кет{+} \\\\ & \пропто \ bigotimes_ {j = 0} ^ {n} \лефт (\кет{0} + \експ (i 2 ^ {j} \фи) \кет{1}\ригхт) \\\\ & \пропто \ sum_ {k = 0} ^ {2 ^ n – 1} \експ (i \Phi k) \ket{k} \end{align}, где $n $ — число требуемых разрядов точности, и где мы использовали ${} \propto {}$, чтобы указать, что мы отменяли коэффициент нормализации $ 1/\sqrt{2 ^ n} $.

Если предполагается, что $ \фи = 2 \пи p/2 ^ k $ для целого числа $p $, то мы понимаем это как $ \кет{\пси} = \Операторнаме{Кфт} \кет{p_0 p_1 \дотс p_n} $, где $p _j $ — $j ^ {\текстрм{с}} $ $2 \пи \фи $.
Применяя смежную часть преобразования Фурье в тактовой области, мы получаем двоичное представление этапа, закодированного как состояние такта.

В Q # это реализуется операцией <xref:microsoft.quantum.characterization.quantumphaseestimation>, которая принимает <xref:microsoft.quantum.oracles.discreteoracle> реализацию приложения $U ^ m $ в качестве функции положительных целых чисел $m $.
