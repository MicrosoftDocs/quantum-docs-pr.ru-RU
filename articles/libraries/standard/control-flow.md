---
title: 'Элементы управления потоком в Q # Standard либарариес'
description: 'Сведения об операциях и функциях управления потоком в стандартной библиотеке Microsoft Q #.'
author: QuantumWriter
uid: microsoft.quantum.concepts.control-flow
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: b41b3edd7a3e3ac13dbda106a869f4cba8183600
ms.sourcegitcommit: 6ccea4a2006a47569c4e2c2cb37001e132f17476
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/28/2020
ms.locfileid: "77907177"
---
# <a name="higher-order-control-flow"></a>Поток управления высшего порядка #

Одна из основных ролей стандартной библиотеки заключается в том, чтобы упростить выражать алгоритмы, основанные на высоком уровне, в качестве [тактовых программ](https://en.wikipedia.org/wiki/Quantum_programming).
Таким же, Q # Canon предоставляет множество различных конструкций управления потоком, каждый из которых реализуется с помощью частичного применения функций и операций.
В качестве примера рассмотрим случай, когда один из них хочет создать «КНОТную лестницу» для регистра:

```qsharp
let nQubits = Length(register);
CNOT(register[0], register[1]);
CNOT(register[1], register[2]);
// ...
CNOT(register[nQubits - 2], register[nQubits - 1]);
```

Этот шаблон можно выразить с помощью циклов итерации и `for`.

```qsharp
for (idxQubit in 0..nQubits - 2) {
    CNOT(register[idxQubit], register[idxQubit + 1]);
}
```

Однако в терминах <xref:microsoft.quantum.canon.applytoeachca> и функций работы с массивами, таких как <xref:microsoft.quantum.arrays.zip>, это гораздо короче и проще в чтении:

```qsharp
ApplyToEachCA(CNOT, Zip(register[0..nQubits - 2], register[1..nQubits - 1]));
```

В оставшейся части этого раздела мы предоставили несколько примеров того, как использовать различные операции и функции управления потоком, предоставляемые процедурой Canon для сжатия тактовых программ.

## <a name="applying-operations-and-functions-over-arrays-and-ranges"></a>Применение операций и функций к массивам и диапазонам ##

Одной из основных абстракций, предоставляемых Canon, является итерация.
Например, рассмотрим единую форму $U \отимес U \отимес \кдотс \отимес U $ для однокубит единого $U $.
В Q # можно использовать <xref:microsoft.quantum.arrays.indexrange>, чтобы представить это как `for` цикл по регистру:

```qsharp
/// # Summary
/// Applies $H$ to all qubits in a register.
operation ApplyHadamardToAll(
    register : Qubit[])
: Unit is Adj + Ctl {
    for (qubit in register) {
        H(qubit);
    }
}
```

Затем эту новую операцию можно использовать в качестве `HAll(register)` для применения $H \отимес H \кдотс \отимес H $.

Однако это довольно сложно, особенно в более крупном алгоритме.
Более того, этот подход специализируется на конкретной операции, которую мы хотим применить к каждому кубит.
Мы можем использовать тот факт, что операции являются первым классом для более четкого выражения этой концепции алгоритма:

```qsharp
ApplyToEachCA(H, register);
```

В этом случае суффикс `CA` указывает, что вызов `ApplyToEach` сам является аджоинтабле и управляемым.
Таким образом, если `U` поддерживает `Adjoint` и `Controlled`, следующие строки эквивалентны:

```qsharp
Adjoint ApplyToEachCA(U, register);
ApplyToEachCA(Adjoint U, register);
```

В частности, это означает, что вызовы `ApplyToEachCA` могут присутствовать в операциях, для которых происходит автоматическое создание примыкающей специализации.
Аналогичным образом <xref:microsoft.quantum.canon.applytoeachindex> удобно использовать для представления шаблонов формы `U(0, targets[0]); U(1, targets[1]); ...`и предоставляет версии для каждого сочетания операторов, поддерживаемого его входными данными.

> [!TIP]
> `ApplyToEach` является параметризованным, так что его можно использовать с операциями, принимающими входные данные, отличные от `Qubit`.
> Например, предположим, что `codeBlocks` является массивом <xref:microsoft.quantum.errorcorrection.logicalregister> значений, которые необходимо восстановить.
> Затем `ApplyToEach(Recover(code, recoveryFn, _), codeBlocks)` применит код исправления ошибок `code` и функции восстановления `recoveryFn` в каждом блоке отдельно.
> Это справедливо даже для классических входных данных: `ApplyToEach(R(_, _, qubit), [(PauliX, PI() / 2.0); (PauliY(), PI() / 3.0]))` применит поворот на $ \пи/$2 о $X $, за которым следует поворот $pi/$3 о $Y $.

В Q # Canon также предусмотрена поддержка классических схем перечисления, знакомых с функциональным программированием.
Например, <xref:microsoft.quantum.arrays.fold> реализует шаблон $f (f (s\_{\текст{инитиал}}, x\_0), x\_1), \дотс) $ для сокращения функции по списку.
Этот шаблон можно использовать для реализации сумм, продуктов, прыжка, прыжка и других таких функций:

```qsharp
open Microsoft.Quantum.Arrays;
function Plus(a : Int, b : Int) : Int { return a + b; }
function Sum(xs : Int[]) {
    return Fold(Sum, 0, xs);
}
```

Аналогично, такие функции, как <xref:microsoft.quantum.arrays.mapped> и <xref:microsoft.quantum.arrays.mappedbyindex>, можно использовать для выражения концепций функционального программирования в Q #.

## <a name="composing-operations-and-functions"></a>Составление операций и функций ##

Конструкции потока управления, предлагаемые процедурой Canon, принимают операции и функции в качестве их входных данных, поэтому полезно иметь возможность объединить несколько операций или функций в один вызываемый.
Например, шаблон $UVU ^ {\дагжер} $ является чрезвычайно распространенным при программировании на такте, так что Canon предоставляет операцию <xref:microsoft.quantum.canon.applywith> в качестве абстракции для этого шаблона.
Эта абстракция также позволяет более эффективно выполнять обработку в цепи, так как `Controlled`, действуя в `U(qubit); V(qubit); Adjoint U(qubit);` последовательности, не требуется действовать на каждом `U`.
Чтобы увидеть это, позвольте $c (U) $ быть единым, представляющим `Controlled U([control], target)`, и позвольте $c (V) $ быть определено таким же образом.
Затем для произвольного состояния $ \кет{\пси} $, \бегин{алигн} c (U) c (V) c (U) ^ \дагжер \кет{1} \отимес \кет{\пси} & = \кет{1} \отимес (УВУ ^ {\дагжер} \кет{\пси}) \\\\ & = (\boldone \otimes u) (c (V)), \boldone{1} \otimes
\енд{алигн} по определению `Controlled`.
С другой стороны, \бегин{алигн} c (U) c (V) c (U) ^ \дагжер \кет{0} \отимес \кет{\пси} & = \кет{0} \отимес \кет{\пси} \\\\ & = \кет{0} \отимес (УУ ^ \dagger \ket{\psi}) \\\\ & = (\boldone \otimes U) (c (V)) (\boldone \otimes U ^ \dagger) \ket{0} \otimes \ket{\psi}.
\енд{алигн} по линейной шкале, мы можем заключить, что мы можем $U $ out таким образом для всех состояний входных данных.
То есть $c (УВУ ^ \дагжер) = U c (V) U ^ \дагжер $.
Так как управление операциями может быть дорогостоящей в целом, использование контролируемых вариантов, таких как `WithC` и `WithCA`, может помочь уменьшить число операторов элементов управления, которые необходимо применить.

> [!NOTE]
> Еще одним следствием того, $U $, является то, что нам не нужно знать, как применить `Controlled` функтор к `U`.
> `ApplyWithCA`, таким образом, имеет более слабую сигнатуру, чем может быть ожидаемо:
> ```qsharp
> ApplyWithCA<'T> : (('T => Unit is Adj),
>     ('T => Unit is Adj + Ctl), 'T) => Unit
> ```

Аналогичным образом <xref:microsoft.quantum.canon.bound> создает операции, которые в свою очередь применяют последовательность других операций.
Например, следующие эквивалентны:

```qsharp
H(qubit); X(qubit);
Bound([H, X], qubit);
```

Сочетание с шаблонами итерации может сделать это особенно полезно:

```qsharp
// Bracket the quantum Fourier transform with $XH$ on each qubit.
ApplyWith(ApplyToEach(Bound([H, X]), _), QFT, _);
```

### <a name="time-ordered-composition"></a>Компоновка с сортировкой по времени ###

Мы можем еще дальше придумать управление потоком в терминах частичного приложения и классических функций, а также моделировать даже довольно сложные тактовые концепции с точки зрения классического управления потоком.
Эта аналогия выполняется точно в соответствии с определением того, что единые операторы точно соответствуют побочным эффектам вызывающих операций, так что любая декомпозиция отдельных операторов с точки зрения других операторов соответствует созданию определенного вызов последовательности для классических подпрограмм, которые выдают инструкции для выполнения в качестве отдельных операторов.
В этом представлении `Bound` является точным представлением матричного произведения, поскольку `Bound([A, B])(target)` эквивалентна `A(target); B(target);`, которая, в свою очередь, является вызывающей последовательностью, соответствующей $BA $.

Более сложным примером является [расширение Троттер – Сузуки](https://arxiv.org/abs/math-ph/0506007v1).
Как обсуждалось в разделе представление динамического генератора [структур данных](xref:microsoft.quantum.libraries.data-structures), расширение Троттер – Сузуки предоставляет особенно полезный способ выражения экспоненциальных Экспонент.
Например, применение расширения в самом нижнем порядке дает для любых операторов $A $ и $B $ таким, что $A = A ^ \дагжер $ and $B = B ^ \дагжер $, \бегин{алигн} \таг{★} \лабел{ЕК: Троттер-Сузуки-0} \експ (i [A + B] t) = \ lim_ {н\то\инфти} \лефт (\експ (я A т/д) \exp (i B t/n) \right) ^ n.
\енд{алигн} разговорной речи, это говорит о том, что мы можем приблизительно развивать состояние в $A + B $B $A $.
Если мы представляем развитие в рамках $A $ с помощью операции `A : (Double, Qubit[]) => Unit`, которая применяет $e ^ {i t} $, то представление расширения Троттер – Сузуки в плане переупорядочения последовательностей вызовов станет ясным.
Конкретнее, при наличии операции, `U : ((Int, Double, Qubit[]) => Unit is Adj + Ctl` такой `A = U(0, _, _)` и `B = U(1, _, _)`, мы можем определить новую операцию, представляющую целую часть `U` $t $ путем создания последовательностей формы.

```qsharp
U(0, time / Float(nSteps), target);
U(1, time / Float(nSteps), target);
U(0, time / Float(nSteps), target);
U(1, time / Float(nSteps), target);
// ...
```

На этом этапе мы теперь можем потроттер о расширении Сузуки *без ссылки на механизм тактов*.
Развертывание фактически представляет собой очень конкретный шаблон итерации, на который послужила $ \екреф{ЕК: Троттер-Сузуки-0} $.
Этот шаблон итерации реализуется <xref:microsoft.quantum.canon.decomposeintotimestepsca>:

```qsharp
// The 2 indicates how many terms we need to decompose,
// while the 1 indicates that we are using the
// first-order Trotter–Suzuki decomposoition.
DecomposeIntoTimeStepsCA((2, U), 1);
```

Сигнатура `DecomposeIntoTimeStepsCA` соответствует общему шаблону в Q #, где коллекции, которые могут быть включены в массивы, или что-то, какие элементы вычислений в режиме реального времени представлены кортежами, первыми элементами которых являются `Int` значения длины.

## <a name="putting-it-together-controlling-operations"></a>Совместное размещение: управление операциями ##

Наконец, Canon строится на `Controlled` функтор, предоставляя дополнительные способы выполнения условных операций в такте.
Обычно, особенно в тактовой арифметике, к условным операциям на основе состояний вычислительных операций, отличных от $ \ket{0\cdots 0} $.
Используя операции управления и функции, представленные выше, можно использовать более общие тактовые условия в одной инструкции.
Давайте перейдем к тому, как <xref:microsoft.quantum.canon.controlledonbitstring> делает это (параметры типа San), а затем разбивает их на одну.
Первое, что нужно сделать, — это определить операцию, которая фактически выполняет тяжелую работу по реализации элемента управления на случайном уровне вычислительных операций.
Однако мы не будем вызывать эту операцию напрямую, поэтому мы добавляем `_` к началу имени, чтобы указать, что это реализация другой конструкции в другом расположении.

```qsharp
operation _ControlledOnBitString(
    bits : Bool[],
    oracle: (Qubit[] => Unit is Adj + Ctl),
    controlRegister : Qubit[],
    targetRegister: Qubit[])
: Unit is Adj + Ctl
```

Обратите внимание, что мы принимаем строку битов, представленную в виде массива `Bool`, который мы используем для указания условия, которое нужно применить к операции `oracle`, которую мы присваиваем.
Так как эта операция фактически выполняет приложение напрямую, нам также нужно взять контрольные и целевые регистры, представленные здесь как `Qubit[]`.

Далее обратите внимание, что Управление состоянием вычислительного основания $ \кет{\век{с}} = \кет{с\_0 s\_1 \дотс s\_{n-1}} $ для разрядной строки $ \век{с} $ может быть реализовано путем преобразования $ \кет{\век{с}} $ в $ \ket{0\cdots 0} $.
В частности, $ \кет{\век{с}} = X ^ {s\_0} \отимес X ^ {s\_1} \отимес \кдотс \отимес X ^ {s\_{n-1}} \ket{0\cdots 0} $.
Начиная с $X ^ {\дагжер} = X $, это означает, что $ \ket{0\dots 0} = X ^ {s\_0} \отимес X ^ {s\_1} \отимес \кдотс \отимес X ^ {s\_{n-1}} \кет{\век{с}} $.
Таким образом, можно применить $P = X ^ {s\_0} \отимес X ^ {s\_1} \отимес \кдотс \отимес X ^ {s\_{n-1}} $, Apply `Controlled oracle`и преобразовать обратно в $ \век{с} $.
Эта конструкция в точности `ApplyWith`, поэтому мы записываем тело нашей новой операции соответствующим образом:

```qsharp
{
    ApplyWithCA(
        ApplyPauliFromBitString(PauliX, false, bits, _),
        (Controlled oracle)(_, targetRegister),
        controlRegister
    );
}
```

Здесь мы использовали <xref:microsoft.quantum.canon.applypaulifrombitstring> для применения $P $, частичного применения к его цели для использования с `ApplyWith`.
Однако обратите внимание, что нам нужно преобразовать *контрольную* регистрацию в нашу требуемую форму, поэтому мы частично применяли внутреннюю операцию `(Controlled oracle)` на *целевом объекте*.
Это оставляет `ApplyWith`, действуя в скобки с $P $ точно так же, как и нужно.

На этом этапе можно было бы сделать, но это не противоречит тем, что наша новая операция не имеет такого поведения, как применение `Controlled` функтор.
Поэтому мы завершаем определение нашей новой концепции потока управления путем написания функции, которая принимает Управление Oracle и возвращает новую операцию.
В этом случае наша новая функция выглядит и работает так же, как `Controlled`, что позволяет легко определять мощные новые конструкции потока управления с помощью Q # и Canon вместе:

```qsharp
function ControlledOnBitString(
    bits : Bool[],
    oracle: (Qubit[] => Unit is Adj + Ctl))
: ((Qubit[], Qubit[]) => Unit is Adj + Ctl) {
    return _ControlledOnBitString(bits, oracle, _, _);
}
```
