---
title: 'Q # Стандартные библиотеки — структуры данных | Документация Майкрософт'
description: 'Q # Стандартные библиотеки — структуры данных'
author: QuantumWriter
uid: microsoft.quantum.libraries.data-structures
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: e8b28561f1aba37cb5bf41c6176386d19bfacf06
ms.sourcegitcommit: 8becfb03eb60ba205c670a634ff4daa8071bcd06
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/27/2019
ms.locfileid: "73184514"
---
# <a name="data-structures-and-modeling"></a><span data-ttu-id="e7e81-103">Структуры и моделирование данных</span><span class="sxs-lookup"><span data-stu-id="e7e81-103">Data Structures and Modeling</span></span> #

## <a name="classical-data-structures"></a><span data-ttu-id="e7e81-104">Классические структуры данных</span><span class="sxs-lookup"><span data-stu-id="e7e81-104">Classical Data Structures</span></span> ##

<span data-ttu-id="e7e81-105">Вместе с определяемыми пользователем типами для представления тактовых концепций Canon также предоставляет операции, функции и типы для работы с классическими данными, используемыми в управлении тактовыми системами.</span><span class="sxs-lookup"><span data-stu-id="e7e81-105">Along with user-defined types for representing quantum concepts, the canon also provides operations, functions, and types for working with classical data used in the control of quantum systems.</span></span>
<span data-ttu-id="e7e81-106">Например, функция <xref:microsoft.quantum.arrays.reversed> принимает массив в качестве входных данных и возвращает один и тот же массив в обратный порядок.</span><span class="sxs-lookup"><span data-stu-id="e7e81-106">For instance, the <xref:microsoft.quantum.arrays.reversed> function takes an array as input and returns the same array in reverse order.</span></span>
<span data-ttu-id="e7e81-107">Затем его можно использовать в массиве типа `Qubit[]`, чтобы избежать применения ненужных \Операторнаме{СВАП} $ Gates при преобразовании между тактовыми представлениями целых чисел.</span><span class="sxs-lookup"><span data-stu-id="e7e81-107">This can then be used on an array of type `Qubit[]` to avoid having to apply unnecessary $\operatorname{SWAP}$ gates when converting between quantum representations of integers.</span></span>
<span data-ttu-id="e7e81-108">Аналогичным образом мы видели в предыдущем разделе Типы формы `(Int, Int -> T)` могут быть полезны для представления коллекций произвольного доступа, поэтому функция <xref:microsoft.quantum.arrays.lookupfunction> предоставляет конвиенент способ создания таких типов из типов массивов.</span><span class="sxs-lookup"><span data-stu-id="e7e81-108">Similarly, we saw in the previous section that types of the form `(Int, Int -> T)` can be useful for representing random access collections, so the <xref:microsoft.quantum.arrays.lookupfunction> function provides a convienent way of constructing such types from array types.</span></span>

### <a name="pairs"></a><span data-ttu-id="e7e81-109">Пар</span><span class="sxs-lookup"><span data-stu-id="e7e81-109">Pairs</span></span> ###

<span data-ttu-id="e7e81-110">Canon поддерживает нотацию функционального стиля для пар, дополняющих доступ к кортежам по деконструкции:</span><span class="sxs-lookup"><span data-stu-id="e7e81-110">The canon supports functional-style notation for pairs, complementing accessing tuples by deconstruction:</span></span>

```qsharp
let pair = (PauliZ, register); // type (Pauli, Qubit[])
ApplyToEach(H, Snd(pair)); // No need to deconstruct to access the register.
```

### <a name="arrays"></a><span data-ttu-id="e7e81-111">Массивы</span><span class="sxs-lookup"><span data-stu-id="e7e81-111">Arrays</span></span> ###

<span data-ttu-id="e7e81-112">Canon предоставляет несколько функций для управления массивами.</span><span class="sxs-lookup"><span data-stu-id="e7e81-112">The canon provides several functions for manipulating arrays.</span></span>
<span data-ttu-id="e7e81-113">Эти функции являются параметризованными и поэтому могут использоваться с массивами любого типа Q #.</span><span class="sxs-lookup"><span data-stu-id="e7e81-113">These functions are type-parameterized, and thus can be used with arrays of any Q# type.</span></span>
<span data-ttu-id="e7e81-114">Например, функция <xref:microsoft.quantum.arrays.reversed> возвращает новый массив, элементы которого находятся в обратном порядке от входных данных.</span><span class="sxs-lookup"><span data-stu-id="e7e81-114">For instance, the <xref:microsoft.quantum.arrays.reversed> function returns a new array whose elements are in reverse order from its input.</span></span>
<span data-ttu-id="e7e81-115">Это можно использовать для изменения способа представления регистра такта при вызове операций:</span><span class="sxs-lookup"><span data-stu-id="e7e81-115">This can be used to change how a quantum register is represented when calling operations:</span></span>

```qsharp
let leRegister = LittleEndian(register);
// QFT expects a BigEndian, so we can reverse before calling.
QFT(BigEndian(Reversed(leRegister!)));
// This is how the LittleEndianAsBigEndian function is implemented:
QFT(LittleEndianAsBigEndian(leRegister));
```

<span data-ttu-id="e7e81-116">Аналогичным образом функция <xref:microsoft.quantum.arrays.subarray> может использоваться для переупорядочивания или получения подмножеств элементов массива:</span><span class="sxs-lookup"><span data-stu-id="e7e81-116">Similarly, the <xref:microsoft.quantum.arrays.subarray> function can be used to reorder or take subsets of the elements of an array:</span></span>

```qsharp
// Applies H to qubits 2 and 5.
ApplyToEach(H, Subarray([2, 5], register));
```

<span data-ttu-id="e7e81-117">В сочетании с управлением потоком функции работы с массивами, такие как <xref:microsoft.quantum.arrays.zip>, могут предоставить мощный способ для выражения тактовых программ:</span><span class="sxs-lookup"><span data-stu-id="e7e81-117">When combined with flow control, array manipulation functions such as <xref:microsoft.quantum.arrays.zip> can provide a powerful way to express quantum programs:</span></span>

```qsharp
// Applies X₃ Y₁ Z₇ to a register of any size.
ApplyToEach(
    ApplyPauli(_, register),
    Map(
        EmbedPauli(_, _, Length(register)),
        Zip([PauliX, PauliY, PauliZ], [3, 1, 7])
    )
);
```

## <a name="oracles"></a><span data-ttu-id="e7e81-118">Oracle</span><span class="sxs-lookup"><span data-stu-id="e7e81-118">Oracles</span></span> ##

<span data-ttu-id="e7e81-119">При [оценке этапов](https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm) и повышении [амплитуды](https://en.wikipedia.org/wiki/Amplitude_amplification) понятие Oracle часто встречается.</span><span class="sxs-lookup"><span data-stu-id="e7e81-119">In the [phase estimation](https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm) and [amplitude amplification](https://en.wikipedia.org/wiki/Amplitude_amplification) literature the concept of an oracle appears frequently.</span></span>
<span data-ttu-id="e7e81-120">Здесь термин Oracle означает подпрограммы такта блаккбокс, которая работает с набором Кубитс и возвращает ответ в качестве фазы.</span><span class="sxs-lookup"><span data-stu-id="e7e81-120">Here the term oracle refers to a blackbox quantum subroutine that acts upon a set of qubits and returns the answer as a phase.</span></span>
<span data-ttu-id="e7e81-121">Эту подпрограммы часто можно рассматривать как входные данные для алгоритма такта, который принимает Oracle, в дополнение к некоторым другим параметрам и применяет ряд операций в такте и обрабатывая вызов этой подпрограммы-такта, как если бы это был фундаментальный шлюз.</span><span class="sxs-lookup"><span data-stu-id="e7e81-121">This subroutine often can be thought of as an input to a quantum algorithm that accepts the oracle, in addition to some other parameters, and applies a series of quantum operations and treating a call to this quantum subroutine as if it were a fundamental gate.</span></span>
<span data-ttu-id="e7e81-122">Очевидно, что для реализации более крупного алгоритма необходимо предоставить конкретную декомпозицию Oracle в фундаментальных шлюзах, но такая декомпозиция не требуется для понимания алгоритма, который вызывает Oracle.</span><span class="sxs-lookup"><span data-stu-id="e7e81-122">Obviously, in order to actually implement the larger algorithm a concrete decomposition of the oracle into fundamental gates must be provided but such a decomposition is not needed in order to understand the algorithm that calls the oracle.</span></span>
<span data-ttu-id="e7e81-123">В Q # эта абстракция представляется с помощью таких операций, которые являются значениями первого класса, так что операции могут передаваться в реализации алгоритмов тактов в виде черного ящика.</span><span class="sxs-lookup"><span data-stu-id="e7e81-123">In Q#, this abstraction is represented by using that operations are first-class values, such that operations can be passed to implementations of quantum algorithms in a black-box manner.</span></span>
<span data-ttu-id="e7e81-124">Более того, определяемые пользователем типы используются для обозначения различных представлений Oracle в строго типизированном виде, что затрудняет случайное затемнение различных типов операций с черными ящиками.</span><span class="sxs-lookup"><span data-stu-id="e7e81-124">Moreover, user-defined types are used to label the different oracle representations in a type-safe way, making it difficult to accidently conflate different kinds of black box operations.</span></span>

<span data-ttu-id="e7e81-125">Такие Oracle отображаются в разных контекстах, в том числе на таких известных примерах, как алгоритмы [поиска Гровер](https://en.wikipedia.org/wiki/Grover%27s_algorithm) и моделирования тактов.</span><span class="sxs-lookup"><span data-stu-id="e7e81-125">Such oracles appear in a number of different contexts, including famous examples such as [Grover's search](https://en.wikipedia.org/wiki/Grover%27s_algorithm) and quantum simulation algorithms.</span></span>
<span data-ttu-id="e7e81-126">Здесь основное внимание уделяется Oracle, необходимым только для двух приложений: усиление амплитуды и оценка фазы.</span><span class="sxs-lookup"><span data-stu-id="e7e81-126">Here we focus on the oracles needed for just two applications: amplitude amplification and phase estimation.</span></span>
<span data-ttu-id="e7e81-127">Прежде чем процедингся на оценку этапа, мы сначала поговорим о том, как перестанут быть рассмотрены Oracle.</span><span class="sxs-lookup"><span data-stu-id="e7e81-127">We will first discuss amplitude amplification oracles before proceding to phase estimation.</span></span>

### <a name="amplitude-amplification-oracles"></a><span data-ttu-id="e7e81-128">Oracle усиление амплитуды</span><span class="sxs-lookup"><span data-stu-id="e7e81-128">Amplitude Amplification Oracles</span></span> ###

<span data-ttu-id="e7e81-129">Алгоритм усиления амплитуды предназначен для выполнения вращения между начальным и конечным состояниями путем применения последовательности отражений состояния.</span><span class="sxs-lookup"><span data-stu-id="e7e81-129">The amplitude amplification algorithm aims to perform a rotation between an initial state and a final state by applying a sequence of reflections of the state.</span></span>
<span data-ttu-id="e7e81-130">Чтобы алгоритм мог функционировать, ему требуется спецификация обоих состояний.</span><span class="sxs-lookup"><span data-stu-id="e7e81-130">In order for the algorithm to function, it needs a specification of both of these states.</span></span>
<span data-ttu-id="e7e81-131">Эти спецификации предоставляются двумя Oracle.</span><span class="sxs-lookup"><span data-stu-id="e7e81-131">These specifications are given by two oracles.</span></span>
<span data-ttu-id="e7e81-132">Эти Oracle работают путем разбиения входных данных на два пробела, "целевое" и "исходное" подпространство.</span><span class="sxs-lookup"><span data-stu-id="e7e81-132">These oracles work by breaking the inputs into two spaces, a "target" subspace and an "initial" subspace.</span></span>
<span data-ttu-id="e7e81-133">Oracle определяет такие подпространства, подобно тому, как Паули операторы определяют два пробела, применяя фазу $ \пм $1 к этим пробелам.</span><span class="sxs-lookup"><span data-stu-id="e7e81-133">The oracles identify such subspaces, similar to how Pauli operators identify two spaces, by applying a $\pm 1$ phase to these spaces.</span></span>
<span data-ttu-id="e7e81-134">Основное отличие состоит в том, что в этом приложении эти пробелы не должны быть половинными пробелами.</span><span class="sxs-lookup"><span data-stu-id="e7e81-134">The main difference is that these spaces need not be half-spaces in this application.</span></span>
<span data-ttu-id="e7e81-135">Также обратите внимание, что эти два подпространства не являются взаимоисключающими, так как в обоих пробелах присутствуют только векторы.</span><span class="sxs-lookup"><span data-stu-id="e7e81-135">Also note that these two subspaces are not usually mutually exclusive: there will be vectors that are members of both spaces.</span></span>
<span data-ttu-id="e7e81-136">Если это не так, это не повлияет на усиление амплитуды, поэтому нам необходимо, чтобы исходное подпространство имело ненулевое перекрытие с целевым подпространством.</span><span class="sxs-lookup"><span data-stu-id="e7e81-136">If this were not true then amplitude amplification would have no effect so we need the initial subspace to have non-zero overlap with the target subspace.</span></span>

<span data-ttu-id="e7e81-137">Мы обносимся первой базой данных Oracle, которую необходимо использовать для усиления амплитуды $P\_$0, чтобы иметь следующее действие.</span><span class="sxs-lookup"><span data-stu-id="e7e81-137">We will denote the first oracle that we need for amplitude amplification to be $P\_0$, defined to have the following action.</span></span>  <span data-ttu-id="e7e81-138">Для всех состояний $ \кет{КС} $ в "начальном" подпространстве $P\_0 \кет{КС} =-\кет{КС} $ и для всех штатов $ \кет{и} $, которые не находятся в этом подпространстве, $P\_0 \кет{и} = \кет{и} $.</span><span class="sxs-lookup"><span data-stu-id="e7e81-138">For all states $\ket{x}$ in the "initial" subspace $P\_0 \ket{x} = -\ket{x}$ and for all states $\ket{y}$ that are not in this subspace we have $P\_0 \ket{y} = \ket{y}$.</span></span>
<span data-ttu-id="e7e81-139">Oracle, помечающий целевое подпространство, $P _1 $, принимает в точности ту же форму.</span><span class="sxs-lookup"><span data-stu-id="e7e81-139">The oracle that marks the target subspace, $P_1$, takes exactly the same form.</span></span>
<span data-ttu-id="e7e81-140">Для всех состояний $ \кет{КС} $ в целевом подпространстве (т. е. для всех состояний, которые нужно использовать для вывода алгоритма), $P _1 \ Сисакет {x} =-\кет{КС} $.</span><span class="sxs-lookup"><span data-stu-id="e7e81-140">For all states $\ket{x}$ in the target subspace (i.e., for all states that you'd like the algorithm to output), $P_1\ket{x} = -\ket{x}$.</span></span>
<span data-ttu-id="e7e81-141">Аналогичным образом для всех состояний $ \кет{и} $, которые не находятся в целевом подпространстве $P _1 \ Сисакет {y} = \кет{и} $.</span><span class="sxs-lookup"><span data-stu-id="e7e81-141">Similarly, for all states $\ket{y}$ that are not in the target subspace $P_1\ket{y} = \ket{y}$.</span></span>
<span data-ttu-id="e7e81-142">Затем эти две отражения объединяются в оператор, который вводит один шаг к повышению амплитуды, $Q =-P_0 P_1 $, где общий знак минуса важен только для того, чтобы рассматриваться в контролируемых приложениях.</span><span class="sxs-lookup"><span data-stu-id="e7e81-142">These two reflections are then combined to form an operator that enacts a single step of amplitude amplification, $Q = -P_0 P_1$, where the overall minus sign is only important to consider in controlled applications.</span></span>
<span data-ttu-id="e7e81-143">Затем функция усиления амплитуды переходит в исходное состояние, $ \кет{\пси} $, расположенное в начальном подпространстве, а затем выполняет $ \кет{\пси} \мапсто Q ^ m \кет{\пси} $.</span><span class="sxs-lookup"><span data-stu-id="e7e81-143">Amplitude amplification then proceeds by taking an initial state, $\ket{\psi}$ that is in the initial subspace and then performs $\ket{\psi} \mapsto Q^m \ket{\psi}$.</span></span>
<span data-ttu-id="e7e81-144">Выполнение такой итерации гарантирует, что если одна из них начинается с начального состояния, которое пересекает $ \син ^ 2 (\сета) $ с отмеченным пространством, то после $m $ итерации перекрываются до $ \син ^ 2 ([2 MБ + 1] \сета) $.</span><span class="sxs-lookup"><span data-stu-id="e7e81-144">Performing such an iteration guarantees that if one starts with an initial state that has overlap $\sin^2(\theta)$ with the marked space then after $m$ iterations this overlap becomes $\sin^2([2m + 1] \theta)$.</span></span>
<span data-ttu-id="e7e81-145">Поэтому обычно требуется выбрать $m $, чтобы быть свободным параметром, таким образом, $ [2 МБ + 1] \сета = \ PI/2 $; Однако такие жесткие выборы не так важны для некоторых форм усиления амплитуды, например для усиления амплитуды с фиксированной точкой.</span><span class="sxs-lookup"><span data-stu-id="e7e81-145">We therefore typically wish to choose $m$ to be a free parameter such that $[2m+1]\theta = \pi/2$; however, such rigid choices are not as important for some forms of amplitude amplification such as fixed point amplitude amplification.</span></span>
<span data-ttu-id="e7e81-146">Этот процесс позволяет нам подготовить состояние в отмеченном подпространстве с помощью минимально меньшего числа запросов к функции пометки и функции подготовки состояния, чем было бы возможно на строго классической устройстве.</span><span class="sxs-lookup"><span data-stu-id="e7e81-146">This process allows us to prepare a state in the marked subspace using quadratically fewer queries to the marking function and the state preparation function than would be possible on a strictly classical device.</span></span>
<span data-ttu-id="e7e81-147">Именно поэтому усиление амплитуды является значительным стандартным блоком для многих приложений тактовых вычислений.</span><span class="sxs-lookup"><span data-stu-id="e7e81-147">This is why amplitude amplification is a significant building block for many applications of quantum computing.</span></span>

<span data-ttu-id="e7e81-148">Чтобы понять, как использовать алгоритм, полезно предоставить пример, который предоставляет построение Oracle.</span><span class="sxs-lookup"><span data-stu-id="e7e81-148">In order to understand how to use the algorithm, it is useful to provide an example that gives a construction of the oracles.</span></span>  <span data-ttu-id="e7e81-149">Рассмотрите возможность выполнения алгоритма Гровер для поиска базы данных в этом параметре.</span><span class="sxs-lookup"><span data-stu-id="e7e81-149">Consider performing Grover's algorithm for database searches in this setting.</span></span>
<span data-ttu-id="e7e81-150">В поиске Гровер необходимо преобразовать состояние $ \кет{+} ^ {\отимес n} = H ^ {\отимес n} \кет{0}$ в одно из (потенциально) много помеченных состояний.</span><span class="sxs-lookup"><span data-stu-id="e7e81-150">In Grover's search the goal is to transform the state $\ket{+}^{\otimes n} = H^{\otimes n} \ket{0}$ into one of (potentially) many marked states.</span></span>
<span data-ttu-id="e7e81-151">Для дальнейшего упрощения рассмотрим случай, когда единственным отмеченным состоянием является $ \кет{0}$.</span><span class="sxs-lookup"><span data-stu-id="e7e81-151">To further simplify, let's just look at the case where the only marked state is $\ket{0}$.</span></span>
<span data-ttu-id="e7e81-152">Затем мы создали две базы данных Oracle: одну, которая помечает только начальное состояние $ \кет{+} ^ {\отимес n} $ символом минуса, а другой символ, помечающий помеченное состояние $ \кет{0}$ символом "минус".</span><span class="sxs-lookup"><span data-stu-id="e7e81-152">Then we have design two oracles: one that only marks the initial state $\ket{+}^{\otimes n}$ with a minus sign and another that marks the marked state $\ket{0}$ with a minus sign.</span></span>
<span data-ttu-id="e7e81-153">Последний шлюз можно реализовать с помощью следующей операции обработки, используя операции потока управления в Canon:</span><span class="sxs-lookup"><span data-stu-id="e7e81-153">The latter gate can be implemented using the following process operation, by using the control flow operations in the canon:</span></span>

```qsharp
operation ReflectAboutAllZeros(register : Qubit[]) : Unit 
is Adj + Ctl {

    // Apply $X$ gates to every qubit.
    ApplyToEach(X, register);

    // Apply an $n-1$ controlled $Z$-gate to the $n^{\text{th}}$ qubit.
    // This gate will lead to a sign flip if and only if every qubit is
    // $1$, which happens only if each of the qubits were $0$ before step 1.
    Controlled Z(Most(register), Tail(register));

    // Apply $X$ gates to every qubit.
    ApplyToEach(X, register);
}
```

<span data-ttu-id="e7e81-154">В этом случае Oracle является особым случаем операции <xref:microsoft.quantum.canon.rall1>, которая позволяет выполнять поворот на произвольном этапе вместо случая отражения $ \фи = \пи $.</span><span class="sxs-lookup"><span data-stu-id="e7e81-154">This oracle is then a special case of the <xref:microsoft.quantum.canon.rall1> operation, which allows for rotating by an arbitrary phase instead of the reflection case $\phi = \pi$.</span></span>
<span data-ttu-id="e7e81-155">В этом случае `RAll1` похоже на операцию <xref:microsoft.quantum.intrinsic.r1> версионного, в том, что она поворачивает около $ \ket{11\cdots1} $, а не кубит State $ \кет{1}$.</span><span class="sxs-lookup"><span data-stu-id="e7e81-155">In this case, `RAll1` is similar to the <xref:microsoft.quantum.intrinsic.r1> prelude operation, in that it rotates about $\ket{11\cdots1}$ instead of the single-qubit state $\ket{1}$.</span></span>

<span data-ttu-id="e7e81-156">Oracle, который помечает начальное подпространство, может быть создан аналогичным образом.</span><span class="sxs-lookup"><span data-stu-id="e7e81-156">The oracle that marks the initial subspace can be constructed similarly.</span></span>
<span data-ttu-id="e7e81-157">В псевдокоде:</span><span class="sxs-lookup"><span data-stu-id="e7e81-157">In pseudocode:</span></span>

1. <span data-ttu-id="e7e81-158">Примените $H $ Гейтс к каждому кубит.</span><span class="sxs-lookup"><span data-stu-id="e7e81-158">Apply $H$ gates to every qubit.</span></span>
2. <span data-ttu-id="e7e81-159">Примените $X $ Гейтс к каждому кубит.</span><span class="sxs-lookup"><span data-stu-id="e7e81-159">Apply $X$ gates to every qubit.</span></span>
3. <span data-ttu-id="e7e81-160">Примените управляемый $n-$1 $Z $-Gate к $n ^ {\текст{с}} $ кубит.</span><span class="sxs-lookup"><span data-stu-id="e7e81-160">Apply an $n-1$ controlled $Z$-gate to the $n^{\text{th}}$ qubit.</span></span>
4. <span data-ttu-id="e7e81-161">Примените $X $ Гейтс к каждому кубит.</span><span class="sxs-lookup"><span data-stu-id="e7e81-161">Apply $X$ gates to every qubit.</span></span>
5. <span data-ttu-id="e7e81-162">Примените $H $ Гейтс к каждому кубит.</span><span class="sxs-lookup"><span data-stu-id="e7e81-162">Apply $H$ gates to every qubit.</span></span>

<span data-ttu-id="e7e81-163">На этот раз мы также демонстрируем использование <xref:microsoft.quantum.canon.applywith> вместе с <xref:microsoft.quantum.canon.rall1>ной операцией, описанной выше:</span><span class="sxs-lookup"><span data-stu-id="e7e81-163">This time, we also demonstrate using <xref:microsoft.quantum.canon.applywith> together with the <xref:microsoft.quantum.canon.rall1> operation discussed above:</span></span>

```qsharp
operation ReflectAboutInitial(register : Qubit[]) : Unit
is Adj + Ctl {
    ApplyWithCA(ApplyToEach(H, _), ApplyWith(ApplyToEach(X, _), RAll1(_, PI()), _), register);
}
```

<span data-ttu-id="e7e81-164">Затем можно объединить эти две Oracle вместе, чтобы переходить между двумя состояниями и детерминированно преобразовать $ \кет{+} ^ {\отимес n} $ в $ \кет{0}$, используя несколько уровней шлюза Хадамард, пропорциональный $ \sqrt{2 ^ n} $ (IE $m \пропто \sqrt{2 ^ n} $) в отличие от приблизительного уровня $2 ^ n $, который требуется для недетерминированной подготовки состояния $ \кет{0}$, путем подготовки и измерения начального состояния до тех пор, пока не будет замечен результат $0 $.</span><span class="sxs-lookup"><span data-stu-id="e7e81-164">We can then combine these two oracles together to rotate between the two states and deterministically transform $\ket{+}^{\otimes n}$ to $\ket{0}$ using a number of layers of Hadamard gates that is proportional to $\sqrt{2^n}$ (ie $m\propto \sqrt{2^n}$) versus the roughly $2^n$ layers that would be needed to non-deterministically prepare the $\ket{0}$ state by preparing and measuring the initial state until the outcome $0$ is observed.</span></span>

### <a name="phase-estimation-oracles"></a><span data-ttu-id="e7e81-165">Оценочная Оценка этапов Oracle</span><span class="sxs-lookup"><span data-stu-id="e7e81-165">Phase Estimation Oracles</span></span> ###

<span data-ttu-id="e7e81-166">Для оценки этапов Oracle является несколько более естественным.</span><span class="sxs-lookup"><span data-stu-id="e7e81-166">For phase estimation the oracles are somewhat more natural.</span></span>
<span data-ttu-id="e7e81-167">Целью оценки фазы является проектирование подпрограммы, которая может выдавать выборку из еиженвалуес единой матрицы.</span><span class="sxs-lookup"><span data-stu-id="e7e81-167">The aim in phase estimation is to design a subroutine that is capable of sampling from the eigenvalues of a unitary matrix.</span></span>
<span data-ttu-id="e7e81-168">Этот метод незаменимым в процессе моделирования такта, так как для многих физических проблем в химия и материальных науки эти еиженвалуес приводят к силыам в состоянии заземления в системах, которые предоставляют ценные сведения о схемах этапов материалы и радиосвязи для молекул.</span><span class="sxs-lookup"><span data-stu-id="e7e81-168">This method is indispensible in quantum simulation because for many physical problems in chemistry and material science these eigenvalues give the ground-state energies of quantum systems which provides us valuable information about the phase diagrams of materials and reaction dynamics for molecules.</span></span>
<span data-ttu-id="e7e81-169">Каждой разновидности оценки фазы требуется ввод в единое целое.</span><span class="sxs-lookup"><span data-stu-id="e7e81-169">Every flavor of phase estimation needs an input unitary.</span></span>
<span data-ttu-id="e7e81-170">Это единое из них описано одним из двух типов Oracle.</span><span class="sxs-lookup"><span data-stu-id="e7e81-170">This unitary is customarily described by one of two types of oracles.</span></span>

> [!TIP]
> <span data-ttu-id="e7e81-171">В примерах рассматриваются оба типа Oracle, описанные ниже.</span><span class="sxs-lookup"><span data-stu-id="e7e81-171">Both of the oracle types described below are covered in the samples.</span></span>
> <span data-ttu-id="e7e81-172">Дополнительные сведения о Oracle с непрерывным запросом см. в [примере **фасистиматион** ](https://github.com/Microsoft/Quantum/tree/master/Samples/src/PhaseEstimation).</span><span class="sxs-lookup"><span data-stu-id="e7e81-172">To learn more about continuous query oracles, please see the [**PhaseEstimation** sample](https://github.com/Microsoft/Quantum/tree/master/Samples/src/PhaseEstimation).</span></span>
> <span data-ttu-id="e7e81-173">Дополнительные сведения о дискретных запросах Oracle см. в примере [ **исингфасистиматион** ](https://github.com/Microsoft/Quantum/tree/master/Samples/src/IsingPhaseEstimation).</span><span class="sxs-lookup"><span data-stu-id="e7e81-173">To learn more about discrete query oracles, please see the [**IsingPhaseEstimation** sample](https://github.com/Microsoft/Quantum/tree/master/Samples/src/IsingPhaseEstimation).</span></span>

<span data-ttu-id="e7e81-174">Первый тип Oracle, который вызывает дискретный запрос Oracle и представлен с определяемым пользователем типом <xref:microsoft.quantum.oracles.discreteoracle>, просто включает в себя единую матрицу.</span><span class="sxs-lookup"><span data-stu-id="e7e81-174">The first type of oracle, which we call a discrete query oracle and represent with the user-defined type <xref:microsoft.quantum.oracles.discreteoracle>, simply involves a unitary matrix.</span></span>
<span data-ttu-id="e7e81-175">Если $U $ является единым, для которой мы хотим оценить, то Oracle для $U $ является просто подподпрограммой, реализующей $U $.</span><span class="sxs-lookup"><span data-stu-id="e7e81-175">If $U$ is the unitary whose eigenvalues we wish to estimate then the oracle for $U$ is simply a stand-in for a subroutine that implements $U$.</span></span>
<span data-ttu-id="e7e81-176">Например, можно взять $U $ в качестве $Q Oracle $, определенного выше для оценки амплитуды.</span><span class="sxs-lookup"><span data-stu-id="e7e81-176">For example, one could take $U$ to be the oracle $Q$ defined above for amplitude estimation.</span></span>
<span data-ttu-id="e7e81-177">Еиженвалуес этой матрицей можно использовать для оценки перекрытия между начальным и целевым состояниями, $ \син ^ 2 (\сета) $, с использованием квадратичного числа выборок, чем в противном случае.</span><span class="sxs-lookup"><span data-stu-id="e7e81-177">The eigenvalues of this matrix can be used to estimate the overlap between the initial and target states, $\sin^2(\theta)$, using quadratically fewer samples than one would need otherwise.</span></span>
<span data-ttu-id="e7e81-178">Это порабатывает применение оценки этапа с помощью Гровер Oracle $Q $ в качестве входного моникера оценки амплитуды.</span><span class="sxs-lookup"><span data-stu-id="e7e81-178">This earns the application of phase estimation using the Grover oracle $Q$ as input the moniker of amplitude estimation.</span></span>
<span data-ttu-id="e7e81-179">Другое общее приложение, широко используемое в тактовой метрологии, включает оценку небольшого угла вращения.</span><span class="sxs-lookup"><span data-stu-id="e7e81-179">Another common application, widely used in quantum metrology, involves estimating a small rotation angle.</span></span>
<span data-ttu-id="e7e81-180">Иными словами, мы хотим оценить $ \сета $ для неизвестного шлюза ротации формы $R _Z (\сета) $.</span><span class="sxs-lookup"><span data-stu-id="e7e81-180">In other words, we wish to estimate $\theta$ for an unknown rotation gate of the form $R_z(\theta)$.</span></span>
<span data-ttu-id="e7e81-181">В таких случаях подпрограммы, с которыми мы будем взаимодействовать, чтобы изучить фиксированное значение $ \сета $ для шлюза, — $ $ \бегин{алигн} U & = R_z (\сета) \\\\ & = \бегин{бматрикс} e ^ {-i \сета/2} & 0 \\\\ 0 & e ^ {i \ тета/2} \енд{бматрикс}.</span><span class="sxs-lookup"><span data-stu-id="e7e81-181">In such cases, the subroutine that we would interact with in order to learn this fixed value of $\theta$ for the gate is $$ \begin{align} U & = R_z(\theta) \\\\ & = \begin{bmatrix} e^{-i \theta / 2} & 0 \\\\ 0 & e^{i\theta/2} \end{bmatrix}.</span></span>
<span data-ttu-id="e7e81-182">\енд{алигн} $ $</span><span class="sxs-lookup"><span data-stu-id="e7e81-182">\end{align} $$</span></span>

<span data-ttu-id="e7e81-183">Второй тип Oracle, используемый в оценке фазы, — это непрерывный запрос Oracle, представленный типом <xref:microsoft.quantum.oracles.continuousoracle>.</span><span class="sxs-lookup"><span data-stu-id="e7e81-183">The second type of oracle used in phase estimation is the continuous query oracle, represented by the <xref:microsoft.quantum.oracles.continuousoracle> type.</span></span>
<span data-ttu-id="e7e81-184">В Oracle для оценки этапа непрерывный запрос принимает форму $U (t) $, где $t $ является классическим, известным вещественным числом.</span><span class="sxs-lookup"><span data-stu-id="e7e81-184">A continuous query oracle for phase estimation takes the form $U(t)$ where $t$ is a classically known real number.</span></span>
<span data-ttu-id="e7e81-185">Если мы попробуем $U $ быть фиксированной, то в Oracle непрерывный запрос принимает форму $U (t) = U ^ t $.</span><span class="sxs-lookup"><span data-stu-id="e7e81-185">If we let $U$ be a fixed unitary then the continuous query oracle takes the form $U(t) = U^t$.</span></span>
<span data-ttu-id="e7e81-186">Это позволяет нам запрашивать такие матрицы, как $ \Скрт{у} $, которые не могут быть реализованы непосредственно в дискретной модели запроса.</span><span class="sxs-lookup"><span data-stu-id="e7e81-186">This allows us to query matrices such as $\sqrt{U}$, which could not be implemented directly in the discrete query model.</span></span>

<span data-ttu-id="e7e81-187">Такой тип Oracle полезен, если вы не проверяюте конкретное единое, а хотите изучить свойства генератора единой.</span><span class="sxs-lookup"><span data-stu-id="e7e81-187">This type of oracle is valuable when you're not probing a particular unitary, but rather wish to learn the properties of the generator of the unitary.</span></span>
<span data-ttu-id="e7e81-188">Например, в динамическом моделировании такта цель состоит в том, чтобы разрабатывать тактовые каналы, которые приблизительно точнее $U (t) = e ^ {-i H t} $ для матрицы Хермитиан $H $ и эволюционное время $t $.</span><span class="sxs-lookup"><span data-stu-id="e7e81-188">For example, in dynamical quantum simulation the goal is to devise quantum circuits that closely approximate $U(t)=e^{-i H t}$ for a Hermitian matrix $H$ and evolution time $t$.</span></span>
<span data-ttu-id="e7e81-189">Еиженвалуес $U (t) $ напрямую связаны с еиженвалуесом $H $.</span><span class="sxs-lookup"><span data-stu-id="e7e81-189">The eigenvalues of $U(t)$ are directly related to the eigenvalues of $H$.</span></span>
<span data-ttu-id="e7e81-190">Чтобы увидеть это, рассмотрите еиженвектор $H $: $H \Кет{е} = Е\кет {E} $, после чего можно легко увидеть в определении ряда питания матрицы, что $U (t) \Кет{е} = e ^ {и\фи} \ Сисакет {E} = e ^ {-ИЕТ} \Кет{е} $.</span><span class="sxs-lookup"><span data-stu-id="e7e81-190">To see this, consider an eigenvector of $H$: $H \ket{E} = E\ket{E}$ then it is easy to see from the power-series definition of the matrix exponential that $U(t) \ket{E} = e^{i\phi}\ket{E}= e^{-iEt}\ket{E}$.</span></span>
<span data-ttu-id="e7e81-191">Таким образом, оценка еиженфасе $U (t) $ дает еиженвалуе $E $, предполагая, что еиженвектор $ \Кет{е} $ является входным алгоритмом оценки этапа.</span><span class="sxs-lookup"><span data-stu-id="e7e81-191">Thus estimating the eigenphase of $U(t)$ gives the eigenvalue $E$ assuming the eigenvector $\ket{E}$ is input into the phase estimation algorithm.</span></span>
<span data-ttu-id="e7e81-192">Однако в этом случае значение $t $ может быть выбрано по усмотрению пользователя, так как для любого достаточного небольшого значения $t $ еиженвалуе $E $ может быть однозначно инвертирован через $E =-\ фи/t $.</span><span class="sxs-lookup"><span data-stu-id="e7e81-192">However, in this case the value $t$ can be chosen at the user's discretion since for any sufficiently small value of $t$ the eigenvalue $E$ can be uniquely inverted through $E=-\phi/t$.</span></span>
<span data-ttu-id="e7e81-193">Так как методы моделирования такта предоставляют возможность выполнения дробной эволюции, это дает алгоритмам оценки этапа дополнительную свободу при запросе от единой функции, в частности, если дискретная модель запроса допускает только унитариес формы $U ^ j $ для применения целочисленного $j $ непрерывный запрос Oracle позволяет приблизительно унитариес форму $U ^ t $ для любого действительного значения $t $.</span><span class="sxs-lookup"><span data-stu-id="e7e81-193">Since quantum simulation methods provide the ability to perform a fractional evolution, this grants phase estimation algorithms an additional freedom when querying the unitary, specifically while the discrete query model allows only unitaries of the form $U^j$ to applied for integer $j$ the continuous query oracle allows us to approximate unitaries of the form $U^t$ for any real valued $t$.</span></span>
<span data-ttu-id="e7e81-194">Это важно для того, чтобы задержать все последние унции эффективности в алгоритмах оценки этапа, так как это позволяет выбрать именно эксперимент, который предоставит наибольшую информацию о $E $; в то время как методы, основанные на дискретных запросах, должны делать это с ослаблением, выбрав лучшее целое число запросов в алгоритме.</span><span class="sxs-lookup"><span data-stu-id="e7e81-194">This is important to squeeze every last ounce of efficiency out of phase estimation algorithms because it allows us to choose precisely the experiment that would provide the most information about $E$; whereas methods based on discrete queries must make do with compromising by choosing the best integer number of queries in the algorithm.</span></span>

<span data-ttu-id="e7e81-195">В качестве конкретного примера рассмотрим проблему оценки не угла вращения шлюза, но процессион частоты поворота тактовой системы.</span><span class="sxs-lookup"><span data-stu-id="e7e81-195">As a concrete example of this, consider the problem of estimating not the rotation angle of a gate but the procession frequency of a rotating quantum system.</span></span>
<span data-ttu-id="e7e81-196">Единая, которая описывает такой тактовую частоту, $U (t) = R_z (2 \ Омега t) $ для эволюции $t $ и неизвестная частота $ \омега $.</span><span class="sxs-lookup"><span data-stu-id="e7e81-196">The unitary that describes such quantum dynamics is $U(t)=R_z(2\omega t)$ for evolution time $t$ and unknown frequency $\omega$.</span></span>
<span data-ttu-id="e7e81-197">В этом контексте можно имитировать $U (t) $ для любого $t $ с помощью одного $R _Z $ Gate и, таким образом, не нужно ограничивать себя только дискретными запросами к единому.</span><span class="sxs-lookup"><span data-stu-id="e7e81-197">In this context, we can simulate $U(t)$ for any $t$ using a single $R_z$ gate and as such do not need to restrict ourselves to only discrete queries to the unitary.</span></span>
<span data-ttu-id="e7e81-198">Такая непрерывная модель также имеет свойство, частота которого больше $2 – PI $ может быть получено из процессов оценки этапа, использующих непрерывные запросы, поскольку сведения о фазе, которые в противном случае были бы скрыты с помощью разветвлений функции логарифма, могут выводятся результаты экспериментов со значениями, отличными от соответствии значений $t $.</span><span class="sxs-lookup"><span data-stu-id="e7e81-198">Such a continuous model also has the property that frequencies greater than $2\pi$ can be learned from phase estimation processes that use continuous queries because phase information that would otherwise be masked by the branch-cuts of the logarithm function can be revealed from the results of experiments performed on non-commensurate values of $t$.</span></span>
<span data-ttu-id="e7e81-199">Таким образом, для таких проблем, как непрерывные модели запросов для оценки фазы Oracle, не только подходит, но и предпочтительны для дискретной модели запросов.</span><span class="sxs-lookup"><span data-stu-id="e7e81-199">Thus for problems such as this continuous query models for the phase estimation oracle are not only appropriate but are also preferable to the discrete query model.</span></span>
<span data-ttu-id="e7e81-200">По этой причине в Q # есть функциональные возможности для обеих форм запросов, и пользователь должен принять решение о алгоритме оценки этапа в соответствии с потребностями и доступным типом Oracle.</span><span class="sxs-lookup"><span data-stu-id="e7e81-200">For this reason Q# has functionality for both forms of queries and leave it to the user to decide upon a phase estimation algorithm to fit their needs and the type of oracle that is available.</span></span>

## <a name="dynamical-generator-modeling"></a><span data-ttu-id="e7e81-201">Динамическое моделирование генератора</span><span class="sxs-lookup"><span data-stu-id="e7e81-201">Dynamical Generator Modeling</span></span> ##

<span data-ttu-id="e7e81-202">Генераторы времени развития описывают, как состояния развиваются по времени.</span><span class="sxs-lookup"><span data-stu-id="e7e81-202">Generators of time-evolution describe how states evolve through time.</span></span> <span data-ttu-id="e7e81-203">Например, значение Dynamics состояния такта $ \кет{\пси} $ регулируется уравнением Шредингер $ $ \бегин{алигн} и\фрак {d \кет{\пси (t)}} {d t} & = H \кет{\пси (t)}, \енд{алигн} $ $ с Хермитиан матрицей $H $, известной как Хамилтониан, как генератор удач.</span><span class="sxs-lookup"><span data-stu-id="e7e81-203">For instance, the dynamics of a quantum state $\ket{\psi}$ is governed by the Schrödinger equation $$ \begin{align} i\frac{d \ket{\psi(t)}}{d t} & = H \ket{\psi(t)}, \end{align} $$ with a Hermitian matrix $H$, known as the Hamiltonian, as the generator of motion.</span></span> <span data-ttu-id="e7e81-204">Учитывая начальное состояние $ \кет{\пси (0)} $ at $t = $0, формальное решение для этого уравнения во время $t $ может быть, в принципе, написал $ $ \бегин{алигн} \кет{\пси (t)} = U (t) \кет{\пси (0)}, \енд{алигн} $ $, где экспоненциальная $U (t) = e ^ {-i H t} $ называется единое время — оператор развития времени.</span><span class="sxs-lookup"><span data-stu-id="e7e81-204">Given an initial state $\ket{\psi(0)}$ at time $t=0$, the formal solution to this equation at time $t$ may be, in principle, written $$ \begin{align} \ket{\psi(t)} = U(t)\ket{\psi(0)}, \end{align} $$ where the matrix exponential $U(t)=e^{-i H t}$ is known as the unitary time-evolution operator.</span></span> <span data-ttu-id="e7e81-205">Несмотря на то, что основное внимание уделяется генераторам этой формы, мы Подчеркните, что концепция применяется более широко, например, для имитации открытых тактовых систем или более абстрактных разностных уравнений.</span><span class="sxs-lookup"><span data-stu-id="e7e81-205">Though we focus on generators of this form in the following, we emphasize that the concept applies more broadly, such as to the simulation of open quantum systems, or to more abstract differential equations.</span></span>

<span data-ttu-id="e7e81-206">Основной целью динамического моделирования является реализация оператора времени развития в некоторых состояниях такта, закодированных в Кубитс компьютера-такта.</span><span class="sxs-lookup"><span data-stu-id="e7e81-206">A primary goal of dynamical simulation is to implement the time-evolution operator on some quantum state encoded in qubits of a quantum computer.</span></span>  <span data-ttu-id="e7e81-207">Во многих случаях Хамилтониан может быть разбит на сумму некоторых $d $ более простых терминов.</span><span class="sxs-lookup"><span data-stu-id="e7e81-207">In many cases, the Hamiltonian may be broken into a sum of some $d$ simpler terms</span></span>

<span data-ttu-id="e7e81-208">$ $ \бегин{алигн} H & = \сум ^ {d-1} _ {j = 0} H_j, \енд{алигн} $ $</span><span class="sxs-lookup"><span data-stu-id="e7e81-208">$$ \begin{align} H & = \sum^{d-1}_{j=0} H_j, \end{align} $$</span></span>

<span data-ttu-id="e7e81-209">где время — развитие каждого термина легко реализовать на тактовой системе.</span><span class="sxs-lookup"><span data-stu-id="e7e81-209">where time-evolution by each term alone is easy to implement on a quantum computer.</span></span> <span data-ttu-id="e7e81-210">Например, если $H _j $ является Паули $X _1X_2 $, действующего на первый и второй элемент кубит Register `qubits`, то время на его развитие в течение любого времени $t $ может быть реализовано просто путем вызова операции `Exp([PauliX,PauliX], t, qubits[1..2])`, которая имеет `((Pauli[], Double, Qubit[]) => Unit is Adj + Ctl)`сигнатуры.</span><span class="sxs-lookup"><span data-stu-id="e7e81-210">For instance, if $H_j$ is a Pauli $X_1X_2$ operator acting on the 1st and 2nd elements of the qubit register `qubits`, time-evolution by it for any time $t$ may be implemented simply by calling the operation `Exp([PauliX,PauliX], t, qubits[1..2])`, which has signature `((Pauli[], Double, Qubit[]) => Unit is Adj + Ctl)`.</span></span> <span data-ttu-id="e7e81-211">Как обсуждалось далее в моделировании Хамилтониан, одно решение — это приблизительное время развития $H $ с последовательностью более простых операций.</span><span class="sxs-lookup"><span data-stu-id="e7e81-211">As discussed later in Hamiltonian Simulation, one solution then is to approximate time-evolution by $H$ with a sequence of simpler operations</span></span>

<span data-ttu-id="e7e81-212">$ $ \бегин{алигн} U (t) & = \лефт (e ^ {-iH\_0 t/r} e ^ {-iH\_1 t/r} \кдотс e ^ {-iH\_{d-1} t/r} \ригхт) ^ {r} + \Маскал{о} (d ^ 2 \max_j \\| H\_j\\| ^ 2 t ^ 2/r), \енд{алигн} $ $</span><span class="sxs-lookup"><span data-stu-id="e7e81-212">$$ \begin{align} U(t) & = \left( e^{-iH\_0 t / r} e^{-iH\_1 t / r} \cdots e^{-iH\_{d-1} t / r} \right)^{r} + \mathcal{O}(d^2 \max_j \\|H\_j\\|^2 t^2/r), \end{align} $$</span></span>

<span data-ttu-id="e7e81-213">где целое число $r > $0 управляет ошибкой приближения.</span><span class="sxs-lookup"><span data-stu-id="e7e81-213">where the integer $r > 0$ controls the approximation error.</span></span>

<span data-ttu-id="e7e81-214">Библиотека динамического моделирования генератора предоставляет платформу для систематической кодирования сложных генераторов с точки зрения более простых генераторов.</span><span class="sxs-lookup"><span data-stu-id="e7e81-214">The dynamical generator modeling library provides a framework for systematically encoding complicated generators in terms of simpler generators.</span></span> <span data-ttu-id="e7e81-215">Такое описание может затем передаваться, скажем, в библиотеку моделирования, чтобы реализовать развитие времени с помощью выбранного алгоритма моделирования с множеством деталей, которые автоматически позаботится.</span><span class="sxs-lookup"><span data-stu-id="e7e81-215">Such a description may then be passed to, say, the simulation library to implement time-evolution by a simulation algorithm of choice, with many details automatically taken care of.</span></span>

> [!TIP]
> <span data-ttu-id="e7e81-216">Библиотека динамического генератора, описанная ниже, рассматривается в примерах.</span><span class="sxs-lookup"><span data-stu-id="e7e81-216">The dynamical generator library described below is covered in the samples.</span></span> <span data-ttu-id="e7e81-217">Пример, основанный на модели Исинг, см. в примере [ **исингженераторс** ](https://github.com/Microsoft/Quantum/tree/master/Samples/src/IsingGenerators).</span><span class="sxs-lookup"><span data-stu-id="e7e81-217">For an example based on the Ising model, please see the [**IsingGenerators** sample](https://github.com/Microsoft/Quantum/tree/master/Samples/src/IsingGenerators).</span></span>
> <span data-ttu-id="e7e81-218">Пример, основанный на молекулярное водорода, см. в примерах [**H2SimulationCmdLine**](https://github.com/Microsoft/Quantum/tree/master/Samples/src/H2SimulationCmdLine) и [**H2SimulationGUI**](https://github.com/Microsoft/Quantum/tree/master/Samples/src/H2SimulationGUI) .</span><span class="sxs-lookup"><span data-stu-id="e7e81-218">For an example based on molecular Hydrogen, please see the [**H2SimulationCmdLine**](https://github.com/Microsoft/Quantum/tree/master/Samples/src/H2SimulationCmdLine) and [**H2SimulationGUI**](https://github.com/Microsoft/Quantum/tree/master/Samples/src/H2SimulationGUI) samples.</span></span>

### <a name="complete-description-of-a-generator"></a><span data-ttu-id="e7e81-219">Полное описание генератора</span><span class="sxs-lookup"><span data-stu-id="e7e81-219">Complete Description of a Generator</span></span> ###

<span data-ttu-id="e7e81-220">На верхнем уровне полное описание Хамилтониан содержится в `EvolutionGenerator` определяемом пользователем типе, который состоит из двух компонентов:</span><span class="sxs-lookup"><span data-stu-id="e7e81-220">At the top level, a complete description of a Hamiltonian is contained in the `EvolutionGenerator` user-defined type which has two components.:</span></span>

```qsharp
newtype EvolutionGenerator = (EvolutionSet, GeneratorSystem);
```

<span data-ttu-id="e7e81-221">Определяемый пользователем тип `GeneratorSystem` является классическим описанием Хамилтониан.</span><span class="sxs-lookup"><span data-stu-id="e7e81-221">The `GeneratorSystem` user-defined type is a classical description of the Hamiltonian.</span></span>

```qsharp
newtype GeneratorSystem = (Int, (Int -> GeneratorIndex));
```

<span data-ttu-id="e7e81-222">Первый элемент `Int` кортежа содержит количество терминов $d $ в Хамилтониан, а второй элемент `(Int -> GeneratorIndex)` является функцией, которая сопоставляет целочисленный индекс в $\{0, 1,..., d-1\}$ с `GeneratorIndex` определяемого пользователем типа, который однозначно определяет каждый примитивный термин в Хамилтониан.</span><span class="sxs-lookup"><span data-stu-id="e7e81-222">The first element `Int` of the tuple stores the number of terms $d$ in the Hamiltonian, and the second element `(Int -> GeneratorIndex)` is a function that maps an integer index in $\{0,1,...,d-1\}$ to a `GeneratorIndex` user-defined type which uniquely identifies each primitive term in the Hamiltonian.</span></span> <span data-ttu-id="e7e81-223">Обратите внимание, что путем выражения коллекции терминов в Хамилтониан в качестве функции, а не `GeneratorIndex[]`массива, это позволяет выполнять вычисления `GeneratorIndex`, которые особенно полезны при описании Хамилтонианс с большим количеством терминов.</span><span class="sxs-lookup"><span data-stu-id="e7e81-223">Note that by expressing the collection of terms in the Hamiltonian as a function rather than as an array `GeneratorIndex[]`, this allows for on-the-fly computation of the `GeneratorIndex` which is especially useful when describing Hamiltonians with a large number of terms.</span></span>

<span data-ttu-id="e7e81-224">По крайней мере, мы не будем использовать соглашение о том, какие примитивные термины, идентифицируемые `GeneratorIndex`, просты для имитации.</span><span class="sxs-lookup"><span data-stu-id="e7e81-224">Crucially, we do not impose a convention on what primitive terms identified by the `GeneratorIndex` are easy-to-simulate.</span></span> <span data-ttu-id="e7e81-225">Например, примитивные термины могут быть Паули операторами, как описано выше, но они также могут быть Фермионик аннихилатион и операторы создания, обычно используемые в моделировании тактовой химия.</span><span class="sxs-lookup"><span data-stu-id="e7e81-225">For instance, primitive terms could be Pauli operators as discussed above, but they could also be Fermionic annihilation and creation operators commonly used in quantum chemistry simulation.</span></span> <span data-ttu-id="e7e81-226">Сам по себе `GeneratorIndex` не имеет смысла, так как он не описывает, как время развития термина, на который он указывает, может быть реализован в виде тактовой цепи.</span><span class="sxs-lookup"><span data-stu-id="e7e81-226">By itself, a `GeneratorIndex` is meaningless as it does not describe how time-evolution by the term it points to may be implemented as a quantum circuit.</span></span>

<span data-ttu-id="e7e81-227">Это разрешается путем указания `EvolutionSet` определяемого пользователем типа, который сопоставляет все `GeneratorIndex`, выведенные из некоторого канонического набора, к единому оператору, `EvolutionUnitary`, выраженному в виде тактовой цепи.</span><span class="sxs-lookup"><span data-stu-id="e7e81-227">This is resolved by specifying an `EvolutionSet` user-defined type that maps any `GeneratorIndex`, drawn from some canonical set, to a unitary operator, the `EvolutionUnitary`, expressed as a quantum circuit.</span></span> <span data-ttu-id="e7e81-228">`EvolutionSet` определяет правила структурирования `GeneratorIndex`, а также определяет набор возможных `GeneratorIndex`.</span><span class="sxs-lookup"><span data-stu-id="e7e81-228">The `EvolutionSet` defines the convention of how a `GeneratorIndex` is structured, and also defines the set of possible `GeneratorIndex`.</span></span>

```qsharp
newtype EvolutionSet = (GeneratorIndex -> EvolutionUnitary);
```

### <a name="pauli-operator-generators"></a><span data-ttu-id="e7e81-229">Генераторы операторов Паули</span><span class="sxs-lookup"><span data-stu-id="e7e81-229">Pauli Operator Generators</span></span> ###

<span data-ttu-id="e7e81-230">Конкретный и полезный пример генераторов — Хамилтонианс, которые являются суммой операторов Паули, каждый из которых может иметь другой коэффициент.</span><span class="sxs-lookup"><span data-stu-id="e7e81-230">A concrete and useful example of generators are Hamiltonians that are a sum of Pauli operators, each possibly with a different coefficient.</span></span>
<span data-ttu-id="e7e81-231">$ $ \бегин{алигн} H & = \сум ^ {d-1} _ {j = 0} a_j H_j, \енд{алигн} $ $, где каждый $ \хат H_j $ теперь нарисован из группы Паули.</span><span class="sxs-lookup"><span data-stu-id="e7e81-231">$$ \begin{align} H & = \sum^{d-1}_{j=0} a_j H_j, \end{align} $$ where each $\hat H_j$ is now drawn from the Pauli group.</span></span> <span data-ttu-id="e7e81-232">Для таких систем мы предоставляем `PauliEvolutionSet()` типа `EvolutionSet`, который определяет соглашение о том, как элемент группы Паули и коэффициент можно идентифицировать с помощью `GeneratorIndex`, который имеет следующую сигнатуру.</span><span class="sxs-lookup"><span data-stu-id="e7e81-232">For such systems, we provide the `PauliEvolutionSet()` of type `EvolutionSet` that defines a convention for how an element of the Pauli group and a coefficient may be identified by a `GeneratorIndex`, which has the following signature.</span></span>

```qsharp
newtype GeneratorIndex = ((Int[], Double[]), Int[]);
```

<span data-ttu-id="e7e81-233">В нашей кодировке первый параметр `Int[]` указывает строку Паули, где $ \хат И\ригхтарров $0, $ \хат Кс\ригхтарров $1, $ \хат И\ригхтарров $2 и $ \хат З\ригхтарров $3.</span><span class="sxs-lookup"><span data-stu-id="e7e81-233">In our encoding, the first parameter `Int[]` specifies a Pauli string, where $\hat I\rightarrow 0$, $\hat X\rightarrow 1$, $\hat Y\rightarrow 2$, and $\hat Z\rightarrow 3$.</span></span> <span data-ttu-id="e7e81-234">Второй параметр `Double[]` сохраняет коэффициент строки Паули в Хамилтониан.</span><span class="sxs-lookup"><span data-stu-id="e7e81-234">The second parameter `Double[]` stores the coefficient of the Pauli string in the Hamiltonian.</span></span> <span data-ttu-id="e7e81-235">Обратите внимание, что используется только первый элемент массива.</span><span class="sxs-lookup"><span data-stu-id="e7e81-235">Note that only the first element of this array is used.</span></span> <span data-ttu-id="e7e81-236">Третий параметр `Int[]` индексирует Кубитс, с которым работает эта строка Паули, и не должна иметь повторяющихся элементов.</span><span class="sxs-lookup"><span data-stu-id="e7e81-236">The third parameter `Int[]` indexes the qubits that this Pauli string acts on, and must have no duplicate elements.</span></span> <span data-ttu-id="e7e81-237">Таким образом, Хамилтониан термин $0,4 \хат X_0 \хат Y_8\hat I_2\hat Z_1 $ может быть представлен как</span><span class="sxs-lookup"><span data-stu-id="e7e81-237">Thus the Hamiltonian term $0.4 \hat X_0 \hat Y_8\hat I_2\hat Z_1$ may be represented as</span></span>

```qsharp
let generatorIndexExample = GeneratorIndex(([1,2,0,3], [0.4]]), [0,8,2,1]);
```

<span data-ttu-id="e7e81-238">`PauliEvolutionSet()` — это функция, которая сопоставляет `GeneratorIndex` этой формы с `EvolutionUnitary` со следующей сигнатурой.</span><span class="sxs-lookup"><span data-stu-id="e7e81-238">The `PauliEvolutionSet()` is a function that maps any `GeneratorIndex` of this form to an `EvolutionUnitary` with the following signature.</span></span>

```qsharp
newtype EvolutionUnitary = ((Double, Qubit[]) => Unit is Adj + Ctl);
```

<span data-ttu-id="e7e81-239">Первый параметр представляет временную длительность, который умножается на коэффициент в `GeneratorIndex`е в едином развитии.</span><span class="sxs-lookup"><span data-stu-id="e7e81-239">The first parameter represents a time-duration, that will be multiplied by the coefficient in the `GeneratorIndex`, of unitary evolution.</span></span> <span data-ttu-id="e7e81-240">Вторым параметром является кубит, который регистрируется для единой функции.</span><span class="sxs-lookup"><span data-stu-id="e7e81-240">The second parameter is the qubit register the unitary acts on.</span></span> 

### <a name="time-dependent-generators"></a><span data-ttu-id="e7e81-241">Генераторы, зависящие от времени</span><span class="sxs-lookup"><span data-stu-id="e7e81-241">Time-Dependent Generators</span></span> ###

<span data-ttu-id="e7e81-242">Во многих случаях мы также заинтересованы в моделировании зависимых от времени генераторов, как это может произойти в уравнении Шредингер $ $ \бегин{алигн} и\фрак {d \кет{\пси (t)}} {d t} & = \хат H (t) \кет{\пси (t)}, \енд{алигн} $ $, где генератор $ \хат H (t) $ теперь зависит от времени.</span><span class="sxs-lookup"><span data-stu-id="e7e81-242">In many cases, we are also interested in modelling time-dependent generators, as might occur in the Schrödinger equation $$ \begin{align} i\frac{d \ket{\psi(t)}}{d t} & = \hat H(t) \ket{\psi(t)}, \end{align} $$ where the generator $\hat H(t)$ is now time-dependent.</span></span> <span data-ttu-id="e7e81-243">Расширение из независимых от времени генераторов выше этого случая очень просто.</span><span class="sxs-lookup"><span data-stu-id="e7e81-243">The extension from the time-independent generators above to this case is straightforward.</span></span> <span data-ttu-id="e7e81-244">Вместо фиксированного `GeneratorSystem`, описывающего Хамилтониан для всех значений $t $, мы используем тип `GeneratorSystemTimeDependent`, определяемый пользователем.</span><span class="sxs-lookup"><span data-stu-id="e7e81-244">Rather than having a fixed `GeneratorSystem` describing the Hamiltonian for all times $t$, we instead have the `GeneratorSystemTimeDependent` user-defined type.</span></span>

```qsharp
newtype GeneratorSystemTimeDependent = (Double -> GeneratorSystem);
```

<span data-ttu-id="e7e81-245">Первый параметр является непрерывным параметром расписания $s \ин [0, 1] $, а функции этого типа возвращают `GeneratorSystem` для этого расписания.</span><span class="sxs-lookup"><span data-stu-id="e7e81-245">The first parameter is a continuous schedule parameter $s\in [0,1]$, and functions of this type return a `GeneratorSystem` for that schedule.</span></span> <span data-ttu-id="e7e81-246">Обратите внимание, что параметр Schedule может быть линейно связан с параметром физического времени, например $s = t/T $, для некоторого общего времени моделирования $T $.</span><span class="sxs-lookup"><span data-stu-id="e7e81-246">Note that the schedule parameter may be linearly related to the physical time parameter e.g. $s = t / T$, for some total time of simulation $T$.</span></span> <span data-ttu-id="e7e81-247">Однако в общем случае это не так.</span><span class="sxs-lookup"><span data-stu-id="e7e81-247">In general however, this need not be the case.</span></span>

<span data-ttu-id="e7e81-248">Аналогичным образом, полное описание этого генератора требует `EvolutionSet`, и поэтому мы определим `EvolutionSchedule` определяемый пользователем тип.</span><span class="sxs-lookup"><span data-stu-id="e7e81-248">Similarly, a complete description of this generator requires an `EvolutionSet`, and so we define an `EvolutionSchedule` user-defined type.</span></span>

```qsharp
newtype EvolutionSchedule = (EvolutionSet, GeneratorSystemTimeDependent);
```
