---
title: 'Q # Стандартные библиотеки — версионного | Документация Майкрософт'
description: 'Q # Стандартные библиотеки — версионного'
author: QuantumWriter
uid: microsoft.quantum.libraries.standard.prelude
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: dddb3d4a5ebcdca16da41a5ae5520d98ea900a7f
ms.sourcegitcommit: 8becfb03eb60ba205c670a634ff4daa8071bcd06
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/29/2019
ms.locfileid: "73183239"
---
# <a name="the-prelude"></a>Версионного #

Компилятор Q # и целевые компьютеры, входящие в состав пакета средств разработки тактовой передачи, предоставляют набор встроенных функций и операций, которые можно использовать при написании тактовых программ в Q #.

## <a name="intrinsic-operations-and-functions"></a>Встроенные операции и функции ##

Внутренние операции, определенные в стандартной библиотеке, относятся к одной из нескольких категорий:

- Неотъемлемые классические функции, собранные в пространстве имен <xref:microsoft.quantum.core>.
- Операции, представляющие унитариес, состоящие из [Клиффорд и $T $ Gates](xref:microsoft.quantum.concepts.qubit).
- Операции, представляющие повороты различных операторов.
- Операции, реализующие измерения.

Так как набор шлюзов Клиффорд + $T $ является [универсальным](xref:microsoft.quantum.concepts.multiple-qubits) для тактовых вычислений, эти операции достаточно для реализации любого тактового алгоритма в неглигибли небольшой ошибке.
Предоставляя также повороты, Q # позволяет программисту работать в рамках единой кубит единой и кнот ворота библиотеки. Эту библиотеку гораздо проще подумать, так как она не требует от программиста непосредственного выражения Клиффорд + $T $, и так как существуют высокоэффективные методы для компиляции одного кубит унитариес в Клиффорд и $T $ Гейтс (см. [здесь](xref:microsoft.quantum.more-information) для получения дополнительных сведений).

Там, где это возможно, операции, определенные в версионного, которые работают с Кубитс, позволяют применить вариант `Controlled`, чтобы целевой компьютер выполнит соответствующую декомпозицию.

Многие функции и операции, определенные в этой части версионного, находятся в пространстве имен @"microsoft.quantum.intrinsic", поэтому большинство исходных файлов Q # будет иметь `open Microsoft.Quantum.Intrinsic;`ную директиву сразу после объявления первоначального пространства имен.
Пространство имен <xref:microsoft.quantum.core> автоматически открывается, поэтому такие функции, как <xref:microsoft.quantum.core.length>, можно использовать без инструкции `open`.

### <a name="common-single-qubit-unitary-operations"></a>Распространенные операции с одиночным кубит единым ###

Версионного также определяет многие распространенные [операции с одной кубит](xref:microsoft.quantum.concepts.qubit#single-qubit-operations).
Все эти операции допускают как `Controlled`, так `Adjoint` операторов.

#### <a name="pauli-operators"></a>Операторы Паули ####

Операция <xref:microsoft.quantum.intrinsic.x> реализует оператор Паули $X $.
Это иногда также называется шлюзом `NOT`.
Он имеет `(Qubit => Unit is Adj + Ctl)`сигнатуры.
Он соответствует единому кубит едину:

\бегин{екуатион} \бегин{бматрикс} 0 & 1 \\\\% FIXME: в настоящее время используется куадвхакк.
1 & 0 \енд{бматрикс} \енд{екуатион}

Операция <xref:microsoft.quantum.intrinsic.y> реализует оператор Паули $Y $.
Он имеет `(Qubit => Unit is Adj + Ctl)`сигнатуры.
Он соответствует единому кубит едину:

\бегин{екуатион} \бегин{бматрикс} 0 &-i \\\\% FIXME: в настоящее время используется куадвхакк.
я & 0 \енд{бматрикс} \енд{екуатион}

Операция <xref:microsoft.quantum.intrinsic.z> реализует оператор Паули $Z $.
Он имеет `(Qubit => Unit is Adj + Ctl)`сигнатуры.
Он соответствует единому кубит едину:

\бегин{екуатион} \бегин{бматрикс} 1 & 0 \\\\% FIXME: это в настоящее время использует куадвхакк.
0 &-1 \енд{бматрикс} \енд{екуатион}

Ниже показаны преобразования, сопоставленные с [блочной сферой](xref:microsoft.quantum.concepts.qubit#visualizing-qubits-and-transformations-using-the-bloch-sphere) (ось вращения в каждом случае выделяется красным цветом):

![Операции Паули, сопоставленные с сферой БЛОЧ](~/media/prelude_pauliBloch.png)

Важно отметить, что применение одного и того же шлюза Паули дважды к тому же кубит отменяет операцию (так как теперь вы выполнили полный поворот 2π (360 °) над поверхностью БЛОЧ Sphere, что приводит к последующей отправной точке). Это приводит нас к следующему удостоверению:

$ $ X ^ 2 = Y ^ 2 = Z ^ 2 = \болдоне $ $

Это можно визуально использовать в сфере БЛОЧ:

![XX = I](~/media/prelude_blochIdentity.png)

#### <a name="other-single-qubit-cliffords"></a>Другие одиночные кубит Клиффордс ####

<xref:microsoft.quantum.intrinsic.h>ная операция реализует шлюз Хадамард.
Это изменяет оси Паули $X $ и $Z $ целевого кубит, например $H \кет{0} = \кет{+} \масрел{: =} (\кет{0} + \кет{1})/\скрт{2}$ и $H \кет{+} = \кет{0}$.
Он имеет сигнатуру `(Qubit => Unit is Adj + Ctl)`и соответствует единому кубит:

\бегин{екуатион} \фрак{1}{\скрт{2}} \бегин{бматрикс} 1 & 1 \\\\% FIXME: в настоящее время используется куадвхакк Hack.
1 &-1 \енд{бматрикс} \енд{екуатион}

Шлюз Хадамард особенно важен, так как его можно использовать для создания части $ \кет{0}$ and $ \кет{1}$ States. В представлении БЛОЧ Sphere проще всего подумать об этом как повороте $ \кет{\пси} $ вокруг оси x на $ \пи $ радианы ($ 180 ^ \Цирк $), за которым следует вращение (по часовой стрелке) вокруг оси y на $ \ PI/2 $ радианы ($ 90 ^ \Цирк $):

![Операция хадамард, сопоставленная с сферой БЛОЧ](~/media/prelude_hadamardBloch.png)

<xref:microsoft.quantum.intrinsic.s>ная операция реализует шлюз фазы $S $.
Это квадратный корень матрицы операции Паули $Z $.
То есть $S ^ 2 = Z $.
Он имеет сигнатуру `(Qubit => Unit is Adj + Ctl)`и соответствует единому кубит:

\бегин{екуатион} \бегин{бматрикс} 1 & 0 \\\\% FIXME: это в настоящее время использует куадвхакк.
0 & я \енд{бматрикс} \енд{екуатион}

#### <a name="rotations"></a>Поворотов ####

В дополнение к операциям Паули и Клиффорд выше, Q # версионного предоставляет разнообразные способы выражения поворотов.
Как описано в разделе [операции с одним кубит](xref:microsoft.quantum.concepts.qubit#single-qubit-operations), возможность смены критически важна для алгоритмов такта.

Начнем с того, что мы можем выразить любую операцию с одним кубит, используя $H $ и $T $ Gates, где $H $ является операцией Хадамард, и где \бегин{екуатион} T \масрел{: =} \бегин{бматрикс} 1 & 0 \\\\% FIXME: в настоящее время используется четыре возврата отправляю хакеров.
0 & e ^ {i \пи/4} \енд{бматрикс} \енд{екуатион} это квадратный корень из операции <xref:microsoft.quantum.intrinsic.s>, что $T ^ 2 = S $.
$T $ Gate в свою очередь реализуется операцией <xref:microsoft.quantum.intrinsic.t> и имеет `(Qubit => Unit is Adj + Ctl)`сигнатуры, указывая, что это единая операция с одним кубит.

Несмотря на то, что этот принцип достаточно для описания любой произвольной операции с одним кубит, различные целевые компьютеры могут иметь более эффективные представления для ротации операторов Паули, таким образом, версионного включает различные способы конвиенентли выражать такие повороты.
Наиболее простым из них является операция <xref:microsoft.quantum.intrinsic.r>, которая реализует поворот вокруг заданной оси Паули, \бегин{екуатион} R (\сигма, \фи) \масрел{: =} \експ (-i \фи \сигма/2), \енд{екуатион}, где $ \сигма $ является оператором Паули, $ \Phi $ является углом и где $ \експ $ представляет экспоненту матрицы.
Он имеет `((Pauli, Double, Qubit) => Unit is Adj + Ctl)`сигнатуры, где первые две части входных данных представляют собой классические аргументы $ \сигма $ и $ \фи $, необходимые для указания $Rного оператора (\сигма, \фи) $.
Можно частично применить $ \сигма $ и $ \фи $, чтобы получить операцию, тип которой является производным от одного кубит.
Например, `R(PauliZ, PI() / 4, _)` имеет тип `(Qubit => Unit is Adj + Ctl)`.

> [!NOTE]
> Операция <xref:microsoft.quantum.intrinsic.r> делит входной угол на 2 и умножает его на-1.
> Для ротаций $Z $ это означает, что параметр $ \кет{0}$ еиженстате поворачивается на $-\фи/$2, а $ \кет{1}$ еиженстате поворачивается на $ \фи/$2. Таким образом,{0}\кет{1}$ еиженстате поворачивается на $ \фи $ по сравнению с $ \кет $ еиженстате.
>
> В частности, это означает, что `T` и `R(PauliZ, PI() / 8, _)` отличаются только ненужной [глобальной фазой](xref:microsoft.quantum.glossary#global-phase).
> По этой причине $T $ иногда называют $ \фрак{\пи}{8}$-Gate.
>
> Обратите внимание, что поворот вокруг `PauliI` просто применяет глобальную фазу $ \фи/$2. Хотя такие этапы несущественны, как в [концептуальных документах](xref:microsoft.quantum.concepts.qubit), они важны для управляемых `PauliI`ных поворотов.

В алгоритмах такта часто бывает полезно выражать повороты как ДЯДИК дроби, например $ \фи = \пи k/2 ^ n $ для некоторых $k \ин \Масбб{з} $ и $n \ин \Масбб{н} $.
Операция <xref:microsoft.quantum.intrinsic.rfrac> реализует поворот вокруг указанной оси Паули, используя это соглашение.
Он отличается от <xref:microsoft.quantum.intrinsic.r> тем, что угол вращения указан как два входных параметра типа `Int`, интерпретируемые как ДЯДИК дробь.
Таким же `RFrac` имеет `((Pauli, Int, Int, Qubit) => Unit is Adj + Ctl)`сигнатуры.
Он реализует однокубитную единую $ \експ (i \пи k \сигма/2 ^ n) $, где $ \сигма $ — это матрица Паули, соответствующая первому аргументу, $k $ является вторым аргументом, а $n $ — третьим аргументом.
`RFrac(_,k,n,_)` совпадает с `R(_,-πk/2^n,_)`; Обратите внимание, что угол — это *отрицательная* часть дроби.

Операция <xref:microsoft.quantum.intrinsic.rx> реализует поворот вокруг оси Паули $X $.
Он имеет `((Double, Qubit) => Unit is Adj + Ctl)`сигнатуры.
`Rx(_, _)` совпадает с `R(PauliX, _, _)`.

Операция <xref:microsoft.quantum.intrinsic.ry> реализует поворот вокруг оси Паули $Y $.
Он имеет `((Double, Qubit) => Unit is Adj + Ctl)`сигнатуры.
`Ry(_, _)` совпадает с `R(PauliY,_ , _)`.

Операция <xref:microsoft.quantum.intrinsic.rz> реализует поворот вокруг оси Паули $Z $.
Он имеет `((Double, Qubit) => Unit is Adj + Ctl)`сигнатуры.
`Rz(_, _)` совпадает с `R(PauliZ, _, _)`.

Операция <xref:microsoft.quantum.intrinsic.r1> реализует поворот на заданную сумму около $ \кет{1}$, еиженстате $-$1 из $Z $.
Он имеет `((Double, Qubit) => Unit is Adj + Ctl)`сигнатуры.
`R1(phi,_)` совпадает с `R(PauliZ,phi,_)`, за которым следует `R(PauliI,-phi,_)`.

Операция <xref:microsoft.quantum.intrinsic.r1frac> реализует поворот на дробную часть по заданному объему вокруг Z = 1 еиженстате.
Он имеет `((Int,Int, Qubit) => Unit is Adj + Ctl)`сигнатуры.
`R1Frac(k,n,_)` совпадает с `RFrac(PauliZ,-k.n+1,_)`, за которым следует `RFrac(PauliI,k,n+1,_)`.

Пример операции вращения (вокруг оси Паули $Z $ в этом экземпляре), сопоставленной с блочной сферой, показан ниже:

![Операция вращения, сопоставленная с блочной сферой](~/media/prelude_rotationBloch.png)

#### <a name="multi-qubit-operations"></a>Операции с несколькими кубит ####

В дополнение к кубит операциям выше, версионного также определяет несколько операций с несколькими кубит.

Во-первых, операция <xref:microsoft.quantum.intrinsic.cnot> выполняет стандартный шлюз`NOT` \бегин{екуатион} \Операторнаме{кнот} \масрел{: =} \бегин{бматрикс} 1 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & 1 \\\\ 0 & 0 & 1 & 0 \енд{бматрикс}.
\енд{екуатион} имеет сигнатуру `((Qubit, Qubit) => Unit is Adj + Ctl)`, представляющую, что $ \Операторнаме{кнот} $ действует унитарили на двух отдельных Кубитс.
`CNOT(q1, q2)` совпадает с `(Controlled X)([q1], q2)`.
Поскольку `Controlled` функтор позволяет управлять регистром, мы используем `[q1]` литерала массива, чтобы указать, что нам нужен только один элемент управления.

Операция <xref:microsoft.quantum.intrinsic.ccnot> выполняет не шлюз с удвоенной назначением, иногда также известный как шлюз Тоффоли.
Он имеет `((Qubit, Qubit, Qubit) => Unit is Adj + Ctl)`сигнатуры.
`CCNOT(q1, q2, q3)` совпадает с `(Controlled X)([q1, q2], q3)`.

Операция <xref:microsoft.quantum.intrinsic.swap> меняет местами такты двух Кубитс.
То есть реализуется единая матрица \бегин{екуатион} \Операторнаме{СВАП} \масрел{: =} \бегин{бматрикс} 1 & 0 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & 1 \енд{бматрикс}.
\енд{екуатион} имеет подпись `((Qubit, Qubit) => Unit is Adj + Ctl)`.
`SWAP(q1,q2)` эквивалентна `CNOT(q1, q2)`, за которой следует `CNOT(q2, q1)`, а затем `CNOT(q1, q2)`.

> [!NOTE]
> Шлюз подкачки *не* совпадает с изменением расположения элементов переменной с типом `Qubit[]`.
> Применение `SWAP(q1, q2)` приводит к изменению состояния Кубитс, на которое ссылается `q1` и `q2`, тогда как `let swappedRegister = [q2, q1];` влияет только на то, как мы будем ссылаться на эти Кубитс.
> Более того, `(Controlled SWAP)([q0], (q1, q2))` позволяет использовать `SWAP` в состоянии третьего кубит, который не может быть представлен путем изменения расположения элементов.
> Шлюз с управляемым ПЕРЕКЛЮЧЕНИЕм, также известный как шлюз Фредкин, достаточно мощный для включения всех классических вычислений.

Наконец, версионного предоставляет две операции для представления экспоненциальных функций операторов множественного кубит Паули.
Операция <xref:microsoft.quantum.intrinsic.exp> выполняет вращение на основе тензорные произведения матриц Паули, представленного множеством кубит, единым \бегин{екуатион} \Операторнаме{ЕКСП} (\век{\сигма}, \фи) \масрел{: =} \експ\лефт (i \Phi \sigma_0 \otimes \sigma_1 \otimes \ кдотс \отимес \sigma_n \ригхт), \енд{екуатион} WHERE $ \век{\сигма} = (\sigma_0, \sigma_1, \дотс, \sigma_n) $ — это последовательность однокубитных операторов Паули, где $ \фи $ является углом.
`Exp`ный поворот представляет $ \век{\сигма} $ как массив элементов `Pauli`, так что он имеет `((Pauli[], Double, Qubit[]) => Unit is Adj + Ctl)`сигнатуры.

Операция <xref:microsoft.quantum.intrinsic.expfrac> выполняет тот же поворот, используя нотацию дробной части ДЯДИК, о которой говорилось выше.
Он имеет `((Pauli[], Int, Int, Qubit[]) => Unit is Adj + Ctl)`сигнатуры.

> [!WARNING]
> Экспоненциальные произведения тензорные операторов Паули не аналогичны тензорныеным продуктам экспоненциальных операторов Паули.
> То есть $e ^ {i (Z \отимес Z) \фи} \не e ^ {i Z \фи} \отимес e ^ {i Z \фи} $.

### <a name="measurements"></a>Измерения ###

При измерении значение + 1 еиженвалуе оператора соответствует результату `Zero`, а значение-1 еиженвалуе — результату `One`.

> [!NOTE]
> Хотя это соглашение может показаться странным, оно имеет два очень замечательных преимущества.
> Во-первых, наблюдение за результатом $ \кет{0}$ представляется `Result` значением `Zero`, а наблюдение $ \кет{1}$ соответствует `One`.
> Во-вторых, мы можем написать, что еиженвалуе $ \ламбда $ соответствует результату, $r $ — $ \ламбда = (-1) ^ r $.

Операции измерения не поддерживают ни `Adjoint`, ни `Controlled` функтор.

Операция <xref:microsoft.quantum.intrinsic.measure> выполняет совместное измерение одного или нескольких Кубитс в указанном продукте операторов Паули.
Если массив Паули и массив кубит имеют разную длину, операция завершается ошибкой.
`Measure` имеет `((Pauli[], Qubit[]) => Result)`сигнатур.

Обратите внимание, что совместное измерение не совпадает с измерением каждого кубит по отдельности.
Например, рассмотрим состояние $ \кет{11} = \кет{1} \отимес \кет{1} = Кс\отимес X \кет{00}$.
По отдельности измеряйте $Z _0 $ и $Z _1 $, чтобы получить результаты $r _0 = $1 и $r _1 = $1.
Однако при измерении $Z _0 Z_1 $ мы получаем единственный результат $r _ {\текстрм{жоинт}} = $0, представляющий, что пара $ \кет{11}$ является положительной.
Разместите иначе $ (-1) ^ {r_0 + r_1} = (-1) ^ r_ {\текстрм{жоинт}}) $.
Так как мы изучен *только* четность из этого измерения, все сведения о такте, представленные в подстановке 2 2 между кубит состояниями положительной четности, $ \кет{00}$ и $ \кет{11}$, сохраняются.
Это свойство будет необходимо для дальнейшего использования, так как мы обсудим исправление ошибок.

Для удобства версионного также предоставляет две другие операции для измерения Кубитс.
Во-первых, поскольку выполнение однокубитных измерений довольно распространено, версионного определяет сокращение для этого случая.
Операция <xref:microsoft.quantum.intrinsic.m> измеряет оператор Паули $Z $ в одном кубит и имеет `(Qubit => Result)`сигнатуры.
`M(q)` эквивалентно правилу `Measure([PauliZ], [q])`.

<xref:microsoft.quantum.measurement.multim> измеряет оператор Паули $Z $ *отдельно* для каждого массива Кубитс, возвращая *массив* значений `Result`, полученных для каждого кубит.
В некоторых случаях это можно оптимизировать. Он имеет подпись (`Qubit[] => Result[])`.
`MultiM(qs)` эквивалентна:

```qsharp
mutable rs = new Result[Length(qs)];
for (index in 0..Length(qs)-1)
{
    set rs[index] = M(qs[index]);
}
return rs;
```

## <a name="extension-functions-and-operations"></a>Функции и операции расширения ##

Кроме того, версионного определяет широкий набор математических функций и функции преобразования типов на уровне .NET для использования в рамках кода Q #.
Например, пространство имен <xref:microsoft.quantum.extensions.math> определяет такие полезные операции, как <xref:microsoft.quantum.extensions.math.sin> и <xref:microsoft.quantum.extensions.math.log>.
Реализация, предоставляемая пакетом разработки тактовой передачи, использует классическую библиотеку базовых классов .NET и, таким же, может затрагивать дополнительный обмен информацией между тактовыми программами и их классическими драйверами.
Хотя это и не является проблемой для локального симулятора, это может быть проблемой с производительностью при использовании удаленного симулятора или реального оборудования в качестве целевого компьютера.
С другой стороны, отдельный целевой компьютер может уменьшить это воздействие на производительность, переопределив эти операции с использованием версий, которые более эффективны для конкретной системы.

### <a name="math"></a>Math ###

Пространство имен <xref:microsoft.quantum.extensions.math> предоставляет множество полезных функций из [класса`System.Math`](https://docs.microsoft.com/dotnet/api/system.math?view=netframework-4.7.1)библиотеки базовых классов .NET.
Эти функции можно использовать точно так же, как и любые другие функции Q #:

```qsharp
open Microsoft.Quantum.Math;
// ...
let y = Sin(theta);
```

Если статический метод .NET перегружен в зависимости от типа его аргументов, соответствующая функция Q # задается суффиксом, указывающим тип входных данных:

```qsharp
let x = AbsI(-3); // x : Int = 3
let y = AbsD(-PI()); // y : Double = 3.1415...
```


### <a name="bitwise-operations"></a>Битовые операции ###

Наконец, пространство имен <xref:microsoft.quantum.extensions.bitwise> предоставляет несколько полезных функций для управления целыми числами с помощью побитовых операторов.
Например, <xref:microsoft.quantum.extensions.bitwise.parity> возвращает побитовую четность целого числа в виде другого целого числа.
