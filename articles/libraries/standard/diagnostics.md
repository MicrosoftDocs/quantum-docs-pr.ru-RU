---
title: 'Диагностика в стандартных библиотеках Q #'
description: 'Сведения о диагностических функциях и операциях в стандартных библиотеках Q #, используемых для перехвата ошибок или ошибок в тактовых программах.'
author: cgranade
uid: microsoft.quantum.libraries.diagnostics
ms.author: chgranad@microsoft.com
ms.topic: article
ms.openlocfilehash: fa5173f710dd9e0b0b2c110e45aa0bf019111aca
ms.sourcegitcommit: 2317473fdf2b80de58db0f43b9fcfb57f56aefff
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/15/2020
ms.locfileid: "83426311"
---
# <a name="diagnostics"></a><span data-ttu-id="dda02-103">Диагностика</span><span class="sxs-lookup"><span data-stu-id="dda02-103">Diagnostics</span></span> #

<span data-ttu-id="dda02-104">Как и в классической среде разработки, важно иметь возможность диагностировать ошибки и ошибки в тактовых программах.</span><span class="sxs-lookup"><span data-stu-id="dda02-104">As with classical development, it is important to be able to diagnose mistakes and errors in quantum programs.</span></span>
<span data-ttu-id="dda02-105">Библиотеки Q # Standard предоставляют различные способы обеспечения правильности работы тактовых программ, как описано в <xref:microsoft.quantum.guide.testingdebugging> .</span><span class="sxs-lookup"><span data-stu-id="dda02-105">The Q# standard libraries provide a variety of different ways to ensure the correctness of quantum programs, as detailed in <xref:microsoft.quantum.guide.testingdebugging>.</span></span>
<span data-ttu-id="dda02-106">В основном эта поддержка происходит в виде функций и операций, которые указывают целевому компьютеру предоставить дополнительные диагностические сведения для основной программы или разработчика или обеспечивают правильность условий и инвариантов, выраженных вызовом функции или операции.</span><span class="sxs-lookup"><span data-stu-id="dda02-106">Largely speaking, this support comes in the form of functions and operations that either instruct the target machine to provide additional diagnostic information to the host program or developer, or enforce the correctness of conditions and invariants expressed by the function or operation call.</span></span>

## <a name="machine-diagnostics"></a><span data-ttu-id="dda02-107">Диагностика компьютеров</span><span class="sxs-lookup"><span data-stu-id="dda02-107">Machine Diagnostics</span></span> ##

<span data-ttu-id="dda02-108">Диагностическую информацию о классических значениях можно получить с помощью <xref:microsoft.quantum.intrinsic.message> функции, которая зарегистрирует сообщение в зависимости от компьютера.</span><span class="sxs-lookup"><span data-stu-id="dda02-108">Diagnostics about classical values can be obtained by using the <xref:microsoft.quantum.intrinsic.message> function to log a message in a machine-dependent way.</span></span>
<span data-ttu-id="dda02-109">По умолчанию строка записывается в консоль.</span><span class="sxs-lookup"><span data-stu-id="dda02-109">By default, this writes the string to the console.</span></span>
<span data-ttu-id="dda02-110">Используется вместе с интерполяцией строк, <xref:microsoft.quantum.intrinsic.message> что позволяет легко передавать диагностические сведения о классических значениях:</span><span class="sxs-lookup"><span data-stu-id="dda02-110">Used together with interpolated strings, <xref:microsoft.quantum.intrinsic.message> makes it easy to report diagnostic information about classical values:</span></span>

```Q#
let angle = Microsoft.Quantum.Math.PI() * 2.0 / 3.0;
Message($"About to rotate by an angle of {angle}...");
```

> [!NOTE]
> <span data-ttu-id="dda02-111">`Message`имеет сигнатуру `(String -> Unit)` , которая снова представляет, что сообщение журнала отладки не может рассматриваться в Q #.</span><span class="sxs-lookup"><span data-stu-id="dda02-111">`Message` has signature `(String -> Unit)`, again representing that emitting a debug log message cannot be observed from within Q#.</span></span>

<span data-ttu-id="dda02-112">Вызываемые командлеты <xref:microsoft.quantum.diagnostics.dumpmachine> <xref:microsoft.quantum.diagnostics.dumpregister> указывают целевым компьютерам на предоставление диагностических сведений обо всех текущих выделенных Кубитс или о конкретной регистрации Кубитс, соответственно.</span><span class="sxs-lookup"><span data-stu-id="dda02-112">The <xref:microsoft.quantum.diagnostics.dumpmachine> and <xref:microsoft.quantum.diagnostics.dumpregister> callables instruct target machines to provide diagnostic information about all currently allocated qubits or about a specific register of qubits, respectively.</span></span>
<span data-ttu-id="dda02-113">Каждый целевой компьютер зависит от того, какие диагностические сведения предоставляются в ответ на инструкцию дампа.</span><span class="sxs-lookup"><span data-stu-id="dda02-113">Each target machine varies in what diagnostic information is provided in response to a dump instruction.</span></span>
<span data-ttu-id="dda02-114">Например, целевой компьютер [имитатора полного состояния](xref:microsoft.quantum.machines.full-state-simulator) предоставляет основной программе вектор состояния, который используется внутренне для представления регистра Кубитс.</span><span class="sxs-lookup"><span data-stu-id="dda02-114">The [full state simulator](xref:microsoft.quantum.machines.full-state-simulator) target machine, for instance, provides the host program with the state vector that it uses internally to represent a register of qubits.</span></span>
<span data-ttu-id="dda02-115">По сравнению, целевой компьютер [имитатора Тоффоли](xref:microsoft.quantum.machines.toffoli-simulator) предоставляет единый Классический бит для каждого кубит.</span><span class="sxs-lookup"><span data-stu-id="dda02-115">By comparison, the [Toffoli simulator](xref:microsoft.quantum.machines.toffoli-simulator) target machine provides a single classical bit for each qubit.</span></span>

 <span data-ttu-id="dda02-116">Чтобы узнать больше о выходных данных [имитатора полного состояния](xref:microsoft.quantum.machines.full-state-simulator) `DumpMachine` , ознакомьтесь с разделом функции дампа [статьи тестирование и отладка](xref:microsoft.quantum.guide.testingdebugging#dump-functions).</span><span class="sxs-lookup"><span data-stu-id="dda02-116">To learn more about the [full state simulator's](xref:microsoft.quantum.machines.full-state-simulator) `DumpMachine` output, take a look at the dump functions section of our [testing and debugging article](xref:microsoft.quantum.guide.testingdebugging#dump-functions).</span></span>


## <a name="facts-and-assertions"></a><span data-ttu-id="dda02-117">Факты и утверждения</span><span class="sxs-lookup"><span data-stu-id="dda02-117">Facts and Assertions</span></span> ##

<span data-ttu-id="dda02-118">Как обсуждалось в разделе [тестирование и отладка](xref:microsoft.quantum.guide.testingdebugging), функция или операция с сигнатурой `Unit -> Unit` или `Unit => Unit` , соответственно, могут быть помечены как *модульный тест*.</span><span class="sxs-lookup"><span data-stu-id="dda02-118">As discussed in [Testing and Debugging](xref:microsoft.quantum.guide.testingdebugging), a function or operation with signature `Unit -> Unit` or `Unit => Unit`, respectively, can be marked as a *unit test*.</span></span>
<span data-ttu-id="dda02-119">Каждый модульный тест обычно состоит из небольшой тактовой программы, а также одного или нескольких условий, которые проверяют правильность этой программы.</span><span class="sxs-lookup"><span data-stu-id="dda02-119">Each unit test generally consists of a small quantum program, along with one or more conditions that check the correctness of that program.</span></span>
<span data-ttu-id="dda02-120">Эти условия могут поступать в виде любых _фактов_, которые проверяют значения их входных данных или _утверждения_, которые проверяют состояния одного или нескольких Кубитс, переданных в качестве входных данных.</span><span class="sxs-lookup"><span data-stu-id="dda02-120">These conditions can come in the form of either _facts_, which check the values of their inputs, or _assertions_, which check the states of one or more qubits passed as input.</span></span>

<span data-ttu-id="dda02-121">Например, `EqualityFactI(1 + 1, 2, "1 + 1 != 2")` представляет математический факт, что $1 + 1 = $2, а `AssertQubit(One, qubit)` представляет условие, которое измерение `qubit` будет возвращать `One` с сохранением.</span><span class="sxs-lookup"><span data-stu-id="dda02-121">For example, `EqualityFactI(1 + 1, 2, "1 + 1 != 2")` represents the mathematical fact that $1 + 1 = 2$, while `AssertQubit(One, qubit)` represents the condition that measuring `qubit` will return a `One` with certainty.</span></span>
<span data-ttu-id="dda02-122">В первом случае мы можем проверить правильность условия, учитывая только его значения. в последнем случае нам необходимо узнать о состоянии кубит, чтобы оценить утверждение.</span><span class="sxs-lookup"><span data-stu-id="dda02-122">In the former case, we can check the correctness of the condition given only its values, while in the latter, we must know something about the state of the qubit in order to evaluate the assertion.</span></span>

<span data-ttu-id="dda02-123">Стандартные библиотеки Q # предоставляют несколько различных функций для представления фактов, включая:</span><span class="sxs-lookup"><span data-stu-id="dda02-123">The Q# standard libraries provide several different functions for representing facts, including:</span></span>

- <xref:microsoft.quantum.diagnostics.fact>
- <xref:microsoft.quantum.diagnostics.equalitywithintolerancefact>
- <xref:microsoft.quantum.diagnostics.nearequalityfactc>
- <xref:microsoft.quantum.diagnostics.equalityfacti>


### <a name="testing-qubit-states"></a><span data-ttu-id="dda02-124">Тестирование состояний кубит</span><span class="sxs-lookup"><span data-stu-id="dda02-124">Testing Qubit States</span></span> ###

<span data-ttu-id="dda02-125">На практике утверждения полагаются на тот факт, что классический симулятор механики не должен подчиняться [Теорема без клонирования](https://arxiv.org/abs/quant-ph/9607018), так что мы можем делать нефизические измерения и утверждения при использовании симулятора на нашем целевом компьютере.</span><span class="sxs-lookup"><span data-stu-id="dda02-125">In practice, assertions rely on the fact that classical simulations of quantum mechanics need not obey the [no-cloning theorem](https://arxiv.org/abs/quant-ph/9607018), such that we can make unphysical measurements and assertions when using a simulator for our target machine.</span></span>
<span data-ttu-id="dda02-126">Таким же путем можно протестировать отдельные операции в классический симулятор перед развертыванием на оборудовании.</span><span class="sxs-lookup"><span data-stu-id="dda02-126">Thus, we can test individual operations on a classical simulator before deploying on hardware.</span></span>
<span data-ttu-id="dda02-127">На целевых компьютерах, которые не допускают оценку утверждений, вызовы в <xref:microsoft.quantum.intrinsic.assert> можно спокойно игнорировать.</span><span class="sxs-lookup"><span data-stu-id="dda02-127">On target machines which do not allow evaluation of assertions, calls to <xref:microsoft.quantum.intrinsic.assert> can be safely ignored.</span></span>

<span data-ttu-id="dda02-128">Как правило, <xref:microsoft.quantum.intrinsic.assert> Операция утверждает, что измерение данного Кубитс в заданной паулиной базе всегда будет иметь заданный результат.</span><span class="sxs-lookup"><span data-stu-id="dda02-128">More generally, the <xref:microsoft.quantum.intrinsic.assert> operation asserts that measuring the given qubits in the given Pauli basis will always have the given result.</span></span>
<span data-ttu-id="dda02-129">Если утверждение не выполняется, выполнение завершается вызовом `fail` с заданным сообщением.</span><span class="sxs-lookup"><span data-stu-id="dda02-129">If the assertion fails, the execution ends by calling `fail` with the given message.</span></span>
<span data-ttu-id="dda02-130">По умолчанию эта операция не реализована. Симуляторы, которые могут поддерживать ИТ, должны обеспечивать реализацию, которая выполняет проверку среды выполнения.</span><span class="sxs-lookup"><span data-stu-id="dda02-130">By default, this operation is not implemented; simulators that can support it should provide an implementation that performs runtime checking.</span></span>
<span data-ttu-id="dda02-131">`Assert`имеет сигнатуру `((Pauli[], Qubit[], Result, String) -> ())` .</span><span class="sxs-lookup"><span data-stu-id="dda02-131">`Assert` has signature `((Pauli[], Qubit[], Result, String) -> ())`.</span></span>
<span data-ttu-id="dda02-132">Поскольку `Assert` функция является функцией с пустым кортежем в качестве типа выходных данных, `Assert` в программе Q # не вызываются никакие эффекты.</span><span class="sxs-lookup"><span data-stu-id="dda02-132">Since `Assert` is a function with an empty tuple as its output type, no effects from having called `Assert` are observable within a Q# program.</span></span>

<span data-ttu-id="dda02-133"><xref:microsoft.quantum.intrinsic.assertprob>Функция Operation утверждает, что измерение заданного Кубитс в заданной паулиной базе будет иметь заданный результат с заданной вероятностью в пределах некоторой допустимости.</span><span class="sxs-lookup"><span data-stu-id="dda02-133">The <xref:microsoft.quantum.intrinsic.assertprob> operation function asserts that measuring the given qubits in the given Pauli basis will have the given result with the given probability, within some tolerance.</span></span>
<span data-ttu-id="dda02-134">Допуском является аддитивный (например, `abs(expected-actual) < tol` ).</span><span class="sxs-lookup"><span data-stu-id="dda02-134">Tolerance is additive (e.g. `abs(expected-actual) < tol`).</span></span>
<span data-ttu-id="dda02-135">Если утверждение не выполняется, выполнение завершается вызовом `fail` с заданным сообщением.</span><span class="sxs-lookup"><span data-stu-id="dda02-135">If the assertion fails, the execution ends by calling `fail` with the given message.</span></span>
<span data-ttu-id="dda02-136">По умолчанию эта операция не реализована. Симуляторы, которые могут поддерживать ИТ, должны обеспечивать реализацию, которая выполняет проверку среды выполнения.</span><span class="sxs-lookup"><span data-stu-id="dda02-136">By default, this operation is not implemented; simulators that can support it should provide an implementation that performs runtime checking.</span></span>
<span data-ttu-id="dda02-137">`AssertProb`имеет сигнатуру `((Pauli[], Qubit[], Result, Double, String, Double) -> Unit)` .</span><span class="sxs-lookup"><span data-stu-id="dda02-137">`AssertProb` has signature `((Pauli[], Qubit[], Result, Double, String, Double) -> Unit)`.</span></span> <span data-ttu-id="dda02-138">Первый из `Double` параметров дает желаемую вероятность результата, а второй — допуск.</span><span class="sxs-lookup"><span data-stu-id="dda02-138">The first of `Double` parameters gives the desired probability of the result, and the second one the tolerance.</span></span>

<span data-ttu-id="dda02-139">Мы можем сделать больше, чем утверждение одного измерения, используя классическую информацию, используемую симулятором для представления внутреннего состояния кубита, податливася к копированию, чтобы не нужно было фактически выполнять измерение для тестирования нашего утверждения.</span><span class="sxs-lookup"><span data-stu-id="dda02-139">We can do more than assert a single measurement, using that the classical information used by a simulator to represent the internal state of a qubit is amenable to copying, such that we do not need to actually perform a measurement to test our assertion.</span></span>
<span data-ttu-id="dda02-140">В частности, это позволяет нам полагаться на *несовместимые* измерения, которые могут быть невозможно на фактическом оборудовании.</span><span class="sxs-lookup"><span data-stu-id="dda02-140">In particular, this allows us to reason about *incompatible* measurements that would be impossible on actual hardware.</span></span>

<span data-ttu-id="dda02-141">Предположим, что `P : Qubit => Unit` это операция, предназначенная для подготовки состояния $ \кет{\пси} $, когда входные данные находятся в состоянии $ \кет {0} $.</span><span class="sxs-lookup"><span data-stu-id="dda02-141">Suppose that `P : Qubit => Unit` is an operation intended to prepare the state $\ket{\psi}$ when its input is in the state $\ket{0}$.</span></span>
<span data-ttu-id="dda02-142">Let $ \кет{\пси '} $ станет действительным состоянием, подготовленным `P` .</span><span class="sxs-lookup"><span data-stu-id="dda02-142">Let $\ket{\psi'}$ be the actual state prepared by `P`.</span></span>
<span data-ttu-id="dda02-143">Затем $ \кет{\пси} = \кет{\пси '} $ If и только в том случае, если измерение $ \кет{\пси '} $ на оси, описываемом $ \кет{\пси} $, всегда возвращает значение `Zero` .</span><span class="sxs-lookup"><span data-stu-id="dda02-143">Then, $\ket{\psi} = \ket{\psi'}$ if and only if measuring $\ket{\psi'}$ in the axis described by $\ket{\psi}$ always returns `Zero`.</span></span>
<span data-ttu-id="dda02-144">То есть \бегин{алигн} \кет{\пси} = \кет{\пси '} \текст{, только если} \бракет{\пси | \пси '} = 1.</span><span class="sxs-lookup"><span data-stu-id="dda02-144">That is, \begin{align} \ket{\psi} = \ket{\psi'} \text{ if and only if } \braket{\psi | \psi'} = 1.</span></span>
<span data-ttu-id="dda02-145">\енд{алигн} с помощью примитивных операций, определенных в версионного, мы можем напрямую выполнить измерение, возвращающее, `Zero` Если $ \кет{\пси} $ является еиженстате одного из операторов Паули.</span><span class="sxs-lookup"><span data-stu-id="dda02-145">\end{align} Using the primitive operations defined in the prelude, we can directly perform a measurement that returns `Zero` if $\ket{\psi}$ is an eigenstate of one of the Pauli operators.</span></span>


<span data-ttu-id="dda02-146">Операция <xref:microsoft.quantum.diagnostics.assertqubit> является особенно полезной для этого в том случае, если мы хотим протестировать утверждение $ \кет{\пси} = \кет {0} $.</span><span class="sxs-lookup"><span data-stu-id="dda02-146">The operation <xref:microsoft.quantum.diagnostics.assertqubit> provides a particularly useful shorthand to do so in the case that we wish to test the assertion $\ket{\psi} = \ket{0}$.</span></span>
<span data-ttu-id="dda02-147">Это часто, например, когда мы невычисленными, чтобы вернуть анЦилла Кубитс в $ \кет {0} $ перед их освобождением.</span><span class="sxs-lookup"><span data-stu-id="dda02-147">This is common, for instance, when we have uncomputed to return ancilla qubits to $\ket{0}$ before releasing them.</span></span>
<span data-ttu-id="dda02-148">Утверждение для $ \кет {0} $ также полезно, когда мы хотим подтвердить, что две подготовительные `P` операции и `Q` действия подготавливают одно и то же состояние и когда `Q` поддерживают `Adjoint` .</span><span class="sxs-lookup"><span data-stu-id="dda02-148">Asserting against $\ket{0}$ is also useful when we wish to assert that two state preparation `P` and `Q` operations both prepare the same state, and when `Q` supports `Adjoint`.</span></span>
<span data-ttu-id="dda02-149">В частности,</span><span class="sxs-lookup"><span data-stu-id="dda02-149">In particular,</span></span>

```qsharp
using (register = Qubit()) {
    P(register);
    Adjoint Q(register);

    AssertQubit(Zero, register);
}
```

<span data-ttu-id="dda02-150">Однако в общем случае у нас может не быть доступа к утверждениям о состояниях, которые не совпадают с еиженстатес операторами Паули.</span><span class="sxs-lookup"><span data-stu-id="dda02-150">More generally, however, we may not have access to assertions about states that do not coincide with eigenstates of Pauli operators.</span></span>
<span data-ttu-id="dda02-151">Например, $ \кет{\пси} = (\кет {0} + e ^ {i \пи/8} \кет {1} )/\скрт {2} $ не является Еиженстате любого оператора Паули, так что мы не можем использовать <xref:microsoft.quantum.intrinsic.assertprob> для однозначного определения того, что состояние $ \кет{\пси '} $ равно $ \кет{\пси} $.</span><span class="sxs-lookup"><span data-stu-id="dda02-151">For example, $\ket{\psi} = (\ket{0} + e^{i \pi / 8} \ket{1}) / \sqrt{2}$ is not an eigenstate of any Pauli operator, such that we cannot use <xref:microsoft.quantum.intrinsic.assertprob> to uniquely determine that a state $\ket{\psi'}$ is equal to $\ket{\psi}$.</span></span>
<span data-ttu-id="dda02-152">Вместо этого необходимо разложить утверждение $ \кет{\пси '} = \кет{\пси} $ на предположения, которые можно напрямую протестировать с использованием примитивов, поддерживаемых нашим симулятором.</span><span class="sxs-lookup"><span data-stu-id="dda02-152">Instead, we must decompose the assertion $\ket{\psi'} = \ket{\psi}$ into assumptions that can be directly tested using  the primitives supported by our simulator.</span></span>
<span data-ttu-id="dda02-153">Для этого позвольте $ \кет{\пси} = \алфа \кет {0} + \бета \кет {1} $ для комплексных чисел $ \алфа = a \_ r + a \_ i $ and $ \бета $.</span><span class="sxs-lookup"><span data-stu-id="dda02-153">To do so, let $\ket{\psi} = \alpha \ket{0} + \beta \ket{1}$ for complex numbers $\alpha = a\_r + a\_i i$ and $\beta$.</span></span>
<span data-ttu-id="dda02-154">Обратите внимание, что для этого выражения требуется четыре вещественных числа $ \{ a \_ r, a \_ i, b \_ r, b \_ i \} $ для указания, так как каждое комплексное число можно выразить как сумму действительной и мнимой части.</span><span class="sxs-lookup"><span data-stu-id="dda02-154">Note that this expression requires four real numbers $\{a\_r, a\_i, b\_r, b\_i\}$ to specify, as each complex number can be expressed as the sum of a real and imaginary part.</span></span>
<span data-ttu-id="dda02-155">Однако из-за глобального этапа мы можем выбрать $a \_ i = $0, чтобы для уникальной идентификации одного кубитного состояния нам потребуются только три реальных числа.</span><span class="sxs-lookup"><span data-stu-id="dda02-155">Due to the global phase, however, we can choose $a\_i = 0$, such that we only need three real numbers to uniquely specify a single-qubit state.</span></span>

<span data-ttu-id="dda02-156">Таким образом, необходимо указать три утверждения, которые не зависят друг от друга, чтобы подтвердить предполагаемое состояние.</span><span class="sxs-lookup"><span data-stu-id="dda02-156">Thus, we need to specify three assertions which are independent of each other in order to assert the state that we expect.</span></span>
<span data-ttu-id="dda02-157">Для этого нужно найти вероятность наблюдения `Zero` за каждым Паули измерением, заданным $ \алфа $ и $ \бета $, и утвердить их независимо друг от друга.</span><span class="sxs-lookup"><span data-stu-id="dda02-157">We do so by finding the probability of observing `Zero` for each Pauli measurement given $\alpha$ and $\beta$, and asserting each independently.</span></span>
<span data-ttu-id="dda02-158">Let $x $, $y $ и $z $ должны быть `Result` значениями для паули $X $, $Y $ и $Z $ измерений соответственно.</span><span class="sxs-lookup"><span data-stu-id="dda02-158">Let $x$, $y$, and $z$ be `Result` values for Pauli $X$, $Y$, and $Z$ measurements respectively.</span></span>
<span data-ttu-id="dda02-159">Затем, используя функцию правдоподобия для измерений тактов, \бегин{алигн} \Пр (x = \Тексттт{зеро} | \алфа, \бета) & = \frac12 + a \_ r b \_ r + a \_ i b \_ i \\ \\ \пр (y = \тексттт{зеро} | \алфа, \бета) & = \frac12 + a \_ r b \_ i – a \_ b \_ r \\ \\ \пр (z = \тексттт{зеро} | \alpha, \beta) & = \frac12\left (1 + a \_ r ^ 2 + b i ^ 2 \_ \_ \_ \right).</span><span class="sxs-lookup"><span data-stu-id="dda02-159">Then, using the likelihood function for quantum measurements, \begin{align} \Pr(x = \texttt{Zero} | \alpha, \beta) & = \frac12 + a\_r b\_r + a\_i b\_i \\\\ \Pr(y = \texttt{Zero} | \alpha, \beta) & = \frac12 + a\_r b\_i - a\_i b\_r \\\\ \Pr(z = \texttt{Zero} | \alpha, \beta) & = \frac12\left( 1 + a\_r^2 + a\_i^2 + b\_r^2 + b\_i^2 \right).</span></span>
<span data-ttu-id="dda02-160">\енд{алигн}</span><span class="sxs-lookup"><span data-stu-id="dda02-160">\end{align}</span></span>

<span data-ttu-id="dda02-161"><xref:microsoft.quantum.diagnostics.assertqubitisinstatewithintolerance>Операция реализует эти утверждения, заданные в представлениях $ \алфа $ и $ \бета $ в качестве значений типа <xref:microsoft.quantum.math.complex> .</span><span class="sxs-lookup"><span data-stu-id="dda02-161">The <xref:microsoft.quantum.diagnostics.assertqubitisinstatewithintolerance> operation implements these assertions given representations of $\alpha$ and $\beta$ as values of type <xref:microsoft.quantum.math.complex>.</span></span>
<span data-ttu-id="dda02-162">Это полезно, когда ожидаемое состояние может быть вычислено математическим.</span><span class="sxs-lookup"><span data-stu-id="dda02-162">This is helpful when the expected state can be computed mathematically.</span></span>

### <a name="asserting-equality-of-quantum-operations"></a><span data-ttu-id="dda02-163">Утверждение равенства операций такта</span><span class="sxs-lookup"><span data-stu-id="dda02-163">Asserting Equality of Quantum Operations</span></span> ###

<span data-ttu-id="dda02-164">До сих пор мы работаем над тестированием операций, предназначенных для подготовки определенных состояний.</span><span class="sxs-lookup"><span data-stu-id="dda02-164">Thus far, we have been concerned with testing operations which are intended to prepare particular states.</span></span>
<span data-ttu-id="dda02-165">Однако часто мы заинтересованы в том, как операция работает с произвольными входными данными, а не с одним фиксированным входом.</span><span class="sxs-lookup"><span data-stu-id="dda02-165">Often, however, we are interested in how an operation acts for arbitrary inputs rather than for a single fixed input.</span></span>
<span data-ttu-id="dda02-166">Например, предположим, что мы реализовали операцию, `U : ((Double, Qubit[]) => () : Adjoint)` соответствующую семейству единых операторов $U (t) $, и предоставили явный `adjoint` блок вместо использования `adjoint auto` .</span><span class="sxs-lookup"><span data-stu-id="dda02-166">For example, suppose we have implemented an operation `U : ((Double, Qubit[]) => () : Adjoint)` corresponding to a family of unitary operators $U(t)$, and have provided an explicit `adjoint` block instead of using `adjoint auto`.</span></span>
<span data-ttu-id="dda02-167">Мы можем заинтересовать, что $U ^ \дагжер (t) = U (-t) $, как и ожидалось, если $t $ представляет время развития.</span><span class="sxs-lookup"><span data-stu-id="dda02-167">We may be interested in asserting that $U^\dagger(t) = U(-t)$, as expected if $t$ represents an evolution time.</span></span>

<span data-ttu-id="dda02-168">В общем, существует две различные стратегии, которые мы можем отслеживать, чтобы сделать утверждение, которое две операции `U` и `V` действуют одинаково.</span><span class="sxs-lookup"><span data-stu-id="dda02-168">Broadly speaking, there are two different strategies that we can follow in making the assertion that two operations `U` and `V` act identically.</span></span>
<span data-ttu-id="dda02-169">Во-первых, мы можем проверить, `U(target); (Adjoint V)(target);` сохраняет ли каждое состояние на заданном уровне.</span><span class="sxs-lookup"><span data-stu-id="dda02-169">First, we can check that `U(target); (Adjoint V)(target);` preserves each state in a given basis.</span></span>
<span data-ttu-id="dda02-170">Во вторых, мы можем проверить, что, `U(target); (Adjoint V)(target);` действуя с половиной состояния запутанными, сохраняет замкнутые.</span><span class="sxs-lookup"><span data-stu-id="dda02-170">Second, we can check that `U(target); (Adjoint V)(target);` acting on half of an entangled state preserves that entanglement.</span></span>
<span data-ttu-id="dda02-171">Эти стратегии реализуются с помощью операций Canon <xref:microsoft.quantum.diagnostics.assertoperationsequalinplace> и <xref:microsoft.quantum.diagnostics.assertoperationsequalreferenced> соответственно.</span><span class="sxs-lookup"><span data-stu-id="dda02-171">These strategies are implemented by the canon operations <xref:microsoft.quantum.diagnostics.assertoperationsequalinplace> and <xref:microsoft.quantum.diagnostics.assertoperationsequalreferenced>, respectively.</span></span>

> [!NOTE]
> <span data-ttu-id="dda02-172">Упомянутое выше утверждение работает на основе [Чои – жамиłковски исоморфисм](https://en.wikipedia.org/wiki/Channel-state_duality), математической платформы, которая связывает операции с $n $ Кубитс с запутанными состояниями в $2N $ Кубитс.</span><span class="sxs-lookup"><span data-stu-id="dda02-172">The referenced assertion discussed above works based on the [Choi–Jamiłkowski isomorphism](https://en.wikipedia.org/wiki/Channel-state_duality), a mathematical framework which relates operations on $n$ qubits to entangled states on $2n$ qubits.</span></span>
> <span data-ttu-id="dda02-173">В частности, операция идентификации в $n $ Кубитс представляется $n $ копиями состояния запутанными $ \кет{\ beta_ {00} } \масрел{: =} (\кет {00} + \кет {11} )/\скрт {2} $.</span><span class="sxs-lookup"><span data-stu-id="dda02-173">In particular, the identity operation on $n$ qubits is represented by $n$ copies of the entangled state $\ket{\beta_{00}} \mathrel{:=} (\ket{00} + \ket{11}) / \sqrt{2}$.</span></span>
> <span data-ttu-id="dda02-174">Операция <xref:microsoft.quantum.preparation.preparechoistate> реализует этот исоморфисм, подготавливая состояние, представляющее заданную операцию.</span><span class="sxs-lookup"><span data-stu-id="dda02-174">The operation <xref:microsoft.quantum.preparation.preparechoistate> implements this isomorphism, preparing a state that represents a given operation.</span></span>

<span data-ttu-id="dda02-175">Примерно эти стратегии различаются по времени.</span><span class="sxs-lookup"><span data-stu-id="dda02-175">Roughly, these strategies are distinguished by a time–space tradeoff.</span></span>
<span data-ttu-id="dda02-176">Для прохода по каждому входному состоянию требуется дополнительное время, а для использования замкнутые в качестве ссылки требуется хранить дополнительные Кубитс.</span><span class="sxs-lookup"><span data-stu-id="dda02-176">Iterating through each input state takes additional time, while using entanglement as a reference requires storing additional qubits.</span></span>
<span data-ttu-id="dda02-177">В случаях, когда операция реализует обратимую классическую операцию, в которой мы заинтересованы только в своем поведении на вычислительные состояния, <xref:microsoft.quantum.diagnostics.assertoperationsequalinplacecompbasis> проверяет равенство на этом ограниченном наборе входных данных.</span><span class="sxs-lookup"><span data-stu-id="dda02-177">In cases where an operation implements a reversible classical operation, such that we are only interested in its behavior on computational basis states, <xref:microsoft.quantum.diagnostics.assertoperationsequalinplacecompbasis> tests equality on this restricted set of inputs.</span></span>

> [!TIP]
> <span data-ttu-id="dda02-178">Итерация по состояниям ввода обрабатывается операциями перечисления <xref:microsoft.quantum.canon.iteratethroughcartesianproduct> и <xref:microsoft.quantum.canon.iteratethroughcartesianpower> .</span><span class="sxs-lookup"><span data-stu-id="dda02-178">The iteration over input states is handled by the enumeration operations <xref:microsoft.quantum.canon.iteratethroughcartesianproduct> and <xref:microsoft.quantum.canon.iteratethroughcartesianpower>.</span></span>
> <span data-ttu-id="dda02-179">Эти операции более часто используются для применения операции к каждому элементу декартово произведения между двумя или более наборами.</span><span class="sxs-lookup"><span data-stu-id="dda02-179">These operations are useful more generally for applying an operation to each element of the Cartesian product between two or more sets.</span></span>

<span data-ttu-id="dda02-180">Однако, что более важно, два подхода проверяют различные свойства выполняемых операций.</span><span class="sxs-lookup"><span data-stu-id="dda02-180">More critically, however, the two approaches test different properties of the operations under examination.</span></span>
<span data-ttu-id="dda02-181">Поскольку утверждение на месте вызывает каждую операцию несколько раз, один раз для каждого входного состояния, любые случайные выборки и результаты измерения могут измениться между вызовами.</span><span class="sxs-lookup"><span data-stu-id="dda02-181">Since the in-place assertion calls each operation multiple times, once for each input state, any random choices and measurement results might change between calls.</span></span>
<span data-ttu-id="dda02-182">Напротив, проверочное утверждение, на которое указывает ссылка, вызывает каждую операцию только один раз, так что она проверяет, что операции равны *одному снимку*.</span><span class="sxs-lookup"><span data-stu-id="dda02-182">By contrast, the referenced assertion calls each operation exactly once, such that it checks that the operations are equal *in a single shot*.</span></span>
<span data-ttu-id="dda02-183">Оба эти теста полезны для обеспечения правильности тактовых программ.</span><span class="sxs-lookup"><span data-stu-id="dda02-183">Both of these tests are useful in ensuring the correctness of quantum programs.</span></span>


## <a name="further-reading"></a><span data-ttu-id="dda02-184">Дополнительные материалы</span><span class="sxs-lookup"><span data-stu-id="dda02-184">Further Reading</span></span> ##

- <xref:microsoft.quantum.guide.testingdebugging>
- <xref:microsoft.quantum.diagnostics>
