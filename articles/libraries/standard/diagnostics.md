---
title: 'Q # Стандартные библиотеки — диагностика | Документация Майкрософт'
description: 'Q # Стандартные библиотеки — диагностика'
author: cgranade
uid: microsoft.quantum.libraries.diagnostics
ms.author: chgranad@microsoft.com
ms.topic: article
ms.openlocfilehash: d5889b8d5a92801b0ada65f7a17c655c959fc57f
ms.sourcegitcommit: 27c9bf1aae923527aa5adeaee073cb27d35c0ca1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/05/2019
ms.locfileid: "74864344"
---
# <a name="diagnostics"></a>Диагностика: #

Как и в классической среде разработки, важно иметь возможность диагностировать ошибки и ошибки в тактовых программах.
Библиотеки Q # Standard предоставляют различные способы обеспечения правильности работы тактовых программ, как описано в <xref:microsoft.quantum.techniques.testing-and-debugging>.
В основном эта поддержка возникает в виде функций и операций, которые сообщают целевому компьютеру о необходимости предоставления дополнительных диагностических сведений ведущему приложению или разработчику, а также обеспечивают правильность выражаются условия и инварианты. функцией или вызовом операции.

## <a name="machine-diagnostics"></a>Диагностика компьютеров ##

Диагностику для классических значений можно получить с помощью функции <xref:microsoft.quantum.intrinsic.message> для записи сообщения в зависимости от компьютера.
По умолчанию строка записывается в консоль.
Используется вместе с интерполяцией строк, <xref:microsoft.quantum.intrinsic.message> позволяет легко сообщить диагностическую информацию о классических значениях:

```Q#
let angle = Microsoft.Quantum.Math.PI() * 2.0 / 3.0;
Message($"About to rotate by an angle of {angle}...");
```

> [!NOTE]
> `Message` имеет `(String -> Unit)`сигнатуры, которая снова представляет, что сообщение журнала отладки не может рассматриваться в Q #.

Вызываемые <xref:microsoft.quantum.diagnostics.dumpmachine> и <xref:microsoft.quantum.diagnostics.dumpregister> указывают целевым компьютерам на предоставление диагностических сведений обо всех текущих выделенных Кубитс или о конкретной регистрации Кубитс, соответственно.
Каждый целевой компьютер зависит от того, какие диагностические сведения предоставляются в ответ на инструкцию дампа.
Например, целевой компьютер [имитатора полного состояния](xref:microsoft.quantum.machines.full-state-simulator) предоставляет основной программе вектор состояния, который используется внутренне для представления регистра Кубитс.
По сравнению, целевой компьютер [имитатора Тоффоли](xref:microsoft.quantum.machines.toffoli-simulator) предоставляет единый Классический бит для каждого кубит.

 Чтобы узнать больше о `DumpMachine` выходных данных [симулятора состояния](xref:microsoft.quantum.machines.full-state-simulator) , ознакомьтесь с разделом функции дампа [статьи тестирование и отладка](xref:microsoft.quantum.techniques.testing-and-debugging#dump-functions).


## <a name="facts-and-assertions"></a>Факты и утверждения ##

Как обсуждалось в разделе [тестирование и отладка](xref:microsoft.quantum.techniques.testing-and-debugging), функция или операция с сигнатурой `Unit -> Unit` или `Unit => Unit`, соответственно, может быть помечена как *модульный тест*.
Каждый модульный тест обычно состоит из небольшой тактовой программы, а также одного или нескольких условий, которые проверяют правильность этой программы.
Эти условия могут поступать в виде любых _фактов_, которые проверяют значения их входных данных или _утверждения_, которые проверяют состояния одного или нескольких Кубитс, переданных в качестве входных данных.

Например, `EqualityFactI(1 + 1, 2, "1 + 1 != 2")` представляет математическый факт, что $1 + 1 = $2, а `AssertQubit(One, qubit)` представляет условие, которое `qubit` будет возвращать `One` с сохранением точности.
В первом случае мы можем проверить правильность условия, учитывая только его значения. в последнем случае нам необходимо узнать о состоянии кубит, чтобы оценить утверждение.

Стандартные библиотеки Q # предоставляют несколько различных функций для представления фактов, включая:

- <xref:microsoft.quantum.diagnostics.fact>
- <xref:microsoft.quantum.diagnostics.equalitywithintolerancefact>
- <xref:microsoft.quantum.diagnostics.nearequalityfact>
- <xref:microsoft.quantum.diagnostics.equalityfacti>


### <a name="testing-qubit-states"></a>Тестирование состояний кубит ###

На практике утверждения полагаются на тот факт, что классический симулятор механики не должен подчиняться [Теорема без клонирования](https://arxiv.org/abs/quant-ph/9607018), так что мы можем делать нефизические измерения и утверждения при использовании симулятора на нашем целевом компьютере.
Таким же путем можно протестировать отдельные операции в классический симулятор перед развертыванием на оборудовании.
На целевых компьютерах, которые не допускают оценку утверждений, вызовы <xref:microsoft.quantum.intrinsic.assert> можно спокойно игнорировать.

В общем случае операция <xref:microsoft.quantum.intrinsic.assert> утверждает, что измерение данного Кубитс в заданной Паулиной базе всегда будет иметь заданный результат.
Если утверждение не выполняется, выполнение завершается вызовом `fail` с данным сообщением.
По умолчанию эта операция не реализована. Симуляторы, которые могут поддерживать ИТ, должны обеспечивать реализацию, которая выполняет проверку среды выполнения.
`Assert` имеет `((Pauli[], Qubit[], Result, String) -> ())`сигнатур.
Поскольку `Assert` является функцией с пустым кортежем в качестве типа выходных данных, в программе Q # не происходит наблюдение за вызовом `Assert`.

Функция <xref:microsoft.quantum.intrinsic.assertprob>ной операции утверждает, что измерение заданного Кубитс в заданной Паулиной базе будет иметь заданный результат с заданной вероятностью в пределах некоторой допустимости.
Допуском является аддитивный (например, `abs(expected-actual) < tol`).
Если утверждение не выполняется, выполнение завершается вызовом `fail` с данным сообщением.
По умолчанию эта операция не реализована. Симуляторы, которые могут поддерживать ИТ, должны обеспечивать реализацию, которая выполняет проверку среды выполнения.
`AssertProb` имеет `((Pauli[], Qubit[], Result, Double, String, Double) -> Unit)`сигнатур. Первый из `Double` параметров дает желаемую вероятность результата, а второй — допуск.

Мы можем сделать больше, чем утверждение одного измерения, используя классическую информацию, используемую симулятором для представления внутреннего состояния кубита, податливася к копированию, чтобы не нужно было фактически выполнять измерение для тестирования нашего утверждения.
В частности, это позволяет нам полагаться на *несовместимые* измерения, которые могут быть невозможно на фактическом оборудовании.

Предположим, что `P : Qubit => Unit` является операцией, предназначенной для подготовки состояния $ \кет{\пси} $, когда его входные данные находятся в состоянии $ \кет{0}$.
Let $ \кет{\пси '} $ станет действительным состоянием, подготовленным `P`.
Затем $ \кет{\пси} = \кет{\пси '} $ If и только в том случае, если измерение $ \кет{\пси '} $ на оси, описываемом $ \кет{\пси} $, всегда возвращает `Zero`.
То есть \бегин{алигн} \кет{\пси} = \кет{\пси '} \текст{, только если} \бракет{\пси | \пси '} = 1.
\енд{алигн} с помощью примитивных операций, определенных в версионного, можно напрямую выполнить измерение, возвращающее `Zero`, если $ \кет{\пси} $ является еиженстате одного из операторов Паули.


Операция <xref:microsoft.quantum.diagnostics.assertqubit> предоставляет особенно полезную форму для этого в случае, если мы хотим протестировать утверждение $ \кет{\пси} = \кет{0}$.
Это часто, например, когда мы невычисленными, чтобы вернуть анЦилла Кубитс в $ \кет{0}$ перед их освобождением.
Утверждение для $ \кет{0}$ также полезно в том случае, если необходимо подтвердить, что две операции подготовки состояния `P` и `Q` как подготавливают одно и то же состояние, а также когда `Q` поддерживает `Adjoint`.
В частности,

```qsharp
using (register = Qubit()) {
    P(register);
    Adjoint Q(register);

    AssertQubit(Zero, register);
}
```

Однако в общем случае у нас может не быть доступа к утверждениям о состояниях, которые не совпадают с еиженстатес операторами Паули.
Например, $ \кет{\пси} = (\кет{0} + e ^ {i \пи/8} \кет{1})/\скрт{2}$ не является еиженстате любого оператора Паули, поэтому мы не можем использовать <xref:microsoft.quantum.intrinsic.assertprob>, чтобы однозначно определить, что состояние $ \кет{\пси "} $ равно $ \кет{\пси} $.
Вместо этого необходимо разложить утверждение $ \кет{\пси '} = \кет{\пси} $ на предположения, которые можно напрямую протестировать с использованием примитивов, поддерживаемых нашим симулятором.
Для этого Let $ \кет{\пси} = \алфа \кет{0} + \бета \кет{1}$ для комплексных чисел $ \алфа = a\_r + a\_i $ and $ \бета $.
Обратите внимание, что для этого выражения требуется четыре вещественных числа $\{\_r,\_i, b\_r, b\_я\}$ для указания, так как каждое комплексное число можно выразить как сумму действительной и мнимой части.
Тем не менее, из-за глобального этапа можно выбрать $a\_i = $0, так что нам нужно только три реальных числа, чтобы уникальным образом указать одно кубит состояние.

Таким образом, необходимо указать три утверждения, которые не зависят друг от друга, чтобы подтвердить предполагаемое состояние.
Для этого нужно найти вероятность наблюдаемых `Zero` для каждого измерения Паули с заданными $ \алфа $ и $ \бета $ и утверждения каждого из них независимо друг от друга.
Давайте $x $, $y $ и $z $ должны `Result` значения для Паули $X $, $Y $ и $Z $, соответственно.
Затем, используя функцию правдоподобия для измерений тактов, \бегин{алигн} \Пр (x = \Тексттт{зеро} | \алфа, \бета) & = \frac12 + a\_r b\_r + a\_я b\_i \\\\ \Пр (y = \Тексттт{зеро} | \алфа, \бета) & = \frac12 + a\_r b\_\_б\_r \\\\ \Пр (z = \Тексттт{зеро} | \alpha, \beta) & = \frac12\left (1 + a\_r ^ 2 + a\_я ^ 2 + b\_r ^ 2 + b\_i ^ 2 \ригхт).
\енд{алигн}

Операция <xref:microsoft.quantum.diagnostics.assertqubitisinstatewithintolerance> реализует эти утверждения, заданные в представлениях $ \алфа $ и $ \бета $ в качестве значений типа <xref:microsoft.quantum.math.complex>.
Это полезно, когда ожидаемое состояние может быть вычислено математическим.

### <a name="asserting-equality-of-quantum-operations"></a>Утверждение равенства операций такта ###

До сих пор мы работаем над тестированием операций, предназначенных для подготовки определенных состояний.
Однако часто мы заинтересованы в том, как операция работает с произвольными входными данными, а не с одним фиксированным входом.
Например, предположим, что мы реализовали операцию `U : ((Double, Qubit[]) => () : Adjoint)`, соответствующую семейству единых операторов $U (t) $, и предоставили явный блок `adjoint` вместо использования `adjoint auto`.
Мы можем заинтересовать, что $U ^ \дагжер (t) = U (-t) $, как и ожидалось, если $t $ представляет время развития.

В широком смысле, существуют две различные стратегии, с помощью которых можно сделать утверждение о том, что две операции `U` и `V` работают одинаково.
Во-первых, мы можем проверить, `U(target); (Adjoint V)(target);` сохраняет каждое состояние в определенной базе данных.
Во вторых, можно проверить, что `U(target); (Adjoint V)(target);`, взаимодействующие с половиной состояния запутанными, сохраняют замкнутые.
Эти стратегии реализуются с помощью операций Canon <xref:microsoft.quantum.diagnostics.assertoperationsequalinplace> и <xref:microsoft.quantum.diagnostics.assertoperationsequalreferenced>соответственно.

> [!NOTE]
> Упомянутое выше утверждение работает на основе [Чои – жамиłковски исоморфисм](https://en.wikipedia.org/wiki/Channel-state_duality), математической платформы, которая связывает операции с $n $ Кубитс с запутанными состояниями в $2N $ Кубитс.
> В частности, операция идентификации в $n $ Кубитс представляется $n $ копиями состояния запутанными $ \кет{\ beta_{00}} \масрел{: =} (\кет{00} + \кет{11})/\скрт{2}$.
> <xref:microsoft.quantum.preparation.preparechoistate> операции реализует этот исоморфисм, подготавливая состояние, представляющее заданную операцию.

Примерно эти стратегии различаются по времени.
Для прохода по каждому входному состоянию требуется дополнительное время, а для использования замкнутые в качестве ссылки требуется хранить дополнительные Кубитс.
В случаях, когда операция реализует обратимую классическую операцию, так что мы заинтересованы только в своем поведении на вычислительные состояния, <xref:microsoft.quantum.diagnostics.assertoperationsequalinplacecompbasis> проверки равенства в этом ограниченном наборе входных данных.

> [!TIP]
> Итерация по состояниям ввода обрабатывается операциями перечисления <xref:microsoft.quantum.canon.iteratethroughcartesianproduct> и <xref:microsoft.quantum.canon.iteratethroughcartesianpower>.
> Эти операции более часто используются для применения операции к каждому элементу декартово произведения между двумя или более наборами.

Однако, что более важно, два подхода проверяют различные свойства выполняемых операций.
Поскольку утверждение на месте вызывает каждую операцию несколько раз, один раз для каждого входного состояния, любые случайные выборки и результаты измерения могут измениться между вызовами.
Напротив, проверочное утверждение, на которое указывает ссылка, вызывает каждую операцию только один раз, так что она проверяет, что операции равны *одному снимку*.
Оба эти теста полезны для обеспечения правильности тактовых программ.


## <a name="further-reading"></a>Дополнительные материалы ##

- <xref:microsoft.quantum.techniques.testing-and-debugging>
- <xref:microsoft.quantum.diagnostics>
