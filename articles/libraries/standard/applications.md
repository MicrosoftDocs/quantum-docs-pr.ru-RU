---
title: 'Q # Стандартные библиотеки — приложения | Документация Майкрософт'
description: Стандартные библиотеки Q#
author: QuantumWriter
uid: microsoft.quantum.libraries.applications
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: 3e629e095bd2ee492496066710ef6fd4e578a543
ms.sourcegitcommit: ca5015fed409eaf0395a89c2e4bc6a890c360aa2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/29/2020
ms.locfileid: "76868974"
---
# <a name="applications"></a>Приложения #

## <a name="hamiltonian-simulation"></a>Гамильтоново моделирование ##

Имитация тактовых систем является одним из самых интересных приложений вычислений тактов.
На классическом компьютере сложность имитации тактового генератора в целом масштабируется с помощью измерения $N $ из представления вектора состояния.
Так как это представление экспоненциально растет с числом $n $ Кубитс $N = 2 ^ n $, признаком, известным также как « [рекурсивное](xref:microsoft.quantum.concepts.multiple-qubits)», является недоступным для классического оборудования.

Однако ситуация может сильно различаться на тактовой аппаратуре. Наиболее распространенный вариант моделирования тактов называется независимым от времени проблемой моделирования Хамилтониан. В нем имеется описание System Хамилтониан $H $, Хермитиан матрица, и некоторое начальное состояние такта $ \кет{\пси (0)} $, которое кодируется в $n $ Кубитс на тактовый компьютер. По мере того, как состояния такта в закрытых системах развиваются в уравнении Шредингер $ $ \бегин{алигн} и\фрак {d \кет{\пси (t)}} {d t} & = H \кет{\пси (t)}, \енд{алигн} $ $ целью является реализация единого $U оператора времени (t) = e ^ {-ИХТ} $ в неопределенное время $t $ , где $ \кет{\пси (t)} = U (t) \кет{\пси (0)} $ разрешает уравнение Шредингер.
Аналогично, проблема Хамилтониан моделирования, зависящая от времени, решает одно и то же уравнение, но с $H (t) $ теперь является функцией времени.

Имитация хамилтониан — это основной компонент многих других проблем моделирования тактов, а решения для проблем моделирования Хамилтониан — это алгоритмы, описывающие последовательность примитивов-простых тактов для синтезирования приблизительного целого числа $ \Тилде{у} $ с ошибкой $\\| \Тилде{у}-U (t)\\| \ле \епсилон $ в [норме Спектрал](xref:microsoft.quantum.concepts.matrix-advanced). Сложность этих алгоритмов очень сильно зависит от того, как описание Хамилтониана становится доступным для тактового компьютера. Например, в худшем случае, если $H $ действует на $n $ Кубитс в виде списка чисел $2 ^ n \тимес 2 ^ n $, по одному для каждого элемента Matrix, простое чтение данных уже потребовало экспоненциального времени. В лучшем случае можно предположить доступ к черного ящика, что $O \кет{т}\кет{\пси (0)} = \Кет{т}у (t) \кет{\пси (0)} $ тривиально решает проблему. Ни одна из этих моделей не особенно интересна — первое, что лучше, чем классические подходы, а второе — как черный квадрат скрывает примитивную сложность своей реализации, которая может быть экспоненциальной в числе Кубитс.

### <a name="descriptions-of-hamiltonians"></a>Описание Хамилтонианс ###

Поэтому требуются дополнительные предположения для формата входных данных. Баланс между входными моделями, которые достаточно описательны для того, чтобы охватывать интересные Хамилтонианс, например для реалистичных физических систем или интересных вычислительных задач, должен быть очень точным. для эффективной реализации на тактовой системе. В литературе может быть обнаружено множество нетривиальных моделей ввода, которые находятся в диапазоне от такта до классического. 

В качестве примеров для моделей входных данных, [основанных на образцах, хамилтониан моделирования](http://www.nature.com/articles/s41534-017-0013-7) предполагает доступ с помощью черного ящика к операциям-тактам, которые создают копии матрицы плотности $ \рхо $, которые принимаются хамилтониан $H $. В [единой модели доступа](https://arxiv.org/abs/1202.5822) Предположим, что хамилтониан не разбивается на сумму унитариес $ $ \бегин{алигн} H & = \сум ^ {d-1}\_{j = 0} a\_j \хат{у}\_j, \енд{алигн} $ $, где $a\_j > 0 $ являются коэффициентами, а $ \хат{у}\_j $ — унитариес. Предполагается, что один из них имеет черный доступ к единой Oracle $V = \сум ^ {d-1}\_{j = 0} \кет{ж}\бра{ж}\отимес \Хат{у}\_j $, который выбирает нужный $ \Хат{у}\_j $, и Oracle $A \кет{0}= \сум ^ {d-1}\_{j = 0} \скрт{а\_j/\ Sum ^ {d-1}\_{k = 0} \алфа\_j} \кет{ж} $, который создает кодирование состояния такта этих коэффициентов. В случае [имитации разреженного хамилтониана](https://arxiv.org/abs/quant-ph/0301023)предполагается, что хамилтониан является разреженной матрицей только $d = \маскал{о} (\Текст{Полилог} (N)) $ ненулевой элемент в каждой строке. Кроме того, одна из них предполагает существование эффективных тактов тактовой задержки, которые выводят расположение этих ненулевых элементов, а также их значения. Сложность [алгоритмов имитации хамилтониан](xref:microsoft.quantum.more-information) оценивается с точки зрения количества запросов к этим черным ящикам, а сложность шлюза-примитива зависит от сложности реализации этих черных ящиков.

> [!NOTE]
> Нотация больших объемов обычно используется для описания сложного масштабирования алгоритмов. Учитывая две реальные функции $f, g $, выражение $g (x) = \Маскал{о} (f (x)) $ означает, что существует абсолютная положительная константа $x\_0, c > 0 $, например $g (x) \ле c f (x) $ для всех $x \же x $0. 

В большинстве приложений, которые должны быть реализованы на тактовый компьютер, эти черные рамки должны быть эффективно реализованы, т. е. с $ \Маскал{о} (\текст{Полилог} (N)) $-примитивами-тактовыми шлюзами. Более строго, эффективно симулабле Хамилтонианс должен иметь некоторое достаточное для них описание в виде классической части. В одном из таких формулировку предполагается, что Хамилтониан разбивается на сумму Хермитиан частей $ $ \бегин{алигн} H & = \сум ^ {d-1} _ {j = 0} H_j.
\енд{алигн} $ $ более того, предполагается, что каждая часть, Хамилтониан $H\_j $, легко имитируется. Это означает, что единая $e ^ {-iH\_j t} $ для любого времени $t $ может быть реализована в точности с использованием $ \Маскал{о} (1) $-примитивных тактов-шлюзов. Например, это справедливо в особом случае, когда каждый $H\_j $ являются локальными операторами Паули, то есть тензорные продуктами $ \Маскал{о} (1) $ не-Identity Паули Operators, которые действуют для пространственного закрытия Кубитс. Эта модель особенно применима к физическим системам с ограниченным и локальным взаимодействием, так как число терминов равно $d = \Маскал{о} (\текст{Полилог} (N)) $ и может быть четко записано, т. е. с классической точки зрения в отношении времени.

> [!TIP]
> Хамилтонианс, которые разбиваются на сумму частей, можно описать с помощью библиотеки представления динамического генератора. Дополнительные сведения см. в разделе представление динамического генератора в [структурах данных](xref:microsoft.quantum.libraries.data-structures).

### <a name="simulation-algorithms"></a>Алгоритмы моделирования ###

Алгоритм моделирования такта преобразует заданное описание Хамилтониан в последовательность простых тактов-шлюзов, которая, в целом, приблизительное развитие времени, называется Хамилтониан.

В особом случае, когда Хамилтониан разбивается на сумму Хермитиан частей, декомпозиция Троттер-Сузуки является особенно простым и интуитивно понятным алгоритмом моделирования Хамилтонианс, разобразующихся в сумме Хермитиан компонентов. Например, интегратор первого заказа этого семейства приблизительный $ $ \бегин{алигн} U (t) & = \лефт (e ^ {-iH\_0 t/r} e ^ {-iH\_1 t/r} \кдотс e ^ {-iH\_{d-1} t/r} \ригхт) ^ {r} + \Маскал{о} (d ^ 2 \ max_j\\| H\_j\\| ^ 2 t ^ 2/r), \енд{алигн} $ $ с использованием продукта $r г $. 

> [!TIP]
> В примерах рассматриваются приложения алгоритма моделирования Троттер-Сузуки.
> Для модели Исинг, использующей только внутренние операции, предоставляемые каждым целевым компьютером, см. [пример **симплеисинг** ](https://github.com/microsoft/Quantum/blob/master/samples/simulation/ising/simple).
> Для модели Исинг с использованием структуры управления библиотекой Троттер-Сузуки см. [пример **исингтроттер** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/trotter-evolution).
> Сведения о молекулярное водофункции с помощью структуры управления библиотекой Троттер-Сузуки см. в [образце **моделирования H2** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line).

Во многих случаях мы хотели бы реализовать алгоритм моделирования, но не заинтересованы в деталях его реализации. Например, интегратор второго порядка приближен к $ $ \бегин{алигн} U (t) & = \лефт (e ^ {-iH\_0 t/2R} e ^ {iH\_1 t/2R} \кдотс e ^ {-iH\_{d-1} t/2R} e ^ {-iH\_{d-1} t/2R} \кдотс e ^ {-iH\_1 t/2R} e ^ {-iH\_0 t/2R} \ригхт) ^ {r} + \Маскал{о} (d ^ 3 \ max_j\\| H\_j\\| ^ 3 t ^ 3/r ^ 2), \енд{алигн} $ $ с использованием продукта $2rd $. Более крупные заказы будут содержать еще больше терминов, а оптимизированные варианты могут потребовать очень нетривиальных заказов по экспоненте. Другие расширенные алгоритмы также могут использовать анЦилла Кубитс в промежуточных шагах. Таким образом, мы упаковываем алгоритмы моделирования в Canon как определяемый пользователем тип

```qsharp
newtype SimulationAlgorithm = ((Double, EvolutionGenerator, Qubit[]) => Unit is Adj + Ctl);
```

Первый параметр `Double` — это время моделирования, второй параметр `EvolutionGenerator`, который рассматривается в разделе представление динамического генератора [структуры данных](xref:microsoft.quantum.libraries.data-structures), является классическим описанием независимых от времени хамилтониан, которые описывают, как каждый термин в хамилтониан может имитироваться тактовым каналом. Типы этой формы приблизительны на единую операцию $e ^ {-ИХТ} $ на третьем `Qubit[]`параметра, который является регистром, в котором хранится состояние такта моделируемой системы. Точно так же, как и в случае с зависимым временем, мы определяем определяемый пользователем тип с `EvolutionSchedule` типом, который является классическим описанием зависимого от времени Хамилтониан.

```qsharp
newtype TimeDependentSimulationAlgorithm = ((Double, EvolutionSchedule, Qubit[]) => Unit : Adjoint, Controlled);
```

Например, декомпозиция Троттер-Сузуки может быть вызвана с помощью следующих функций Canon с параметрами `trotterStepSize` изменении длительности имитации в каждой экспоненциальной модели и `trotterOrder` в порядке требуемого интегратора.

```qsharp
function TrotterSimulationAlgorithm(
    trotterStepSize : Double, 
    trotterOrder : Int) 
: SimulationAlgorithm {
    ...
}

function TimeDependentTrotterSimulationAlgorithm(
    trotterStepSize : Double, 
    trotterOrder : Int) 
: TimeDependentSimulationAlgorithm {
    ...
}
```

> [!TIP]
> В примерах рассматриваются приложения библиотеки моделирования. Сведения об оценке этапов в модели Исинг с помощью `SimulationAlgorithm`см. в [примере **исингфасистиматион** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/phase-estimation).
> Сведения о подготовке состояния адиабатик в модели Исинг с помощью `TimeDependentSimulationAlgorithm`см. в [примере **адиабатиЦисинг** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/adiabatic).


### <a name="adiabatic-state-preparation--phase-estimation"></a>Оценка этапа & подготовки состояния адиабатик ###

Одним из распространенных приложений моделирования Хамилтониан является подготовка адиабатик State. Здесь есть два Хамилтонианс $H\_{\текст{старт}} $ и $H\_{\текст{енд}} $, и состояние такта $ \кет{\пси (0)} $, которое является состоянием заземления для Start Хамилтониан $H\_{\текст{старт}} $. Как правило, $H\_{\текст{старт}} $ выбирается так, что $ \кет{\пси (0)} $ легко подготовиться из вычислительного состояния $ \ket{0\cdots 0} $. Интерполяция между этими Хамилтониансми в задаче моделирования, зависящей от времени, достаточно медленно, но при высокой вероятности в состоянии заземления окончательной Хамилтониан $H\_{\текст{енд}} $. Хотя подготовка правильных приближений к Хамилтонианм состояниям заземления может быть выполнена таким образом, вызывая на зависимые от времени алгоритмы моделирования Хамилтониан в качестве подпрограммы, другие концептуально отличающиеся подходы, такие как Квант времени. еиженсолвер возможны.

Еще одно приложение, повсеместно представленное в тактовой химия, оценивает энергию штата земли Хамилтонианс, представляющих промежуточные шаги химических реакции. Такая схема может, например, полагаться на подготовку состояния адиабатик, чтобы создать состояние заземления, а затем включить независимую от времени моделирование Хамилтониан в качестве подпрограммы в процессе оценки фазы, чтобы извлечь эту энергию с некоторой конечной ошибкой и вероятность успеха. 

Абстрактные алгоритмы моделирования как определяемые пользователем типы `SimulationAlgorithm` и `TimeDependentSimulationAlgorithm` позволяют нам легко внедрять свои функции в более сложные алгоритмы обработки тактов. Это мотивация нас в том, что мы делаем то же самое для часто используемых подпрограмм.

Таким способом мы определим удобную функцию

```qsharp
function InterpolatedEvolution(
        interpolationTime : Double, 
        evolutionGeneratorStart : EvolutionGenerator,
        evolutionGeneratorEnd : EvolutionGenerator,
        timeDependentSimulationAlgorithm : TimeDependentSimulationAlgorithm)
: (Qubit[] => Unit is Adj + Ctl) {
        ...
}
 
```

Это возвращает единую операцию, которая реализует все шаги подготовки состояния адиабатик. Первый параметр `interpolatedTime` определяет время, при превышении которого линейная интерполяция между start Хамилтониан, описываемой вторым параметром `evolutionGeneratorStart` и конечным Хамилтониан, описанными третьим параметром `evolutionGeneratorEnd`. Четвертый параметр `timeDependentSimulationAlgorithm`, где один выбирает алгоритм моделирования. Обратите внимание, что если `interpolatedTime` достаточно долго, начальное состояние заземления остается неизменным состоянием заземления Хамилтониан на протяжении всей длительности моделирования, и поэтому завершается в состоянии заземления конечного Хамилтониан.

Мы также определим полезную операцию, которая автоматически выполняет все шаги типичного химияного эксперимента. Например, у нас есть следующий пример, который возвращает оценку энергии для состояния, полученного при подготовке адиабатик State.

```qsharp
operation EstimateAdiabaticStateEnergy(
    nQubits : Int,
    statePrepUnitary : (Qubit[] => Unit),
    adiabaticUnitary : (Qubit[] => Unit),
    qpeUnitary: (Qubit[] => Unit is Adj + Ctl),
    phaseEstAlgorithm : ((DiscreteOracle, Qubit[]) => Double))
: Double {
...
}
```

`nQubits` — число Кубитс, используемых для кодирования начального состояния такта. `statePrepUnitary` готовит начальное состояние от вычислительной базы $ \ket{0\cdots 0} $. `adiabaticUnitary` — это единая операция, которая реализует подготовку адиабатик State, например, созданную функцией `InterpolatedEvolution`. `qpeUnitary` является единой операцией, используемой для оценки этапа в результате выполнения состояния такта. `phaseEstAlgorithm` является нашим выбором алгоритма оценки этапа.

> [!TIP]
> В примерах рассматриваются приложения для подготовки состояния адиабатик. Для модели Исинг, использующей ручную реализацию адиабатик состояния в сравнении с использованием функции `AdiabaticEvolution`, см. [пример **адиабатиЦисинг** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/adiabatic).
> Сведения об оценке этапа и подготовке состояния адиабатик в модели Исинг см. в примере [ **исингфасистиматион** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/phase-estimation).

> [!TIP]
> [Имитация молекулярное водорода](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line) — это интересный и краткий пример. Модель и экспериментальные результаты выводятся в [O'Malley) et. al.](https://arxiv.org/abs/1512.06860) требуются только матрицы Паули и принимает форму $ \хат H = g\_{0}I\_0I\_1 + g\_1 {Z\_0} + g\_2 {Z\_1} + g\_3 {Z\_0} {Z\_1} + g\_4 {Y\_0} {Y\_1} + g\_5 {X\_0} {X\_1} $. Это эффективный Хамилтониан, требующий только 2 Кубитс, где константы $g $ вычисляются по расстоянию $R $ между двумя атомами водорода. С помощью функций Canon Пол преобразуется в унитариес, а затем развивается за короткий период времени с помощью декомпозиции Троттер-Сузуки. Хорошее приближение к $H _2 $ земля может быть создано без использования подготовки адиабатик состояния, поэтому энергия состояния земли можно найти напрямую, используя оценку фазы из Canon.

## <a name="shors-algorithm"></a>Алгоритм Шора ##
Алгоритм Шор остается одним из самых значительных нововведений в тактовых вычислениях, поскольку он показал, что для решения важных, в настоящее время невероятных неполадок можно было использовать тактовые компьютеры.
Алгоритм Шор обеспечивает быстрый способ факторинга больших чисел с помощью тактового компьютера — проблемы, называемой *факторингом*.
Безопасность множества криптосистемсов в день на данный момент основана на предположении, что для факторинга не существует быстрого алгоритма.
Таким способом, алгоритм Шор имеет более глубокое влияние на безопасность в пост-такте.

Алгоритм Шор можно рассматривать как гибридный алгоритм.
Компьютер-такт используется для выполнения вычислительной задачи, которая называется поиском периода.
Затем результаты поиска по периоду будут классической обработаны для оценки факторов.
Мы рассмотрим эти два шага ниже.

### <a name="period-finding"></a>Поиск по периоду ###

Просмотрели принцип работы преобразования Фурье и оценки фазы (см. раздел [алгоритмы такта](xref:microsoft.quantum.libraries.standard.algorithms)), мы можем использовать эти средства для решения классической, трудной вычислительной задачи, называемой *поиском периода*.  В следующем разделе будет показано, как применить Поиск периода для факторинга.

Учитывая два целых числа $a $ и $N $, где $a < N $, цель периода поиска, также называемая нахождением заказа, заключается в поиске _заказа_ $r $ of $a $ \екуив $N $, где $r $ определяется как наименьшее положительное целое число, которое $a ^ r 1 \текст{mod} N $.  

Чтобы найти заказ с помощью тактового компьютера, можно использовать алгоритм оценки этапа, применяемый к следующему оператору $U _a $: $ $ U_a \кет{КС} \екуив \кет{(AX) \текст{mod} N}. $ $ основе собственных векторов $U _a $ предназначены для целочисленных $s $ и $0 \ LEQ s \лек r-$1, $ $ \кет{x_s} \екуив 1/\скрт{р} \сум\_{k = 0} ^ {r-1} e ^ {\frac{-2\pi i SK} {r}} \кет{а ^ к\текст {mod} N}, $ $ — _еиженстатес_ $U _A $.
Еиженвалуес $U _a $ $ $ U\_\кет{КС\_s} = e ^ {2 \ PI i s/r} \кет{КС\_s}. $$

Таким способом, Оценка этапа выводит еиженвалуес $e ^ {2 \ PI i s/r} $, из которого $r $ может быть [эффективно получен с](https://en.wikipedia.org/wiki/Continued_fraction) помощью прочего $s/r $.

Схема цепи для поиска тактового периода:

![](./../../media/QPE.svg)

Здесь $2N $ Кубитс инициализируются значением $ \кет{0}$, а $n $ Кубитс инициализируются значением $ \кет{1}$.
Читатель снова может заинтересоваться тем, почему регистр такта для хранения еиженстатес инициализируется значением $ \кет{1}$.
Так как он не знает порядок $r $ заранее, мы не можем фактически подготавливать $ \кет{x_s} $ States напрямую.
К счастью, $1/\ sqrt {r} \сум\_{s = 0} ^ {r-1} \кет{КС\_s} = \кет{1}$.
Нам не нужно действительно подготавливать $ \кет{КС} $!
Можно просто подготовить тактовый регистр $n $ Кубитс в состоянии $ \кет{1}$. 

Цепь содержит Кфт и несколько управляемых шлюзов.
Шлюз Кфт был описан [ранее](xref:microsoft.quantum.libraries.standard.algorithms).
Управляемый-$U _a $ Gate сопоставляет $ \кет{КС} $ с $ \кет{(AX) \текст{mod} N} $, если элемент управления кубит имеет значение $ \кет{1}$, и сопоставляет $ \кет{КС} $ с $ \кет{КС} $ в противном случае.

Чтобы достичь $ (a ^ NX) \текст{mod} N $, мы можем просто применить контролируемый $U _ {a ^ N} $, где мы вычисляем $a ^ n \текст{mod} N $ Classic, чтобы подключаться к тактовой цепи.  
Цепи для достижения такой модульной арифметической операции были описаны в [документации по арифметическим](./algorithms.md#arithmetic)операциям, в частности, нам требуется модульное возведение в степень для реализации управляемого $U\_{a ^ i} $ операций.

Хотя Вышеприведенная цепь соответствует [оценке этапа такта](xref:microsoft.quantum.characterization.quantumphaseestimation) и явно включает поиск заказов, мы можем сократить количество Кубитс. Мы можем проследить за методом Беаурегард для поиска, как описано [на стр. 8 из арксив: Куант-pH/0205095v3](https://arxiv.org/pdf/quant-ph/0205095v3.pdf#page=8), или использовать одну из подпрограмм оценки этапа, доступных в Microsoft. тактов. charactering. Например, в ходе [надежной оценки этапа](xref:microsoft.quantum.characterization.robustphaseestimation) также используется один дополнительный кубит.
 
### <a name="factoring"></a>Учитывая ###
Целью факторинга является определение двух простых факторов целочисленного $N $, где $N $ является $n $-битным числом.  
Факторинг состоит из описанных ниже действий. Шаги делятся на три части: классическая процедура предварительной обработки (1-4); Подсистема тактовых вычислений для поиска порядка $a \текст{mod} N $ (5); и классическая процедура создания последовательностей для получения простых факторов из заказа (6-9).

Классическая процедура предварительной обработки состоит из следующих этапов.
1. Если $N $ является четным, возвращается простой фактор $2 $.
2. Если $N = p ^ q $ для $p \geq1 $, $q \geq2 $, возвратите простой фактор $p $.  Этот шаг выполняется в классическом виде.
3. Выберите случайное число $a $ например, $1 < < N-$1.
4. Если $ \текст{ГКД} (a, N) > 1 $, возвращайте простой фактор $ \текст{ГКД} (a, N) $. Этот шаг вычисляются с помощью алгоритма Еуклид.
Если простой фактор не был возвращен, мы переходим к тактовой подпрограмме:
5. Вызовите алгоритм поиска тактового периода, чтобы вычислить порядок $r $ of $a \текст{mod} N $. Используйте $r $ в классической процедуре обработки, чтобы определить простые факторы:
6. Если $r $ нечетен, вернитесь к этапу предварительной обработки (3).
7. Если $r $ является четным и $a ^ {r/2} =-1 \ Text {mod} N $, вернитесь к шагу предварительной обработки (3).
8. Если $ \текст{ГКД} (a ^ {r/2} + 1, N) $ является нетривиальным фактором $N $, возвращайте $ \текст{ГКД} (a ^ {r/2} + 1, N) $.
9. Если $ \текст{ГКД} (a ^ {r/2}-1, N) $ является нетривиальным фактором $N $, возвращайте $ \текст{ГКД} (a ^ {r/2}-1, N) $.


Алгоритм факторинга — вероятностная: он может показать, что с вероятностью не менее одной половины, что $r $ будет даже и $a ^ {r/2} \нек-1 \текст{mod} N $, что приведет к созданию простого фактора.  (Дополнительные [сведения](xref:microsoft.quantum.more-information)см. в [статье об исходном документе Шор](https://doi.org/10.1109/SFCS.1994.365700) или в одном из *основных текстов тактовых вычислений* в разделе.)
Если простой фактор не возвращается, мы просто повторим алгоритм из шага (1).  После $n $ попыток, вероятность того, что каждая попытка не удалась, не превышает $2 ^ {-n} $.
Таким же результатом, после повторения алгоритма небольшое количество случаев успешного выполнения практически гарантированно.
