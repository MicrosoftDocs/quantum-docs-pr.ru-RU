---
title: Иордания — представление Вигнер | Документация Майкрософт
description: Иордания — Вигнер представление концептуальных документов
author: nathanwiebe2
ms.author: nawiebe@microsoft.com
ms.date: 10/09/2017
ms.topic: article-type-from-white-list
uid: microsoft.quantum.chemistry.concepts.jordanwigner
ms.openlocfilehash: f34233bc17ff68a9e04256959f8d79be2682c34f
ms.sourcegitcommit: 8becfb03eb60ba205c670a634ff4daa8071bcd06
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/26/2019
ms.locfileid: "73184055"
---
# <a name="jordan-wigner-representation"></a>Иордания — представление Вигнер

Несмотря на то, что второй квантования Хамилтонианс удобно представить в виде $a ^ \дагжер $ (создание) и $a $ (аннихилатион), эти операции не являются фундаментальными операциями на тактовых компьютерах.
В результате, если бы мы хотели реализовать их на тактовый компьютер, необходимо сопоставлять операторы с едиными матрицами, которые могут быть реализованы на тактовый компьютер.
Представление "Иордания — Вигнер" дает одну такую карту.
Тем не менее, другие, например Брави – Китаев, также существуют и имеют собственные относительные преимущества и недостатки.
Основным преимуществом представления «Иордания-Вигнер» является его простота.

Представление "Иордания-Вигнер" прямо вперед к производному.
Помните, что состояние $ \кет{0}_j $ подразумевает, что Spin Орбитал $j $ является пустым, а $ \кет{1}_j $ означает, что он занят.
Это означает, что Кубитс может естественным образом сохранить род данного Орбитал.
Затем это $a ^ \dagger_j \кет{0}_j = \кет{1}_j $ и $a ^ \dagger_j \кет{1}_j = $0.
Легко проверить, что \бегин{алигн} a ^ \dagger_j & = \begin{bmatrix}0 & 1 \\\ 0 & 0 \енд{бматрикс} = \frac{X_j + iY_j}{2}, \нонумбер\\\\ a_j & = \begin{bmatrix}0 & 0 \\\ 1 & 0 \енд{ бматрикс} = \frac{X_j-iY_j}{2}, \енд{алигн}, где $X _j $ и $Y _j $ являются операторами Паули-$X $ и-$Y $, работающими с кубит $j $.
Это показывает, что для одного Орбитал можно легко представить операторы создания и аннихилатион в терминах отдельных матриц, которые понимают компьютеры-такты.
Обратите внимание, что хотя $X $ и $Y $ являются едиными $a ^ \дагжер $ и $a $ не являются.
Далее мы увидим, что это не является проблемой для моделирования.

Одна из проблем заключается в том, что хотя описанная выше конструкция работает для одного Орбитал, она завершается ошибкой для систем с двумя или более оборотами.
Так как Фермионс — антисимметик, мы понимаем, что $a ^ \dagger_j a ^ \dagger_k = – a ^ \dagger_k a ^ \dagger_j $ для любого $j $ и $k $.
Однако $ $ \лефт (\frac{X_j-iY_j}{2}\ригхт) \лефт (\frac{X_k-iY_k}{2}\ригхт) = \лефт (\frac{X_k-iY_k}{2}\ригхт) \лефт (\frac{X_j-iY_j}{2}\ригхт).
$ $ Другими словами, при необходимости два оператора создания не выполняют защиту.
Это может быть исправлено, если это неизящный способ.
Исправление заключается в том, что Паули операторы естественным образом не работает.
В частности, $XZ =-ЗКС $ и $YZ =-зи $.
Таким же путем интерсперсинг $Z $ Operators в конструкцию оператора, мы можем эмулировать правильное сглаживание коммутатион.
Полная конструкция выглядит следующим образом: 

\бегин{алигн} a ^ \dagger_1 & = \лефт (\Фрак{КС-ий}{2}\ригхт) \отимес 1 \отимес 1 \отимес 1 \отимес \кдотс \отимес 1,\\\\ a ^ \dagger_2 & = Z\otimes\left (\frac{X-iY}{2}\right) \otimes 1 \ otimes 1 \otimes \cdots \otimes 1 ,\\\\ ^ \dagger_3 & = З\отимес З\отимес \лефт (\Фрак{КС-ий}{2}\ригхт) \отимес 1 \отимес \кдотс \отимес 1,\\\\ & \вдотс\\\\ a ^ \dagger_N & = З\отимес Z\otimes Z\otimes Z \otimes \cdots \otimes З\отимес \лефт (\Фрак{КС-ий}{2}\ригхт). \лабел{ЕК: JW} \енд{алигн}

Также удобно выразить числовые операторы $n _j $ с точки зрения операторов Паули.
К счастью, строки $Z $ Operators (известные как «Иордания-Вигнер строки») отменяются после того, как это подставится.
После истечения этого (и отзыва этого $X _jY_j = iZ_j $) у нас есть \бегин{екуатион} n_j = a ^ \dagger_j a_j = \фрак{(1-Z_j)}{2}.
\енд{екуатион}


## <a name="constructing-hamiltonians-in-jordan-wigner-representation"></a>Создание Хамилтонианс в формате "Иордания-Вигнер"

После вызова представления "Иордания-Вигнер", переводимого Хамилтониан на сумму операторов Паули, будет прямо вперед.
Необходимо просто заменить каждый из операторов $a ^ \дагжер $ и $a $ в Фермионик Хамилтониан строками Паули-Operators, указанных выше.
Когда одна подстановка выполняет эту замену, в Хамилтониан есть только пять классов терминов.
Эти пять классов соответствуют различным способам выбора $p, q $ и $p, q, r, s $ в одном основном тексте и двух основных терминах в Хамилтониан.
Эти пять классов, если $p > q > r > s $ и орбиты с реальными значениями, являются

\бегин{алигн} H_ {PP} a_p ^ \дагжер a_p & = \sum_p \frac{H_{PP}}{2}(1-Z_p)\\\\ H_ {PQ} (a_p ^ \дагжер a_q + a ^ \dagger_q a_p) & = \frac{H_{PQ}}{2}\лефт (\prod_{j = q + 1} ^ {p-1} Z_j \ригхт) \ Left (X_pX_q + Y_pY_q\right)\\\\ H_ {пккп} n_p n_q & = \frac{H_{pqqp}}{4}\лефт (1-Z_p-Z_q + Z_pZ_q \ригхт)\\\\ H_ {ПККР} & = \frac{H_{pqqr}}{2}\лефт (\prod_{j = r + 1} ^ {p-1} Z_j \ригхт) \лефт (X_pX_r + Y_pY_r\right) \лефт (\frac{1-Z_q}{2}\ригхт)\\\\ H_ {пкрс} & = \frac{H_{PQRS}}{8}\prod_{j = s + 1} ^ {r-1} Z_j\prod_ {k = q + 1} ^ {p-1} Z_k \Биг (XXXX-КСКСИИ + Ксикси\нонумбер\\\\ & \ккуад\ккуад\ккуад\ккуад\ккуад + ИКСКСИ + Иксикс-иикскс\нонумбер\\\\ & \ккуад\ккуад\ккуад\ккуад\ккуад + XYYX + YYYY\Big) \end{align}

При создании такого Хамилтонианса вручную требуется только применение этих правил замены. это может оказаться невозможным для больших молекул, которые могут состоять из миллионов Хамилтонианных терминов.
В качестве альтернативы можно автоматически создать `JordanWignerEncoding` с учетом `FermionHamiltonian` представления Хамилтониан.

```csharp
    // We load the namespace containing fermion and Pauli objects. 
    using Microsoft.Quantum.Chemistry.Fermion;
    using Microsoft.Quantum.Chemistry.Pauli;
    
    // We create an example `FermionHamiltonian` instance.
    var fermionHamiltonian = new FermionHamiltonian();

    // We convert this Fermion Hamiltonian to a Jordan-Wigner representation.
    var jordanWignerEncoding = fermionHamiltonian.ToPauliHamiltonian(QubitEncoding.JordanWigner);
```

После создания Хамилтонианс в этой форме мы можем использовать узел алгоритмов моделирования такта для компиляции Dynamics, созданного $e ^ {-ИХТ} $ в последовательности простейших шлюзов (в пределах некоторой определяемой пользователем отказоустойчивости).
В документации по алгоритму рассматриваются два наиболее популярных метода моделирования такта, кубитизатион и Троттер — Сузуки формулы. Мы предоставляем реализации для обоих методов в библиотеке моделирования Хамилтониан.
