---
title: 'Q # тип модель | Документация Майкрософт'
description: Модель типов Q#
author: QuantumWriter
uid: microsoft.quantum.language.type-model
ms.author: Alan.Geller@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: 0aabb144779da301b71ad215c8e975cc29b4dcce
ms.sourcegitcommit: ca5015fed409eaf0395a89c2e4bc6a890c360aa2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/29/2020
ms.locfileid: "76871640"
---
# <a name="the-type-model"></a>Модель типа

В этом разделе рассматривается модель типа Q # и описывается синтаксис указания и работы с типами.
Обратите внимание, что Q # является *строго типизированным* языком, поэтому Аккуратное использование этих типов может помочь компилятору обеспечить строгую гарантию для программ Q # во время компиляции.

Чтобы обеспечить максимально возможную гарантию, преобразования между типами в Q # должны быть явными с помощью вызовов функций, которые выражают это преобразование. Ряд таких функций предоставляется как часть пространства имен <xref:microsoft.quantum.convert>.
С другой стороны, операции приведения к совместимым типам происходят неявно. 

Q # предоставляет оба типа-примитива, которые можно использовать напрямую, и различные способы создания новых типов из других типов.
В оставшейся части этого раздела мы рассмотрим каждую из них.

## <a name="primitive-types"></a>Примитивные типы

Язык Q # предоставляет несколько *простых типов*, из которых можно создавать другие типы:

- Тип `Int` представляет собой 64-разрядное целое число со знаком, например: `2`, `107`, `-5`.
- Тип `BigInt` представляет целое число со знаком произвольного размера, например `2L`, `107L`, `-5L`.
   Этот тип основан на .NET <xref:System.Numerics.BigInteger>
   Тип.
- Тип `Double` представляет число с плавающей запятой двойной точности, например: `0.0`, `-1.3`, `4e-7`.
- Тип `Bool` представляет логическое значение, которое может быть как `true`, так и `false`.
- Тип `Qubit` представляет тактовый бит или кубит.
   `Qubit`ы непрозрачны для пользователя; единственной операцией с ними, кроме передачи их в другую операцию, является проверка удостоверения (равенство).
   В конечном итоге действия с `Qubit`реализуются путем вызова внутренних инструкций в процессоре тактовой задержки (или модели).
- Тип `Pauli` представляет один из четырех однокубитных операторов Паули.
   Этот тип используется для обозначения базовой операции для поворотов и для указания измеряемого наблюдаемого типа.
   Это перечислимый тип, имеющий четыре возможных значения: `PauliI`, `PauliX`, `PauliY`и `PauliZ`, которые являются константами типа `Pauli`.
- Тип `Result` представляет результат измерения.
   Это перечислимый тип с двумя возможными значениями: `One` и `Zero`, которые являются константами типа `Result`.
   `Zero` указывает, что измерение + 1 еиженвалуео. `One` указывает на еиженвалуе-1.
- Тип `Range` представляет последовательность целых чисел, обозначенную `start..step..stop`, где обозначаются параметры. 
   Это `start .. stop` соответствует `start..1..stop`, например, `1..2..7` представляет последовательность $\{1, 3, 5, 7\}$.
- Тип `String` — это последовательность символов Юникода, которая непрозрачна для пользователя после создания.
  Этот тип используется для передачи сообщений в классический узел в случае ошибки или диагностического события.
- Тип `Unit` — это тип, который допускает только одно значение `()`. 
  Этот тип используется, чтобы указать, что функция Q # или операция не возвращает никаких сведений. 

Константы `true`, `false`, `PauliI`, `PauliX`, `PauliY`, `PauliZ`, `One`и `Zero` являются зарезервированными символами в Q #.

## <a name="array-types"></a>Типы массивов

Учитывая любой допустимый тип Q # `'T`, существует тип, представляющий массив значений типа `'T`.
Этот тип массива представлен как `'T[]`. Например, `Qubit[]` или `Int[][]`.
Например, коллекция целых чисел обозначается `Int[]`, а массив массивов `(Bool, Pauli)` значений обозначается `(Bool, Pauli)[][]`.

Во втором примере обратите внимание, что это может быть массив массивов массива, а не прямоугольный двумерный массив.
Q # не обеспечивает поддержку для прямоугольных многомерных массивов.

Значение массива может быть написано в исходном коде Q # с помощью квадратных скобок вокруг элементов массива, как в `[PauliI, PauliX, PauliY, PauliZ]`.
Тип литерала массива определяется общим базовым типом всех элементов массива. 

> [!WARNING]
> Элементы массива нельзя изменить после создания массива.
> Для создания измененного массива можно использовать операторы обновления и повторного назначения, а также выражения копирования и обновления.

Кроме того, массив можно создать из его размера с помощью ключевого слова `new`:

```qsharp
let zeros = new Int[13];
// new also allows for creating empty arrays:
let emptyRegister = new Qubit[0];
```

В любом случае, после создания массива можно использовать базовую функцию `Length`, чтобы получить количество элементов в виде `Int`.
Массивы могут быть вложенными в скрипты с помощью квадратных скобок, при этом подстрочные индексы имеют тип `Int` или Type `Range`, чтобы получить либо отдельные элементы, либо новые массивы, содержащие подмножество элементов массива.
Индексы массивов отсчитываются от нуля:

```qsharp
let arr = [10, 11, 36, 49];
let ten = arr[0]; // 10
let odds = arr[1..2..4]; // [11, 49]
```

## <a name="tuple-types"></a>Типы кортежей

Если `T0`, `T1`,..., в соответствии с нулем или более разными типами, `Tn`, можно обозначить новый *тип кортежа* как `(T0, T1, ..., Tn)`.
Типы, используемые для создания нового типа кортежа, могут быть кортежами, как в `(Int, (Qubit, Qubit))`.
Однако такое вложение всегда имеет конечное ограничение, так как типы кортежей не могут быть в каких-либо обстоятельствах.

Значения нового типа кортежа являются кортежами, сформированными последовательностями значений из каждого типа в кортеже.
Например, `(3, false)` является кортежем, типом которого является тип кортежа `(Int, Bool)`.
Можно создавать массивы кортежей, кортежи массивов, кортежи подкортежей и т. д.

По отношению к Q # 0,3 `Unit` — имя *типа* пустого кортежа; `()` используется для пустого *значения*кортежа.

Экземпляры кортежей являются неизменяемыми.
Q # не предоставляет механизм для изменения содержимого кортежа после его создания.

Кортежи — это мощная концепция, используемая в Q # для объединения значений в одно значение, что упрощает их передачу.
В частности, с помощью нотации кортежа можно выразить, что каждая операция и вызываемый метод принимают ровно один вход и возвращает ровно один результат.

### <a name="singleton-tuple-equivalence"></a>Эквивалентность одноэлементного кортежа

Можно создать одноэлементный кортеж (с одним элементом), `('T1)`, например `(5)` или `([1,2,3])`.
Однако Q # обрабатывает одноэлементный кортеж как полностью эквивалентный значению заключенного в него типа.
Это значит, что различия между `5` и `(5)`, а также между `5` и `(((5)))`или между `(5, (6))` и `(5, 6)`отсутствуют.

Это эквивалентное действие применяется для всех целей, включая присваивание и выражения.
Это может быть так же, как и `(5)+3` для записи `5+3`, и оба выражения будут считаться `8`.
В частности, это означает, что операция или функция, для которых Входной кортеж или тип выходного кортежа имеет одно поле, можно рассматривать как принимающий один аргумент или возвращая одно значение.

Мы будем называть это свойство _эквивалентностью одноэлементного кортежа_.

## <a name="user-defined-types"></a>Определяемые пользователем типы

Файл Q # может определять новый именованный тип, содержащий одно значение любого допустимого типа.
Для любого типа кортежа `T`можно объявить новый определяемый пользователем тип, который является подтипом `T` с помощью инструкции `newtype`.
Например, в пространстве имен @"microsoft.quantum.math" комплексные числа определяются как определяемые пользователем типы данных.

```qsharp
newtype Complex = (Double, Double);
```

Эта инструкция создает новый тип с двумя анонимными элементами типа `Double`.   
Помимо анонимных элементов, определяемые пользователем типы также поддерживают именованные элементы в Q # версии 0,7 или более поздней. Например, можно назвать "to Items" `Re` для Double, представляющей реальную часть комплексного числа и `Im` для мнимой части: 

```qsharp
newtype Complex = (Re : Double, Im : Double);
```
Именование одного элемента в определяемом пользователем типе не подразумевает, что все элементы должны иметь имя — любое сочетание именованных и неименованных элементов поддерживается. Кроме того, внутренние элементы могут называться.
Тип `Nested`, как определено ниже, имеет базовый тип `(Double, (Int, String))`, из которого называется только элемент типа `Int` и все остальные элементы являются анонимными. 

```qsharp
newtype Nested = (Double, (ItemName : Int, String)); 
```
Именованные элементы имеют преимущество, доступ к которому можно получить напрямую с помощью оператора доступа `::`. 

```qsharp
function ComplexAddition(c1 : Complex, c2 : Complex) : Complex {
    return Complex(c1::Re + c2::Re, c1::Im + c2::Im);
}
```

Для доступа к анонимным элементам с другой стороны, сначала необходимо извлечь заключенное в оболочку значение с помощью постфиксного оператора `!`.
Оператор "Unwrap", `!`, позволяет извлекать значение, содержащееся в определяемом пользователем типе.
Тип такого выражения "Unwrap" является базовым типом определяемого пользователем типа. 

```qsharp
function PrintedMessage(value : Nested) : Unit {
    let (d, (_, str)) = value!;
    Message ($"{str}, value: {d}");
}
```

Оператор Unwrap разворачивает ровно один слой упаковки.
Для доступа к значению с множественной обтеканием можно использовать несколько операторов распаковки.

Например:

```qsharp
newtype WrappedInt = Int;
newtype DoublyWrappedInt = WrappedInt;

...
    let x = DoublyWrappedInt(WrappedInt(6));
    let y = x!;       // y is WrappedInt(6)
    let z = x!!;      // z is 6
    let a = x + 5;    // This is an error, a DoublyWrappedInt isn't an Int
    let b = x! + 5;   // Also an error
    let c = x!! + 5;  // This is valid, c will be 11
...
```

Дополнительные сведения см. в разделе о том, как [разносить выражения](xref:microsoft.quantum.language.expressions#unwrap-expressions) и [приоритеты операторов](xref:microsoft.quantum.language.expressions#operator-precedence) .

Значения определяемого пользователем типа можно создать, вызвав соответствующий конструктор типа:

```
let realUnit = Complex(1.0, 0.0);
let imaginaryUnit = Complex(0.0, 1.0);
```

Кроме того, новые значения можно создавать из существующих с помощью [выражений копирования и обновления](xref:microsoft.quantum.language.expressions#copy-and-update-expressions). Как и для массивов, такие выражения копируют все значения элементов исходного выражения, за исключением указанных именованных элементов. Для этих значений задаются значения, определенные в правой части выражения. Любые другие языковые конструкции, например [Операторы обновления и повторного назначения](xref:microsoft.quantum.language.statements#update-and-reassign-statement), доступные для элементов массива, существуют и для именованных элементов в определяемых пользователем типах.

```qsharp
newtype ComplexArray = (Count : Int, Data : Complex[]);

function AsComplexArray (data : Double[]) : ComplexArray {

    mutable res = ComplexArray(0, new Complex[0]);
    for (item in data) {
        set res w/= Data <- res::Data + [Complex(item, 0.)]; // update-and-reassign statement
    }
    return res w/ Count <- Length(res::Data); // returning a copy-and-update expression
}
```

Определяемые пользователем типы могут использоваться в любом месте, где можно использовать любой другой тип.
В частности, можно определить массив определяемого пользователем типа и включить определяемый пользователем тип как элемент типа кортежа.

Невозможно создать рекурсивные структуры типа.
То есть тип, определяющий определяемый пользователем тип, не может быть типом кортежа, включающим элемент определяемого пользователем типа.
Как правило, определяемые пользователем типы могут не иметь циклических зависимостей друг от друга, поэтому следующий набор определений типов будет недопустимым:

```qsharp
newtype TypeA = (Int, TypeB);
newtype TypeB = (Double, TypeC);
newtype TypeC = (TypeA, Range);
```

Помимо простых псевдонимов для потенциально сложных типов кортежей, одно существенное преимущество определения таких типов заключается в том, что они могут документировать намерение определенного значения.
При возврате к примеру `Complex`один из них мог бы также определить двумерные полярные координаты как определяемый пользователем тип:

```qsharp
newtype Polar = (Radius : Double, Phase : Double);
```

Несмотря на то, что оба `Complex` и `Polar` имеют базовый тип `(Double, Double)`, эти два типа полностью несовместимы в Q #, что сводит к минимуму риск случайного вызова сложной математической функции с полярными координатами и наоборот.
Таким образом, определяемые пользователем типы имеют аналогичную роль в качестве записей в F# , например. 


## <a name="operation-and-function-types"></a>Типы операций и функций

_Операция_ Q # — это подпрограмма-такт.
Такая вызываемая подпрограмма содержит квантовые операции.

_Функция_ Q # — это классическая подпрограмма, используемая в алгоритме такта.
Он может содержать классический код, но не операции с тактовыми тактами.
В частности, функции могут не выделять или позаимствовановать Кубитс, а также не могут вызывать операции.
Однако можно передать им операции или Кубитс для обработки.
Таким образом, функции полностью детерминированы в том смысле, что их вызов с использованием одних и тех же аргументов всегда приводит к одинаковому результату. 

Вместе операции и функции называются _вызываемыми_.  Некоторые [примеры](#examples) приведены ниже.

Все вызываемые команды Q # принимают одно значение в качестве входных данных и возвращают одно значение в качестве выходных данных.
Входные и выходные значения могут быть кортежами.
Вызываемые, не возвращающие результатов `Unit`.
Вызываемые, не имеющие входных данных, принимают пустой кортеж в качестве входных данных.

Базовый тип для любого вызываемого типа записывается как `('Tinput => 'Tresult)` или `('Tinput -> 'Tresult)`, где оба `'Tinput` и `'Tresult` являются типами.
Первая форма с `=>`используется для операций. Вторая форма с `->`для функций.
Например, `((Qubit, Pauli) => Result)` представляет сигнатуру для возможной операции измерения с одним кубит.

Типы функций полностью определяются их сигнатурой.
Например, функция, вычисляющая синус угла, будет иметь тип `(Double -> Double)`.

Операции (но не функции) имеют определенные дополнительные _характеристики_ , которые выражаются как часть типа операции. Такие характеристики включают сведения о том, что операторов поддерживает операция.
Операторов являются мета-операциями, создающими специализацию базовой операции; см. [операторов](#functors)ниже.

Типы операций задаются типом входных данных, типом вывода и их характеристиками.    
Чтобы обеспечить поддержку `Controlled` и (или) `Adjoint` функтор в типе операции, необходимо добавить аннотацию, указывающую соответствующие характеристики.
Заметка `is Ctl` например, указывает, что операция является управляемой. Если требуется, чтобы операция этого типа поддерживала и `Adjoint`, и `Controlled` функтор, мы можем выразить это как `(Qubit => Unit is Adj + Ctl)`. Используемые характеристики операции `Adj` и `Ctl` строго говорят — два предопределенных набора меток, где каждая метка указывает определенные характеристики операции, такие как, например, поддержка определенного функтор.
Таким образом, `+` используется для указания объединения этих двух наборов, а `*` используется для указания пересечения, т. е. меток, общих для обоих наборов.  

Например, операция `X` Паули имеет тип `(Qubit => Unit is Adj + Ctl)`.
Тип операции, который не поддерживает ни один операторов, задается только типом входного и выходного типа без дополнительной заметки.


### <a name="type-parameterized-functions-and-operations"></a>Функции и операции с параметрами типа

Вызываемые типы могут содержать параметры типа.
Параметры типа обозначаются символом, который предваряется одинарной кавычкой; Например, `'A` является допустимым параметром типа.

Параметр типа может присутствовать в одной сигнатуре более одного раза.
Например, функция, которая применяет другую функцию к каждому элементу массива и возвращает собранные результаты, будет иметь сигнатуру `(('A[], 'A->'A) -> 'A[])`.
Аналогично, функция, возвращающая композицию двух операций, может иметь сигнатуру `((('A=>'B), ('B=>'C)) -> ('A=>'C))`.

При вызове вызываемого параметризованного типа все аргументы, имеющие один и тот же параметр типа, должны иметь один и тот же тип.

Q # не предоставляет механизм ограничения возможных типов, которые могут быть заменены для параметра типа.

### <a name="type-compatibility"></a>Совместимость типов

Операция с поддержкой дополнительного операторов может использоваться в любом месте, где выполняется операция с меньшим числом операторов, но ожидается та же сигнатура.
Например, операция типа `(Qubit => Unit is Adj)` может использоваться в любом месте, где ожидается операция типа `(Qubit => Unit)`.

Q # является ковариантным по отношению к вызываемым возвращаемым типам: вызываемый метод, возвращающий тип `'A` который совместим с вызываемым с тем же типом входных данных и типом результата, который `'A` совместим с.

Q # является контравариантным по отношению к входным типам: вызываемый тип, который принимает `'A` типа в качестве входных данных, совместим с вызываемым с тем же типом результата и типом входных данных, совместимым с `'A`.

Это происходит при наличии следующих определений:

```qsharp
operation Invert(qubits : Qubit[]) : Unit 
is Adj {...} 

operation ApplyUnitary(qubits : Qubit[]) : Unit 
is Adj + Ctl {...} 

function ConjugateInvertWith(
    inner : (Qubit[] => Unit is Adj),
    outer : (Qubit[] => Unit is Adj))
: (Qubit[] => Unit is Adj) {...}

function ConjugateUnitaryWith(
    inner : (Qubit[] => Unit is Adj + Ctl),
    outer : (Qubit[] => Unit is Adj))
: (Qubit[] => Unit is Adj + Ctl) {...}
```

выполняются следующие условия.

- Функцию `ConjugateInvertWith` можно вызвать с аргументом `inner` либо `Invert`, либо `ApplyUnitary`.
- Функция `ConjugateUnitaryWith` может быть вызвана с `inner` аргументом `ApplyUnitary`, но не `Invert`.
- Значение типа `(Qubit[] => Unit is Adj + Ctl)` может быть возвращено из `ConjugateInvertWith`.

> [!IMPORTANT]
> В параметре Q # 0,3 появилась существенная разница в работе определяемых пользователем типов.

Определяемые пользователем типы обрабатываются как упакованная версия базового типа, а не как подтип.
Это означает, что значение определяемого пользователем типа не может использоваться, если ожидается значение базового типа.

### <a name="functors"></a>Операторов

Функтор в Q # — это фабрика, которая определяет новую операцию на основе другой операции.
Операторов имеет доступ к реализации базовой операции при определении реализации новой операции.
Таким же операторов может выполнять более сложные функции, чем традиционные функции более высокого уровня.

Операторов не имеют представления в системе типов Q #. Таким образом, сейчас невозможно привязать их к переменной или передать в качестве аргументов. 

Функтор используется, применяя его к операции, возвращая новую операцию.
Например, операция, полученная в результате применения `Adjoint` функтор к операции `Y`, записывается как `Adjoint Y`.
Новая операция может быть затем вызвана как любая другая операция.
Таким же `Adjoint Y(q1)` применяет смежный функтор к операции `Y` для создания новой операции и применяет эту новую операцию к `q1`.

Аналогичным образом `Controlled X(controls, target)` применяет контролируемый функтор к операции `X` для создания новой операции и применяет эту новую операцию к `controls` и `target`.

Два стандартных операторов в Q # `Adjoint` и `Controlled`.

#### <a name="adjoint"></a>Прилегающий

В тактовых вычислениях смежная операция представляет собой комплексно сопряженное перестановку операции.
Для операций, которые реализуют единые операторы, прилегающим является обратная операция.
Для простой операции, которая просто вызывает последовательность других операций с набором Кубитс, можно вычислить соседнюю, применив аджоинтс подопераций к тому же Кубитс в обратный последовательности.

При наличии выражения операции новое выражение операции может быть сформировано с помощью `Adjoint` функтор.
Например, `Adjoint QFT` обозначает смежную операцию `QFT`.
Новая операция имеет ту же сигнатуру и тип, что и базовая операция.
В частности, новая операция также допускает `Adjoint`и позволяет `Controlled` только в том случае, если базовая операция была выполнена.

Прилегающий функтор является собственным инверсией; то есть `Adjoint Adjoint Op` всегда совпадает с `Op`.

#### <a name="controlled"></a>Управляет

Управляемая версия операции — это новая операция, которая фактически применяет базовую операцию только в том случае, если все элементы управления Кубитс находятся в указанном состоянии.
Если элемент управления Кубитс в самом положении, то базовая операция применяется к соответствующей части детального размещения.
Поэтому управляемые операции часто используются для создания замкнутые.

В Q # управляемые версии всегда принимают массив элементов управления Кубитс, а заданное состояние всегда используется для всех Кубитс элементов управления, которые должны находиться в вычислительном (`PauliZ`) `One`ном состоянии, $ \кет{1}$.
Управление, основанное на других состояниях, можно получить, применив соответствующую единую операцию к элементу управления, Кубитс до управляемой операции, а затем применяя обратную операцию единой операции после управляемой операции.
Например, применение операции `X` к элементу управления, кубит до и после управляемой операции, приведет к тому, что операция будет управлять состоянием `Zero` ($ \кет{0}$) для этого кубит; применение операции `H` до и после будет контролировать состояние `PauliX` `One`, то есть-1 еиженвалуе Паули X, $ \кет{-} \масрел{: =} (\кет{0}-\кет{1})/\скрт{2}$, а не `PauliZ` `One`.

При наличии выражения операции новое выражение операции может быть сформировано с помощью `Controlled` функтор.
Сигнатура новой операции основана на сигнатуре исходной операции.
Тип результата такой же, но тип входных данных — это кортеж с массивом кубит, содержащий элемент управления кубит в качестве первого элемента и аргументы исходной операции в качестве второго элемента.
Новая операция поддерживает `Controlled`и будет поддерживать `Adjoint` только в том случае, если была выполнена исходная операция.

Если исходная операция заняла только один аргумент, здесь будет прилагаться эквивалентность одноэлементного кортежа.
Например, `Controlled X` является управляемой версией операции `X`.
`X` имеет тип `(Qubit => Unit is Adj + Ctl)`, поэтому `Controlled X` имеет тип `((Qubit[], (Qubit)) => Unit is Adj + Ctl)`; из-за равенства одноэлементных кортежей это то же самое, что `((Qubit[], Qubit) => Unit is Adj + Ctl)`.

Если базовая операция заняла несколько аргументов, не забудьте заключить соответствующие аргументы управляемой версии операции в круглые скобки, чтобы преобразовать их в кортеж.
Например, `Controlled Rz` является управляемой версией операции `Rz`.
`Rz` имеет тип `((Double, Qubit) => Unit is Adj + Ctl)`, поэтому `Controlled Rz` имеет тип `((Qubit[], (Double, Qubit)) => Unit is Adj + Ctl)`.
Таким образом, `Controlled Rz(controls, (0.1, target))` будет действительным вызовом `Controlled Rz` (Обратите внимание на круглые скобки вокруг `0.1, target`).

Другой пример: `CNOT(control, target)` можно реализовать как `Controlled X([control], target)`. Если целевой объект должен управляться 2 Control Кубитс (ККНОТ), можно использовать оператор `Controlled X([control1, control2], target)`.

### <a name="examples"></a>Примеры

Этот пример операции Q # взят из примера [измерения](https://github.com/microsoft/Quantum/tree/master/samples/getting-started/measurement) . В рамках операций мы можем выделить Кубитс и использовать операции над такими Кубитс, как `H` и `X`:

```qsharp
/// # Summary
/// Prepares a state and measures it in the Pauli-Z basis.
operation MeasureOneQubit() : Result {
        mutable result = Zero;

        using (qubit = Qubit()) { // Allocate a qubit
            H(qubit);               // Use a quantum operation on that qubit
            set result = M(qubit);      // Measure the qubit
            if (result == One) {    // Reset the qubit so that it can be released
                X(qubit);
            }

            return result;
        }
 }
```

Этот пример функции взят из примера [фасистиматион](https://github.com/microsoft/Quantum/tree/master/samples/characterization/phase-estimation) . Он содержит чисто классический код. Вы видите, что, в отличие от приведенного выше примера, Кубитс не выделяется, а операции с тактами не используются.

```qsharp
/// # Summary
/// Given two arrays, returns a new array that is the pointwise product
/// of each of the given arrays.
function PointwiseProduct(left : Double[], right : Double[]) : Double[] {
    mutable product = new Double[Length(left)];

    for (idxElement in IndexRange(left)) {
        set product w/= idxElement <- left[idxElement] * right[idxElement];
    }
    return product;
}
```

Также возможно, что функция передается Кубитс для обработки, как в этом примере из примера [реверсиблелогиксинсесис](https://github.com/microsoft/Quantum/tree/master/samples/algorithms/reversible-logic-synthesis) . Кубитс передаются функции и используются для обработки, хотя ни одна из них не изменила кубит состояния.

```qsharp
/// # Summary
/// Translate MCT masks into multiple-controlled Toffoli gates (with single
/// targets).
function GateMasksToToffoliGates(
    qubits : Qubit[], 
    masks : MCMTMask[]) 
: MCTGate[] {

    mutable result = new MCTGate[0];
    let n = Length(qubits);

    for (i in 0 .. Length(masks) - 1) {
        let (controls, targets) = (masks[i])!;
        let controlBits = IntegerBits(controls, n);
        let targetBits = IntegerBits(targets, n);
        let cQubits = Subarray(controlBits, qubits);
        let tQubits = Subarray(targetBits, qubits);

        for (target in tQubits) {
            set result += [MCTGate(cQubits, target)];
        }
    }

    return result;
}
```
