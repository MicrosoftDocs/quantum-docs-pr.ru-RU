---
title: 'Выражения Q #'
description: 'Узнайте, как указывать, ссылаться и объединять константы, переменные, операторы, операции и функции в качестве выражений в Q #.'
author: QuantumWriter
ms.author: Alan.Geller@microsoft.com
ms.date: 12/11/2017
ms.topic: article
uid: microsoft.quantum.language.expressions
ms.openlocfilehash: 095be52af27f827f3e52d39a70702f50d6d59ee8
ms.sourcegitcommit: db23885adb7ff76cbf8bd1160d401a4f0471e549
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/01/2020
ms.locfileid: "82683926"
---
# <a name="expressions"></a>Выражения

## <a name="grouping"></a>Группирование

При наличии любого выражения такое же выражение, заключенное в круглые скобки, является выражением того же типа.
`(7)` Например, `Int` является выражением, `([1,2,3])` является выражением типа массива `Int`s и `((1,2))` является выражением с типом. `(Int, Int)`

Эквивалентность простых значений и кортежей с одним элементом, описанных в [модели типов](xref:microsoft.quantum.language.type-model#tuple-types) , устраняет неоднозначность между `(6)` как группой и `(6)` кортежем с одним элементом.

## <a name="symbols"></a>Символы

Имя символа, привязанного к значению типа `'T` или присваиваемое ему, является выражением типа `'T`.
Например, если символ `count` привязан к целому значению `5`, то `count` является целочисленным выражением.

## <a name="numeric-expressions"></a>Числовые выражения

Числовые выражения — это выражения `Int`типа `BigInt`, или `Double`.
То есть это либо целочисленное, либо числовое число с плавающей запятой.

`Int`литералы в Q # идентичны целочисленным литералам в C#, за исключением того, что конечные знаки "l" и "L" не являются обязательными (или не разрешены).
Шестнадцатеричные и двоичные целые числа поддерживаются с префиксом "0x" и "0b" соответственно.

`BigInt`литералы в Q # идентичны строкам больших целых чисел в .NET с завершающим "l" или "L".
Шестнадцатеричные большие целые числа поддерживаются с префиксом "0x".
Таким образом, все следующие допустимые варианты использования `BigInt` литералов:

```qsharp
let bigZero = 0L;
let bigHex = 0x123456789abcdef123456789abcdefL;
let bigOne = bigZero + 1L;
```

`Double`литералы в Q # идентичны двойным литералам в C#, за исключением того, что завершающие "d" или "D" не являются обязательными (или не разрешены).

При наличии выражения массива `Int` любого типа элементов выражение может быть сформировано с помощью `Length` встроенной функции с выражением массива, заключенным в круглые скобки, `(` и. `)`
Например, если `a` привязан к массиву, то `Length(a)` является целочисленным выражением.
Если `b` является массивом массивов целых `Int[][]`чисел, то `Length(b)` — число подмассивов в `b`, а `Length(b[1])` — число целых чисел во втором подмассиве в. `b`

При наличии двух числовых выражений одного `+`типа бинарные операторы `-` `*`,, и `/` могут использоваться для формирования нового числового выражения.
Тип нового выражения будет таким же, как и типы составных выражений.

При наличии двух целочисленных выражений бинарный `^` оператор (Power) может использоваться для формирования нового целочисленного выражения.
Аналогичным `^` образом для формирования нового двойного выражения можно использовать два выражения типа Double.
Наконец, `^` можно использовать с большим целым числом слева и целым числом справа для формирования нового выражения больших целочисленных значений.
В этом случае второй параметр должен соответствовать 32 бит; Если нет, возникнет ошибка времени выполнения.

При наличии двух целочисленных или больших целочисленных выражений можно формировать новое целочисленное или большое целочисленное выражение `%` с помощью операторов ( `&&&` модуль), (побитовое и), `|||` ( `^^^` побитовое или) или (побитовое исключающее).

При наличии целочисленного или длинного целочисленного выражения слева, а также целочисленного выражения справа можно использовать операторы `<<<` (арифметические сдвиги влево `>>>` ) или (арифметические сдвиги вправо) для создания нового выражения с тем же типом, что и у левого выражения.

Второй параметр (сумма сдвига) для операции сдвига должен быть больше или равен нулю; поведение для отрицательных сумм сдвига не определено.
Сумма сдвига для операции сдвига также должна соответствовать 32 бит; Если нет, возникнет ошибка времени выполнения.
Если число, которое необходимо сдвинуть, является целым числом, то величина сдвига интерпретируется `mod 64`; то есть сдвиг 1 и сдвиг 65 имеют одинаковый результат.

Для целочисленных и больших целочисленных значений сдвиги являются арифметическими.
Сдвиг отрицательного значения влево или вправо приведет к отрицательному числу.
Это значит, что сдвиг на один шаг влево или вправо точно так же, как умножение или деление на 2 соответственно.

Целочисленный разделитель и модуль целых чисел соответствуют тому же поведению для отрицательных чисел, что и в C#.
То есть всегда `a % b` будет иметь тот же знак, что `a`и, `b * (a / b) + a % b` и всегда будет `a`равно.
Пример:

 `A` | `B` | `A / B` | `A % B`
---------|----------|---------|---------
 5 | 2 | 2 | 1
 5 | -2 | -2 | 1
 -5 | 2 | -2 | -1
 -5 | -2 | 2 | -1

Подразделение больших целых чисел и модуль работают одинаково.

При наличии любого числового выражения новое выражение может быть сформировано с `-` помощью унарного оператора.
Новое выражение будет иметь тот же тип, что и составное выражение.

При наличии целочисленного или длинного целочисленного выражения новое выражение того же типа может быть сформировано с `~~~` помощью унарного оператора (побитовое дополнение).

## <a name="boolean-expressions"></a>Логические выражения

Двумя `Bool` литеральными значениями являются `true` и `false`.

При наличии двух выражений одного и того же примитивного типа `==` для `!=` создания `Bool` выражения можно использовать бинарные операторы и.
Выражение будет иметь значение true, если два выражения равны, и false в противном случае.

Значения определяемых пользователем типов могут не сравниваться, можно сравнивать только их неупакованные значения. Например, с помощью оператора `!` "Распаковка" (см. описание на [странице "модель типов Q #](xref:microsoft.quantum.language.type-model#user-defined-types)").

```qsharp
newtype WrappedInt = Int;     // Yes, this is a contrived example
let x = WrappedInt(1);
let y = WrappedInt(2);
let z = x! == y!;             // This will compile and yield z = false.
let t = x == y;               // This will cause a compiler error.
```

Сравнение на равенство для `Qubit` значений — равенство идентификаторов; то есть, определяет, совпадают ли два выражения одинаковым кубит.
Состояние двух Кубитс не сравнивается, обращается, измеряется или изменяется с помощью этого сравнения.

Сравнение значений на `Double` равенство может привести к неверному результату из-за эффектов округления.
Например, `49.0 * (1.0/49.0) != 1.0`.

При наличии двух числовых `>`выражений бинарные операторы `<` `>=`,, и `<=` могут использоваться для создания нового логического выражения, которое имеет значение true, если первое выражение соответственно больше, меньше, больше или равно или меньше или равно второму выражению.

При наличии двух логических выражений бинарные `and` операторы `or` и можно использовать для создания нового логического выражения, которое имеет значение true, если оба выражения (отв. оба или оба) имеют значение true.

При наличии любого логического выражения `not` унарный оператор может использоваться для создания нового логического выражения, которое имеет значение true, если составное выражение имеет значение false.

## <a name="string-expressions"></a>Строковые выражения

Q # позволяет использовать строки в `fail` операторе и `Log` стандартной функции.

Строки в Q # — это литералы или интерполяции строк.
Строковые литералы похожи на простые строковые литералы в большинстве языков: последовательность символов Юникода, `"`заключенная в двойные кавычки.
Внутри строки `\` символ обратной косой черты может использоваться для экранирования символа двойной кавычки, а также для вставки новой строки `\n`как, возврата каретки в виде `\r`и табуляции как. `\t`
например

```qsharp
"\"Hello world!\", she said.\n"
```

Синтаксис Q # для интерполяции строк представляет собой подмножество синтаксиса C# 7,0. Q # не поддерживает буквальные строки с интерполяцией (многострочные).
Синтаксис C# см. в разделе [*интерполяция строк*](https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/interpolated-strings) .

Выражения внутри строки с интерполяцией следуют синтаксису Q #, а не синтаксису C#.
Любое допустимое выражение Q # может присутствовать в интерполяции строки.

## <a name="qubit-expressions"></a>Выражения кубит

Единственными `Qubit` выражениями являются символы, привязанные `Qubit` к значениям или элементам `Qubit` массива массивов.
Литералы отсутствуют `Qubit` .

## <a name="pauli-expressions"></a>Выражения Паули

Все четыре `Pauli` значения, `PauliI` `PauliX` `PauliY`,, и `PauliZ`, являются допустимыми `Pauli` выражениями.

Кроме того, единственными `Pauli` выражениями являются символы, привязанные к `Pauli` значениям или элементам массива `Pauli` массивов.

## <a name="result-expressions"></a>Выражения результатов

Два `Result` значения, `One` и `Zero`, являются допустимыми `Result` выражениями.

Кроме того, единственными `Result` выражениями являются символы, привязанные к `Result` значениям или элементам массива `Result` массивов.
В частности, обратите `One` внимание, что не совпадает с целым `1`числом и прямое преобразование между ними отсутствует.
Это справедливо и для `Zero` и. `0`

## <a name="range-expressions"></a>Выражения диапазона

Учитывая все три `Int` выражения `start`, `step`, и `stop`, `start .. step .. stop` — это выражение диапазона, первый элемент которого `start`имеет значение, второй `start+step`элемент —, третий `start+step+step`элемент — и т. `stop` д., пока не будет передан.
Диапазон может быть пустым, если, например, `step` положительным и. `stop < start`
Последний элемент `stop` в диапазоне будет иметь значение, если разница между `start` и `stop` является целым числом `step`, кратным. Это значит, что диапазон является инклюзивным на обоих концах.

`start .. stop` При `start .. 1 .. stop`наличии двух `Int` выражений `start` и `stop`является выражением диапазона, равным.
Обратите внимание, `step` что подразумеваемым является + `stop` 1, даже `start`если меньше; в этом случае диапазон пуст.

Ниже приведены некоторые примеры диапазонов.

- `1..3`диапазон значений 1, 2, 3.
- `2..2..5`диапазон 2, 4.
- `2..2..6`— диапазон 2, 4, 6.
- `6..-2..2`— диапазон 6, 4, 2.
- `2..1`является пустым диапазоном.
- `2..6..7`— диапазон 2.
- `2..2..1`является пустым диапазоном.
- `1..-1..2`является пустым диапазоном.

## <a name="callable-expressions"></a>Вызываемые выражения

Вызываемый литерал — это имя операции или функции, определенной в области компиляции.
Например, `X` — это литерал операции, который ссылается на стандартную операцию `X` библиотеки и `Message` является литералом функции, который ссылается на стандартную библиотеку `Message` .

Если операция поддерживает `Adjoint` функтор, то `Adjoint op` это выражение операции.
Аналогично, если операция поддерживает `Controlled` функтор, то `Controlled op` это выражение операции.
Типы этих выражений указываются в [операторов](xref:microsoft.quantum.language.type-model#functors).

Операторов (`Adjoint` и `Controlled`) привязываются более тесно, чем все другие операторы, за исключением `!` оператора Unwrap и `[]`индексирования массивов с помощью.
Таким образом, все следующие юридические, предполагая, что операции поддерживают операторов.

```qsharp
Adjoint Op(qs)
Controlled Op(controls, targets)
Controlled Adjoint Op(controls, targets)
Adjoint WrappedOp!(qs)
```

В качестве значения можно использовать вызываемый литерал, например, чтобы присвоить значение переменной или передать другому вызываемому.
В этом случае, если вызываемый тип имеет параметры типа, они должны быть предоставлены как часть вызываемого значения.
Вызываемое значение не может иметь неопределенные параметры типа.

Например, если `Fun` является функцией с сигнатурой `'T1->Unit`:

```qsharp
let f = Fun<Int>;            // f is Int->Unit.
SomeOtherFun(Fun<Double>);   // A Double->Unit is passed to SomeOtherFun.
let g = Fun;                 // This causes a compilation error.
SomeOtherFun(Fun);           // This also causes a compilation error.
```

## <a name="callable-invocation-expressions"></a>Выражения вызываемого вызова

При наличии вызываемого выражения (операции или функции) и кортежного выражения входного типа сигнатуры вызываемого метода выражение вызова может быть сформировано путем добавления кортежного выражения к вызываемому выражению.
Тип выражения вызова является выходным типом сигнатуры вызываемого метода.

Например `Op` , если является операцией с сигнатурой `((Int, Qubit) => Double)`, `Op(3, qubit1)` является выражением типа `Double`.
Аналогично, `Sin` если является функцией с `(Double -> Double)`сигнатурой `Sin(0.1)` , является выражением типа `Double`.
Наконец, если `Builder` является функцией с сигнатурой `(Int -> (Int -> Int))`, `Builder(3)` функция преобразуется в тип в int.

Для вызова результата выражения с вызываемым значением требуется еще одна пара круглых скобок вокруг вызываемого выражения.
Таким образом, чтобы вызвать результат вызова `Builder` из предыдущего абзаца, правильным синтаксисом является:

```qsharp
(Builder(3))(2)
```

При вызове вызываемого типа с параметрами, фактические параметры типа могут быть указаны в угловых `<` скобках и `>` после вызываемого выражения.
Обычно это не требуется, так как компилятор Q # будет вычислять фактические типы.
Он необходим для частичного применения (см. ниже), если аргумент с параметризованным типом не указан.
Кроме того, она иногда полезна при передаче операций с разными функтор, которые поддерживаются для вызова.

`Func` Например, если имеет сигнатуру `('T1, 'T2, 'T1) -> 'T2` `Op1` и `Op2` `(Qubit[] => Unit is Adj)`имеет сигнатуру и `Op3` имеет `(Qubit[] => Unit)`сигнатуру, то для `Func` вызова `Op1` с помощью в качестве первого `Op2` аргумента, а `Op3` также в качестве третьей:

```qsharp
let combinedOp = Func<(Qubit[] => Unit), (Qubit[] => Unit is Adj)>(Op1, Op2, Op3);
```

Спецификация типа является обязательной, `Op3` поскольку `Op1` и имеет разные типы, поэтому компилятор будет считать его неоднозначным без спецификации.

### <a name="partial-application"></a>Частичное приложение

При наличии вызываемого выражения можно создать новый вызываемый объект, предоставив подмножество аргументов вызываемому.
Это называется _частичным приложением_.

В Q # частично примененный вызываемый объект выражается путем написания обычного выражения вызова, но с использованием символа подчеркивания `_`для неуказанных аргументов.
Результирующий вызываемый объект имеет тот же тип результата, что и базовый вызываемый, и те же специализации для операций.
Тип входных данных частичного приложения — это просто исходный тип с удаленными указанными аргументами.

Если изменяемая переменная передается в качестве указанного аргумента при создании частичного приложения, используется текущее значение переменной.
Изменение значения переменной после этого не влияет на часть приложения.

Например, если `Op` имеет тип `((Int, ((Qubit, Qubit), Double)) => Unit is Adj)`:

- `Op(5,(_,_))`имеет тип `(((Qubit,Qubit), Double) => Unit is Adj)`и т `Op(5,_)`. д.
- `Op(_,(_,1.0))` имеет тип `((Int, (Qubit,Qubit)) => Unit is Adj)`.
- `Op(_,((q1,q2),_))` имеет тип `((Int,Double) => Unit is Adj)`.
   Обратите внимание, что здесь применяется эквивалентность одноэлементного кортежа.

Если частично применяемый тип вызываемого метода имеет параметры типа, которые не могут быть определены компилятором, они должны быть предоставлены на сайте вызова.
Часть приложения не может иметь неопределенные параметры типа.

Например, если `Op` имеет тип `(('T1, Qubit, 'T1) => Unit : Adjoint)`:

```qsharp
let f1 = Op<Int>(_, qb, _); // f1 has type ((Int,Int) => Unit is Adj)
let f2 = Op(5, qb, _);      // f2 has type (Int => Unit is Adj)
let f3 = Op(_,qb, _);       // f3 generates a compilation error
```

### <a name="recursion"></a>Рекурсия

Возможность вызовов Q # может быть прямо или косвенно рекурсивной.
Это значит, что операция или функция может вызвать саму себя или вызвать другой вызываемый метод, который напрямую или косвенно вызывает вызываемую операцию.

Однако существует два важных комментария об использовании рекурсии.

- Использование рекурсии в операциях, скорее всего, мешает некоторым оптимизациям.
  Это может оказать значительное влияние на время выполнения алгоритма.
- При выполнении на фактическом устройстве-такте пространство стека может быть ограничено, так что глубокая рекурсия может привести к ошибке времени выполнения.
  В частности, компилятор Q # и среда выполнения не выявляет и не оптимизируют заключительную рекурсию.

## <a name="tuple-expressions"></a>Кортежные выражения

Литерал кортежа — это последовательность выражений элементов соответствующего типа, разделенных запятыми, заключенная в `(` и. `)`
Например, `(1, One)` является `(Int, Result)` выражением.

Кроме литералов, единственными кортежными выражениями являются символы, привязанные к значениям кортежа, элементы массива кортежей и вызываемые вызовы, возвращающие кортежи.

## <a name="user-defined-type-expressions"></a>Выражения определяемого пользователем типа

Литерал определяемого пользователем типа состоит из имени типа, за которым следует литерал кортежа базового типа кортежа типа.
Например, если `IntPair` является определяемым пользователем типом, основанным на `(Int, Int)`, то `IntPair(2,3)` будет допустимым литералом этого типа.

Кроме литералов, единственными выражениями определяемого пользователем типа являются символы, привязанные к значениям этого типа, элементы массива массивов этого типа и вызываемые вызовы, возвращающие этот тип.

## <a name="unwrap-expressions"></a>Разносить выражения

В Q # оператор Unwrap является восклицательным знаком в конце `!`.
Например, `IntPair` если является определяемым пользователем типом с базовым типом `(Int, Int)`и `s` является переменной со значением `IntPair(2,3)`, то `s!` это будет. `(2,3)`

Для определяемых пользователем типов, определенных с точки зрения других определяемых пользователем типов. Оператор Unwrap может повторяться; Например, `s!!` указывает значение удвоенного неупакованного значения `s`.
Таким образом, `WrappedPair` если является определяемым пользователем типом с базовым `IntPair`типом, `t` а является переменной со значением `WrappedPair(IntPair(1,2))`, то `t!!` будет `(1,2)`.

Оператор `!` имеет более высокий приоритет, чем все остальные операторы, `[]` Кроме для индексирования и среза массива.
`!`и `[]` установите привязку с позиционированием. то есть, `a[i]![3]` должен быть считан как `((a[i])!)[3]`: взять элемент `i`"th" `a`, распаковать его, а затем получить третий элемент неупакованного значения (который должен быть массивом).

Приоритет `!` оператора имеет одно влияние, которое может быть неочевидным.
Если функция или операция возвращает значение, которое затем извлекается, функция или вызов операции должны быть заключены в круглые скобки, чтобы кортеж аргументов привязывается к вызову, а не к развернутому.
Пример:

```qsharp
let f = (Foo(arg))!;    // Calls Foo(arg), then unwraps the result
let g = Foo(arg)!;      // Syntax error
```

## <a name="array-expressions"></a>Выражения массива

Литерал массива — это последовательность из одного или нескольких выражений элементов, разделенных запятыми, заключенная `[` в `]`и.
Все элементы должны быть совместимы с одним и тем же типом.

Если тип общего элемента является операцией или типом функции, все элементы должны иметь одинаковые входные и выходные типы.
Тип элемента массива будет поддерживать любые операторов, поддерживаемые всеми элементами.
Например, `Op1`если, `Op2`, и `Op3` все являются `Qubit[] => Unit`, но `Op1` поддерживают `Adjoint` `Op2` `Controlled`, поддерживают и `Op3` поддерживают оба:

- `[Op1, Op2]`является массивом `(Qubit[] => Unit)` операций.
- `[Op1, Op3]`является массивом `(Qubit[] => Unit is Adj)` операций.
- `[Op2, Op3]`является массивом `(Qubit[] => Unit is Ctl)` операций.

Пустые литералы `[]`массива не допускаются.
Вместо этого `new ★[0]`с помощью `★` , где является заполнителем для подходящего типа, позволяет создать требуемый массив нулевой длины.

При наличии двух массивов одного типа бинарный `+` оператор может использоваться для формирования нового массива, который объединяет два массива.
Например, `[1,2,3] + [4,5,6]` имеет `[1,2,3,4,5,6]`.

### <a name="array-creation"></a>Создание массива

При наличии типа и `Int` выражения `new` оператор может использоваться для выделения нового массива заданного размера.
Например, `new Int[i+1]` будет выделять новый `Int` массив `i+1` элементами.

Элементы нового массива инициализируются значением по умолчанию, зависящим от типа.
В большинстве случаев это разновидность нуля.

Для Кубитс и вызываемых объектов, которые являются ссылками на сущности, не существует разумного значения по умолчанию.
Таким же для этих типов по умолчанию используется недопустимая ссылка, которую нельзя использовать, не вызывая ошибку во время выполнения.
Это похоже на пустую ссылку на таких языках, как C# или Java.
Массивы, содержащие Кубитс или вызываемые, должны быть правильно инициализированы значениями, отличными от значений по умолчанию, прежде чем их элементы могут быть безопасно использованы. Подходящие процедуры инициализации можно найти в <xref:microsoft.quantum.arrays>.

Значения по умолчанию для каждого типа:

Тип | По умолчанию
---------|----------
 `Int` | `0`
 `BigInt` | `0L`
 `Double` | `0.0`
 `Bool` | `false`
 `String` | `""`
 `Qubit` | _Недопустимый кубит_
 `Pauli` | `PauliI`
 `Result` | `Zero`
 `Range` | Пустой диапазон,`1..1..0`
 `Callable` | _Недопустимый вызываемый_
 `Array['T]` | `'T[0]`

Типы кортежей инициализируются элементом по элементу.


### <a name="jagged-arrays"></a>Массивы массивов

Массив массива, иногда называемый «массивом массивов», является массивом, элементы которого являются массивами. Элементы массива массивов могут иметь разные размеры. В следующем примере показано объявление и инициализация массива массивов, представляющего таблицу умножения.

```qsharp
let N = 4;
mutable multiplicationTable = new Int[][N];
for (i in 1..N) {

    mutable row = new Int[i];
    for (j in 1..i) {
        set row w/= j-1 <- i * j;
    }
    set multiplicationTable w/= i-1 <- row;
}
```


### <a name="array-slices"></a>Срезы массива

При наличии выражения массива и `Range` выражения можно формировать новое выражение, используя оператор среза массива `[` и `]` .
Новое выражение будет иметь тот же тип, что и массив, и будет содержать элементы массива `Range`, индексируемые элементами, в порядке, определенном. `Range`
Например `a` , если привязан к массиву `Double`s, то `a[3..-1..0]` является `Double[]` выражением, содержащим первые четыре элемента, `a` но в порядке, в котором они отображаются в. `a`

Если параметр `Range` пуст, результирующий срез массива будет иметь нулевую длину.

Если выражение массива не является простым идентификатором, его необходимо заключить в круглые скобки для среза.
Например, если `a` и `b` являются массивами `Int`s, срез из объединения будет выражаться следующим образом:

```qsharp
(a+b)[1..2..7]
```

Все массивы в Q # отсчитываются от нуля.
То есть первый элемент массива `a` всегда `a[0]`имеет значение.

Начиная с нашего выпуска 0,8 мы поддерживаем контекстные выражения для среза диапазона. В частности, начальные и конечные значения диапазона могут быть опущены в контексте выражения среза диапазона. В этом случае компилятор применит следующие правила, чтобы определить предполагаемые разделители для диапазона. 

Например, если начальное значение диапазона опущено, то выводимое начальное значение 
- равно нулю, если шаг не указан или указанный шаг является положительным; 
- Длина фрагментированного массива минус один, если указанный шаг является отрицательным. 

Если значение конца диапазона опущено, то выводимое конечное значение 
- Длина фрагментированного массива минус один, если шаг не указан или указанный шаг является положительным; 
- равно нулю, если указанный шаг является отрицательным. 

```qsharp
let arr = [1,2,3,4,5,6];
let slice1  = arr[3...];      // slice1 is [4,5,6];
let slice2  = arr[0..2...];   // slice2 is [1,3,5];
let slice3  = arr[...2];      // slice3 is [1,2,3];
let slice4  = arr[...2..3];   // slice4 is [1,3];
let slice5  = arr[...2...];   // slice5 is [1,3,5];
let slice7  = arr[4..-2...];  // slice7 is [5,3,1];
let slice8  = arr[...-1..3];  // slice8 is [6,5,4];
let slice9  = arr[...-1...];  // slice9 is [6,5,4,3,2,1];
let slice10 = arr[...];       // slice10 is [1,2,3,4,5,6];
```

## <a name="array-element-expressions"></a>Выражения элементов массива

При наличии выражения массива и `Int` выражения можно формировать новое выражение с помощью оператора `[` и `]` элемента массива.
Новое выражение будет иметь тот же тип, что и тип элемента массива.
Например, `a` если привязан к массиву `Double`s, то `a[4]` является `Double` выражением.

Если выражение массива не является простым идентификатором, его необходимо заключить в круглые скобки, чтобы выбрать элемент.
Например, если `a` и `b` являются массивами `Int`s, элемент из объединения будет выражаться следующим образом:

```qsharp
(a+b)[13]
```

Все массивы в Q # отсчитываются от нуля.
То есть первый элемент массива `a` всегда `a[0]`имеет значение.


## <a name="copy-and-update-expressions"></a>Выражения копирования и обновления

Новые массивы можно создавать из существующих с помощью выражений копирования и обновления.
Выражение копирования `expression1 w/ expression2 <- expression3`и обновления является выражением формы, где `expression1` должно иметь тип `T[]` для какого-либо типа. `T` Второй `expression2` определяет индексы элементов, которые необходимо изменить, по сравнению с массивом в `expression1` и должны иметь тип `Int` или. `Range` Если `expression2` имеет тип `Int`, `expression3` должен иметь тип. `T` Если `expression2` имеет тип `Range`, `expression3` должен иметь тип. `T[]`

Выражение `arr w/ idx <- value` копирования и обновления формирует новый массив со всеми элементами, заданными в соответствующем элементе в `arr`, за исключением элементов в `idx`, для которых заданы единицы в. `value` Например, если `arr` содержит массив `[0,1,2,3]`, то 
- `arr w/ 0 <- 10`является массивом `[10,1,2,3]`.
- `arr w/ 2 <- 10`является массивом `[0,1,10,3]`.
- `arr w/ 0..2..3 <- [10,12]`является массивом `[10,1,12,3]`.

Аналогичные выражения существуют для именованных элементов в определяемых пользователем типах. Рассмотрим, например, тип 

```qsharp
newtype Complex = (Re : Double, Im : Double);
```
Если `c` `Complex(1.,-1.)`параметр содержит значение типа, то `c w/ Re <- 0.` является выражением типа `Complex` , результатом вычисления которого является. `Complex(0.,-1.)`

## <a name="conditional-expressions"></a>Условные выражения

Учитывая два других выражения одного и того же типа и логического выражения, условное выражение может быть сформировано с помощью вопросительного знака `?` и вертикальной черты. `|`
Например, `a==b ? c | d`.
В этом примере значение условного выражения будет `c` `a==b` равно true, а `d` если — false.

Эти два выражения могут возвращать операции с одинаковыми входными и выходными данными, но поддерживают разные операторов.
В этом случае тип условного выражения является операцией с входными и выходными данными, которые поддерживают любые операторов, поддерживаемые обоими выражениями.
Например, `Op1`если, `Op2`, и `Op3` все являются `Qubit[]=>Unit`, но `Op1` поддерживают `Adjoint` `Op2` `Controlled`, поддерживают и `Op3` поддерживают оба:

- `flag ? Op1 | Op2`является `(Qubit[] => Unit)` операцией.
- `flag ? Op1 | Op3`является `(Qubit[] => Unit is Adj)` операцией.
- `flag ? Op2 | Op3`является `(Qubit[] => Unit is Ctl)` операцией.

Если одно из двух возможных результатов содержит вызов функции или операции, этот вызов будет выполняться только в том случае, если результатом является значение, которое будет значением вызова.
Например, `a==b ? C(qs) | D(qs)`если `a==b` имеет значение true, то `C` операция будет вызвана, и если значение равно false, будет вызываться только. `D`
Это похоже на сокращенное вычисление на других языках.


## <a name="operator-precedence"></a>Приоритет операторов

Все бинарные операторы являются правой ассоциативными, за `^`исключением.

Квадратные `[` скобки и `]`, для среза и индексирования массива, выполните привязку перед любым оператором.

Операторов `Adjoint` и `Controlled` BIND после индексирования массива, но перед всеми другими операторами.

Круглые скобки для операции и вызова функции также привязываются перед любым оператором, но после индексирования массива и операторов.

Операторы в порядке приоритета, от самого высокого до самого низкого:

Оператор | Арность | Описание | Типы операндов
---------|----------|---------|---------------
 конечные`!` | Унарный | разворачивание; | Любой определяемый пользователем тип
 `-`, `~~~`, `not` | Унарный | Числовое отрицательное, побитовое дополнение, логическое отрицание | `Int`, `BigInt` или `Double` для `-`, `Int` или `BigInt` для `~~~` `Bool` для`not`
 `^` | Двоичные данные | Целочисленное энергопотребление | `Int`или `BigInt` для основания, `Int` для показателя степени
 `/`, `*`, `%` | Двоичные данные | Деление, умножение, целочисленный модуль | `Int`, `BigInt` или `Double` для `/` и `*`, `Int` или `BigInt` для`%`
 `+`, `-` | Двоичные данные | Сложение или объединение строк и массивов, вычитание | `Int`, `BigInt` или `Double`, кроме `String` того, или любого типа массива для`+`
 `<<<`, `>>>` | Двоичные данные | Сдвиг влево, сдвиг вправо | `Int` или `BigInt`
 `<`, `<=`, `>`, `>=` | Двоичные данные | Сравнения "меньше чем", "меньше или равно", "больше чем", "больше или равно" | `Int`, `BigInt` или`Double`
 `==`, `!=` | Двоичные данные | сравнения «равно» и «не равно» | любой тип-примитив
 `&&&` | Двоичные данные | Побитовое И | `Int` или `BigInt`
 `^^^` | Двоичные данные | Побитовое исключающее ИЛИ | `Int` или `BigInt`
 <code>\|\|\|</code> | Двоичные данные | Побитовое ИЛИ | `Int` или `BigInt`
 `and` | Двоичные данные | Логическое И | `Bool`
 `or` | Двоичные данные | Логическое ИЛИ | `Bool`
 `..` | Двоичный/Ternary | Оператор Range | `Int`
 `?` `|` | Ternary | Условная логика | `Bool`для левой стороны
`w/` `<-` | Ternary | Копирование и обновление | см. раздел [выражения копирования и обновления](#copy-and-update-expressions) .
