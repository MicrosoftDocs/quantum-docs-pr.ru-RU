---
title: Выражения | Документация Майкрософт
description: Выражения
author: QuantumWriter
ms.author: Alan.Geller@microsoft.com
ms.date: 12/11/2017
ms.topic: article
uid: microsoft.quantum.language.expressions
ms.openlocfilehash: 83fe697aa07a8ab28bd64437c8f5746bc5893b27
ms.sourcegitcommit: 5094c0a60cbafdee669c8728b92df281071259b9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/06/2020
ms.locfileid: "77036320"
---
# <a name="expressions"></a>Выражения

## <a name="grouping"></a>Группирование

При наличии любого выражения такое же выражение, заключенное в круглые скобки, является выражением того же типа.
Например, `(7)` является выражением `Int`, `([1,2,3])` является выражением типа массива `Int`s, а `((1,2))` — выражение с типом `(Int, Int)`.

Эквивалентность простых значений и кортежей с одним элементом, описанных в [модели типов](xref:microsoft.quantum.language.type-model#tuple-types) , устраняет неоднозначность между `(6)` как группой и `(6)` как кортеж с одним элементом.

## <a name="symbols"></a>Символы

Имя символа, привязанного или присвоенного значению типа `'T`, является выражением типа `'T`.
Например, если символ `count` привязан к целочисленному значению `5`, то `count` является целочисленным выражением.

## <a name="numeric-expressions"></a>Числовые выражения

Числовыми выражениями являются выражения типа `Int`, `BigInt`или `Double`.
То есть это либо целочисленное, либо числовое число с плавающей запятой.

`Int` литералы в Q # идентичны целочисленным литералам в C#, за исключением того, что конечные знаки "l" и "l" не являются обязательными (или не разрешены).
Шестнадцатеричные и двоичные целые числа поддерживаются с префиксом "0x" и "0b" соответственно.

`BigInt` литералы в Q # идентичны строкам больших целых чисел в .NET с завершающим "l" или "L".
Шестнадцатеричные большие целые числа поддерживаются с префиксом "0x".
Таким образом, все следующие допустимые варианты использования литералов `BigInt`:

```qsharp
let bigZero = 0L;
let bigHex = 0x123456789abcdef123456789abcdefL;
let bigOne = bigZero + 1L;
```

`Double` литералы в Q # идентичны двойным литералам в C#, за исключением того, что завершающие "d" или "d" не являются обязательными (или не разрешены).

При наличии выражения массива любого типа элементов `Int` выражение может быть сформировано с помощью встроенной функции `Length`, где выражение массива заключено в круглые скобки, `(` и `)`.
Например, если `a` привязан к массиву, `Length(a)` является целочисленным выражением.
Если `b` является массивом массивов целых чисел, `Int[][]`, то `Length(b)` — число подмассивов в `b`, а `Length(b[1])` — число целых чисел во втором подмассиве в `b`.

При наличии двух числовых выражений одного типа бинарные операторы `+`, `-`, `*`и `/` могут использоваться для формирования нового числового выражения.
Тип нового выражения будет таким же, как и типы составных выражений.

При наличии двух целочисленных выражений бинарный оператор `^` (Power) может использоваться для формирования нового целочисленного выражения.
Аналогичным образом, `^` можно использовать с двумя выражениями типа Double для формирования нового двойного выражения.
Наконец, `^` можно использовать с большим целым числом слева, а целое число справа — для формирования нового выражения с большими целочисленными значениями.
В этом случае второй параметр должен соответствовать 32 бит; Если нет, возникнет ошибка времени выполнения.

При наличии двух целочисленных или больших целочисленных выражений может быть сформировано новое целочисленное или большое целочисленное выражение с помощью `%` (модуля), `&&&` (побитовое и), `|||` (побитовое или) или `^^^` (побитовое ИСКЛЮЧАЮЩее).

При наличии целочисленного или длинного целочисленного выражения слева и целочисленного выражения справа можно использовать операторы `<<<` (арифметические сдвиги влево) или `>>>` (арифметические сдвиги вправо), чтобы создать новое выражение с тем же типом, что и левое выражение.

Второй параметр (сумма сдвига) для операции сдвига должен быть больше или равен нулю; поведение для отрицательных сумм сдвига не определено.
Сумма сдвига для операции сдвига также должна соответствовать 32 бит; Если нет, возникнет ошибка времени выполнения.
Если число, которое необходимо сдвинуть, является целым числом, то величина сдвига интерпретируется `mod 64`; то есть сдвиг 1 и сдвиг 65 имеют одинаковый результат.

Для целочисленных и больших целочисленных значений сдвиги являются арифметическими.
Сдвиг отрицательного значения влево или вправо приведет к отрицательному числу.
Это значит, что сдвиг на один шаг влево или вправо точно так же, как умножение или деление на 2 соответственно.

Целочисленный разделитель и модуль целых чисел следуют тому же поведению для C#отрицательных чисел, что и.
То есть `a % b` всегда будет иметь тот же знак, что и `a`, и `b * (a / b) + a % b` всегда будет `a`.
Пример:

 `A` | `B` | `A / B` | `A % B`
---------|----------|---------|---------
 5 | 2 | 2 | 1
 5 | -2 | -2 | 1
 -5 | 2 | -2 | -1
 -5 | -2 | 2 | -1

Подразделение больших целых чисел и модуль работают одинаково.

При наличии любого числового выражения новое выражение может быть сформировано с помощью унарного оператора `-`.
Новое выражение будет иметь тот же тип, что и составное выражение.

При наличии целочисленного или длинного целочисленного выражения новое выражение того же типа может быть сформировано с помощью унарного оператора `~~~` (побитовое дополнение).

## <a name="boolean-expressions"></a>Логические выражения

Два `Bool` литеральных значений `true` и `false`.

При наличии двух выражений одного и того же примитивного типа для создания выражения `Bool` можно использовать бинарные операторы `==` и `!=`.
Выражение будет иметь значение true, если два выражения равны, и false в противном случае.

Значения определяемых пользователем типов могут не сравниваться, можно сравнивать только их неупакованные значения. Например, с помощью оператора "Распаковка" `!` (объясняется на [странице "модель типа Q #](xref:microsoft.quantum.language.type-model#user-defined-types)"),

```qsharp
newtype WrappedInt = Int;     // Yes, this is a contrived example
let x = WrappedInt(1);
let y = WrappedInt(2);
let z = x! == y!;             // This will compile and yield z = false.
let t = x == y;               // This will cause a compiler error.
```

Сравнение на равенство для значений `Qubit` — равенство идентификаторов; то есть, определяет, совпадают ли два выражения одинаковым кубит.
Состояние двух Кубитс не сравнивается, обращается, измеряется или изменяется с помощью этого сравнения.

Сравнение на равенство значений `Double` может привести к неверному результату из-за эффектов округления.
Например, `49.0 * (1.0/49.0) != 1.0`.

При наличии двух числовых выражений бинарные операторы `>`, `<`, `>=`и `<=` могут использоваться для создания нового логического выражения, равного true, если первое выражение имеет значение больше, меньше, больше или равно или меньше или равно второму выражению.

При наличии двух логических выражений можно использовать бинарные операторы `and` и `or` для создания нового логического выражения, которое имеет значение true, если оба выражения (отв. оба или оба) имеют значение true.

При наличии любого логического выражения можно использовать унарный оператор `not`, чтобы создать новое логическое выражение, равное true, если составное выражение имеет значение false.

## <a name="string-expressions"></a>Строковые выражения

Q # позволяет использовать строки в операторе `fail` и стандартной функции `Log`.

Строки в Q # — это литералы или интерполяции строк.
Строковые литералы похожи на простые строковые литералы в большинстве языков: последовательность символов Юникода, заключенная в двойные кавычки, `"`.
Внутри строки символ обратной косой черты `\` может использоваться для экранирования символа двойной кавычки, а также для вставки новой строки как `\n`, возврата каретки как `\r`и табуляции `\t`.
например

```qsharp
"\"Hello world!\", she said.\n"
```

Синтаксис Q # для интерполяции строк представляет собой подмножество синтаксиса C# 7,0. Q # не поддерживает буквальные строки с интерполяцией (многострочные).
Синтаксис см. в C# разделе [*интерполяция строк*](https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/interpolated-strings) .

Выражения внутри строки с интерполяцией следуют синтаксису Q #, а C# не синтаксису.
Любое допустимое выражение Q # может присутствовать в интерполяции строки.

## <a name="qubit-expressions"></a>Выражения кубит

Единственными `Qubit`ными выражениями являются символы, привязанные к `Qubit` значениям или элементам массива `Qubit` массивов.
Нет `Qubit` литералов.

## <a name="pauli-expressions"></a>Выражения Паули

Четыре `Pauli` значения, `PauliI`, `PauliX`, `PauliY`и `PauliZ`, являются допустимыми `Pauli` выражениями.

Кроме того, единственными `Pauli`ными выражениями являются символы, привязанные к `Pauli` значениям или элементам массива `Pauli` массивов.

## <a name="result-expressions"></a>Выражения результатов

Два значения `Result`, `One` и `Zero`, являются допустимыми `Result` выражениями.

Кроме того, единственными `Result`ными выражениями являются символы, привязанные к `Result` значениям или элементам массива `Result` массивов.
В частности, обратите внимание, что `One` не совпадает с целочисленным `1`, и между ними нет прямого преобразования.
Это справедливо и для `Zero` и `0`.

## <a name="range-expressions"></a>Выражения диапазона

Учитывая три выражения `Int` `start`, `step`и `stop`, `start .. step .. stop` является выражением диапазона, первый элемент которого `start`, второй элемент — `start+step`, третий элемент — `start+step+step`и т. д., пока не будет передан `stop`.
Диапазон может быть пустым, если, например, `step` положительный и `stop < start`.
Последний элемент диапазона будет `stop`, если разница между `start` и `stop` является целым числом, кратным `step`; Это значит, что диапазон является инклюзивным на обоих концах.

При наличии двух выражений `Int` `start` и `stop``start .. stop` является выражением диапазона, равным `start .. 1 .. stop`.
Обратите внимание, что подразумеваемым `step`ом является + 1, даже если `stop` меньше `start`; в этом случае диапазон пуст.

Ниже приведены некоторые примеры диапазонов.

- `1..3` — диапазон 1, 2, 3.
- `2..2..5` — диапазон 2, 4.
- `2..2..6` — диапазон 2, 4, 6.
- `6..-2..2` — диапазон 6, 4, 2.
- `2..1` является пустым диапазоном.
- `2..6..7` — диапазон 2.
- `2..2..1` является пустым диапазоном.
- `1..-1..2` является пустым диапазоном.

## <a name="callable-expressions"></a>Вызываемые выражения

Вызываемый литерал — это имя операции или функции, определенной в области компиляции.
Например, `X` является литералом операции, который ссылается на стандартную `X`ную операцию, а `Message` является литералом функции, который ссылается на стандартную библиотеку `Message` функцию.

Если операция поддерживает `Adjoint` функтор, `Adjoint op` является выражением операции.
Аналогично, если операция поддерживает `Controlled` функтор, `Controlled op` является выражением операции.
Типы этих выражений указываются в [операторов](xref:microsoft.quantum.language.type-model#functors).

Операторов (`Adjoint` и `Controlled`) привязываются более тесно, чем все другие операторы, за исключением того, что оператор растекания `!` и индексирование массивов с `[]`.
Таким образом, все следующие юридические, предполагая, что операции поддерживают операторов.

```qsharp
Adjoint Op(qs)
Controlled Op(controls, targets)
Controlled Adjoint Op(controls, targets)
Adjoint WrappedOp!(qs)
```

В качестве значения можно использовать вызываемый литерал, например, чтобы присвоить значение переменной или передать другому вызываемому.
В этом случае, если вызываемый тип имеет параметры типа, они должны быть предоставлены как часть вызываемого значения.
Вызываемое значение не может иметь неопределенные параметры типа.

Например, если `Fun` является функцией с сигнатурой `'T1->Unit`:

```qsharp
let f = Fun<Int>;            // f is Int->Unit.
SomeOtherFun(Fun<Double>);   // A Double->Unit is passed to SomOtherFun.
let g = Fun;                 // This causes a compilation error.
SomeOtherFun(Fun);           // This also causes a compilation error.
```

## <a name="callable-invocation-expressions"></a>Выражения вызываемого вызова

При наличии вызываемого выражения (операции или функции) и кортежного выражения входного типа сигнатуры вызываемого метода выражение вызова может быть сформировано путем добавления кортежного выражения к вызываемому выражению.
Тип выражения вызова является выходным типом сигнатуры вызываемого метода.

Например, если `Op` является операцией с сигнатурой `((Int, Qubit) => Double)`, `Op(3, qubit1)` является выражением типа `Double`.
Аналогично, если `Sin` является функцией с сигнатурой `(Double -> Double)`, `Sin(0.1)` является выражением типа `Double`.
Наконец, если `Builder` является функцией с сигнатурой `(Int -> (Int -> Int))`, то `Builder(3)` является функцией из в тип int.

Для вызова результата выражения с вызываемым значением требуется еще одна пара круглых скобок вокруг вызываемого выражения.
Таким образом, чтобы вызвать результат вызова `Builder` из предыдущего абзаца, правильный синтаксис:

```qsharp
(Builder(3))(2)
```

При вызове вызываемого параметризованного типа фактические параметры типа могут быть указаны в угловых скобках `<` и `>` после вызываемого выражения.
Обычно это не требуется, так как компилятор Q # будет вычислять фактические типы.
Он необходим для частичного применения (см. ниже), если аргумент с параметризованным типом не указан.
Кроме того, она иногда полезна при передаче операций с разными функтор, которые поддерживаются для вызова.

Например, если `Func` имеет `('T1, 'T2, 'T1) -> 'T2`сигнатуры, `Op1` и `Op2` имеют сигнатуру `(Qubit[] => Unit is Adj)`, а `Op3` имеет `(Qubit[] => Unit)`сигнатуры, для вызова `Func` с `Op1` в качестве первого аргумента `Op2`, а `Op3` как третье:

```qsharp
let combinedOp = Func<(Qubit[] => Unit), (Qubit[] => Unit is Adj)>(Op1, Op2, Op3);
```

Спецификация типа является обязательной, так как `Op3` и `Op1` имеют разные типы, поэтому компилятор будет считать его неоднозначным без спецификации.

### <a name="partial-application"></a>Частичное приложение

При наличии вызываемого выражения можно создать новый вызываемый объект, предоставив подмножество аргументов вызываемому.
Это называется _частичным приложением_.

В Q # частично примененный вызываемый объект выражается путем написания обычного выражения вызова, но с использованием символа подчеркивания `_`для неуказанных аргументов.
Результирующий вызываемый объект имеет тот же тип результата, что и базовый вызываемый, и те же специализации для операций.
Тип входных данных частичного приложения — это просто исходный тип с удаленными указанными аргументами.

Если изменяемая переменная передается в качестве указанного аргумента при создании частичного приложения, используется текущее значение переменной.
Изменение значения переменной после этого не влияет на часть приложения.

Например, если `Op` имеет тип `((Int, ((Qubit, Qubit), Double)) => Unit is Adj)`:

- `Op(5,(_,_))` имеет тип `(((Qubit,Qubit), Double) => Unit is Adj)`и поэтому имеет `Op(5,_)`.
- `Op(_,(_,1.0))` имеет тип `((Int, (Qubit,Qubit)) => Unit is Adj)`.
- `Op(_,((q1,q2),_))` имеет тип `((Int,Double) => Unit is Adj)`.
   Обратите внимание, что здесь применяется эквивалентность одноэлементного кортежа.

Если частично применяемый тип вызываемого метода имеет параметры типа, которые не могут быть определены компилятором, они должны быть предоставлены на сайте вызова.
Часть приложения не может иметь неопределенные параметры типа.

Например, если `Op` имеет тип `(('T1, Qubit, 'T1) => Unit : Adjoint)`:

```qsharp
let f1 = Op<Int>(_, qb, _); // f1 has type ((Int,Int) => Unit is Adj)
let f2 = Op(5, qb, _);      // f2 has type (Int => Unit is Adj)
let f3 = Op(_,qb, _);       // f3 generates a compilation error
```

### <a name="recursion"></a>Рекурсия

Возможность вызовов Q # может быть прямо или косвенно рекурсивной.
Это значит, что операция или функция может вызвать саму себя или вызвать другой вызываемый метод, который напрямую или косвенно вызывает вызываемую операцию.

Однако существует два важных комментария об использовании рекурсии.

- Использование рекурсии в операциях, скорее всего, мешает некоторым оптимизациям.
  Это может оказать значительное влияние на время выполнения алгоритма.
- При выполнении на фактическом устройстве-такте пространство стека может быть ограничено, так что глубокая рекурсия может привести к ошибке времени выполнения.
  В частности, компилятор Q # и среда выполнения не выявляет и не оптимизируют заключительную рекурсию.

## <a name="tuple-expressions"></a>Кортежные выражения

Литерал кортежа — это последовательность выражений элементов соответствующего типа, разделенных запятыми, заключенная в `(` и `)`.
Например, `(1, One)` является выражением `(Int, Result)`.

Кроме литералов, единственными кортежными выражениями являются символы, привязанные к значениям кортежа, элементы массива кортежей и вызываемые вызовы, возвращающие кортежи.

## <a name="user-defined-type-expressions"></a>Выражения определяемого пользователем типа

Литерал определяемого пользователем типа состоит из имени типа, за которым следует литерал кортежа базового типа кортежа типа.
Например, если `IntPair` является определяемым пользователем типом, основанным на `(Int, Int)`, то `IntPair(2,3)` будет допустимым литералом этого типа.

Кроме литералов, единственными выражениями определяемого пользователем типа являются символы, привязанные к значениям этого типа, элементы массива массивов этого типа и вызываемые вызовы, возвращающие этот тип.

## <a name="unwrap-expressions"></a>Разносить выражения

В Q # оператор Unwrap является восклицательным знаком в конце `!`.
Например, если `IntPair` является определяемым пользователем типом с базовым типом `(Int, Int)`, а `s` — переменной со значением `IntPair(2,3)`, `s!` будет `(2,3)`.

Для определяемых пользователем типов, определенных с точки зрения других определяемых пользователем типов. Оператор Unwrap может повторяться; Например, `s!!` указывает значение удвоенного неупакованного значения `s`.
Таким образом, если `WrappedPair` является определяемым пользователем типом с базовым типом `IntPair`, а `t` является переменной со значением `WrappedPair(IntPair(1,2))`, `t!!` будет `(1,2)`.

Оператор `!` имеет более высокий приоритет, чем другие операторы, кроме `[]` для индексирования и среза массива.
Привязка `!` и `[]` позиционирования. то есть `a[i]![3]` должны считываться как `((a[i])!)[3]`: взять `i`элемент "th" `a`, распаковать его, а затем получить третий элемент неупакованного значения (который должен быть массивом).

Приоритет оператора `!` имеет одно влияние, которое может быть неочевидным.
Если функция или операция возвращает значение, которое затем извлекается, функция или вызов операции должны быть заключены в круглые скобки, чтобы кортеж аргументов привязывается к вызову, а не к развернутому.
Пример:

```qsharp
let f = (Foo(arg))!;    // Calls Foo(arg), then unwraps the result
let g = Foo(arg)!;      // Syntax error
```

## <a name="array-expressions"></a>Выражения массива

Литерал массива — это последовательность из одного или нескольких выражений элементов, разделенных запятыми, заключенная в `[` и `]`.
Все элементы должны быть совместимы с одним и тем же типом.

Если тип общего элемента является операцией или типом функции, все элементы должны иметь одинаковые входные и выходные типы.
Тип элемента массива будет поддерживать любые операторов, поддерживаемые всеми элементами.
Например, если `Op1`, `Op2`и `Op3` все `Qubit[] => Unit`, но `Op1` поддерживает `Adjoint`, `Op2` поддерживает `Controlled`, а `Op3` поддерживает оба:

- `[Op1, Op2]` — это массив операций `(Qubit[] => Unit)`.
- `[Op1, Op3]` — это массив операций `(Qubit[] => Unit is Adj)`.
- `[Op2, Op3]` — это массив операций `(Qubit[] => Unit is Ctl)`.

Пустые литералы массива `[]`не допускаются.
Вместо этого с помощью `new ★[0]`, где `★` является заполнителем для подходящего типа, позволяет создать требуемый массив нулевой длины.

При наличии двух массивов одного типа бинарный оператор `+` можно использовать для формирования нового массива, который объединяет два массива.
Например, `[1,2,3] + [4,5,6]` `[1,2,3,4,5,6]`.

### <a name="array-creation"></a>Создание массива

При наличии типа и выражения `Int` можно использовать оператор `new` для выделения нового массива заданного размера.
Например, `new Int[i+1]` выделит новый массив `Int` элементами `i+1`.

Элементы нового массива инициализируются значением по умолчанию, зависящим от типа.
В большинстве случаев это разновидность нуля.

Для Кубитс и вызываемых объектов, которые являются ссылками на сущности, не существует разумного значения по умолчанию.
Таким же для этих типов по умолчанию используется недопустимая ссылка, которую нельзя использовать, не вызывая ошибку во время выполнения.
Это похоже на пустую ссылку на таких языках, как C# или Java.
Массивы, содержащие Кубитс или вызываемые, должны быть правильно инициализированы значениями, отличными от значений по умолчанию, прежде чем их элементы могут быть безопасно использованы. Подходящие процедуры инициализации можно найти в <xref:microsoft.quantum.arrays>.

Значения по умолчанию для каждого типа:

Тип | По умолчанию
---------|----------
 `Int` | `0`
 `BigInt` | `0L`
 `Double` | `0.0`
 `Bool` | `false`
 `String` | `""`
 `Qubit` | _Недопустимый кубит_
 `Pauli` | `PauliI`
 `Result` | `Zero`
 `Range` | Пустой диапазон, `1..1..0`
 `Callable` | _Недопустимый вызываемый_
 `Array['T]` | `'T[0]`

Типы кортежей инициализируются элементом по элементу.


### <a name="jagged-arrays"></a>Зубчатые массивы

Массив массива, иногда называемый «массивом массивов», является массивом, элементы которого являются массивами. Элементы массива массивов могут иметь разные размеры. В следующем примере показано объявление и инициализация массива массивов, представляющего таблицу умножения.

```qsharp
let N = 4;
mutable multiplicationTable = new Int[][N];
for (i in 1..N) {

    mutable row = new Int[i];
    for (j in 1..i) {
        set row w/= j-1 <- i * j;
    }
    set multiplicationTable w/= i-1 <- row;
}
```


### <a name="array-slices"></a>Срезы массива

При наличии выражения массива и `Range`ного выражения новое выражение может быть сформировано с помощью оператора `[` и `]` среза массива.
Новое выражение будет иметь тот же тип, что и массив, и будет содержать элементы массива, индексируемые элементами `Range`, в порядке, определенном `Range`.
Например, если `a` привязан к массиву `Double`s, то `a[3..-1..0]` является выражением `Double[]`, содержащим первые четыре элемента `a` но в порядке, в котором они отображаются в `a`.

Если `Range` пуст, результирующий срез массива будет иметь нулевую длину.

Если выражение массива не является простым идентификатором, его необходимо заключить в круглые скобки для среза.
Например, если `a` и `b` являются массивами `Int`s, срез из объединения будет выражаться следующим образом:

```qsharp
(a+b)[1..2..7]
```

Все массивы в Q # отсчитываются от нуля.
То есть первый элемент массива `a` всегда `a[0]`.

Начиная с нашего выпуска 0,8 мы поддерживаем контекстные выражения для среза диапазона. В частности, начальные и конечные значения диапазона могут быть опущены в контексте выражения среза диапазона. В этом случае компилятор применит следующие правила, чтобы определить предполагаемые разделители для диапазона. 

Например, если начальное значение диапазона опущено, то выводимое начальное значение 
- равно нулю, если шаг не указан или указанный шаг является положительным; 
- Длина фрагментированного массива минус один, если указанный шаг является отрицательным. 

Если значение конца диапазона опущено, то выводимое конечное значение 
- Длина фрагментированного массива минус один, если шаг не указан или указанный шаг является положительным; 
- равно нулю, если указанный шаг является отрицательным. 

```qsharp
let arr = [1,2,3,4,5,6];
let slice1  = arr[3...];      // slice1 is [4,5,6];
let slice2  = arr[0..2...];   // slice2 is [1,3,5];
let slice3  = arr[...2];      // slice3 is [1,2,3];
let slice4  = arr[...2..3];   // slice4 is [1,3];
let slice5  = arr[...2...];   // slice5 is [1,3,5];
let slice7  = arr[4..-2...];  // slice7 is [5,3,1];
let slice8  = arr[...-1..3];  // slice8 is [6,5,4];
let slice9  = arr[...-1...];  // slice9 is [6,5,4,3,2,1];
let slice10 = arr[...];       // slice10 is [1,2,3,4,5,6];
```

## <a name="array-element-expressions"></a>Выражения элементов массива

При наличии выражения массива и `Int`ного выражения новое выражение может быть сформировано с помощью оператора `[` и `]` элемента массива.
Новое выражение будет иметь тот же тип, что и тип элемента массива.
Например, если `a` привязан к массиву `Double`s, то `a[4]` является выражением `Double`.

Если выражение массива не является простым идентификатором, его необходимо заключить в круглые скобки, чтобы выбрать элемент.
Например, если `a` и `b` являются массивами `Int`s, то элемент из объединения будет выражаться следующим образом:

```qsharp
(a+b)[13]
```

Все массивы в Q # отсчитываются от нуля.
То есть первый элемент массива `a` всегда `a[0]`.


## <a name="copy-and-update-expressions"></a>Выражения копирования и обновления

Новые массивы можно создавать из существующих с помощью выражений копирования и обновления.
Выражение копирования и обновления — это выражение в форме `expression1 w/ expression2 <- expression3`, где `expression1` должно иметь тип `T[]` для некоторых `T`типа. Вторая `expression2` определяет индексы элементов для изменения по сравнению с массивом в `expression1` и должен иметь тип `Int` или типа `Range`. Если `expression2` имеет тип `Int`, `expression3` должен иметь тип `T`. Если `expression2` имеет тип `Range`, `expression3` должен иметь тип `T[]`.

Выражение копирования и обновления `arr w/ idx <- value` формирует новый массив со всеми элементами, заданными в соответствующем элементе в `arr`, за исключением элементов в `idx`, для которых в `value`заданы один (-ов). Например, если `arr` содержит массив `[0,1,2,3]`, то 
- `arr w/ 0 <- 10` является `[10,1,2,3]`массива.
- `arr w/ 2 <- 10` является `[0,1,10,3]`массива.
- `arr w/ 0..2..3 <- [10,12]` является `[10,1,12,3]`массива.

Аналогичные выражения существуют для именованных элементов в определяемых пользователем типах. Рассмотрим, например, тип 

```qsharp
newtype Complex = (Re : Double, Im : Double);
```
Если `c` содержит значение типа `Complex(1.,-1.)`, `c w/ Re <- 0.` является выражением типа `Complex`, результатом которого является `Complex(0.,-1.)`.

## <a name="conditional-expressions"></a>Условные выражения

Учитывая два других выражения одного и того же типа и логического выражения, условное выражение может быть сформировано с помощью вопросительного знака `?` и `|`вертикальной черты.
Например, `a==b ? c | d`.
В этом примере значение условного выражения будет `c`, если `a==b` имеет значение true, и `d`, если это значение равно false.

Эти два выражения могут возвращать операции с одинаковыми входными и выходными данными, но поддерживают разные операторов.
В этом случае тип условного выражения является операцией с входными и выходными данными, которые поддерживают любые операторов, поддерживаемые обоими выражениями.
Например, если `Op1`, `Op2`и `Op3` все `Qubit[]=>Unit`, но `Op1` поддерживает `Adjoint`, `Op2` поддерживает `Controlled`, а `Op3` поддерживает оба:

- `flag ? Op1 | Op2` является операцией `(Qubit[] => Unit)`.
- `flag ? Op1 | Op3` является операцией `(Qubit[] => Unit is Adj)`.
- `flag ? Op2 | Op3` является операцией `(Qubit[] => Unit is Ctl)`.

Если одно из двух возможных результатов содержит вызов функции или операции, этот вызов будет выполняться только в том случае, если результатом является значение, которое будет значением вызова.
Например, в случае `a==b ? C(qs) | D(qs)`, если `a==b` имеет значение true, будет вызвана операция `C`, и если это значение равно false, будет вызван только `D`.
Это похоже на сокращенное вычисление на других языках.


## <a name="operator-precedence"></a>Приоритет операторов

Все бинарные операторы являются правой ассоциативными, за исключением `^`.

Квадратные скобки, `[` и `]`для разбиения по массиву и индексирования привязываются перед любым оператором.

Операторов `Adjoint` и `Controlled` привязываются после индексирования массива, но перед всеми другими операторами.

Круглые скобки для операции и вызова функции также привязываются перед любым оператором, но после индексирования массива и операторов.

Операторы в порядке приоритета, от самого высокого до самого низкого:

Оператор | Арность | Description | Типы операндов
---------|----------|---------|---------------
 Конечная `!` | Унарный | разворачивание; | Любой определяемый пользователем тип
 `-`, `~~~`, `not` | Унарный | Числовое отрицательное, побитовое дополнение, логическое отрицание | `Int`, `BigInt` или `Double` для `-`, `Int` или `BigInt` `~~~`, `Bool``not`
 `^` | Двоичные данные | Целочисленное энергопотребление | `Int` или `BigInt` для основания, `Int` для экспоненты
 `/`, `*`, `%` | Двоичные данные | Деление, умножение, целочисленный модуль | `Int`, `BigInt` или `Double` для `/` и `*`, `Int` или `BigInt` для `%`
 `+`, `-` | Двоичные данные | Сложение или объединение строк и массивов, вычитание | `Int`, `BigInt` или `Double`, кроме `String` или любого типа массива для `+`
 `<<<`, `>>>` | Двоичные данные | Сдвиг влево, сдвиг вправо | `Int` либо `BigInt`
 `<`, `<=`, `>`, `>=` | Двоичные данные | Сравнения "меньше чем", "меньше или равно", "больше чем", "больше или равно" | `Int`, `BigInt` или `Double`
 `==`, `!=` | Двоичные данные | сравнения «равно» и «не равно» | любой тип-примитив
 `&&&` | Двоичные данные | Побитовое И | `Int` либо `BigInt`
 `^^^` | Двоичные данные | Побитовое исключающее ИЛИ | `Int` либо `BigInt`
 <code>\|\|\|</code> | Двоичные данные | Побитовое ИЛИ | `Int` либо `BigInt`
 `and` | Двоичные данные | Логическое И | `Bool`
 `or` | Двоичные данные | Логическое ИЛИ | `Bool`
 `..` | Двоичный/Ternary | Оператор Range | `Int`
 `?` `|` | Ternary | Условная логика | `Bool` для левой стороны
`w/` `<-` | Ternary | Копирование и обновление | см. раздел [выражения копирования и обновления](#copy-and-update-expressions) .
