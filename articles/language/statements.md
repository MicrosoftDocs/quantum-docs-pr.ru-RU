---
title: 'Инструкции Q #'
description: 'Сведения о правильном использовании операторов в Q #, включая объявления функций и операций, объявления переменных и назначения, а также вызовы операций.'
author: QuantumWriter
uid: microsoft.quantum.language.statements
ms.author: Alan.Geller@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: e801a5fdd24b973f47d23d2aca6f11bbebf333d4
ms.sourcegitcommit: 6ccea4a2006a47569c4e2c2cb37001e132f17476
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/28/2020
ms.locfileid: "77904678"
---
# <a name="statements-and-other-constructs"></a>Операторы и другие конструкции

## <a name="comments"></a>Комментарии

Комментарии начинаются с двух косых черт, `//`и продолжаются до конца строки.
Комментарий может находиться в любом месте исходного файла Q #.

### <a name="documentation-comments"></a>Комментарии к документации

Комментарии, начинающиеся с трех косых черт, `///`, обрабатываются компилятором специально, когда они появляются непосредственно перед определением пространства имен, операции, специализации, функции или типа.
В этом случае их содержимое берется в виде документации по определенному вызываемому или определяемому пользователем типу, как и для других языков .NET.

В `///` комментариях текст, отображаемый в составе документации по API, форматируется как [Markdown](https://daringfireball.net/projects/markdown/syntax), а различные части документации указываются с помощью специально именованных заголовков.
Как расширение Markdown, перекрестные ссылки на операции, функции и определяемые пользователем типы в Q # можно включать с помощью `@"<ref target>"`, где `<ref target>` заменяется полным именем объекта кода, на который указывает ссылка.
Кроме того, обработчик документации может также поддерживать дополнительные расширения Markdown.

Пример:

```qsharp
/// # Summary
/// Given an operation and a target for that operation,
/// applies the given operation twice.
///
/// # Input
/// ## op
/// The operation to be applied.
/// ## target
/// The target to which the operation is to be applied.
///
/// # Type Parameters
/// ## 'T
/// The type expected by the given operation as its input.
///
/// # Example
/// ```Q#
/// // Should be equivalent to the identity.
/// ApplyTwice(H, qubit);
/// ```
///
/// # See Also
/// - Microsoft.Quantum.Intrinsic.H
operation ApplyTwice<'T>(op : ('T => Unit), target : 'T) : Unit {
    op(target);
    op(target);
}
```

Следующие имена распознаются как заголовки комментариев документации.

- **Сводка**: краткое описание поведения функции или операции или назначения типа. Первый абзац сводки используется для сведений о наведении. Он должен быть обычным текстом.
- **Описание**: описание поведения функции или операции, либо назначение типа. Сводные данные и описание объединяются, образуя созданный файл документации для функции, операции или типа.
  Описание может содержать встроенные LaTeX символы и уравнения.
- **Входные данные**: описание входного кортежа для операции или функции.
  Может содержать дополнительные подразделы Markdown, указывающие каждый отдельный элемент входного кортежа.
- **Output**: описание кортежа, возвращаемого операцией или функцией.
- **Параметры типа**: пустой раздел, содержащий один дополнительный подраздел для каждого параметра универсального типа.
- **Пример**. короткий пример используемой операции, функции или типа.
- **Примечания**. различные prose, описывающие некоторые аспекты операции, функции или типа.
- **См. также**: список полных имен, указывающих связанные функции, операции или определяемые пользователем типы.
- **Ссылки**: список ссылок и ссылок для задокументированного элемента.

## <a name="namespaces"></a>Пространства имен

Каждая операция Q #, функция и определяемый пользователем тип определяется в пространстве имен.
В параметре Q # применяются те же правила именования, что и для других языков .NET.
Однако Q # не поддерживает относительные ссылки на пространства имен.
То есть если было открыто `a.b` пространства имен, ссылка на имена операций `c.d` не будет разрешена в операцию с полным именем `a.b.c.d`.

В блоке пространства имен директива `open` может использоваться для импорта всех типов и вызываемых, объявленных в определенном пространстве имен, и ссылаться на них по их неполному имени. Кроме того, можно определить короткое имя для открытого пространства имен таким, чтобы все элементы из этого пространства имен могли уточняться определенным коротким именем. Директива `open` применяется ко всему блоку пространства имен в файле.

На тип или вызываемый объект, определенный в другом пространстве имен, который не открыт в текущем пространстве имен, должен ссылаться полное имя.
Например, на операцию с именем `Op` в пространстве имен `X.Y` должно ссылаться полное имя `X.Y.Op`, если только пространство имен `X.Y` не было открыто ранее в текущем блоке. Как упоминалось выше, даже при открытии пространства имен `X` нельзя ссылаться на операцию как на `Y.Op`.
Если в этом пространстве имен и файле определено короткое имя `Z` для `X.Y`, то `Op` необходимо называть `Z.Op`. 

```qsharp
namespace NS {
    open Microsoft.Quantum.Intrinsic; // opens the namespace
    open Microsoft.Quantum.Math as Math; // defines a short name for the namespace
}
```

Обычно лучше включать пространство имен с помощью директивы `open`.
Использование полного имени требуется, если два пространства имен определяют конструкции с одинаковым именем, а текущий источник использует конструкции из обоих.

## <a name="formatting"></a>Форматирование

Большинство инструкций и директив Q # заканчиваются завершающей точкой с запятой, `;`.
Инструкции и объявления, такие как `for` и `operation`, заканчивающиеся блоком операторов, не нуждаются в завершающей точке с запятой.
Каждое описание инструкции отмечает, требуется ли завершающая точка с запятой.

Инструкции, такие как выражения, объявления и директивы, могут быть разбиты на несколько строк.
Следует избегать нескольких инструкций в одной строке.

## <a name="statement-blocks"></a>Блоки инструкций

Инструкции Q # группируются в блоки инструкций.
Блок операторов начинается с открывающего `{` и заканчивается закрывающим `}`.

Блок операторов, который лексической заключен в другой блок, считается вложенным блоком содержащего блока. содержащие и вложенные блоки также называются внешними и внутренними блоками.

## <a name="symbol-binding-and-assignment"></a>Привязка и назначение символов

Q # различает изменяемые и неизменяемые символы.
Как правило, использование неизменяемых символов рекомендуется, поскольку оно позволяет компилятору выполнять более оптимизацию.

Левая часть привязки состоит из кортежа символов, а также с правой стороны выражения.

Так как все типы Q # являются типами значений — с Кубитс, принимающей более специальную роль, формально создается «Copy», когда значение привязывается к символу, или при повторной привязке символа. То есть, поведение Q # аналогично тому, как если бы копия была создана при назначении. В частности, это также касается массивов. Разумеется, на практике при необходимости воссоздаются только соответствующие части. 

### <a name="tuple-deconstruction"></a>Деконструкция кортежа

Если правая часть привязки является кортежем, то этот кортеж можно деконструировать после назначения.
Такие деконструкции могут содержать вложенные кортежи, а любая полная или частичная деконструкция является допустимой, если форма кортежа в правой части совместима с формой кортежа символов.
Деконструкцию кортежей можно также использовать, если правая часть `=` является кортежным выражением.

```qsharp
let (i, f) = (5, 0.1); // i is bound to 5 and f to 0.1
mutable (a, (_, b)) = (1, (2, 3)); // a is bound to 1, b is bound to 3
mutable (x, y) = ((1, 2), [3, 4]); // x is bound to (1,2), y is bound to [3,4]
set (x, _, y) = ((5, 6), 7, [8]);  // x is rebound to (5,6), y is rebound to [8]
let (r1, r2) = MeasureTwice(q1, PauliX, q2, PauliY);
```

### <a name="immutable-symbols"></a>Неизменяемые символы

Неизменяемые символы привязываются с помощью оператора `let`.
Это примерно эквивалентно объявлению и инициализации переменных на таких языках, C#как, за исключением того, что символ Q # после привязки не может быть изменен. привязки `let` являются неизменяемыми.

Неизменяемая Привязка состоит из ключевого слова `let`, за которым следует символ или кортеж символов, знак равенства `=`, выражение для привязки символов к и завершающая точка с запятой.
Тип привязанных символов определяется на основе выражения с правой стороны.

### <a name="mutable-symbols"></a>Изменяемые символы

Изменяемые символы определяются и инициализируются с помощью инструкции `mutable`.
Символы, объявленные и привязанные как часть оператора `mutable`, можно повторно привязать к другому значению позже в коде. 

Изменяемый оператор привязки состоит из ключевого слова `mutable`, за которым следует символ или кортеж символов, знак равенства `=`, выражение для привязки символов к и завершающая точка с запятой.
Тип привязанных символов определяется на основе выражения с правой стороны. Если символ повторно привязан позже в коде, его тип не изменится, а связанное значение должно быть совместимо с этим типом.

### <a name="rebinding-of-mutable-symbols"></a>Повторная привязка изменяемых символов

Изменяемую переменную можно повторно привязать с помощью инструкции `set`.
Такая повторная привязка состоит из ключевого слова `set`, за которым следует символ или кортеж символов, знак равенства `=`, выражение для повторной привязки символов к и завершающая точка с запятой.
Значение должно быть совместимо с типами символов, к которым он привязан.

#### <a name="apply-and-reassign-statement"></a>Инструкция Apply и REASSIGN

Определенный тип оператора Set, который называется оператором применения и повторного присваивания, предоставляет удобный способ объединения, если правая часть состоит из приложения бинарного оператора, а результат повторно привязан к оператору слева. Например,
```qsharp
mutable counter = 0;
for (i in 1 .. 2 .. 10) {
    set counter += 1;
    // ...
}
```
увеличивает значение счетчика `counter` в каждой итерации цикла `for`. Приведенный выше код эквивалентен 
```qsharp
mutable counter = 0;
for (i in 1 .. 2 .. 10) {
    set counter = counter + 1;
    // ...
}
```
Аналогичные операторы доступны для всех бинарных операторов, в которых тип левой стороны соответствует типу выражения. Это предоставляет пример удобного способа накопления значений:
```qsharp
mutable results = new Result[0];
for (qubit in qubits) {
    set results += [M(q)];
    // ...
}
```
#### <a name="update-and-reassign-statement"></a>Инструкция UPDATE и REASSIGN

Аналогичное объединение существует для выражений копирования и обновления с правой стороны. Соответственно, операторы Update и reassignя существуют для именованных элементов в определяемых пользователем типах, а также для элементов массива.  

```qsharp
newtype Complex = (Re : Double, Im : Double);

function ComplexSum(reals : Double[], ims : Double[]) : Complex[] {
    mutable res = Complex(0.,0.);

    for (r in reals) {
        set res w/= Re <- res::Re + r; // update-and-reassign statement
    }
    for (i in ims) {
        set res w/= Im <- res::Im + i; // update-and-reassign statement
    }
    return res;
}
```

В случае массивов наши стандартные библиотеки содержат необходимые средства для многих общих задач инициализации и манипуляции массивов, что позволяет избежать необходимости обновлять элементы массива в первую очередь. Инструкции обновления и повторного назначения предоставляют альтернативный вариант при необходимости:

```qsharp
operation GenerateRandomInts(max : Int, nSamples : Int) : Int[] {
    mutable samples = new Double[0];
    for (i in 1 .. nSamples) {
        set samples += [RandomInt(max)];
    }
    return samples;
}

operation SampleUniformDistrbution(nSamples : Int, nSteps : Int) : Double[] {
    let normalization = 1. / IntAsDouble(nSteps);
    mutable samples = GenerateRandomInts(nSteps, nSamples);
    
    for (i in IndexRange(samples) {
        let value = IntAsDouble(samples[i]);
        set samples w/= i <- normalization * value; // update-and-reassign statement
    }
}

```

> [!TIP]   
> Избегайте ненужного использования инструкций обновления и повторного назначения, используя средства, предоставляемые в <xref:microsoft.quantum.arrays>.

Функция
```qsharp
function PauliEmbedding(pauli : Pauli, length : Int, location : Int) : Pauli[] {
    mutable pauliArray = new Pauli[length];
    for (index in 0 .. length - 1) {
        set pauliArray w/= index <- 
            index == location ? pauli | PauliI;
    }    
    return pauliArray;
}
```
Например, можно просто упростить использование функции `ConstantArray` в `Microsoft.Quantum.Arrays`и возвратить выражение копирования и обновления:

```qsharp
function PauliEmbedding(pauli : Pauli, length : Int, location : Int) : Pauli[] {
    return ConstantArray(length, PauliI) w/ location <- pauli;
}
```

### <a name="binding-scopes"></a>Области привязки

Как правило, привязки к символам выходят за пределы области действия и становятся неработоспособными в конце блока операторов, в котором они встречаются.
Существует два исключения из этого правила:

- Привязка переменной цикла `for` цикла находится в области видимости тела цикла for, но не после конца цикла.
- Все три части `repeat`/цикл `until` (текст, тест и адресная привязка) обрабатываются как одна область, поэтому символы, привязанные к тексту, доступны в тесте и в адресной привязке.

Для обоих типов циклов каждый проход по циклу выполняется в своей собственной области, поэтому привязки из предыдущего прохода не будут доступны на более позднем этапе.

Привязки символов из внешних блоков наследуются внутренними блоками.
Символ может быть привязан только один раз для каждого блока; нельзя определить символ с тем же именем, что и у другого символа, находящихся в пределах области (без "тени").
Следующие последовательности будут допустимыми:

```qsharp
if (a == b) {
    ...
    let n = 5;
    ...             // n is 5
}
let n = 8;
...                 // n is 8
```

и

```qsharp
if (a == b) {
    ...
    let n = 5;
    ...             // n is 5
} else {
    ...
    let n = 8;
    ...             // n is 8
}
```

Но это недопустимо:

```qsharp
let n = 5;
...                 // n is 5
let n = 8;          // Error!!
...
```

как:

```qsharp
let n = 8;
if (a == b) {
    ...             // n is 8
    let n = 5;      // Error!
    ...
}
...
```

## <a name="control-flow"></a>Поток управления

### <a name="for-loop"></a>Цикл For

Оператор `for` поддерживает итерацию по диапазону целых чисел или к массиву.
Оператор состоит из ключевого слова `for`, открывающей скобки `(`, за которой следует символ или кортеж символов, ключевое слово `in`, выражение типа `Range` или Array, закрывающая круглая скобка `)`и блок операторов.

Блок операторов (тело цикла) выполняется повторно с определенными символами (переменными цикла), привязанными к каждому значению в диапазоне или массиве.
Обратите внимание, что если выражение диапазона принимает пустой диапазон или массив, тело не будет выполняться вообще.
Выражение полностью вычисляется перед входом в цикл и не будет изменяться во время выполнения цикла.

Привязка объявленных символов является неизменяемой и соответствует тем же правилам, что и другие привязки переменных. В частности, можно уничтожения, например, элементы массива для итерации по массиву после присваивания переменным цикла.

Например,

```qsharp
// ...
for (qubit in qubits) { // qubits contains a Qubit[]
    H(qubit);
}

mutable results = new (Int, Results)[Length(qubits)];
for (index in 0 .. Length(qubits) - 1) {
    set results w/= index <- (index, M(qubits[index]));
}

mutable accumulated = 0;
for ((index, measured) in results) {
    if (measured == One) {
        set accumulated += 1 <<< index;
    }
}
```

Переменная цикла привязывается к каждому входу в тело цикла и не привязана к концу тела.
В частности, переменная цикла не привязана после завершения цикла for.

### <a name="repeat-until-success-loop"></a>Цикл "повторить" до "успешно"

Инструкция `repeat` поддерживает шаблон такта "повторять до успешного завершения".
Он состоит из ключевого слова `repeat`, за которым следует блок операторов (тело _цикла_ ), ключевое слово `until`, логическое выражение и либо завершающая точка с запятой, либо ключевое слово `fixup`, за которым следует другой блок операторов ( _адресная привязка_).
Тело цикла, условие и исправление считаются одной областью, поэтому символы, привязанные к тексту, доступны в условии и адресной привязке.

```qsharp
mutable iter = 1;
repeat {
    ProbabilisticCircuit(qubits);
    let success = ComputeSuccessIndicator(qubits);
}
until (success || iter > maxIter)
fixup {
    iter += 1;
    ComputeCorrection(qubits);
}
```

Выполняется тело цикла, а затем вычисляется условие.
Если условие истинно, инструкция завершается; в противном случае выполняется адресная привязка и выполняется повторная инструкция, начиная с тела цикла.
Обратите внимание, что завершение выполнения адресной привязки завершает область действия инструкции, чтобы привязки символов, сделанные во время тела или исправления, были недоступны при последующих повторах.

Например, следующий код представляет собой цепь вероятностная, которая реализует важный шлюз ротации $V _3 = (\болдоне + 2 i Z)/\скрт{5}$ с использованием Хадамард и T Gates.
Цикл завершается в параметре $ \фрак{8}{5}числом повторений $ в среднем.
Дополнительные сведения см. в разделе [*Повтор-Until-Success: недетерминированная декомпозиция одного кубит унитариес*](https://arxiv.org/abs/1311.1074) (Паетзникк и своре, 2014).

```qsharp
using (qubit = Qubit()) {
    repeat {
        H(qubit);
        T(qubit);
        CNOT(target, qubit);
        H(qubit);
        Adjoint T(qubit);
        H(qubit);
        T(qubit);
        H(qubit);
        CNOT(target, qubit);
        T(qubit);
        Z(target);
        H(qubit);
        let result = M(qubit);
    } until (result == Zero);
}
```

> [!TIP]   
> Избегайте использования циклов повторения до успешного выполнения в функциях. Соответствующие функциональные возможности обеспечиваются циклами while в функциях. 

### <a name="while-loop"></a>Цикл while

Шаблоны Repeat-Until-Success имеют очень много времени. Они широко используются в определенных классах тактовых алгоритмов, поэтому выделенная конструкция языка в Q #. Однако циклы, которые нарушаются в зависимости от условия и длина выполнения которого во время компиляции неизвестны, должны обрабатываться с определенной осторожностью в среде выполнения такта. Их использование в функциях с другой стороны не является проблемой, поскольку в них содержится только код, который будет выполняться на обычном (не такте) оборудовании. 

Таким образом, Q # поддерживает использование циклов while только внутри функций. Оператор `while` состоит из ключевого слова `while`, открывающей скобки `(`, условия (т. е. логического выражения), закрывающей скобки `)`и блока операторов.
Блок операторов (тело цикла) выполняется при условии, что условие принимает значение `true`.

```qsharp
// ...
mutable (item, index) = (-1, 0);
while (index < Length(arr) && item < 0) { 
    set item = arr[index];
    set index += 1;
}
```

### <a name="conditional-statement"></a>Условный оператор

Оператор `if` поддерживает условное выполнение.
Он состоит из ключевого слова `if`, открывающей скобки `(`, логического выражения, закрывающей скобки `)`и блока операторов (блок _then_ ).
За этим может следовать любое число предложений else-if, каждое из которых состоит из ключевого слова `elif`, открывающей скобки `(`, логического выражения, закрывающей скобки `)`и блока операторов ( _Else-If_ ).
Наконец, оператор может при необходимости завершиться предложением else, которое состоит из ключевого слова `else` за которым следует другой блок операторов (блок _else_ ).
Условие вычисляется, и, если оно равно true, выполняется блок then.
Если условие имеет значение false, то проверяется первое условие else-if; Если значение равно true, выполняется блок Else-If.
В противном случае проверяется второй блок-If, а затем третий и т. д., пока не будет обнаружено предложение с истинным условием или отсутствуют другие предложения Else-If.
Если исходное условие If и все предложения Else-If имеют значение false, то блок Else выполняется, если он был предоставлен.

Обратите внимание, что любой блок выполняется в своей собственной области.
Привязки, сделанные внутри блока then, else-if или else, не видны после окончания оператора if.

Например,

```qsharp
if (result == One) {
    X(target);
} 
```

или диспетчер конфигурации служб

```qsharp
if (i == 1) {
    X(target);
} elif (i == 2) {
    Y(target);
} else {
    Z(target);
}
```

### <a name="return"></a>Возвращает

Оператор Return завершает выполнение операции или функции и возвращает значение вызывающему объекту.
Он состоит из ключевого слова `return`, за которым следует выражение соответствующего типа и завершающая точка с запятой.

Вызываемый метод, возвращающий пустой кортеж, `()`, не требует оператора return.
Если требуется выполнить раннее завершение работы, в этом случае может использоваться `return ()`.
Для вызова, возвращающего любой другой тип, требуется завершающий оператор return.

В операции отсутствует максимальное число инструкций Return.
Компилятор может выдать предупреждение, если операторы следуют за оператором Return в блоке.

Например,

```qsharp
return 1;
```

или диспетчер конфигурации служб

```qsharp
return ();
```

или диспетчер конфигурации служб

```qsharp
return (results, qubits);
```

### <a name="fail"></a>Ошибка

Инструкция Fail завершает выполнение операции и возвращает вызывающему объекту значение ошибки.
Он состоит из ключевого слова `fail`, за которым следует строка и завершающая точка с запятой.
Строка возвращается в классический драйвер в качестве сообщения об ошибке.

Количество инструкций Fail в операции не ограничено.
Компилятор может выдать предупреждение, если операторы следуют за оператором Fail в блоке.

Например,

```qsharp
fail $"Impossible state reached";
```

или диспетчер конфигурации служб

```qsharp
fail $"Syndrome {syn} is incorrect";
```

## <a name="qubit-management"></a>Управление кубит

Обратите внимание, что ни одна из этих инструкций не разрешена в теле функции.
Они действительны только в пределах операций.

### <a name="clean-qubits"></a>Очистить Кубитс

Оператор `using` используется для получения новых Кубитс для использования во время блока инструкций.
Кубитс гарантированно инициализируются в вычислительное состояние `Zero`.
Кубитс должен находиться в состоянии вычислительного `Zero` в конце блока инструкции; для этого рекомендуется применять симуляторы.

Оператор состоит из ключевого слова `using`, за которым следует открывающая круглая скобка `(`, привязка, закрывающая круглая скобка `)`и блок операторов, в рамках которого будет доступна Кубитс.
Привязка соответствует тому же шаблону, что и `let`ные операторы: один символ или кортеж символов, за которым следует знак равенства `=`и одно значение или соответствующий кортеж инициализаторов.
Инициализаторы доступны для одного кубит, обозначенного как `Qubit()`, или массива Кубитс, обозначенного `Qubit[`, `Int`ным выражением и `]`.

Например,

```qsharp
using (qubit = Qubit()) {
    // ...
}
using ((auxiliary, qubits) = (Qubit(), Qubit[bits * 2 + 3])) {
    // ...
}
```

### <a name="borrowed-qubits"></a>Заимствованный Кубитс

Оператор `borrowing` используется для получения Кубитс для временного использования. Оператор состоит из ключевого слова `borrowing`, за которым следует открывающая круглая скобка `(`, привязка, закрывающая круглая скобка `)`и блок операторов, в рамках которого будет доступна Кубитс.
Привязка соответствует тому же шаблону и правилам, что и в операторе `using`.

Например,

```qsharp
borrowing (qubit = Qubit()) {
    // ...
}
borrowing ((auxiliary, qubits) = (Qubit(), Qubit[bits * 2 + 3])) {
    // ...
}
```

Заимствованные Кубитс находятся в неизвестном состоянии и выходят за пределы области действия в конце блока инструкций.
Он фиксируется, чтобы покинуть Кубитс в том состоянии, в котором они находились в момент заимствования, т. е. состояние в начале и в конце блока инструкции должны совпадать.
Это состояние в частности не всегда является классическим состоянием, поэтому в большинстве случаев области действия не должны содержать измерений. 

Пример заимствованного роеттелер использования см. в разделе [*факторинг с использованием 2N + 2 Кубитс с модульным умножением на основе Тоффоли*](https://arxiv.org/abs/1611.07995) (Ханер, Своре и кубит 2017).

При заимствовании Кубитс система сначала пытается заполнить запрос от Кубитс, который используется, но к нему не обращаются в теле инструкции `borrowing`.
Если такой Кубитс не хватает, он выделит новый Кубитс для выполнения запроса.

## <a name="conjugations"></a>Лиц

В отличие от классических битов освобождение памяти такта немного сложнее, так как в результате нежелательного сброса Кубитс может иметь нежелательные последствия для оставшихся вычислений, если Кубитс все еще запутанными. Это можно избежать, правильно выполнив вычисления перед освобождением памяти. Общий шаблон в тактовых вычислениях, следовательно, является следующим: 

```qsharp
operation ApplyWith<'T>(
    outerOperation : ('T => Unit is Adj), 
    innerOperation : ('T => Unit), 
    target : 'T) 
: Unit {

    outerOperation(target);
    innerOperation(target);
    Adjoint outerOperation(target);
}
```

: New: начиная с нашего выпуска 0,9 мы поддерживаем инструкцию конжугатион, которая реализует преобразование выше. С помощью этой инструкции операция `ApplyWith` может быть реализована следующим образом:

```qsharp
operation ApplyWith<'T>(
    outerOperation : ('T => Unit is Adj), 
    innerOperation : ('T => Unit), 
    target : 'T) 
: Unit {

    within{ 
        outerOperation(target);
    }
    apply {
        innerOperation(target);
    }
}
```
Очевидно, что такой оператор конжугатион гораздо полезнее, если внешнее и внутреннее преобразование недоступно в качестве операций, но вместо этого более удобно описывать блоком, состоящим из нескольких инструкций. 

Обратное преобразование для инструкций, определенных в блоке внутри блока, автоматически создается компилятором и выполняется после завершения блока Apply. Поскольку любые изменяемые переменные, используемые в качестве части блока in, не могут быть повторно привязаны в блоке применения, созданное преобразование гарантируется как прилегающие вычисления в блоке внутри блока. 

## <a name="expression-evaluation-statements"></a>Операторы вычисления выражений

Любое выражение вызова типа `Unit` может использоваться в качестве инструкции.
Это в первую очередь используется при вызове операций с Кубитс, возвращающих `Unit`, так как целью инструкции является изменение неявного состояния такта.
Для операторов вычисления выражения требуется завершающая точка с запятой.

Например,

```qsharp
X(q);
CNOT(control, target);
Adjoint T(q);
```
