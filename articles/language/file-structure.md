---
title: 'Q # файл структура'
description: 'Сведения о структурировании пространств имен, операций, функций и определяемых пользователем типов объявлений в Q # Programs and librarys.'
author: QuantumWriter
uid: microsoft.quantum.language.file-structure
ms.author: Alan.Geller@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: 96de062bc6ce4edf94520bec449e8d95259c0f5c
ms.sourcegitcommit: a0e50c5f07841b99204c068cf5b5ec8ed087ffea
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/26/2020
ms.locfileid: "80320766"
---
# <a name="file-structure"></a>Структура файла

Файл Q # состоит из последовательности объявлений пространств имен.
Каждое объявление пространства имен содержит объявления для определяемых пользователем типов, операций и функций.
Объявление пространства имен может содержать любое количество объявлений каждого типа и в любом порядке.
Единственный текст, который может находиться за пределами объявления пространства имен, — это комментарии.
В частности, комментарии к документации для пространства имен предшествуют объявлению.

## <a name="namespace-declarations"></a>Объявление пространств имен

Как правило, файл Q # содержит только одно объявление пространства имен, но может содержать пустое значение (и быть пустым или содержать только комментарии) или может включать несколько пространств имен.
Объявления пространств имен не могут быть вложенными.

Одно и то же пространство имен может быть объявлено в нескольких файлах Q #, компилируемых вместе, при условии, что отсутствуют объявления типов, операций или функций с одинаковыми именами.
В частности, нельзя определить один и тот же тип в одном пространстве имен в нескольких файлах, даже если объявления идентичны.

Объявление пространства имен состоит из ключевого слова `namespace`, за которым следует имя пространства имен, `{`открывающая скобка, объявления, содержащиеся в пространстве имен, и закрывающая фигурная скобка `}`.
Имена пространств имен соответствуют шаблону .NET последовательности из одного или нескольких юридических символов, разделенных точками `.`.
Например, `MyQuantumStuff` и `Microsoft.Quantum.Canon` являются допустимыми именами пространств имен.
По соглашению символы в имени пространства имен записываются прописными буквами, но это не является обязательным.

Объявления могут располагаться в любом порядке в объявлении пространства имен.
Ссылки на типы или вызываемые объекты, объявленные ниже в файле, разрешаются правильно. нет необходимости в объявлении типа, операции или функции перед ссылкой на нее.

## <a name="open-directives"></a>Открытые директивы

В блоке пространства имен директива `open` может использоваться для импорта всех типов и вызываемых в определенное пространство имен, а также для обращения к ним по их неполному имени. 

Такая директива `open` состоит из ключевого слова `open`, за которым следует открытое пространство имен и завершающая точка с запятой.

Например,

```qsharp
open Microsoft.Quantum.Canon;
```

Кроме того, можно определить короткое имя для открытого пространства имен таким, чтобы все элементы из этого пространства имен могли уточняться определенным коротким именем. Это короткое имя определяется путем добавления ключевого слова `as` за которым следует требуемое короткое имя перед точкой с запятой в директиве `open`:

```qsharp
open Microsoft.Quantum.Math as Math;
```

Все директивы `open` должны располагаться перед объявлениями `function`, `operation`или `newtype` в блоке пространства имен.
Директива `open` применяется ко всему блоку пространства имен в файле.

## <a name="user-defined-type-declarations"></a>Объявления определяемого пользователем типа

Q # предоставляет пользователям возможность объявлять новые определяемые пользователем типы, как описано в разделе " [модель типов Q #](xref:microsoft.quantum.language.type-model) ".
Определяемые пользователем типы различаются, даже если базовые типы идентичны.
В частности, нет автоматического преобразования между значениями двух определяемых пользователем типов, даже если базовые типы идентичны.

Объявление определяемого пользователем типа состоит из ключевого слова `newtype`, за которым следует имя определяемого пользователем типа, `=`, допустимая спецификация типа и завершающая точка с запятой.

Пример:

```qsharp
newtype PairOfInts = (Int, Int);
```

Каждый исходный файл Q # может объявлять любое количество определяемых пользователем типов.
Имена типов должны быть уникальными в пределах пространства имен и могут не конфликтовать с именами операций и функций.

Невозможно определить циклические зависимости между определяемыми пользователем типами. Поэтому рекурсивные типы невозможны в Q #.

## <a name="operation-declarations"></a>Объявления операций

Операции — это ядро Q #, примерно аналогичное функциям на других языках.
Каждый исходный файл Q # может определять любое количество операций.

Имена операций должны быть уникальными в пределах пространства имен и могут не конфликтовать с именами типа и функции.

Объявления операций состоят из ключевого слова `operation`, за которым следует символ, который представляет собой имя операции, кортеж типизированного идентификатора, определяющий аргументы для операции, двоеточие `:`, аннотацию типа, описывающую тип результата операции, при необходимости заметку с характеристиками операции, открывающую фигурную скобку `{`, текст объявления операции и окончательную закрывающую скобку `}`.

Тело объявления операции либо состоит из реализации по умолчанию, либо списка специализаций.
Реализация по умолчанию может быть указана непосредственно в объявлении, если только реализация специализации тела по умолчанию должна быть явно указана.
В этом случае заметка с характеристиками операций в объявлении полезна для обеспечения автоматического создания компилятором других специализаций на основе реализации по умолчанию. 

Например. 

```qsharp
operation PrepareEntangledPair(here : Qubit, there : Qubit) : Unit 
is Adj + Ctl { // implies the existence of an adjoint, a controlled, and a controlled adjoint specialization
    H(here);
    CNOT(here, there);
}
```

Характеристики операции определяют типы операторов, которые могут быть применены к объявленной операции, и их воздействие. Если операция реализует единое преобразование, можно определить, как работает операция при *аджоинтед* или *управлении*.
Существование этих специализаций можно объявить как часть сигнатуры операции. Затем соответствующая реализация для каждой такой неявно объявленной специализации создается компилятором. В приведенном выше примере компилятор создает смежную, управляемую и управляемую соседнюю специализацию. 

В случае, если реализация не может быть создана компилятором, ее можно указать явно. Такие явные объявления специализации могут либо состоять из подходящей директивы поколения, поясняющей, как должна быть построена определенная специализация, или пользовательской реализации. Код в `PrepareEntangledPair` выше, например, эквивалентен приведенному ниже коду, содержащему явные объявления специализации: 

```qsharp
operation PrepareEntangledPair(here : Qubit, there : Qubit) : Unit {
    body (...) { // default body specialization
        H(here);
        CNOT(here, there);
    }

    adjoint auto; // auto-generate adjoint specialization
    controlled auto; // auto-generate controlled specialization
    controlled adjoint auto; // auto-generate controlled adjoint specialization
}
```
Ключевое слово `auto` указывает, что компилятор должен определить способ создания реализации специализации.
Если компилятор не может создать реализацию для определенной специализации без дальнейших инструкций, например более точной директивы создания, или если можно предоставить более эффективную реализацию, то реализация может быть также определена вручную.

```qsharp
operation PrepareEntangledPair(here : Qubit, there : Qubit) : Unit
is Ctl + Adj {
    body (...) { // default body specialization
        H(here);
        CNOT(here, there);
    }

    controlled (cs, ...) { // user defined implementation for the controlled specialization
        Controlled H(cs, here);
        Controlled X(cs + [here], there);
    }

    adjoint invert; 
    controlled adjoint invert; 
}
```

В приведенном выше примере `adjoint invert;` указывает, что примыкающая специализация должна быть создана путем инвертирования реализации тела, а `controlled adjoint invert;` указывает, что управляемая примыкающая специализация должна быть создана путем инвертирования заданной реализации управляемой специализации.

Чтобы операция поддерживала приложение `Adjoint` и (или) `Controlled` функтор, необходимо `Unit`его возвращаемый тип. 


### <a name="explicit-specialization-declarations"></a>Явные объявления специализации

Операции Q # могут содержать следующие явные объявления специализаций:

- Специализация `body` указывает реализацию операции без применения операторов.
- `adjoint` Специализация определяет реализацию операции с применением `Adjoint` функтор.
- `controlled` Специализация определяет реализацию операции с применением `Controlled` функтор.
- `controlled adjoint`ная Специализация определяет реализацию операции с применением `Adjoint` и `Controlled` операторов.
  Эта специализация также может называться `adjoint controlled`, так как две операторов работы.


Специализация операции состоит из тега специализации (например, `body`или `adjoint`и т. д.), за которым следует одно из следующих значений:

- Явное объявление, как описано ниже.
- Директива, сообщающая компилятору, как создать специализацию, одним из следующих:
  - `intrinsic`, что указывает на то, что специализация предоставляется целевым компьютером.
  - `distribute`, который можно использовать с специализациями `controlled` и `controlled adjoint`.
    При использовании с `controlled`указывает, что компилятор должен вычислить специализацию, применяя `Controlled` ко всем операциям в `body`.
    При использовании с `controlled adjoint`указывает, что компилятор должен вычислить специализацию, применяя `Controlled` ко всем операциям в специализации `adjoint`.
  - `invert`, которое указывает, что компилятор должен вычислять специализацию `adjoint` путем обращения `body`, т. е. Порядок операций и применение прилегающих к каждому из них.
    При использовании с `adjoint controlled`это означает, что компилятор должен вычислить специализацию, инверсию специализации `controlled`.
  - `self`, чтобы указать, что прилегающий специализации совпадает с специализацией `body`.
    Это допустимо для `adjoint` и `adjoint controlled`ных специализаций.
    Для `adjoint controlled``self` подразумевает, что специализация `adjoint controlled` совпадает с специализацией `controlled`.
  - `auto`, чтобы указать, что компилятор должен выбрать соответствующую директиву для применения.
    `auto` не может использоваться для специализации `body`.

Для директив и `auto` все требуются закрывающие `;`с точкой с запятой.
Директива `auto` разрешается в следующую директиву поколения, если предоставлено явное объявление `body`:

- `adjoint` специализация создается в соответствии с директивой `invert`.
- `controlled` специализация создается в соответствии с директивой `distribute`.
- `adjoint controlled`ная специализация создается в соответствии с директивой `invert`, если явное объявление для `controlled` задано, но не одно для `adjoint`, и `distribute` в противном случае.

> [!TIP]   
> Если операция является самопримыкающей, явно укажите либо примыкающую, либо управляемую соседнюю специализацию с помощью директивы поколения `self`, чтобы компилятор использовал эту информацию в целях оптимизации.

Объявление специализации, содержащее определенную пользователем реализацию, состоит из кортежа аргументов, за которым следует блок операторов с кодом Q #, реализующим специализацию.
В списке аргументов `...` используется для представления аргументов, объявленных для операции в целом.
Для `body` и `adjoint`список аргументов всегда должен быть `(...)`. для `controlled` и `adjoint controlled`список аргументов должен быть символом, представляющим массив элемента управления Кубитс, за которым следует `...`, заключенный в круглые скобки; Например, `(controls,...)`.

Если необходимо явно объявить одну или несколько специализаций, кроме тела по умолчанию, то реализация тела по умолчанию должна быть заключена в подходящее объявление специализации:

```qsharp
operation CountOnes(qubits: Qubit[]) : Int {

    body (...) // default body specialization
    {
        mutable n = 0;
        for (qubit in qubits) {
            set n += M(q) == One ? 1 | 0;
        }
        return n;
    }

    ...
```

### <a name="adjoint"></a>Прилегающий

Смежная операция указывает, как реализуется комплексно сопряженное преобразование операции, т. е. как работает операция при выполнении операции "выполнить в обратную".
Допускается указание операции без примыкающего; Например, операции измерения не имеют примыкающих, так как они необратимы.
Операция поддерживает `Adjoint` функтор, если ее объявление содержит неявное или неявное объявление примыкающей специализации.
Объявленная непосредственно управляемая примыкающая специализация подразумевает существование примыкающей специализации. 

Для операций, текст которых содержит циклы повтора, инструкции SET, измерения, операторы Return или вызовы других операций, которые не поддерживают `Adjoint` функтор, автоматическое создание примыкающей специализации, следующей за директивой `invert` или `auto`, невозможно.

### <a name="controlled"></a>Управляет

Управляемая версия операции указывает, как реализуется версия операции, управляемой тактовым генератором, т. е. как работает операция при условии применения условия в состоянии регистра такта.
Более полное описание приведено в разделе [Управление](xref:microsoft.quantum.language.type-model#controlled) .

Допускается указание операции без контролируемой версии; Например, операции измерения не имеют контролируемой версии, так как они не являются управляемыми.
Операция поддерживает `Controlled` функтор только в том случае, если ее объявление содержит неявное или явное объявление управляемой специализации.
Объявленная в явном виде управляемая примыкающая специализация подразумевает наличие управляемой специализации. 

Для операции, текст которой содержит вызовы других операций, не поддерживающих `Controlled` функтор, автоматическое создание управляемой специализации после директивы `distribute` или `auto` невозможно.

### <a name="controlled-adjoint"></a>Управляемый соседний

Управляемая смежная версия операции указывает, как реализуется зависящая от такта версия смежной операции.
Допускается указание операции без управляемой примыкающей версии; Например, операции измерения не имеют контролируемой версии, так как они не являются управляемыми и необратимыми.

Управляемая примыкающая специализация для операции должна существовать только в том случае, если существует и смежная, и управляемая специализация. В этом случае определяется существование управляемой примыкающей специализации, и компилятор создает соответствующую специализацию, если реализация не определена явным образом. 

Для операции, тело которой содержит вызовы других операций, не имеющих управляемой примыкающей версии, автоматическое создание примыкающей специализации после директивы `invert`, `distribute` или `auto` невозможно.


### <a name="examples"></a>Примеры

Объявление операции может быть простым, как показано ниже, которое определяет операцию примитива Паули X:

```qsharp
operation X (qubit : Qubit) : Unit
is Adj + Ctl {
    body intrinsic;
    adjoint self;
}
```

Ниже определяется операция телепортируйтесь.

```qsharp
// Entangle two qubits.
// Assumes that both qubits are in the |0> state.
operation PrepareEntangledPair (q1 : Qubit, q2 : Qubit) : Unit 
is Adj + Ctl {
    H(q2);
    CNOT(q2, q1);
}

// Teleport the quantum state of the source to the target.
// Assumes that the target is in the |0> state.
operation Teleport (source : Qubit, target : Qubit) : Unit {

    // Get a temporary for the Bell pair
    using (ancilla = Qubit())
    {
        // Create a Bell pair between the temporary and the target
        PrepareEntangledPair(target, ancilla);

        // Do the teleportation
        Adjoint PrepareEntangledPair(ancilla, source);

        if (MResetZ(source) == One) {
            X(target);
        }
        if (MResetZ(ancilla) == One) {
            Z(target);
        }
    }
}
```

## <a name="function-declarations"></a>Объявления функций

Функции являются исключительно классическими подпрограммами в Q #.
Каждый исходный файл Q # может определять любое количество функций.

Объявление функции состоит из ключевого слова `function`, за которым следует символ, который является именем функции, кортежем типизированного идентификатора, аннотацией типа, описывающей тип возвращаемого значения функции, и блоком инструкций, описывающим реализацию функции.

Блок инструкций, определяющий функцию, должен быть заключен в `{` и `}` как любой другой блок операторов.

Имена функций должны быть уникальными в пределах пространства имен и не могут конфликтовать с именами операций и типов.
Функции не могут выделить или получить Кубитс или вызвать операции. Частичное применение операций или передача типизированных значений операции прекрасно подходит.

Например,

```qsharp
function DotProduct(a : Double[], b : Double[]) : Double {
    if (Length(a) != Length(b)) {
        fail "Arrays are not compatible";
    }

    mutable accum = 0.0;
    for (i in 0..Length(a)-1) {
        set accum += a[i] * b[i];
    }
    return accum;
}
```


## <a name="internal-declarations"></a>Внутренние объявления

Определяемые пользователем типы, операции и функции также могут быть объявлены как *внутренние*.
Это означает, что доступ к ним можно получить только в проекте Q #, в котором они объявляются.
Если в качестве ссылки используется проект, все его *открытые* (не внутренние) объявления становятся доступными, но попытка использовать внутреннее объявление из другого проекта приведет к ошибке.
Внутренние объявления полезны при написании модульного кода, который может повторно использоваться другими частями проекта, но по-прежнему изменяется, не нарушая работу других проектов, которые могут зависеть от него.

Внутренний определяемый пользователем тип, операция или функция могут быть объявлены просто путем добавления `internal` в начале объявления.
Например,

```qsharp
internal newtype PairOfQubits = (Qubit, Qubit);

internal operation PrepareEntangledPair(pair : PairOfQubits) : Unit 
is Adj + Ctl {
    let (q1, q2) = pair!;
    H(q2);
    CNOT(q2, q1);
}

internal function DotProduct(a : Double[], b : Double[]) : Double {
    ...
}
```

> [!WARNING]
> Внутренние определяемые пользователем типы могут использоваться только в сигнатурах или базовых типах, если соответствующий вызываемый или определяемый пользователем тип также является внутренним.
> Например, если имеется определяемый пользователем тип `InternalOptions`, объявленный с ключевым словом `internal`, то следующие объявления приведут к ошибкам:
>
> ```qsharp
> // Error: Can't use InternalOptions as an output type of a public function.
> function DefaultInternalOptions() : InternalOptions { ... }
>
> // Error: Can't use InternalOptions as an item in a public user-defined type.
> newtype ExtendedOptions = (Internal : InternalOptions);
> ```
