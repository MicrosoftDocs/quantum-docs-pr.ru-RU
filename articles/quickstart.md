---
title: Исследование запутанности с использованием Q#
description: Узнайте о том, как написать квантовую программу на Q#. Разработка приложения, которое использует состояние Белла, с помощью Microsoft Quantum Development Kit
author: natke
ms.author: nakersha
ms.date: 10/07/2019
ms.topic: tutorial
uid: microsoft.quantum.write-program
ms.openlocfilehash: 7836e39227fa2282c6e2faa039f6e625103d5403
ms.sourcegitcommit: 2317473fdf2b80de58db0f43b9fcfb57f56aefff
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/15/2020
ms.locfileid: "83426844"
---
# <a name="tutorial-explore-entanglement-with-q"></a>Руководство по Исследование запутанности с использованием Q\#

В этом руководстве показано, как создать программу на Q#, которая управляет кубитами и измеряет их, демонстрируя эффекты суперпозиции и запутанности.
Следуя этим инструкциям, вы установите QDK, напишете программу и выполните ее на квантовом симуляторе.  

В результате у вас получится приложение Bell, которое демонстрирует квантовую запутанность.
Имя Bell — это отсылка к состоянию Белла, которое обозначает особые квантовые состояния двух кубитов с простейшими примерами эффектов суперпозиции и квантовой запутанности.

## <a name="pre-requisites"></a>Предварительные требования

Если вы готовы писать код, выполните следующие действия, прежде чем продолжать: 

* [Установите](xref:microsoft.quantum.install) Microsoft Quantum Development Kit для выбранного вами языка и среды разработки.
* Если эта платформа уже установлена, убедитесь, что она [обновлена](xref:microsoft.quantum.update) до последней версии.

Вы также можете просто прочитать это руководство, не устанавливая QDK, чтобы получить общие сведения о языке программирования Q# и важнейших концепциях квантовых вычислений.

## <a name="demonstrating-qubit-behavior-with-q"></a>Демонстрация поведения кубитов с использованием Q#

Давайте вспомним простейшее [определение кубита](xref:microsoft.quantum.overview.understanding).  В классическом бите хранится одно двоичное значение (0 или 1), а кубит может находиться в состоянии **суперпозиции** значений 0 и 1 одновременно.  В теории кубит можно рассматривать как направление в пространстве (вектор).  Кубит может содержать любое из возможных направлений. Два **классических состояния** в этой модели соответствуют двум направлениям: 100 % вероятности получить при измерении 0 и 100 % вероятности получить 1.  Такое представление более строго визуализируется в виде [сферы Блоха](/quantum/concepts/the-qubit#visualizing-qubits-and-transformations-using-the-bloch-sphere).


Измерение кубита возвращает двоичный результат и изменяет состояние кубита. Результатом измерения будет классическое двоичное значение: 0 или 1.  При этом кубит переходит из состояния суперпозиции в одно из классических состояний.  С этого момента все повторные измерения будут возвращать тот же двоичный результат, если не выполняются дополнительные промежуточные операции.  

Несколько кубитов могут находиться в состоянии **запутанности**. При измерении одного из запутанных кубитов мы получаем сведения о состоянии второго.

Теперь мы готовы продемонстрировать, как это поведение моделируется с использованием Q#.  Вы начнете работу с самой простой программы и постепенно доработаете ее для демонстрации квантовой суперпозиции и квантовой запутанности.

## <a name="setup"></a>Настройка

Приложения в Microsoft Quantum Development Kit состоят из двух частей:

1. Один или несколько квантовых алгоритмов реализуются на квантовом языке программирования Q#.
1. Основная программа на любом традиционном языке программирования, например Python или C#, используется в качестве основной точки входа и вызывает операции Q# для применения квантовых алгоритмов.

#### <a name="python"></a>[Python](#tab/tabid-python)

1. Выберите расположение для приложения.

1. Создайте файл с именем `Bell.qs`. Этот файл будет содержать код Q#.

1. Создайте файл с именем `host.py`. Этот файл будет содержать основной код Python.

#### <a name="c-command-line"></a>[Командная строка C#](#tab/tabid-csharp)

1. Создайте проект Q#.

    ```bash
    dotnet new console -lang Q# --output Bell
    cd Bell
    ```

    Вы увидите файл `.csproj`, файл Q# с именем `Operations.qs` и файл основной программы с именем `Driver.cs`.

1. Переименование файла Q#

    ```bash
    mv Operation.qs Bell.qs
    ```

#### <a name="visual-studio"></a>[Visual Studio](#tab/tabid-vs2019)

1. Создание нового проекта

   * Запустите Visual Studio
   * Откройте меню **Файл** и щелкните **Создать** -> **Проект**.
   * В обозревателе шаблонов проектов введите `Q#` в поле поиска и выберите шаблон `Q# Application`.
   * Присвойте проекту имя `Bell`.

1. Переименование файла Q#

   * Перейдите к **обозревателю решений**.
   * Щелкните правой кнопкой мыши файл `Operations.qs`.
   * Переименуйте его в `Bell.qs`.

* * *

## <a name="write-a-q-operation"></a>Создание операции Q#

Мы намерены подготовить два кубита в особом квантовом состоянии, на примере которых мы продемонстрируем работу с кубитами в Q#, изменяя их состояние и применяя эффекты суперпозиции и запутанности. Мы создадим эту систему постепенно, описывая функции состояний кубитов, операций и измерений.

**Обзор.**  В первом примере кода мы покажем, как работать с кубитами в Q#.  Мы вводим две операции `M` и `X`, которые преобразуют состояние кубита. 

В этом фрагменте кода определена операция `Set`, которая принимает в качестве параметров кубит и значение состояния `desired`, в котором должен находиться этот кубит.  Операция `Set` выполняет измерение кубита с помощью операции `M`.  В Q# измерение кубита всегда возвращает `Zero` или `One`.  Если значение, полученное в результате измерения, не совпадает с желаемым значением, операция Set инвертирует кубит. При этом выполняется операция `X`, которая изменяет состояние кубит на обратное, т. е. с противоположными вероятностями измерения значений `Zero` и `One`.  Чтобы продемонстрировать выполнение операции `Set`, после этого добавляется операция `TestBellState`.  Эта операция принимает в качестве входных данных `Zero` или `One`, вызывает для этого объекта операцию `Set` заданное количество раз, а также подсчитывает количество значений `Zero` и значений `One` в выполненных измерениях кубита. Разумеется, в нашей первой модели операции `TestBellState` мы ожидаем получить результат `Zero` для всех измерений кубита, определенного с помощью операции `Zero`, и результат `One` для всех измерений кубита, определенного с помощью операции `One`.  Далее мы добавим в `TestBellState` код для демонстрации суперпозиции и запутанности.


### <a name="q-operation-code"></a>Код операции Q#

1. Замените содержимое файла Bell.qs следующим кодом:

    ```qsharp
    namespace Quantum.Bell {
        open Microsoft.Quantum.Intrinsic;
        open Microsoft.Quantum.Canon;

        operation Set(desired : Result, q1 : Qubit) : Unit {
            if (desired != M(q1)) {
                X(q1);
            }
        }
    }
    ```

    Теперь вы можете вызвать эту операцию, чтобы установить кубит в классическое состояние, которое в 100 % случаев возвращает одно из значений: `Zero` или `One`.  Константы `Zero` и `One` представляют все возможные результаты измерения кубита.

    Операция `Set` измеряет кубит.
    Если кубит находится в нужном состоянии, `Set` больше не влияет на него, в противном случае мы выполняем операцию `X`, чтобы изменить состояние кубита на требуемое.

### <a name="about-q-operations"></a>Сведения об операциях Q#

Операцией в Q# называется квантовая подпрограмма. Такая вызываемая подпрограмма содержит квантовые операции.

Аргументы операции задаются в виде кортежа в круглых скобках.

Возвращаемый тип операции задается после двоеточия. В нашем примере операция `Set` ничего не возвращает, поэтому для нее указан возвращаемый тип `Unit`. Эта конструкция Q# эквивалентна `unit` в F# и похожа на `void` в C# или пустой кортеж (`Tuple[()]`) в Python.

В первой операции на Q# вы применили две квантовые операции:

* операция [M](xref:microsoft.quantum.intrinsic.m) измеряет состояние кубита;
* операция [X](xref:microsoft.quantum.intrinsic.x) инвертирует состояние кубита.

Квантовая операция преобразует состояние кубита. Иногда вместо термина "операция" применяют термин "вентиль", по аналогии с классическими логическими вентилями. Это связано с тем, что на ранних этапах квантовых вычислений все алгоритмы были только теоретическими конструкциями и оформлялись в виде схем, похожих на схемы электрических контуров для классических вычислений.

### <a name="add-q-test-code"></a>Добавление тестового кода Q#

1. В файле `Bell.qs` добавьте следующую операцию в пространство имен, сразу после операции `Set`:

    ```qsharp
    operation TestBellState(count : Int, initial : Result) : (Int, Int) {

        mutable numOnes = 0;
        using (qubit = Qubit()) {

            for (test in 1..count) {
                Set(initial, qubit);
                let res = M(qubit);

                // Count the number of ones we saw:
                if (res == One) {
                    set numOnes += 1;
                }
            }
            Set(Zero, qubit);
        }

        // Return number of times we saw a |0> and number of times we saw a |1>
        return (count-numOnes, numOnes);
    }
    ```

    Эта операция (`TestBellState`) выполняет `count` раз следующий цикл: устанавливает для кубита указанное значение `initial` и измеряет результат (`M`). Она собирает статистические данные о количестве нулей и единиц в измерениях, а затем возвращает эти данные вызывающему объекту. Она выполняет еще одну важную операцию — восстановление известного состояния кубита (`Zero`) перед завершением работы, чтобы другие операции могли получить этот кубит в известном состоянии. Это поведение диктуется инструкцией `using`.

### <a name="about-variables-in-q"></a>Сведения о переменных в Q#

По умолчанию все переменные в Q# являются неизменяемыми, т. е. их значение нельзя изменить после привязки. Ключевое слово `let` обозначает привязку неизменяемой переменной. Аргументы операций всегда остаются неизменяемыми.

Если же вам нужна переменная, значение которой может меняться (в нашем примере это `numOnes`), объявите такую переменную с ключевым словом `mutable`. Значение изменяемой переменной можно изменить с помощью инструкции `set`.

Тип переменной в обоих случаях выводится компилятором. В Q# не требуется объявлять тип для переменных.

### <a name="about-using-statements-in-q"></a>Сведения об инструкциях `using` в Q#

В Q# есть уникальная инструкция `using`. Она выделяет кубиты для использования в блоке кода. Все кубиты в Q# выделяются и освобождаются динамически, а не закрепляются как фиксированные ресурсы на весь период работы сложного алгоритма. Оператор `using` выделяет набор кубитов в начале блока и освобождает их в конце блока.

## <a name="create-the-host-application-code"></a>Создание кода для основного приложения

#### <a name="python"></a>[Python](#tab/tabid-python)

1. Откройте файл `host.py` и добавьте в него следующий код.

    ```python
    import qsharp

    from qsharp import Result
    from Quantum.Bell import TestBellState

    initials = (Result.Zero, Result.One)

    for i in initials:
      res = TestBellState.simulate(count=1000, initial=i)
      (num_zeros, num_ones) = res
      print(f'Init:{i: <4} 0s={num_zeros: <4} 1s={num_ones: <4}')
    ```

#### <a name="c"></a>[C#](#tab/tabid-csharp)

1. Замените содержимое файла `Driver.cs` приведенным ниже кодом.

    ```csharp
    using System;

    using Microsoft.Quantum.Simulation.Core;
    using Microsoft.Quantum.Simulation.Simulators;

    namespace Quantum.Bell
    {
        class Driver
        {
            static void Main(string[] args)
            {
                using (var qsim = new QuantumSimulator())
                {
                    // Try initial values
                    Result[] initials = new Result[] { Result.Zero, Result.One };
                    foreach (Result initial in initials)
                    {
                        var res = TestBellState.Run(qsim, 1000, initial).Result;
                        var (numZeros, numOnes) = res;
                        System.Console.WriteLine(
                            $"Init:{initial,-4} 0s={numZeros,-4} 1s={numOnes,-4}");
                    }
                }

                System.Console.WriteLine("Press any key to continue...");
                Console.ReadKey();
            }
        }
    }
    ```

#### [](#tab/tabid-vs2019)

* * *

### <a name="about-the-host-application-code"></a>Сведения о коде основного приложения

#### <a name="python"></a>[Python](#tab/tabid-python)

Основное приложение на языке Python состоит из трех частей, которые выполняют следующие действия:

* Вычисление всех аргументов для квантового алгоритма. В нашем примере `count` получает фиксированное значение 1000, а `initial` содержит начальное состояние кубита.
* Выполняет квантовый алгоритм, вызывая метод `simulate()` из импортированной операции Q#.
* Обработка результата операции. В нашем примере результат операции сохраняется в `res`. Результатом здесь является кортеж с информацией о количестве нулей (`num_zeros`) и единиц (`num_ones`), полученных симулятором при измерениях. Мы разбираем этот кортеж на два поля и выводим эти результаты.

#### <a name="c"></a>[C#](#tab/tabid-csharp)

Основное приложение на языке C# состоит из четырех частей, которые выполняют следующие действия:

* Создание квантового симулятора. В нашем примере это `qsim`.
* Вычисление всех аргументов для квантового алгоритма. В нашем примере `count` получает фиксированное значение 1000, а `initial` содержит начальное состояние кубита.
* Выполнение квантового алгоритма. Для каждой операции Q# создается класс C# с тем же именем. Этот класс содержит метод `Run`, который **асинхронно** выполняет соответствующую операцию. Асинхронное выполнение имитирует асинхронный процесс на реальном оборудовании. Так как метод `Run` является асинхронным, мы получаем свойство `Result`. Выполнение блокируется до тех пор, пока задача не завершится, и результат возвращается уже в синхронном режиме.
* Обработка результата операции. В нашем примере результат операции сохраняется в `res`. Результатом здесь является кортеж с информацией о количестве нулей (`numZeros`) и единиц (`numOnes`), полученных симулятором при измерениях. Он возвращается в C# с типом ValueTuple. Мы разбираем этот кортеж на два поля, выводим эти результаты и ожидаем нажатия клавиши.

#### [](#tab/tabid-vs2019)

* * *

## <a name="build-and-run"></a>Сборка и запуск

#### <a name="python"></a>[Python](#tab/tabid-python)

1. Выполните следующую команду в окне терминала:

    ```
    python host.py
    ```

    Эта команда запускает основное приложение, которое имитирует операцию Q#.

Результаты должны выглядеть так:

```Output
Init:0    0s=1000 1s=0   
Init:1    0s=0    1s=1000
```

#### <a name="command-line--visual-studio-code"></a>[Командная строка и Visual Studio Code](#tab/tabid-csharp)

1. В окне терминала выполните следующую команду:

    ```bash
    dotnet run
    ```

    Эта команда автоматически скачает все необходимые пакеты, скомпилирует приложение и запустит его в командной строке.

1. Вы также можете нажать клавишу **F1**, чтобы открыть палитру команд, и выбрать команду **Отладка: запустить без отладки.**
Возможно, вам будет предложено создать новый файл ``launch.json`` с описанием того, как запускать программу.
Используемый по умолчанию вариант ``launch.json`` хорошо подходит для большинства приложений.

Результаты должны выглядеть так:

```Output
Init:Zero 0s=1000 1s=0
Init:One  0s=0    1s=1000
Press any key to continue...
```

#### <a name="visual-studio"></a>[Visual Studio](#tab/tabid-vs2019)

1. Просто нажмите `F5` — программа автоматически скомпилируется и запустится!

Результаты должны выглядеть так:

```Output
Init:Zero 0s=1000 1s=0
Init:One  0s=0    1s=1000
Press any key to continue...
```

Программа завершает работу после нажатия любой клавиши.

* * *

## <a name="prepare-superposition"></a>Подготовка суперпозиции

**Обзор** Теперь давайте посмотрим, как Q# выражает методы создания суперпозиции для кубитов.  Как вы помните, кубит может находиться в суперпозиции значений 0 и 1.  Для этого мы будем использовать операцию `Hadamard`. Если кубит находится в одном из классических состояний (т. е. его измерение возвращает всегда `Zero` или `One`), операция `Hadamard` или `H` переведет этот кубит в такое состояние, в котором измерение с вероятностью 50 % вернет одно из значений: `Zero` или `One`.  В теории можно рассматривать состояние кубита как промежуточное между `Zero` и `One`.  Итак, мы смоделировали операцию `TestBellState`, и теперь в наших результатах после измерения будет примерно равное количество значений `Zero` и `One`.  

Для начала мы попробуем инвертировать кубит (если он находится в состоянии `Zero`, он перейдет в состояние `One`, и наоборот). Для этого мы выполним операцию `X` до того, как измерять кубит в `TestBellState`:

```qsharp
X(qubit);
let res = M(qubit);
```

Мы увидим, что возвращаемые после нажатия `F5` результаты теперь инвертированы:

```Output
Init:Zero 0s=0    1s=1000
Init:One  0s=1000 1s=0
```

Но все эти действия пока не отличаются от классических вычислений. А мы хотим получить квантовый результат. Нам нужно просто заменить операцию `X` в предыдущем коде операцией `H` (вентиль Адамара). Теперь мы инвертируем кубит не полностью (с 0 на 1), а в промежуточное значение. Замененные строки в `TestBellState` теперь выглядят так:

```qsharp
H(qubit);
let res = M(qubit);
```

И результат сразу становится более интересным:

```Output
Init:Zero 0s=484  1s=516
Init:One  0s=522  1s=478
```

При каждом измерении мы получаем классическое значение, но наш кубит находится в промежуточном состоянии (между 0 и 1), поэтому мы статистически получаем в половине случаев значение 0, а в другой половине — 1. Это и есть __суперпозиция__, которая дает первое реальное представление о квантовых состояниях.

## <a name="prepare-entanglement"></a>Подготовка запутанности

**Обзор.**  Теперь мы покажем, как выразить в Q# запутанность кубитов.  Прежде всего мы присвоим кубиту начальное состояние, а затем с помощью операции `H` переместим его в состояние суперпозиции.  Далее, прежде чем измерять первый кубит, мы применим новую операцию контролируемого отрицания `CNOT`.  В результате выполнения этой операции второй кубит инвертируется, только если первый кубит имеет значение `One`.  Теперь эти два кубита являются запутанными.  Статистика значений для первого кубита не изменилась (распределение 50/50 для значений `Zero` и `One` после измерения), но при измерении второго кубита он теперь __всегда__ возвращает такое же состояние, как у первого кубита. Вентиль `CNOT` добавил запутанность кубитов, и любые изменения с одним из них теперь влияют и на другой. Если выполнять измерения в обратном порядке (сначала второй кубит, потом первый), результат будет таким же. Первое измерение дает случайный результат, а второе всегда дублирует то же значение, которое мы получили в первом.

Для этого мы прежде всего выделим в `TestBellState` два кубита вместо одного:

```qsharp
using ((q0, q1) = (Qubit(), Qubit())) {
```

Это позволяет добавить новую операцию (`CNOT`) перед измерением (`M`) в `TestBellState`:

```qsharp
Set(initial, q0);
Set(Zero, q1);

H(q0);
CNOT(q0, q1);
let res = M(q0);
```

Также мы добавили операцию `Set` для инициализации первого кубита, чтобы при запуске алгоритма он всегда находился в состоянии `Zero`.

Также нам нужно сбросить второй кубит перед освобождением.

```qsharp
Set(Zero, q0);
Set(Zero, q1);
```

Полностью код метода теперь выглядит так:

```qsharp
    operation TestBellState(count : Int, initial : Result) : (Int, Int) {

        mutable numOnes = 0;
        using ((q0, q1) = (Qubit(), Qubit())) {
            for (test in 1..count) {
                Set (initial, q0);
                Set (Zero, q1);

                H(q0);
                CNOT(q0,q1);
                let res = M(q0);

                // Count the number of ones we saw:
                if (res == One) {
                    set numOnes += 1;
                }
            }
            
            Set(Zero, q0);
            Set(Zero, q1);
        }

        // Return number of times we saw a |0> and number of times we saw a |1>
        return (count-numOnes, numOnes);
    }
```

Выполнив этот код, мы получим такое же распределение результатов (50/50), как и раньше. Но нам нужно не это, а реакция второго кубита на измерения состояния первого кубита. Эту статистику мы будем собирать в новой версии операции `TestBellState`:

```qsharp
    operation TestBellState(count : Int, initial : Result) : (Int, Int, Int) {
        mutable numOnes = 0;
        mutable agree = 0;
        using ((q0, q1) = (Qubit(), Qubit())) {
            for (test in 1..count) {
                Set(initial, q0);
                Set(Zero, q1);

                H(q0);
                CNOT(q0, q1);
                let res = M(q0);

                if (M(q1) == res) {
                    set agree += 1;
                }

                // Count the number of ones we saw:
                if (res == One) {
                    set numOnes += 1;
                }
            }
            
            Set(Zero, q0);
            Set(Zero, q1);
        }

        // Return number of times we saw a |0> and number of times we saw a |1>
        return (count-numOnes, numOnes, agree);
    }
```

Новое возвращаемое значение (`agree`) отслеживает количество циклов, в которых измеренные состояния первого и второго кубитов совпадают. Также мы внесем соответствующие изменения в основное приложение:

#### <a name="python"></a>[Python](#tab/tabid-python)

```python
import qsharp

from qsharp import Result
from Quantum.Bell import TestBellState

initials = {Result.Zero, Result.One} 

for i in initials:
    res = TestBellState.simulate(count=1000, initial=i)
    (num_zeros, num_ones, agree) = res
    print(f'Init:{i: <4} 0s={num_zeros: <4} 1s={num_ones: <4} agree={agree: <4}')
```

#### <a name="c"></a>[C#](#tab/tabid-csharp)

```csharp
            using (var qsim = new QuantumSimulator())
            {
                // Try initial values
                Result[] initials = new Result[] { Result.Zero, Result.One };
                foreach (Result initial in initials)
                {
                    var res = TestBellState.Run(qsim, 1000, initial).Result;
                    var (numZeros, numOnes, agree) = res;
                    System.Console.WriteLine(
                        $"Init:{initial,-4} 0s={numZeros,-4} 1s={numOnes,-4} agree={agree,-4}");
                }
            }
            
            System.Console.WriteLine("Press any key to continue...");
            Console.ReadKey();
```

#### [](#tab/tabid-vs2019)

* * *

Выполнив этот проект, мы получим удивительный результат:

```Output
Init:Zero 0s=499  1s=501  agree=1000
Init:One  0s=490  1s=510  agree=1000
```

Как мы уже писали выше, статистика значений для первого кубита не изменилась (распределение 50/50 для значений 0 и 1), но при измерении второго кубита он теперь __всегда__ возвращает такое же состояние, как у первого кубита. Это и есть эффект запутанности.

Поздравляем, вы создали первую квантовую программу!

## <a name="whats-next"></a>Дальнейшие действия

В руководстве по [алгоритму поиска Гровера](xref:microsoft.quantum.quickstarts.search) показано, как создать и применить алгоритм Гровера, один из самых популярных квантовых алгоритмов. Там вы найдете хороший пример программы на Q# для решения реальных проблем с помощью квантовых вычислений.  

В руководстве по [началу работы с Microsoft Quantum Development Kit](xref:microsoft.quantum.welcome) вы найдете дополнительные рекомендации по изучению Q# и квантового программирования.

