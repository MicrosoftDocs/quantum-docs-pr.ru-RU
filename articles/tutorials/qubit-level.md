---
title: 'Создание и имитация программ уровня кубит в Q #'
description: Пошаговое руководство по написанию и моделированию тактовой программы, работающей на уровне отдельного кубита
author: gillenhaalb
ms.author: a-gibec@microsoft.com
ms.date: 10/06/2019
uid: microsoft.quantum.circuit-tutorial
ms.topic: tutorial
ms.openlocfilehash: e7ebdec4cd1aa201030d82759a3aa56473b26417
ms.sourcegitcommit: 0181e7c9e98f9af30ea32d3cd8e7e5e30257a4dc
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/23/2020
ms.locfileid: "85275347"
---
# <a name="tutorial-write-and-simulate-qubit-level-programs-in-q"></a>Учебник. Создание и имитация программ уровня кубит в Q\#

Добро пожаловать в учебник по созданию и моделированию основной тактовой программы, которая работает с отдельными Кубитс. 

Несмотря на то, что Q # был создан в основном как высокоуровневый язык программирования для крупномасштабных тактов, его можно легко использовать для изучения более низкого уровня тактовых программ: прямой адресации конкретных Кубитс.
Гибкость Q # позволяет пользователям подходить к тактовым системам любого такого уровня абстракции, и в этом учебнике мы подробно рассмотрим Кубитс.
В частности, мы рассмотрим внешний вид [преобразования Фурье в тактовой](https://en.wikipedia.org/wiki/Quantum_Fourier_transform)области — подпрограммы, которая является неотъемлемой для многих более крупных алгоритмов такта.

Обратите внимание, что это низкоуровневое представление обработки данных о такте часто описывается в терминах «[тактовые цепи](xref:microsoft.quantum.concepts.circuits)», которые представляют последовательные приложения шлюзов для конкретных Кубитс системы.

Таким же кубит операции, которые последовательно применяются, можно легко представить в виде «схемы цепи».
В нашем случае мы определим операцию Q # для выполнения всего преобразования Фурье с тремя кубитами, которое в качестве цепи имеет следующее представление:

<br/>
<img src="../media/qft_full.PNG" alt="Three qubit quantum Fourier transform circuit diagram" width="600">

## <a name="prerequisites"></a>Предварительные условия

* [Установите](xref:microsoft.quantum.install) пакет средств разработки тактов, используя предпочитаемый язык и среду разработки.
* Если эта платформа уже установлена, убедитесь, что она [обновлена](xref:microsoft.quantum.update) до последней версии.


## <a name="in-this-tutorial-youll-learn-how-to"></a>Из этого руководства вы узнаете, как выполнять следующие задачи:

> [!div class="checklist"]
> * Определение операций такта в Q #
> * Вызов Q # операций непосредственно из командной строки или с помощью классического ведущего приложения
> * Моделирование операции-такта от выделения кубит до выходных данных измерения
> * Обратите внимание на то, как имитация вавефунктион в тактовой системе развивается во всей операции.

Выполнение тактовой программы с помощью пакета Microsoft тактов Development Kit обычно состоит из двух частей:
1. Сама программа, которая реализуется с помощью языка программирования на основе такта Q #, а затем вызывается для запуска на тактовой или имитаторной системе. Они состоят из 
    - Q # операции: подпрограммы, действующие в тактовые регистры и 
    - Функции Q #: классические подпрограммы, используемые в алгоритме такта.
2. Точка входа, используемая для вызова тактовой программы и указания целевого компьютера, на котором она должна быть запущена.
    Это можно сделать непосредственно из командной строки или с помощью основной программы, написанной на основе классического языка программирования, такого как Python или C#.
    Этот учебник содержит инструкции для любого предпочтительного метода.

## <a name="allocate-qubits-and-define-quantum-operations"></a>Выделение Кубитс и определение операций такта

Первая часть этого руководства состоит из определения операции Q # `Perform3qubitQFT` , которая выполняет преобразование Фурье в тактовую операцию на трех Кубитс. 

Кроме того, мы будем использовать [`DumpMachine`](xref:microsoft.quantum.diagnostics.dumpmachine) функцию, чтобы увидеть, как имитация вавефунктиона нашей кубит системы в рамках всей операции.

Первым шагом является создание проекта Q # и файла.
Действия для этого зависят от среды, которая будет использоваться для вызова программы. подробные сведения можно найти в соответствующих [руководствах по установке](xref:microsoft.quantum.install).

Мы рассмотрим компоненты файла пошаговым образом, но код также доступен в полном блоке ниже.

### <a name="namespaces-to-access-other-q-operations"></a>Пространства имен для доступа к другим операциям Q #
Внутри файла сначала определяется пространство имен, доступ к `NamespaceQFT` которому будет осуществляться компилятором.
Чтобы наша операция использовала существующие операции Q #, мы откроем соответствующие `Microsoft.Quantum.<>` пространства имен.

```qsharp
namespace NamespaceQFT {
    open Microsoft.Quantum.Intrinsic;
    open Microsoft.Quantum.Diagnostics;
    open Microsoft.Quantum.Math;
    open Microsoft.Quantum.Arrays;

    // operations go here
}
```

### <a name="define-operations-with-arguments-and-returns"></a>Определение операций с аргументами и возвраты
Далее мы определим `Perform3qubitQFT` операцию:

```qsharp
    operation Perform3qubitQFT() : Unit {
        // do stuff
    }
```

Пока операция не принимает аргументов и не возвращает ничего,---в этом случае мы записываем, что он возвращает `Unit` объект, который в `void` C# или пустой кортеж, `Tuple[()]` в Python.
Позже мы изменим его, чтобы возвращался массив результатов измерения, после чего точка `Unit` будет заменена `Result[]` . 

### <a name="allocate-qubits-with-using"></a>Выделить Кубитс с помощью`using`
В рамках операции Q # мы сначала выделили регистр из трех Кубитс с помощью `using` инструкции:

```qsharp
        using (qs = Qubit[3]) {

            Message("Initial state |000>:");
            DumpMachine();

        }
```

При использовании `using` Кубитс автоматически выделяются в состоянии $ \кет {0} $. Мы можем проверить это с помощью [`Message(<string>)`](xref:microsoft.quantum.intrinsic.message) и [`DumpMachine()`](xref:microsoft.quantum.diagnostics.dumpmachine) , чтобы вывести строку и текущее состояние системы на консоль.

> [!NOTE]
> `Message(<string>)`Функции и `DumpMachine()` (от [`Microsoft.Quantum.Intrinsic`](xref:microsoft.quantum.intrinsic) и [`Microsoft.Quantum.Diagnostics`](xref:microsoft.quantum.diagnostics) соответственно) печатаются непосредственно на консоли. Как и в реальных вычислениях тактов, Q # не позволяет нам напрямую обращаться к кубит состояниям.
> Однако, как `DumpMachine` выводит текущее состояние целевого компьютера, оно может предоставить ценную информацию для отладки и обучения при использовании в сочетании с симулятором полного состояния.


### <a name="applying-single-qubit-and-controlled-gates"></a>Применение кубит и контролируемых шлюзов

Далее мы применяем шлюз, который состоит из самой операции.
Q # уже содержит много базовых шлюзов в качестве операций в [`Microsoft.Quantum.Intrinsic`](xref:microsoft.quantum.intrinsic) пространстве имен, и они не являются исключением. 

В операции Q # инструкции, вызывающие вызываемые, будут выполняться в последовательном порядке.
Следовательно, первый применяемый шлюз — это [`H`](xref:microsoft.quantum.intrinsic.h) (хадамард) к первому кубит:

<br/>
<img src="../media/qft_firstH.PNG" alt="Circuit diagram for three qubit QFT through first Hadamard" width="120">

Чтобы применить операцию к определенному кубит из регистра (т. е. отдельного объекта `Qubit` из массива `Qubit[]` ), мы используем стандартную нотацию индекса.
Таким образом, применение [`H`](xref:microsoft.quantum.intrinsic.h) к первому кубиту регистра `qs` имеет вид:

```qsharp
            H(qs[0]);
```

Помимо применения `H` шлюза (хадамард) к отдельным Кубитс, цепь Кфт состоит в основном из контролируемых [`R1`](xref:microsoft.quantum.intrinsic.r1) поворотов.
`R1(θ, <qubit>)`Операция в целом оставляет компонент $ \кет {0} $ кубит без изменений, одновременно применяя поворот $e ^ {и\сета} $ к {1} компоненту $ \кет $.

#### <a name="controlled-operations"></a>Управляемые операции

Q # делает несложным условие выполнения операции в одном или нескольких кубитсах элементов управления.
В целом, мы просто предваряем вызов `Controlled` , а аргументы операции изменяются следующим образом:

 `Op(<normal args>)`$ \то $ `Controlled Op([<control qubits>], (<normal args>))` .

Обратите внимание, что элемент управления Кубитс должен быть предоставлен как массив, даже если он является одним кубит.

После этого `H` мы видим, что следующие шлюзы являются `R1` шлюзами, действующими на первый кубит (и контролируются вторым/третьим):

<br/>
<img src="../media/qft_firstqubit.PNG" alt="Circuit diagram for three qubit QFT through first qubit" width="310">

Мы вызываем их с помощью

```qsharp
            Controlled R1([qs[1]], (PI()/2.0, qs[0]));
            Controlled R1([qs[2]], (PI()/4.0, qs[0]));
```

Обратите внимание, что мы используем [`PI()`](xref:microsoft.quantum.math.pi) функцию из [`Microsoft.Quantum.Math`](xref:microsoft.quantum.math) пространства имен для определения поворотов с точки зрения PI радиан.
Кроме того, мы разделены на `Double` (например, `2.0` ), так как деление на целое число `2` вызовет ошибку типа. 

> [!TIP]
> `R1(π/2)`и `R1(π/4)` эквивалентны `S` `T` операциям и (также в `Microsoft.Quantum.Intrinsic` ).


После применения соответствующих `H` операций и управляемых поворотов ко второму и третьему Кубитс:

```qsharp
            //second qubit:
            H(qs[1]);
            Controlled R1([qs[2]], (PI()/2.0, qs[1]));

            //third qubit:
            H(qs[2]);
```

[`SWAP`](xref:microsoft.quantum.intrinsic.swap)для завершения канала необходимо применить только шлюз:

```qsharp
            SWAP(qs[2], qs[0]);
```

Это необходимо потому, что природа преобразования Фурье в тактовой области выводит Кубитс в обратную последовательность, поэтому замена позволяет легко интегрировать подпрограммы в большие алгоритмы.

Поэтому мы завершили запись операций кубит-уровня в процессе преобразования Фурье в операцию Q #:

<img src="../media/qft_full.PNG" alt="Three qubit quantum Fourier transform circuit diagram" width="600">

Тем не менее, мы не можем вызвать его еще раз в день.
Наш Кубитс находился в штате $ \кет {0} $, когда мы выделили их, и во многом похоже на то, что в Q # Мы должны оставить вещи так же, как мы нашли их (или лучше!).

### <a name="deallocate-qubits"></a>Освобождение Кубитс

Мы [`DumpMachine()`](xref:microsoft.quantum.diagnostics.dumpmachine) опять вызываем состояние после операции и, наконец, применяемся [`ResetAll`](xref:microsoft.quantum.intrinsic.resetall) к регистру кубит для сброса Кубитс в $ \кет {0} $ перед выполнением операции:

```qsharp
            Message("After:");
            DumpMachine();

            ResetAll(qs);
```

Обязательно, чтобы все освобожденные Кубитс были явно заданы как $ \кет {0} $ — это базовая функция Q #, так как она позволяет другим операциям точно узнавать свое состояние, когда они начинают использовать те же Кубитс (неограниченный ресурс).
Кроме того, это гарантирует, что они не будут запутанными с другими Кубитс в системе.
Если сброс не выполняется в конце `using` блока выделения, возникнет ошибка времени выполнения.

Полный файл Q # теперь должен выглядеть следующим образом:

```qsharp
namespace NamespaceQFT {
    open Microsoft.Quantum.Intrinsic;
    open Microsoft.Quantum.Diagnostics;
    open Microsoft.Quantum.Math;
    open Microsoft.Quantum.Arrays;

    operation Perform3qubitQFT() : Unit {

        using (qs = Qubit[3]) {

            Message("Initial state |000>:");
            DumpMachine();

            //QFT:
            //first qubit:
            H(qs[0]);
            Controlled R1([qs[1]], (PI()/2.0, qs[0]));
            Controlled R1([qs[2]], (PI()/4.0, qs[0]));

            //second qubit:
            H(qs[1]);
            Controlled R1([qs[2]], (PI()/2.0, qs[1]));

            //third qubit:
            H(qs[2]);

            SWAP(qs[2], qs[0]);

            Message("After:");
            DumpMachine();

            ResetAll(qs);
        }
    }
}
```


После завершения работы с файлом Q # и операцией, наша тактовая программа готова к вызову и имитации.

## <a name="execute-the-program"></a>Выполнение программы

Определив операцию Q # в `.qs` файле, теперь нужно вызвать эту операцию и просмотреть все возвращенные классические данные.
Пока что ничего не возвращается (Помните, что наша операция, определенная выше, возвращает `Unit` ), но когда позже мы изменим операцию Q #, чтобы возвращался массив результатов измерения ( `Result[]` ), мы будем решать это.

Несмотря на то, что программа Q # повсеместно используется в средах, используемых для ее вызова, способ ее выполнения будет зависеть. Таким образом, просто следуйте инструкциям на вкладке, соответствующей вашей программе установки: работа из приложения командной строки Q # или использование основной программы в Python или C#.

#### <a name="command-line"></a>[Командная строка](#tab/tabid-cmdline)

Для выполнения программы Q # из командной строки требуется небольшое изменение в файле Q #.

Просто добавьте `@EntryPoint()` в строку, предшествующую определению операции:

```qsharp
    @EntryPoint()
    operation Perform3qubitQFT() : Unit {
        // ...
```

Чтобы запустить программу, откройте терминал в папке проекта и введите

```dotnetcli
dotnet run
```

После выполнения вы увидите приведенные `Message` `DumpMachine` ниже выходные данные и выводимые в консоли.


#### <a name="python"></a>[Python](#tab/tabid-python)

Создайте файл узла Python: `host.py` .

Файл узла создается следующим образом: 
1. Сначала импортируйте `qsharp` модуль, который регистрирует загрузчик модуля для взаимодействия Q #. 
    Это позволяет пространствам имен Q # (например, `NamespaceQFT` определенному в нашем файле Q #) выглядеть как модули Python, из которых можно импортировать операции Q #.
2. Затем импортируйте операции Q #, которые будут напрямую вызывать---в этом случае `Perform3qubitQFT` .
    Нам нужно только импортировать точку входа в программу Q # (т. е. _не_ такие операции `H` , как и `R1` , которые вызываются другими операциями q #, но никогда не являются классическим узлом).
3. При моделировании операций и функций Q # используйте форму `<Q#callable>.simulate(<args>)` для их запуска на `QuantumSimulator()` целевом компьютере. 

> [!NOTE]
> Если бы мы хотели вызвать операцию на другом компьютере, например `ResourceEstimator()` , мы просто используем `<Q#callable>.estimate_resources(<args>)` .
> В общем случае операции Q # не зависят от компьютеров, на которых они выполняются, но некоторые функции, например, `DumpMachine` могут вести себя по-разному.

4. При выполнении моделирования вызов операции возвратит значения, как определено в файле Q #.
    Пока ничего не возвращается, но позже мы увидим пример назначения и обработки этих значений.
    Используя итоговые данные в наших практических занятиях, мы можем выполнить все, что нам бы хотелось.

Полный `host.py` файл должен быть следующим:

```python
import qsharp
from NamespaceQFT import Perform3qubitQFT

Perform3qubitQFT.simulate()
```

Запустите файл Python и распечатайте его в консоли `Message` `DumpMachine` . ниже показаны выходные данные и. 


#### <a name="c"></a>[C#](#tab/tabid-csharp)

Следуя тем же инструкциям, что и в разделе [руководство по установке](xref:microsoft.quantum.install.cs), создайте файл узла C# и переименуйте его в `host.cs` .

Узел C# состоит из четырех частей:
1. Создание квантового симулятора.
    В приведенном ниже коде это переменная `qsim` .
2. Вычисление всех аргументов для квантового алгоритма.
    В этом примере нет ни одного.
3. Выполнение квантового алгоритма. 
    Для каждой операции Q# создается класс C# с тем же именем. 
    Этот класс содержит метод `Run`, который **асинхронно** выполняет соответствующую операцию.
    Асинхронное выполнение имитирует асинхронный процесс на реальном оборудовании. 
    Так как `Run` метод является асинхронным, мы вызываем `Wait()` метод. он блокирует выполнение до завершения задачи и возвращает результат в синхронном режиме. 
4. Обработать возвращенный результат операции.
    Пока операция не возвращает ничего.


```csharp
using System;

using Microsoft.Quantum.Simulation.Core;
using Microsoft.Quantum.Simulation.Simulators;

namespace NamespaceQFT
{
    class Driver
    {
        static void Main(string[] args)
        {
            using (var qsim = new QuantumSimulator())
            {
                Perform3QubitQFT.Run(qsim).Wait();
            }
            
            System.Console.WriteLine("Press any key to continue...");
            Console.ReadKey();
        }
    }
}

```
Запустите приложение, и выходные данные должны соответствовать приведенным ниже данным.
Программа завершает работу после нажатия любой клавиши.
***

```Output
Initial state |000>:
# wave function for qubits with ids (least to most significant): 0;1;2
|0>:     1.000000 +  0.000000 i  ==     ******************** [ 1.000000 ]     --- [  0.00000 rad ]
|1>:     0.000000 +  0.000000 i  ==                          [ 0.000000 ]                   
|2>:     0.000000 +  0.000000 i  ==                          [ 0.000000 ]                   
|3>:     0.000000 +  0.000000 i  ==                          [ 0.000000 ]                   
|4>:     0.000000 +  0.000000 i  ==                          [ 0.000000 ]                   
|5>:     0.000000 +  0.000000 i  ==                          [ 0.000000 ]                   
|6>:     0.000000 +  0.000000 i  ==                          [ 0.000000 ]                   
|7>:     0.000000 +  0.000000 i  ==                          [ 0.000000 ]                   
After:
# wave function for qubits with ids (least to most significant): 0;1;2
|0>:     0.353553 +  0.000000 i  ==     ***                  [ 0.125000 ]     --- [  0.00000 rad ]
|1>:     0.353553 +  0.000000 i  ==     ***                  [ 0.125000 ]     --- [  0.00000 rad ]
|2>:     0.353553 +  0.000000 i  ==     ***                  [ 0.125000 ]     --- [  0.00000 rad ]
|3>:     0.353553 +  0.000000 i  ==     ***                  [ 0.125000 ]     --- [  0.00000 rad ]
|4>:     0.353553 +  0.000000 i  ==     ***                  [ 0.125000 ]     --- [  0.00000 rad ]
|5>:     0.353553 +  0.000000 i  ==     ***                  [ 0.125000 ]     --- [  0.00000 rad ]
|6>:     0.353553 +  0.000000 i  ==     ***                  [ 0.125000 ]     --- [  0.00000 rad ]
|7>:     0.353553 +  0.000000 i  ==     ***                  [ 0.125000 ]     --- [  0.00000 rad ]
```

При вызове в симуляторе с полным состоянием `DumpMachine()` предоставляет эти множественные представления вавефунктион состояния такта. Возможные состояния системы $n $-кубит могут быть представлены в виде $2 ^ n $ вычислительных показателей, каждый из которых имеет соответствующий сложный коэффициент (просто амплитуда и фаза).
Состояние вычислительных операций соответствует всем возможным двоичным строкам длиной $n $---т. е. все возможные сочетания состояний кубит $ \кет {0} $ и $ \кет {1} $, где каждая двоичная цифра соответствует отдельному кубит.

Первая строка содержит комментарий с идентификаторами соответствующего Кубитс в значительном порядке.
Кубит `2` является «самым значимым» просто означает, что в двоичном представлении вектора состояния «\кет{и} $» состояние кубит `2` соответствует крайней левой разрядности. Например, $ \кет {6} = \кет {110} $ состоит из Кубитс `2` и `1` в $ \кет {1} $ и кубит `0` в $ \кет {0} $.


Остальные строки описывают амплитуду вероятности по измерению вектора состояния базы данных $ \кет{и} $ в декартовой и полярной форматах.
Подробно для первой строки нашего входного состояния $ \кет {000} $:
* **`|0>:`** Эта строка соответствует `0` определенному вычислительному состоянию (учитывая, что начальное состояние после выделения было равно $ \кет {000} $, мы бы ожидали, что это единственное состояние с амплитудой вероятности на этом этапе).
* **`1.000000 +  0.000000 i`**: амплитуда вероятности в формате Декарт.
* **` == `**: `equal` знак разделяет оба эквивалентных представления.
* **`********************`**: Графическое представление величины, количество `*` пропорционально вероятности измерения этого вектора состояния. 
* **`[ 1.000000 ]`**: числовое значение величины.
* **`    ---`**— Графическое представление фазы амплитуды.
* **`[ 0.0000 rad ]`**: числовое значение этапа (в радианах).

Как величина, так и фаза отображаются с графическим представлением. Представление величины является простым: оно показывает полоску `*` , а чем выше вероятность, тем больше будет полоска. Для этапа см. раздел [тестирование и отладка. функции дампа](xref:microsoft.quantum.guide.testingdebugging#dump-functions) для возможных представлений символов на основе диапазонов угла.


Таким образом, выводимые данные показывают, что наши запрограммированные Шлюзы преобразуют состояние из

$ $ \кет{\пси} \_ {Initial} = \кет {000} $ $

значение 

$ $ \бегин{алигн} \кет{\пси} \_ {final} &= \фрак {1} {\скрт} \лефт (\кет \кет + \кет + \кет + \кет {8} {000} {001} {010} {011} {100} + \кет {101} + \кет {110} + \кет {111} \ригхт) \\ \\ &= \frac {1} {\sqrt{2 ^ n}} \sum \_ {j = 0} ^ {2 ^ n-1} \ket{j}, \end{align} $ $

что является точным поведением преобразования «3-кубит Фурье». 

Если вы хотите узнать, как затрагиваются другие входные состояния, мы рекомендуем поэкспериментировать с применением операций кубит перед преобразованием.

## <a name="adding-measurements"></a>Добавление измерений

К сожалению, в результате механики тактовой задержки говорится, что в реальной тактовой системе не может быть такой `DumpMachine` функции. Вместо этого мы вынуждены извлекать информацию с помощью измерений, что в целом не только дает нам полное состояние такта, но и радикально изменяет саму систему.
Существует множество видов измерений такта, но мы будем сосредоточиться на самых базовых: проецированные измерения на одном Кубитс.
При измерении на определенном уровне (например, на основе вычислительной базы $ \{ \кет {0} , \кет {1} \} $) состояние кубит проецируется на то, что было измерено по отдельности,---таким образом удаление любого из них.

Чтобы реализовать измерения в программе Q #, мы используем `M` операцию (FROM `Microsoft.Quantum.Intrinsic` ), которая возвращает `Result` тип.

Сначала мы изменим `Perform3QubitQFT` операцию, чтобы вернуть массив результатов измерения, `Result[]` вместо `Unit` .

```qsharp
    operation Perform3QubitQFT() : Result[] {
```

#### <a name="define-and-initialize-result-array"></a>Определение и инициализация `Result[]` массива

Прежде чем даже выделять Кубитс (т. е. перед `using` инструкцией), мы объявляем и привязали этот массив length-3 ( `Result` по одному для каждого кубит): 

```qsharp
        mutable resultArray = new Result[3];
```

`mutable`Преднаправленное ключевое слово `resultArray` позволяет позже повторно привязать переменную в коде---например, при добавлении результатов измерения.

#### <a name="perform-measurements-in-a-for-loop-and-add-results-to-array"></a>Выполнение измерений в `for` цикле и добавление результатов в массив

После выполнения операций преобразования Фурье внутри `using` блока вставьте следующий код:

```qsharp
            for(i in IndexRange(qs)) {
                set resultArray w/= i <- M(qs[i]);
            }
```
[`IndexRange`](xref:microsoft.quantum.arrays.indexrange)Функция, вызываемая для массива (например, наш массив Кубитс, `qs` ), возвращает диапазон по индексам массива. Здесь мы используем его в нашем `for` цикле, чтобы последовательно измерять каждую кубит с помощью `M(qs[i])` инструкции.
Затем каждый измеряемый `Result` тип ( `Zero` или `One` ) добавляется в соответствующую позиции индекса в `resultArray` с помощью инструкции UPDATE и REASSIGN.

> [!NOTE]
> Синтаксис этой инструкции уникален для Q #, но соответствует аналогичному повторному назначению переменной, представленному `resultArray[i] <- M(qs[i])` на других языках, таких как F # и R.

Ключевое слово `set` всегда используется для повторного присвоения переменных, привязанных с помощью `mutable` .

#### <a name="return-resultarray"></a>Вернул`resultArray`

Если все три Кубитс измерения и результаты добавлены в `resultArray` , мы сможем сбросить и отменить выделение Кубитс как раньше.
После `using` закрытия блока вставьте

```qsharp
        return resultArray;
```
чтобы возвратить результат нашей операции в конечном итоге. 

### <a name="understanding-the-effects-of-measurement"></a>Основные сведения о влиянии измерения

Давайте изменим размещение наших `DumpMachine` функций для вывода состояния до и после измерений.
Окончательный код операции должен выглядеть следующим образом: 

```qsharp
    operation Perform3QubitQFT() : Result[] {

        mutable resultArray = new Result[3];

        using (qs = Qubit[3]) {

            //QFT:
            //first qubit:
            H(qs[0]);
            Controlled R1([qs[1]], (PI()/2.0, qs[0]));
            Controlled R1([qs[2]], (PI()/4.0, qs[0]));

            //second qubit:
            H(qs[1]);
            Controlled R1([qs[2]], (PI()/2.0, qs[1]));

            //third qubit:
            H(qs[2]);

            SWAP(qs[2], qs[0]);

            Message("Before measurement: ");
            DumpMachine();

            for(i in IndexRange(qs)) {
                set resultArray w/= i <- M(qs[i]);
            }

            Message("After measurement: ");
            DumpMachine();

            ResetAll(qs);
        }
        return resultArray;
    }
}
```

Если вы работаете из командной строки, возвращаемый массив будет просто напечатан непосредственно на консоли в конце выполнения.
В противном случае обновите программу узла для обработки возвращенного массива.

#### <a name="command-line"></a>[Командная строка](#tab/tabid-cmdline)

Чтобы получить более полное представление о возвращенном массиве, который будет напечатан в консоли, мы можем добавить еще одну часть `Message` в файл Q # непосредственно перед `return` инструкцией:

```qsharp
        Message("Post-QFT measurement results [qubit0, qubit1, qubit2]: ");
        return resultArray;
```

Запустите проект, и выходные данные должны выглядеть следующим образом:

```Output
Before measurement: 
# wave function for qubits with ids (least to most significant): 0;1;2
|0>:     0.353553 +  0.000000 i  ==     ***                  [ 0.125000 ]     --- [  0.00000 rad ]
|1>:     0.353553 +  0.000000 i  ==     ***                  [ 0.125000 ]     --- [  0.00000 rad ]
|2>:     0.353553 +  0.000000 i  ==     ***                  [ 0.125000 ]     --- [  0.00000 rad ]
|3>:     0.353553 +  0.000000 i  ==     ***                  [ 0.125000 ]     --- [  0.00000 rad ]
|4>:     0.353553 +  0.000000 i  ==     ***                  [ 0.125000 ]     --- [  0.00000 rad ]
|5>:     0.353553 +  0.000000 i  ==     ***                  [ 0.125000 ]     --- [  0.00000 rad ]
|6>:     0.353553 +  0.000000 i  ==     ***                  [ 0.125000 ]     --- [  0.00000 rad ]
|7>:     0.353553 +  0.000000 i  ==     ***                  [ 0.125000 ]     --- [  0.00000 rad ]
After measurement:
# wave function for qubits with ids (least to most significant): 0;1;2
|0>:     0.000000 +  0.000000 i  ==                          [ 0.000000 ]
|1>:     0.000000 +  0.000000 i  ==                          [ 0.000000 ]
|2>:     0.000000 +  0.000000 i  ==                          [ 0.000000 ]
|3>:     1.000000 +  0.000000 i  ==     ******************** [ 1.000000 ]     --- [  0.00000 rad ]
|4>:     0.000000 +  0.000000 i  ==                          [ 0.000000 ]
|5>:     0.000000 +  0.000000 i  ==                          [ 0.000000 ]
|6>:     0.000000 +  0.000000 i  ==                          [ 0.000000 ]
|7>:     0.000000 +  0.000000 i  ==                          [ 0.000000 ]

Post-QFT measurement results [qubit0, qubit1, qubit2]: 
[One,One,Zero]
```

#### <a name="python"></a>[Python](#tab/tabid-python)

Обновите программу Python следующим образом:

```python
import qsharp
from NamespaceQFT import Perform3QubitQFT

measurementResult = Perform3QubitQFT.simulate()
print("\n")
print("Measured post-QFT state: [qubit0, qubit1, qubit2]")
print(measurementResult)

# reversing order to show corresponding basis state in binary form
binaryCompBasisState = ""
for i in measurementResult:
    binaryCompBasisState = str(i) + binaryCompBasisState
print("Corresponding basis state in binary:")
print("|" + binaryCompBasisState + ">")
```

Запустите файл, и выходные данные должны выглядеть следующим образом:

```Output
Before measurement: 
# wave function for qubits with ids (least to most significant): 0;1;2
|0>:     0.353553 +  0.000000 i  ==     ***                  [ 0.125000 ]     --- [  0.00000 rad ]
|1>:     0.353553 +  0.000000 i  ==     ***                  [ 0.125000 ]     --- [  0.00000 rad ]
|2>:     0.353553 +  0.000000 i  ==     ***                  [ 0.125000 ]     --- [  0.00000 rad ]
|3>:     0.353553 +  0.000000 i  ==     ***                  [ 0.125000 ]     --- [  0.00000 rad ]
|4>:     0.353553 +  0.000000 i  ==     ***                  [ 0.125000 ]     --- [  0.00000 rad ]
|5>:     0.353553 +  0.000000 i  ==     ***                  [ 0.125000 ]     --- [  0.00000 rad ]
|6>:     0.353553 +  0.000000 i  ==     ***                  [ 0.125000 ]     --- [  0.00000 rad ]
|7>:     0.353553 +  0.000000 i  ==     ***                  [ 0.125000 ]     --- [  0.00000 rad ]
After measurement: 
# wave function for qubits with ids (least to most significant): 0;1;2
|0>:     0.000000 +  0.000000 i  ==                          [ 0.000000 ]                   
|1>:     0.000000 +  0.000000 i  ==                          [ 0.000000 ]                   
|2>:     0.000000 +  0.000000 i  ==                          [ 0.000000 ]                   
|3>:     1.000000 +  0.000000 i  ==     ******************** [ 1.000000 ]     --- [  0.00000 rad ]
|4>:     0.000000 +  0.000000 i  ==                          [ 0.000000 ]                   
|5>:     0.000000 +  0.000000 i  ==                          [ 0.000000 ]                   
|6>:     0.000000 +  0.000000 i  ==                          [ 0.000000 ]                   
|7>:     0.000000 +  0.000000 i  ==                          [ 0.000000 ]                   

Post-QFT measurement results [qubit0, qubit1, qubit2]: 
[1, 1, 0]

Corresponding basis state in binary:
|011>
```

#### <a name="c"></a>[C#](#tab/tabid-csharp)

Теперь, когда наша операция возвращает результат, замените вызов метода `Wait()` на выборку `Result` Свойства. Это по-прежнему выполняет ту же синхронности, что обсуждалось ранее, и мы можем напрямую привязать это значение к переменной `measurementResult` .

```csharp
using System;

using Microsoft.Quantum.Simulation.Core;
using Microsoft.Quantum.Simulation.Simulators;

namespace NamespaceQFT
{
    class Driver
    {
        static void Main(string[] args)
        {
            using (var qsim = new QuantumSimulator())
            {
                var measurementResult = Perform3QubitQFT.Run(qsim).Result;
                System.Console.WriteLine(
                    $"Post-QFT measurement results [qubit0, qubit1, qubit2]: ");
                System.Console.WriteLine(
                    measurementResult);

                // reversing order to show corresponding basis state in binary form
                string binaryCompBasisState = String.Empty;

                foreach (Result i in measurementResult)
                {
                    string iString = i.ToString();
                    binaryCompBasisState = iString + binaryCompBasisState;
                }
                binaryCompBasisState = "|" + binaryCompBasisState + ">";
                System.Console.WriteLine(
                    $"Corresponding basis state in binary:");
                System.Console.WriteLine(
                    binaryCompBasisState);
            }
            
            System.Console.WriteLine("Press any key to continue...");
            Console.ReadKey();
        }
    }
}
```

Запустите проект, и выходные данные должны выглядеть следующим образом:

```Output
Before measurement: 
# wave function for qubits with ids (least to most significant): 0;1;2
|0>:     0.353553 +  0.000000 i  ==     ***                  [ 0.125000 ]     --- [  0.00000 rad ]
|1>:     0.353553 +  0.000000 i  ==     ***                  [ 0.125000 ]     --- [  0.00000 rad ]
|2>:     0.353553 +  0.000000 i  ==     ***                  [ 0.125000 ]     --- [  0.00000 rad ]
|3>:     0.353553 +  0.000000 i  ==     ***                  [ 0.125000 ]     --- [  0.00000 rad ]
|4>:     0.353553 +  0.000000 i  ==     ***                  [ 0.125000 ]     --- [  0.00000 rad ]
|5>:     0.353553 +  0.000000 i  ==     ***                  [ 0.125000 ]     --- [  0.00000 rad ]
|6>:     0.353553 +  0.000000 i  ==     ***                  [ 0.125000 ]     --- [  0.00000 rad ]
|7>:     0.353553 +  0.000000 i  ==     ***                  [ 0.125000 ]     --- [  0.00000 rad ]
After measurement:
# wave function for qubits with ids (least to most significant): 0;1;2
|0>:     0.000000 +  0.000000 i  ==                          [ 0.000000 ]
|1>:     0.000000 +  0.000000 i  ==                          [ 0.000000 ]
|2>:     0.000000 +  0.000000 i  ==                          [ 0.000000 ]
|3>:     1.000000 +  0.000000 i  ==     ******************** [ 1.000000 ]     --- [  0.00000 rad ]
|4>:     0.000000 +  0.000000 i  ==                          [ 0.000000 ]
|5>:     0.000000 +  0.000000 i  ==                          [ 0.000000 ]
|6>:     0.000000 +  0.000000 i  ==                          [ 0.000000 ]
|7>:     0.000000 +  0.000000 i  ==                          [ 0.000000 ]

Post-QFT measurement results [qubit0, qubit1, qubit2]: 
[One,One,Zero]

Corresponding basis state in binary:
|ZeroOneOne>

Press any key to continue...
```
***

В этих выходных данных показано несколько различных моментов.
1. Сравнивая возвращенный результат с предварительным измерением `DumpMachine` , он четко _не_ иллюстрирует ПОшаговую кфтную перестановку на основе состояния.
    Измерение возвращает только одно состояние основания с вероятностью, которое определяется амплитудой этого состояния в вавефунктионе системы.
2. С момента последующей единицы `DumpMachine` измерения видно, что измерение _изменяет_ само состояние, проецирование его из первоначального перестановки в поверх состояний в одно состояние, соответствующее измеренному значению.

Если бы нам пришлось повторить эту операцию несколько раз, мы увидим, что статистика результатов начинается с одинаковой взвешенной части состояния после Кфт, что дает случайному результату на каждом снимке.
_Однако_, помимо неэффективного и неидеальны, это, тем не менее, будет воспроизводить только относительные амплитуды базисных состояний, а не относительные этапы между ними.
Последнее не является проблемой в этом примере, но будут отображены относительные этапы, если для Кфт более сложным входом, чем $ \кет {000} $.

#### <a name="partial-measurements"></a>Частичные измерения 
Чтобы узнать, как измерение только некоторых Кубитс ККМ может повлиять на состояние системы, попробуйте добавить следующее в `for` цикле после строки измерения:
```qsharp
                let iString = IntAsString(i);
                Message("After measurement of qubit " + iString + ":");
                DumpMachine();
```

Обратите внимание, что для доступа к `IntAsString` функции потребуется добавить 
```qsharp
    open Microsoft.Quantum.Convert;
```
с остальными `open` операторами пространства имен.

В результирующих выходных данных вы увидите постепенное проецирование на подпространства при измерении каждого кубит.


## <a name="use-the-q-libraries"></a>Использование библиотек Q #
Как мы упоминали во введении, многие из вопросов, связанных с возможной назначением Q #, позволят вам получить более абстрактные сведения о работе с отдельными Кубитс.
В действительности, если вы хотите разрабатывать масштабируемые, применимые тактовые программы, не беспокойтесь о том, `H` проходит ли операция до или после определенного вращения, вы замедляете работу. 

Библиотеки Q # содержат операцию [Кфт](xref:microsoft.quantum.canon.qft) , которую можно просто взять и применить для любого числа Кубитс.
Чтобы придать ему возможность, определите новую операцию в файле Q #, имеющую то же содержимое `Perform3QubitQFT` , но с первой, `H` `SWAP` замененной на две простые линии:
```qsharp
            let register = BigEndian(qs);    //from Microsoft.Quantum.Arithmetic
            QFT(register);                   //from Microsoft.Quantum.Canon
```
В первой строке просто создается [`BigEndian`](xref:microsoft.quantum.arithmetic.bigendian) выражение выделенного массива Кубитс, то `qs` есть операция [Кфт](xref:microsoft.quantum.canon.qft) принимает в качестве аргумента.
Это соответствует упорядочению индексов Кубитс в регистре.

Чтобы получить доступ к этим операциям, добавьте `open` инструкции для соответствующих пространств имен в начале файла Q #:
```qsharp
    open Microsoft.Quantum.Canon;
    open Microsoft.Quantum.Arithmetic;
```

Теперь настройте программу для вызова имени новой операции (например `PerformIntrinsicQFT` ,) и присвойте ей попробуйте.

Чтобы увидеть реальное преимущество использования операций с библиотекой Q #, измените число Кубитс на что-либо, отличное от `3` :
```qsharp
        mutable resultArray = new Result[4]; 

        using (qs = Qubit[4]) {
            //...
        }
```
Таким образом, можно применить правильный Кфт для любого определенного числа Кубитс, не заботясь о новых `H` операциях и поворотах для каждого кубит.

Обратите внимание, что тактовый симулятор занимает больше времени, так как вы увеличиваете число Кубитс---точно, почему мы надеемся на работу с реальными тактами!













