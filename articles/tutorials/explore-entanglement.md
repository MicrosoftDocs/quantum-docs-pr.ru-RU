---
title: Изучите замкнутые с помощью Q#
description: Узнайте, как написать тактовую программу в Q# . Разработка приложения, которое использует состояние Белла, с помощью Microsoft Quantum Development Kit
author: geduardo
ms.author: v-edsanc
ms.date: 05/29/2020
ms.topic: tutorial
uid: microsoft.quantum.write-program
no-loc:
- Q#
- $$v
ms.openlocfilehash: ac9c060c157ba5ee3bc66852c42298ac8adcb3b3
ms.sourcegitcommit: 685a8ab16d7e6a25e63a168d6e7c385fa6e876cc
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/29/2020
ms.locfileid: "91492342"
---
# <a name="tutorial-explore-entanglement-with-q"></a>Руководство по Исследование запутанности с использованием Q\#

В этом учебнике мы покажем, как написать Q# программу, которая манипулирует и измеряет Кубитс и демонстрирует эффект замкнутые.

В результате у вас получится приложение Bell, которое демонстрирует квантовую запутанность.
Имя Bell — это отсылка к состоянию Белла, которое обозначает особые квантовые состояния двух кубитов с простейшими примерами эффектов суперпозиции и квантовой запутанности.

## <a name="pre-requisites"></a>Предварительные требования

Если вы готовы писать код, выполните следующие действия, прежде чем продолжать: 

* [Установите](xref:microsoft.quantum.install) пакет средств разработки тактов, используя предпочитаемый язык и среду разработки.
* Если эта платформа уже установлена, убедитесь, что она [обновлена](xref:microsoft.quantum.update) до последней версии.

Вы также можете следовать инструкциям, не устанавливая КДК, просматривая обзоры Q# языка программирования и первые основные понятия тактовых вычислений.

## <a name="in-this-tutorial-youll-learn-how-to"></a>В этом руководстве вы узнаете, как:

> [!div class="checklist"]
> * Операции создания и объединения в Q\#
> * Создайте операции, чтобы поместить Кубитс в ентангле и измерять их.
> * Демонстрация тактовой замкнутые с Q# программой, выполняемой в симуляторе. 

## <a name="demonstrating-qubit-behavior-with-the-qdk"></a>Демонстрация поведения кубит с помощью КДК

В классическом бите хранится одно двоичное значение (0 или 1), а [кубит](xref:microsoft.quantum.glossary#qubit) может находиться в состоянии **суперпозиции**, принимая оба эти значения.  По сути, состояние кубит можно рассматривать как направление в абстрактном пространстве (также называемом вектором).  Состояние кубит может быть в любом из возможных направлений. Два **классических состояния** в этой модели соответствуют двум направлениям: 100 % вероятности получить при измерении 0 и 100 % вероятности получить 1.

Измерение кубита возвращает двоичный результат и изменяет состояние кубита.
Измерение создает двоичное значение 0 или 1.  При этом кубит переходит из состояния суперпозиции в одно из классических состояний.  С этого момента все повторные измерения будут возвращать тот же двоичный результат, если не выполняются дополнительные промежуточные операции.  

Несколько кубитов могут находиться в состоянии [**запутанности**](xref:microsoft.quantum.glossary#entanglement).  При измерении одного из запутанных кубитов мы получаем сведения о состоянии второго.

Теперь мы готовы продемонстрировать, как Q# выражает это поведение.  Вы начнете работу с самой простой программы и постепенно доработаете ее для демонстрации квантовой суперпозиции и квантовой запутанности.

## <a name="creating-a-no-locq-project"></a>Создание Q# проекта

Первое, что нужно сделать, — это создать новый Q# проект. В этом учебнике мы будем использовать среду на основе [ Q# приложений с VS Code](xref:microsoft.quantum.install.standalone).

Чтобы создать новый проект, в VS Code: 

1. Щелкните **Представление** -> **Палитра команд** и выберите **Q#: создать проект**.
2. Щелкните **Standalone console application** (Автономное консольное приложение).
3. Перейдите к расположению, в котором нужно сохранить проект, и щелкните **Создать проект**.
4. После успешного создания проекта нажмите **Открыть новый проект...** в правом нижнем углу.

В этом случае мы назвали проект `Bell` . Это приводит к созданию двух файлов: `Bell.csproj` , файла проекта и `Program.qs` шаблона Q# приложения, которое будет использоваться для написания нашего приложения. Содержимое `Program.qs` должно быть следующим:

```qsharp
   namespace Bell {

      open Microsoft.Quantum.Canon;
      open Microsoft.Quantum.Intrinsic;
    

      @EntryPoint()
      operation HelloQ() : Unit {
          Message("Hello quantum world!");
      }
   }
```

## <a name="write-the-q-application"></a>Написание \# приложения Q
 
Нашей целью является подготовка двух Кубитс в определенном состоянии такта, демонстрация работы с Кубитс с Q# целью изменения их состояния и демонстрации эффектов замкнутые. Мы создадим этот фрагмент по части для представления кубитных состояний, операций и измерений.

### <a name="initialize-qubit-using-measurement"></a>Инициализация кубит с помощью измерения

В первом фрагменте кода ниже показано, как работать с Кубитс в Q# .  Мы предоставим две операции, [`M`](xref:microsoft.quantum.intrinsic.m) [`X`](xref:microsoft.quantum.intrinsic.x) которые преобразуют состояние кубит. В этом фрагменте кода определена операция `SetQubitState`, которая принимает в качестве параметров кубит и значение состояния `desired`, в котором должен находиться этот кубит.  Операция `SetQubitState` выполняет измерение кубита с помощью операции `M`.  В Q# кубит измерение всегда возвращает значение `Zero` или `One` .  Если измерение возвращает значение, не равное желаемому значению, `SetQubitState` "переворачивает" кубит, то есть выполняет `X` операцию, которая изменяет состояние кубит на новое состояние, в котором вероятности возврата и изменения значений измерений меняются `Zero` `One` местами. Таким образом `SetQubitState` Целевая кубит всегда помещается в нужное состояние.

Замените содержимое `Program.qs` следующим кодом:


```qsharp
   namespace Bell {
       open Microsoft.Quantum.Intrinsic;
       open Microsoft.Quantum.Canon;

       operation SetQubitState(desired : Result, q1 : Qubit) : Unit {
           if (desired != M(q1)) {
               X(q1);
           }
       }
   }
```

Теперь вы можете вызвать эту операцию, чтобы установить кубит в классическое состояние, которое в 100 % случаев возвращает одно из значений: `Zero` или `One`.
Константы `Zero` и `One` представляют все возможные результаты измерения кубита.

Операция `SetQubitState` измеряет кубит. Если кубит находится в нужном состоянии, `SetQubitState` оставляет его только один. в противном случае, выполнив `X` операцию, мы изменим состояние кубит на нужное.

#### <a name="about-no-locq-operations"></a>Сведения об Q# операциях

Q#Операция — это подпрограммы такта. То есть это вызываемая подпрограммы, которая содержит вызовы других тактовых операций.

Аргументы операции задаются в виде кортежа в круглых скобках.

Возвращаемый тип операции задается после двоеточия. В этом случае `SetQubitState` операция не имеет возвращаемого типа, поэтому она помечается как возвращаемая `Unit` . Это Q# эквивалент `unit` в F #, который примерно аналогичен `void` в C#, и пустой кортеж в Python ( `()` представленный указанием типа `Tuple[()]` ).

В первой операции вы использовали две тактовые операции Q# :

* [`M`](xref:microsoft.quantum.intrinsic.m)Операция, которая измеряет состояние кубит
* [`X`](xref:microsoft.quantum.intrinsic.x)Операция, которая отражает состояние кубит

Квантовая операция преобразует состояние кубита. Иногда вместо термина "операция" применяют термин "вентиль", по аналогии с классическими логическими вентилями. Это связано с тем, что на ранних этапах квантовых вычислений все алгоритмы были только теоретическими конструкциями и оформлялись в виде схем, похожих на схемы электрических контуров для классических вычислений.

### <a name="counting-measurement-outcomes"></a>Подсчет результатов измерения

Чтобы продемонстрировать выполнение операции `SetQubitState`, после этого добавляется операция `TestBellState`. Эта операция принимает в качестве входных данных `Zero` или `One`, вызывает для этого объекта операцию `SetQubitState` заданное количество раз, а также подсчитывает количество значений `Zero` и значений `One` в выполненных измерениях кубита. Разумеется, в нашей первой модели операции `TestBellState` мы ожидаем получить результат `Zero` для всех измерений кубита, определенного с помощью операции `Zero`, и результат `One` для всех измерений кубита, определенного с помощью операции `One`. Далее мы добавим код в, `TestBellState` чтобы продемонстрировать замкнутые.

В файле `Program.qs` добавьте следующую операцию в пространство имен, сразу после операции `SetQubitState`:

```qsharp
   operation TestBellState(count : Int, initial : Result) : (Int, Int) {

       mutable numOnes = 0;
       using (qubit = Qubit()) {

           for (test in 1..count) {
               SetQubitState(initial, qubit);
               let res = M(qubit);

               // Count the number of ones we saw:
               if (res == One) {
                   set numOnes += 1;
               }
           }
            
           SetQubitState(Zero, qubit);
       }

       // Return number of times we saw a |0> and number of times we saw a |1>
       Message("Test results (# of 0s, # of 1s): ");
       return (count - numOnes, numOnes);
   }
```
Обратите внимание, что мы добавили строку перед `return` печатью пояснительного сообщения в консоли с помощью функции ( `Message` ) [Microsoft. тактов. Inline. Message].

Эта операция (`TestBellState`) выполняет `count` раз следующий цикл: устанавливает для кубита указанное значение `initial` и измеряет результат (`M`). Она собирает статистические данные о количестве нулей и единиц в измерениях, а затем возвращает эти данные вызывающему объекту. Она выполняет еще одну важную операцию — восстановление известного состояния кубита (`Zero`) перед завершением работы, чтобы другие операции могли получить этот кубит в известном состоянии. Это поведение диктуется инструкцией `using`.

#### <a name="about-variables-in-q"></a>О переменных в Q\#

По умолчанию переменные в Q# являются неизменяемыми; их значения не могут изменяться после их привязки. Ключевое слово `let` обозначает привязку неизменяемой переменной. Аргументы операций всегда остаются неизменяемыми.

Если же вам нужна переменная, значение которой может меняться (в нашем примере это `numOnes`), объявите такую переменную с ключевым словом `mutable`. Значение изменяемой переменной можно изменить с помощью инструкции `set`.

Тип переменной в обоих случаях выводится компилятором. Q# не требует никаких аннотаций типа для переменных.

#### <a name="about-using-statements-in-q"></a>О `using` инструкциях в Q\#

`using`Оператор также является специальным для Q# . Она выделяет кубиты для использования в блоке кода. В Q# все Кубитс динамически выделяются и освобождаются, вместо фиксированных ресурсов, которые находятся в течение всего времени существования сложного алгоритма. Оператор `using` выделяет набор кубитов в начале блока и освобождает их в конце блока.

## <a name="run-the-code-from-the-command-prompt"></a>Запуск кода из командной строки

Чтобы выполнить код, необходимо сообщить компилятору, *что* вызываемый объект должен запускаться при вводе `dotnet run` команды. Это делается простым изменением в Q# файле путем добавления строки, `@EntryPoint()` непосредственно предшествующей вызываемой: в `TestBellState` этом случае операция. Полный код должен быть следующим:

```qsharp
namespace Bell {
    open Microsoft.Quantum.Canon;
    open Microsoft.Quantum.Intrinsic;

    operation SetQubitState(desired : Result, target : Qubit) : Unit {
        if (desired != M(target)) {
            X(target);
        }
    }

    @EntryPoint()
    operation TestBellState(count : Int, initial : Result) : (Int, Int) {

        mutable numOnes = 0;
        using (qubit = Qubit()) {

            for (test in 1..count) {
                SetQubitState(initial, qubit);
                let res = M(qubit);

                // Count the number of ones we saw:
                if (res == One) {
                    set numOnes += 1;
                }
            }

            SetQubitState(Zero, qubit);
        }

    // Return number of times we saw a |0> and number of times we saw a |1>
    Message("Test results (# of 0s, # of 1s): ");
    return (count - numOnes, numOnes);
    }
}
```

Чтобы запустить программу, необходимо указать `count` аргументы и в `initial` командной строке. Давайте рассмотрим пример `count = 1000` и `initial = One` . Введите следующую команду:

```dotnetcli
dotnet run --count 1000 --initial One
```

Обратите внимание на следующие выходные данные:

```output
Test results (# of 0s, # of 1s):
(0, 1000)
```

Если вы попробуете с вами, выполните `initial = Zero` следующие действия.

```dotnetcli
dotnet run --count 1000 --initial Zero
```
```output
Test results (# of 0s, # of 1s):
(1000, 0)
```

## <a name="prepare-superposition"></a>Подготовка суперпозиции

Теперь давайте посмотрим, как Q# выражают способы размещения Кубитс в крайнем положении.  Как вы помните, кубит может находиться в суперпозиции значений 0 и 1.  Для этого мы будем использовать операцию `Hadamard`. Если кубит находится в одном из классических состояний (т. е. его измерение возвращает всегда `Zero` или `One`), операция `Hadamard` или `H` переведет этот кубит в такое состояние, в котором измерение с вероятностью 50 % вернет одно из значений: `Zero` или `One`.  В теории можно рассматривать состояние кубита как промежуточное между `Zero` и `One`.  Итак, мы смоделировали операцию `TestBellState`, и теперь в наших результатах после измерения будет примерно равное количество значений `Zero` и `One`.  

### <a name="x-flips-qubit-state"></a>`X` переворачивает состояние кубит

Сначала мы попытаемся перевернуть кубит (если кубит находится в `Zero` состоянии, он будет перевернут `One` и наоборот). Для этого мы выполним операцию `X` до того, как измерять кубит в `TestBellState`:

```qsharp
X(qubit);
let res = M(qubit);
```

Теперь результаты будут реверсированы:

```dotnetcli
dotnet run --count 1000 --initial One
```

```output
Test results (# of 0s, # of 1s):
(1000, 0)
```

```dotnetcli
dotnet run --count 1000 --initial Zero
```
```output
Test results (# of 0s, # of 1s):
(0, 1000)
```

Теперь давайте рассмотрим свойства такта Кубитс.

### <a name="h-prepares-superposition"></a>`H` подготавливает подстановку

Нам нужно просто заменить операцию `X` в предыдущем коде операцией `H` (вентиль Адамара). Теперь мы инвертируем кубит не полностью (с 0 на 1), а в промежуточное значение. Замененные строки в `TestBellState` теперь выглядят так:

```qsharp
H(qubit);
let res = M(qubit);
```

И результат сразу становится более интересным:

```dotnetcli
dotnet run --count 1000 --initial One
```

```output
Test results (# of 0s, # of 1s):
(496, 504)
```

```dotnetcli
dotnet run --count 1000 --initial Zero
```

```output
Test results (# of 0s, # of 1s):
(506, 494)
```

При каждом измерении мы получаем классическое значение, но наш кубит находится в промежуточном состоянии (между 0 и 1), поэтому мы статистически получаем в половине случаев значение 0, а в другой половине — 1.
Это и есть **суперпозиция**, которая дает первое реальное представление о квантовых состояниях.

## <a name="prepare-entanglement"></a>Подготовка запутанности

Теперь давайте посмотрим, как Q# выражает способы ентангле Кубитс.
Прежде всего мы присвоим кубиту начальное состояние, а затем с помощью операции `H` переместим его в состояние суперпозиции.  Затем, прежде чем измерять первый кубит, мы используем новую операцию ( `CNOT` ), которая означает *контролируемый*.  Результат выполнения этой операции с двумя кубитсами заключается в том, чтобы перевернуть второй кубит, если первый кубит имеет значение `One` .  Теперь эти два кубита являются запутанными.  Статистика значений для первого кубита не изменилась (распределение 50/50 для значений `Zero` и `One` после измерения), но при измерении второго кубита он теперь __всегда__ возвращает такое же состояние, как у первого кубита. Вентиль `CNOT` добавил запутанность кубитов, и любые изменения с одним из них теперь влияют и на другой. Если выполнять измерения в обратном порядке (сначала второй кубит, потом первый), результат будет таким же. Первое измерение дает случайный результат, а второе всегда дублирует то же значение, которое мы получили в первом.

Первое, что нужно сделать, — это выделить два Кубитс вместо одного в `TestBellState` :

```qsharp
using ((q0, q1) = (Qubit(), Qubit())) {
```

Это позволяет добавить новую операцию (`CNOT`) перед измерением (`M`) в `TestBellState`:

```qsharp
SetQubitState(initial, q0);
SetQubitState(Zero, q1);

H(q0);
CNOT(q0, q1);
let res = M(q0);
```

Также мы добавили операцию `SetQubitState` для инициализации первого кубита, чтобы при запуске алгоритма он всегда находился в состоянии `Zero`.

Также нам нужно сбросить второй кубит перед освобождением.

```qsharp
SetQubitState(Zero, q0);
SetQubitState(Zero, q1);
```

Полностью код метода теперь выглядит так:

```qsharp
    operation TestBellState(count : Int, initial : Result) : (Int, Int) {

        mutable numOnes = 0;
        using ((q0, q1) = (Qubit(), Qubit())) {
            for (test in 1..count) {
                SetQubitState(initial, q0);
                SetQubitState(Zero, q1);

                H(q0);
                CNOT(q0,q1);
                let res = M(q0);

                // Count the number of ones we saw:
                if (res == One) {
                    set numOnes += 1;
                }
            }

            SetQubitState(Zero, q0);
            SetQubitState(Zero, q1);
        }

        // Return number of times we saw a |0> and number of times we saw a |1>
        return (count-numOnes, numOnes);
    }
```

Выполнив этот код, мы получим такое же распределение результатов (50/50), как и раньше. Но нам нужно не это, а реакция второго кубита на измерения состояния первого кубита. Эту статистику мы будем собирать в новой версии операции `TestBellState`:

```qsharp
    operation TestBellState(count : Int, initial : Result) : (Int, Int, Int) {
        mutable numOnes = 0;
        mutable agree = 0;
        using ((q0, q1) = (Qubit(), Qubit())) {
            for (test in 1..count) {
                SetQubitState(initial, q0);
                SetQubitState(Zero, q1);

                H(q0);
                CNOT(q0, q1);
                let res = M(q0);

                if (M(q1) == res) {
                    set agree += 1;
                }

                // Count the number of ones we saw:
                if (res == One) {
                    set numOnes += 1;
                }
            }
            
            SetQubitState(Zero, q0);
            SetQubitState(Zero, q1);
        }

        // Return times we saw |0>, times we saw |1>, and times measurements agreed
        Message("Test results (# of 0s, # of 1s, # of agreements)");
        return (count-numOnes, numOnes, agree);
    }
```

Новое возвращаемое значение (`agree`) отслеживает количество циклов, в которых измеренные состояния первого и второго кубитов совпадают.

Выполнение полученного кода:

```dotnetcli
dotnet run --count 1000 --initial One
```
```output
(505, 495, 1000)
```
```dotnetcli
dotnet run --count 1000 --initial Zero
```
```output
Test results (# of 0s, # of 1s, # of agreements)
(507, 493, 1000)
```

Как мы уже писали выше, статистика значений для первого кубита не изменилась (распределение 50/50 для значений 0 и 1), но при измерении второго кубита он теперь __всегда__ возвращает такое же состояние, как у первого кубита. Это и есть эффект запутанности.

## <a name="next-steps"></a>Дальнейшие действия

В руководстве по [поиску Гровер](xref:microsoft.quantum.quickstarts.search) показано, как создать и запустить поиск Гровер, один из наиболее популярных алгоритмов тактовой частоты и предлагает хороший пример Q# программы, которую можно использовать для решения реальных проблем с тактовыми вычислениями.  

Приступая к [работе с пакетом разработки тактовой](xref:microsoft.quantum.welcome) программы порекомендует больше способов изучения Q# и тактовой программирования.
