---
Title: описание такта Oracle: Узнайте, как работать с тактовыми Oracle и определять тактовые генераторы, черные блочные операции, используемые в качестве входных данных для другого алгоритма.
Автор: кгранаде UID: Microsoft. тактов. Основные сведения. oracles MS. author: чгранад MS. Дата: 07/11/2018 МС. раздел: концептуальный No-Loc:
- "Q#"
- "$$v"
- "$$"
- "$$"
- "$"
- "$"
- "$"
- "$$"
- "\cdots"
- "bmatrix"
- "\ddots"
- "\equiv"
- "\sum"
- "\begin"
- "\end"
- "\sqrt"
- "\otimes"
- "{"
- "}"
- "\text"
- "\phi"
- "\kappa"
- "\psi"
- "\alpha"
- "\beta"
- "\gamma"
- "\delta"
- "\omega"
- "\bra"
- "\ket"
- "\boldone"
- "\\\\"
- "\\"
- "="
- "\frac"
- "\text"
- "\mapsto"
- "\dagger"
- "\to"
- "\begin{cases}"
- "\end{cases}"
- "\operatorname"
- "\braket"
- "\id"
- "\expect"
- "\defeq"
- "\variance"
- "\dd"
- "&"
- "\begin{align}"
- "\end{align}"
- "\Lambda"
- "\lambda"
- "\Omega"
- "\mathrm"
- "\left"
- "\right"
- "\qquad"
- "\times"
- "\big"
- "\langle"
- "\rangle"
- "\bigg"
- "\Big"
- "|"
- "\mathbb"
- "\vec"
- "\in"
- "\texttt"
- "\ne"
- "<"
- ">"
- "\leq"
- "\geq"
- "~~"
- "~"
- "\begin{bmatrix}"
- "\end{bmatrix}"
- "\_"

---
# <a name="quantum-oracles"></a>Тактовые Oracle

Oracle $ O $ — это «черная Box» операция, которая используется в качестве входных данных для другого алгоритма.
Часто такие операции определяются с помощью классической функции $ f: \\ { 0, 1 \\ } ^ n \to \\ { 0, 1 \\ } ^ m, $ которая принимает $ n- $ разрядный двоичный вход и создает $ $ двоичный выходной файл m-bit.
Для этого рассмотрим определенный двоичный вход $ x = (X_ { 0 } , X_ { 1 } , \дотс, X_ { n-1 } ) $ .
Можно пометить кубит состояния как $ \ket { \vec { x } } = \ket { X_ { 0 } } \otimes \ket { X_ { 1 } } \otimes \cdots \otimes \ket { X_ { n-1 } } $ .

Мы можем сначала попытаться определить $ o $ так, что $ o \ket { x } = \ket { f (x) } $ , но это потребует нескольких проблем.
$Во-первых, f $ может иметь разный размер входных и выходных данных ( $ n \ne m $ ), поэтому применение $ O $ приведет к изменению числа Кубитс в регистре.
Во-вторых, даже если $ n = m $ функция может оказаться необратимой: Если $ f (x) = f (y) $ для некоторых $ x \ne y $ , то $ o \ket { x } = o y, \ket { } $ но $ o ^ \dagger o \ket { x } \ne o ^ \dagger o \ket { y } $ .
Это означает, что мы не сможем создать смежную операцию $ O ^ \dagger $ , и для Oracle необходимо задать для них смежное значение.

## <a name="defining-an-oracle-by-its-effect-on-computational-basis-states"></a>Определение Oracle с учетом его воздействия на состояния вычислительных баз
Мы можем справиться с этими проблемами, поставляя второй регистр $ m $ Кубитс для хранения нашего ответа.
Затем мы определим воздействие Oracle на все состояния вычислительных операций: для всех $ x \in \\ { 0, 1 \\ } ^ n $ и $ y \in \\ { 0, 1 \\ } ^ m $

$$
\begin{align}
    O ( \ket { x } \otimes \ket { y } ) = \ket { x } \otimes \ket { y \оплус f (x) } .
\end{align}
$$

Теперь $ = \dagger $ назначением "o o ^ by", мы разрешили обе предыдущие проблемы.

> [!TIP]
>Чтобы увидеть, что o $ = o ^ { \dagger } $ , обратите внимание, что $ o ^ 2 = \boldone $ с $ \оплус b \оплус = a $ для всех $ a, b \in \: :: un-Loc ({)::: 0, 1 \: :: No-Loc (})::: $ .
>В результате $ O \ket { x } \ket { y \оплус f (x) } = \ket { x } \ket { y \оплус f (x) \оплус f (x) } = \ket { x } \ket { y } $ .

Важно, что определение Oracle таким образом для каждого вычислительного состояния $ \ket { x } \ket { y } $ также определяет, как операция $ O $ действует для любого другого состояния.
Это происходит сразу же из того факта, что $ $ операция O, как и все операции над тактами, линейная в состоянии, в котором он работает.
Рассмотрим операцию хадамард, например, которая определяется в $ h \ket { 0 } = \ket { + } $ и $ h \ket { 1 } = \ket { - } $ .
Если нам нужно понять, как $ $ работает h $ \ket { + } $ , мы можем использовать этот $ h $ линейный,

$$
\begin{align}
H \ket { + } & = \frac { 1 } { \sqrt { 2 } } h ( \ket { 0 }  +  \ket { 1 } ) = \frac { 1 } { \sqrt { 2 } } (h \ket { 0 } + h \ket { 1 } )\\\\
           &= \frac{ 1 } { \sqrt { 2 } } ( \ket { + }  +  \ket { - } ) = \frac 12 ( \ket { 0 }  +  \ket { 1 }  +  \ket { 0 }  -  \ket { 1 } ) = \ket { 0 } .
\end{align}
$$

В случае определения нашего Oracle $ O можно также $ использовать, чтобы любое состояние $ \ket { \psi } $ в $ n + m $ Кубитс можно было написать следующим образом:

$$
\begin{align}
\ket{\psi}& = \sum _ { x \in \\ { 0, 1 \\ } ^ n, y \in \\ { 0, 1 \\ } ^ m } \alpha (x, y) \ket { x } \ket { y}
\end{align}
$$

где $ \alpha : \\ { 0, 1 \\ } ^ n \times \\ { 0, 1 \\ } ^ m \to \mathbb { C } $ — коэффициенты состояния $ \ket { \psi } $ . Таким образом, выражение

$$
\begin{align}
O \ket { \psi } & = o \sum _{ x \in \\ { 0, 1 \\ } ^ n, y \in \\ { 0, 1 \\ } ^ m } \alpha (x, y) \ket { x } \ket { y } x \\\\ 0 & , = 1 ^ n, y 0, 1 ^ m (x, y) O \sum_ { \in \\ { \\ } \in \\ { \\ } } \alpha \ket { x } \ket { y }\\\\
             &= \sum _ { x \in \\ { 0, 1 \\ } ^ n, y \in \\ { 0, 1 \\ } ^ m } \alpha (x, y) \ket { x } \ket { y \оплус f (x) } .
\end{align}
$$

## <a name="phase-oracles"></a>Этапы Oracle
Кроме того, можно закодировать $ f $ в Oracle $ O $ , применив _этап_ на основе входных данных для $ O $ . Например, можно определить $ O $ таким, что $$
\begin{align}
    O \ket { x } = (-1) ^ { f (x) } \ket { x } .
\end{align}
$$
Если стадия Oracle изначально работает над регистром в вычислительном уровне $ \ket { x } $ , этот этап является глобальным и, следовательно, не является наблюдаемым.
Однако такой объект Oracle может быть очень мощным ресурсом, если он применяется к крайнему положению или управляемой операции.
Например, рассмотрим фазу $ O_f Oracle $ для одной кубит функции $ f $ .
Этого $$
\begin{align}
    O_f \ket{+}
        &=O_f ( \ket { 0 }  +  \ket { 1 } )/ \sqrt { 2 }\\\\
        &=((-1) ^ { f (0) } \ket { 0 } + (-1) ^ { f (1) } \ket { 1 } )/ \sqrt { 2 }\\\\
        &=(-1) ^ { f (0) } ( \ket { 0 } + (-1) ^ { f (1)-f (0) } \ket { 1 } )/ \sqrt { 2 }\\\\
        &=(-1) ^ { f (0) } Z ^ { f (0)-f (1) } \ket { + } .
\end{align}
$$

> [!NOTE]
>Обратите внимание, что $ z ^ { -1 } = z ^ { \dagger } = z $ и, следовательно, $ z ^ { f (0)-f (1) } = Z ^ { f (1)-f (0) } .$

В общем, оба представления Oracle можно расширить, чтобы представить классические функции, которые возвращают реальные числа, а не только один бит.

Выбор наилучшего способа реализации Oracle зависит сильно от того, как эта база данных Oracle будет использоваться в рамках данного алгоритма.
Например, [алгоритм Deutsch-жозса](https://en.wikipedia.org/wiki/Deutsch%E2%80%93Jozsa_algorithm) полагается на первую реализацию Oracle, тогда как [алгоритм Гровер](https://en.wikipedia.org/wiki/Grover's_algorithm) использует реализацию Oracle во втором случае.


Для получения дополнительных сведений мы рекомендуем обсуждение в [гилиéн *et al*. 1711,00465](https://arxiv.org/abs/1711.00465).
