---
Title: описание нотации Дирак: сведения об использовании нотации Дирак для представления состояний тактов и моделирования операций тактов.
Автор: Куантумвритер UID: Microsoft. тактов. Основные сведения. Дирак MS. author: v-бенбра MS. Дата: 12/11/2017 МС. раздел: концептуальные No-Loc:
- "Q#"
- "$$v"
- "$$"
- "$$"
- "$"
- "$"
- "$"
- "$$"
- "\cdots"
- "bmatrix"
- "\ddots"
- "\equiv"
- "\sum"
- "\begin"
- "\end"
- "\sqrt"
- "\otimes"
- "{"
- "}"
- "\text"
- "\phi"
- "\kappa"
- "\psi"
- "\alpha"
- "\beta"
- "\gamma"
- "\delta"
- "\omega"
- "\bra"
- "\ket"
- "\boldone"
- "\\\\"
- "\\"
- "="
- "\frac"
- "\text"
- "\mapsto"
- "\dagger"
- "\to"
- "\begin{cases}"
- "\end{cases}"
- "\operatorname"
- "\braket"
- "\id"
- "\expect"
- "\defeq"
- "\variance"
- "\dd"
- "&"
- "\begin{align}"
- "\end{align}"
- "\Lambda"
- "\lambda"
- "\Omega"
- "\mathrm"
- "\left"
- "\right"
- "\qquad"
- "\times"
- "\big"
- "\langle"
- "\rangle"
- "\bigg"
- "\Big"
- "|"
- "\mathbb"
- "\vec"
- "\in"
- "\texttt"
- "\ne"
- "<"
- ">"
- "\leq"
- "\geq"
- "~~"
- "~"
- "\begin{bmatrix}"
- "\end{bmatrix}"
- "\_"

---

# <a name="dirac-notation"></a>Нотация Дирак

Хотя нотация векторов столбцов является повсеместной в линейной перерезке, она часто бывает очень громоздкими в тактовых вычислениях, особенно при работе с несколькими Кубитс.  Например, когда мы определим как $ \psi $ вектор, явно не ясно, является ли он $ \psi $ строкой или вектором столбца.  Таким образом $ \phi $ , если и $ \psi $ являются векторами, то он одинаково нечетким, если $ \phi \psi $ даже определен, так как фигуры $ \phi $ и $ \psi $ могут быть нечеткими в контексте.  Помимо неоднозначности в фигурах векторов, выражения с простыми векторами с использованием линейной алгебраические нотации, представленной ранее, могут быть очень громоздкими. Например, если нам нужно описать $ n $ -кубит состояние, где каждый кубит принимает значение $ 0, то это $ будет формально выражаться в состоянии 

$$\begin{bmatrix}1 \\\\ 0 \end{bmatrix} \otimes \cdots \otimes \begin{bmatrix} 1 \\\\ \end{bmatrix} . $$  

Конечно, оценка этого продукта тензорные непрактична, поскольку вектор находится в экспоненциально больших пространствах, поэтому Эта нотация фактически является лучшим описанием состояния, которое может быть предоставлено с помощью предыдущей нотации.  

[*Нотация Дирак*](https://en.wikipedia.org/wiki/Bra%E2%80%93ket_notation) решает эти проблемы, предоставляя новый язык для удовлетворения точных потребностей механизма такта.  По этой причине мы рекомендуем читателям не просматривать примеры в этом разделе в качестве жесткого рецепта того, как описать состояния такта, а не Рекомендуйте читателю просматривать их в качестве предложений, которые можно использовать для краткого выражения тактовых идей.

Существует два типа векторов в нотации Дирак: вектор *неверное* и вектор *Сисакет* , так что они именуются, так как при объединении они образуют *двусторонний или внутренний* продукт.  Если $ \psi $ является вектором столбца, то его можно записать в нотации Дирак как $ \ket { \psi } $ , где $ \ket { \кдот } $ означает, что это вектор столбца единицы, т. е. вектор *Сисакет* Vector.  Аналогичным образом, вектор строки $ \psi ^ \dagger $ выражается как $ \bra { \psi } $ . Иными словами, получает сложные конжугатион с пошаговыми $ \psi ^ \dagger $ операциями для элементов $ \psi $ перестановки. Нотация неверное-Сисакет напрямую подразумевает, что $ \braket { \psi | \psi } $ является внутренним произведением Vector $ \psi $ с самим собой, которое определяется определением $ 1 $ .  

В общем случае, если $ \psi $ и $ \phi $ являются векторами состояния такта, их внутренний продукт $ \braket { \phi | \psi } $ означает, что вероятность измерения состояния $ \ket { \psi } $ равна $ \ket { \phi } $ $ | \braket { \phi | \psi } | ^ 2 $ .  

Приведенное ниже соглашение используется для описания состояний тактов, которые задают значения 0 и One (однокубитные вычислительные состояния):

$$
\begin{bmatrix}1 \\\\ 0 \end{bmatrix} = \ket { } ,\qquad
\begin{bmatrix}0 \\\\ 1 \end{bmatrix} = \ket { 1 } .
$$

### <a name="example-representing-the-hadamard-operation-with-dirac-notation"></a>Пример. представление операции Хадамард с нотацией Дирак

Следующая нотация часто используется для описания состояний, которые возникают в результате применения шлюза хадамард к $ \ket { 0 } $ и $ \ket { 1 } $ (который соответствует векторам единиц в $ направлениях + x $ и $ -x в $ БЛОЧ Sphere):

$$
\frac{1 } { \sqrt { 2 } } \begin{bmatrix} 1 \\\\ 1 \end{bmatrix} = ч \ket { 0 } = \ket { + } ,\qquad
\frac{1 } { \sqrt { 2 } } \begin{bmatrix} 1 \\\\ – 1-один \end{bmatrix} = H \ket { 1 } = \ket { - } .
$$

Эти состояния также можно расширить с помощью нотации Дирак в виде сумм $ \ket { 0 } $ и $ \ket { 1 } $ :

$$
\ket{+}= \frac{ 1 } { \sqrt { 2 } } ( \ket { 0 }  +  \ket { 1 } ), \qquad \ket { - } = \frac { 1 } { \sqrt { 2 } } ( \ket { 0 }  -  \ket { 1 } ).
$$

### <a name="computational-basis-vectors"></a>Векторы вычислительных операций

Это показывает, почему эти состояния часто называются *вычислительными*. Каждое состояние такта всегда может выражаться в виде сумм базисных векторов вычислений, а такие суммы легко выражаются с помощью нотации Дирак.  Обратное также значение true в том, что состояния, $ \ket { + } $ а $ \ket { - } $ также формируют базу для состояний тактов.  Это видно из того факта, что

$$
\ket{0 } = \frac { 1 } { \sqrt { 2 } } ( \ket { + }  +  \ket { - } ), \qquad \ket { 1 } = \frac { 1 } { \sqrt { 2 } } ( \ket { + }  -  \ket { - } ).
$$

В качестве примера нотации Дирак рассмотрим «тормоз $ \braket { 0 | 1 } $ », который является внутренним продуктом от $ 0 $ до $ 1 $ .  Его можно записать как 

$$
\braket{0 1 0 1 0 | } = \begin{bmatrix} & \end{bmatrix} \begin{bmatrix} \\\\ \end{bmatrix} = .
$$

Это говорит о том, что $ \ket { 0 } $ и $ \ket { 1 } $ являются ортогональными векторами, то есть $ \braket { 0 | 1 } = \braket { 1 | 0 } = $ .  Кроме определения $ \braket { 0 | 0 1 1 1 } = \braket { | , это } = $ означает, что два вычислительных вектора могут также называться *орсонормал*.

Эти свойства орсонормал будут полезны в следующем примере. Если у нас есть состояние $ \ket { \psi } = { \frac { 3 } { 5 } } \ket { 1 }  +  { \frac { 4 } { 5 } } \ket { 0, } $ то из $ \braket { -за 1 | 0 } = 0 $ вероятности измерения $ 1 $ 

$$
\big|\braket{1 | \psi } \big | ^ 2 = \left | \frac { 3 } { 5 } \braket { 1 | 1 }  + \frac { 4 } { 5 } \braket { 1 | 0 } \right | ^ 2 = \frac { 9 } { 25 } .
$$

### <a name="tensor-product-notation"></a>Запись продукта тензорные

Нотация Дирак также включает в себя неявную структуру продуктов тензорные.  Это важно, поскольку в тактовых вычислениях вектор состояния, описанный двумя некоррелированными тактовыми регистрами, является тензорные продуктами двух векторов состояния.  Чтобы объяснить тактовую информацию, необходимо кратко описать структуру продукта тензорные или ее отсутствие.  Структура продукта тензорные подразумевает, что мы можем писать $ \psi \otimes \phi $ для любых двух векторов состояния такта $ \phi $ и $ \psi $ $ \ket { \psi } \ket { \phi } $ , как правило, они явно записаны как $ \ket { \psi } \otimes \ket { \phi } $ , однако в этом случае не требуется использовать правила записи $ \otimes $ между векторами.  Например, состояние с двумя Кубитс, инициализированными в нулевом состоянии, присваивается следующим образом:

$$
\begin{bmatrix}1 0 0 0 1 0 1 0 0 0 \\\\ \\\\ \\\\ \end{bmatrix} = \begin{bmatrix} \\\\ \end{bmatrix} \otimes \begin{bmatrix} \\\\ \end{bmatrix} = \ket { } \otimes \ket { } = \ket { } \ket { } .
$$

Аналогично, состояние $ \ket { p } $ для Integer $ p $ представляет состояние такта, которое кодирует в двоичном представлении целое $ число $ p.  Например, если нам нужно выразить число $ 5 $ с помощью двоичной кодировки без знака, мы могли бы выразить это как

$$
\ket{1 } \ket { 0 } \ket { 1 } = \ket { 101 } = \ket { 5 } .
$$

В этой нотации $ \ket { 0 } $ не требуется ссылаться на одно кубит состояние, а *кубит регистр* , в котором хранится двоичная кодировка $ 0 $ .  Различия между этими двумя нотациями обычно понятны из контекста.  Это соглашение полезно для упрощения первого примера, который может быть написан одним из следующих способов.

$$
\begin{bmatrix}1 \\\\ 0 \end{bmatrix} \otimes \cdots \otimes \begin{bmatrix} 1 \\\\ 0 \end{bmatrix} = \ket { } \otimes \cdots \otimes \ket { } = | \cdots \rangle = \ket { } ^ { \otimes } = \ket { } 0 0 0.
$$

### <a name="example-describing-superposition-with-dirac-notation"></a>Пример. Описание Дирак с помощью нотации

Еще один пример того, как можно использовать нотацию Дирак для описания состояния такта, рассмотрим следующие эквивалентные способы записи состояния такта, которое является равным преположением в каждой возможной битовой строке длиной $ n$

$$
H ^ { \otimes n } \ket { 0 } = \frac { 1 } { 2 ^ { n/2 } } \sum _ { j = 0 } ^ { 2 ^ n-1 } \ket { j } = \ket { + } ^ { \otimes n } .
$$

Здесь может возникнуть вопрос, почему сумма будет от $ 0 $ до $ 2 ^ { n } – 1 $ для $ n $ бит.  Сначала обратите внимание, что существует $ 2 ^ { n } $ различных конфигураций, которые $ $ могут занять n бит.  Это можно увидеть, отметив, что один бит может принимать $ 2 $ значения, но два бита могут принимать $ 4 $ значения и т. д. В общем случае это означает, что существует $ 2 ^ n $ разных возможных битовых строк, но наибольшее значение, закодированное в любом из них, $ \cdots равно 1 1 = 2 ^ n-1 $ и, следовательно, является верхним пределом суммы.
Обратите внимание, что в этом примере мы не использовали $ \ket { + } ^ { \otimes n } = \ket { + } $ в качестве аналогового для $ \ket { 0 } ^ { \otimes n } = \ket { 0, } $ так как это обычно зарезервировано для вычислительного состояния с каждым кубит, инициализированным нулем.  Хотя такое соглашение будет разумным в этом случае, оно не будет использоваться в литературе для обработки тактов.

### <a name="expressing-linearity-with-dirac-notation"></a>Выражать линейность с помощью нотации Дирак

Еще одна удобная функция нотации Дирак — это тот факт, что он линейный.  Если мы хотим писать для любых четырех векторов состояния такта, 

$$( \alpha \ket { \psi }  + \beta \ket { \phi } ) \otimes ( \gamma \ket { \чи }  +  \delta \ket { \omega } ) = \alpha \gamma \ket { \psi } \ket { \чи }  +  \alpha \delta \ket { \psi } \ket { \omega } + \beta \gamma \ket { \phi } \ket { \чи } + \beta \delta \ket { \phi } \ket { \omega } .$$

Это означает, что вы можете распределить нотацию продукта тензорные в нотации Дирак, чтобы взять тензорные продукты между векторами состояния, которые будут выглядеть так же, как обычное умножение.

Векторы неверное соответствуют тому же соглашению, что и векторы Сисакет.  Например, вектор $ \bra { \psi } \bra { \phi } $ эквивалентен вектору состояния $ \psi ^ \dagger \otimes \phi ^ \dagger = ( \psi \otimes \phi ) ^ \dagger $ . Если вектор Сисакет $ \ket { \psi } $ равен $ \alpha \ket { 0 }  +  \beta \ket { 1 } $ , то векторная версия вектора неверное имеет значение $ \bra { \psi } = \ket { \psi } ^ \dagger = ( \bra { 0 } \alpha ^ * + \bra { 1 } \beta ^ *) $ .

Например, представьте, что мы хотим вычислить вероятность измерения состояния $ \ket { \psi } = \frac { 3 } { 5 } \ket { 1 }  +  \frac { 4 } { 5 } \ket { 0 } $ с помощью тактовой программы для измерения состояний как $ \ket { + } $ или $ \ket { - } $ . Затем вероятность того, что устройство $ выводит состояние \ket { - } $ 

$$|\braket{- |\psi}| ^ 2 = \left | \frac { 1 } { \sqrt { 2 } } ( \bra { 0 }  -  \bra { 1 } ) ( \frac { 3 } { 5 } \ket { 1 }  +  \frac { 4 } { 5 } \ket { 0 } ) \right | ^ 2 = \left | - \frac { 3 } { 5 \sqrt { 2 } }  +  \frac { 4 } { 5 \sqrt { 2 } } \right | ^ 2 = \frac { 1 } { 50 } .$$

Тот факт, что отрицательный знак отображается в вычислении вероятности, является проявлением тактовых помех, которые являются одним из механизмов, с помощью которых тактовые вычисления получают преимущества по сравнению с классическими вычислениями.

## <a name="ketbra-or-outer-product"></a>кетбра или внешний продукт

Последним элементом, который стоит обсудить в нотации Дирак, является *кетбра* или внешний продукт.  Внешний продукт представлен в нотациях Дирак как $ \ket { \psi } \bra { \phi } $ , и иногда называется кетбрас, так как Брас и КЕТС встречаются в обратном порядке как Бракетс.  Внешний продукт определяется посредством умножения матрицы $ \ket { \psi } \bra { \phi } = \psi \phi ^ \dagger $ для векторов состояния такта $ \psi $ и $ \phi $ .  Самый простой и, вероятно, наиболее распространенный пример этой нотации:

$$
\ket{0 } \bra { 0 } = \begin{bmatrix} 1 \\\\ 0 1 0 \end{bmatrix} \begin{bmatrix} & \end{bmatrix} = \begin{bmatrix} 1 & 0 \\\\ & \end{bmatrix} \qquad \ket { } \bra { } = \begin{bmatrix} \\\\ \end{bmatrix} \begin{bmatrix} & \end{bmatrix} = \begin{bmatrix} & \\\\ & \end{bmatrix} 0 0 1 1 0 1 0 0 0 0 1.
$$

Кетбрас часто называются проекторами, так как они проецирует состояние такта в фиксированное значение.  Так как эти операции не являются едиными (и даже не сохраняют нормы вектора), они должны быть не удивительно, что тактовый компьютер не может детерминированно применять проектор.  Однако Проекторы представляют собой прекрасную задачу, описывающую действие, которое измерение имеет в состоянии такта.  Например, если измерение состояния $ \ket { \psi } $ должно быть $ равно 0, то $ результирующее преобразование, которое имеет состояние в результате измерения, будет

  $$\ket{\psi}\right \frac стрелка { ( \ket { 0 } \bra { 0 } ) \ket { \psi } } { | \braket { 0 | \psi } | } = \ket { 0 } ,$$

как и в случае, если необходимо измерить состояние и найти его как $ \ket { 0 } $ .  Чтобы повторно выполнить итерацию, такие Проекторы не могут быть применены к состоянию на компьютере-такте детерминированно.  Вместо этого они могут применяться случайным образом, при этом результат $ \ket { 0 будет } $ отображаться с некоторой фиксированной вероятностью.  Вероятность того, что такое измерение будет продолжено, можно записать как значение ожидания для тактовой репроектора в состоянии.

$$
\bra{\psi}( \ket { 0 } \bra { 0 } ) \ket { \psi } = | \braket { \psi | 0 } | ^ 2,$$

Это показывает, что Проекторы просто предоставляют новый способ представления процесса измерения.

Если вместо этого мы рекомендуем измерять первый кубит состояния кубит равным $ 1, $ мы также можем описать этот процесс, используя проекторы и нотацию Дирак:

$$
P ( \text { First кубит = 1 } ) = \bra { \psi } \left ( \ket { 1 } \bra { 1 } \otimes \boldone ^ { \otimes n-1 } \right ) \ket { \psi } .
$$

Здесь матрица идентификаторов можно легко написать в нотации Дирак.

$$
\boldone= \ket{ 0 } \bra { 0 1 1 1 } + \ket { } \bra { } = \begin{bmatrix} & 0 \\\\ 0 & 1 \end{bmatrix} .
$$

В случае с двумя Кубитс проектор можно расширить, как 

$$
\ket{1 1 1 1 } \bra { } \otimes \id = \ket { } \bra { } \otimes ( \ket { 0 } \bra { 0 } + \ket { 1 } \bra { 1 } ) = \ket { 10 } \bra { 10 }  +  \ket { 11 11 } \bra { } .
$$

Затем можно увидеть, что это согласуется с обсуждением вероятностей измерений для состояний мултикубит, использующих нотацию вектора столбцов:

$$
P ( \text { First кубит = 1 } ) = \psi ^ \dagger (e \_ { 10 } e \_ { 10 } ^ \dagger + e \_ { 11 } e \_ { 11 } ^ \dagger ) \psi = | e \_ { 10 } ^ \dagger \psi | ^ 2 + | e \_ { 11 } ^ \dagger \psi | ^ 2,$$

который соответствует обсуждению кубит измерения.  Тем не менее, обобщение этого результата в кубит случае немного более проста для выражения с использованием нотации Дирак, чем нотация вектора столбцов, и полностью эквивалентно предыдущему излечения.

## <a name="density-operators"></a>Операторы плотности

Еще один полезный оператор для выражения с использованием нотации Дирак — это *оператор плотности*, иногда также называемый *оператором State*.
Оператор плотности для вектора состояния такта имеет форму $ \рхо = \ket { \psi } \bra { \psi } $ .
Эта концепция, представляющая состояние как матрица, а не вектор, зачастую удобна, поскольку она предоставляет удобный способ представления вычислений вероятности, а также позволяет описать как статистическую неопределенность, так и неопределенность такта в одном и том же формальном процессе.
Общие операторы состояния такта, а не векторы, являются повсеместными в некоторых областях тактовых вычислений, но не являются обязательными для понимания основ поля.
Для заинтересованного читателя рекомендуется ознакомиться с одной из справочных книг, предоставленных в, [для получения дополнительных сведений](xref:microsoft.quantum.more-information).

## <a name="no-locq-gate-sequences-equivalent-to-quantum-states"></a>Q# последовательности шлюзов, эквивалентные состояниям тактов

Наконец, следует обратить внимание на тактовую нотацию и Q# язык программирования: в SES этого документа мы упомянули, что состояние такта является фундаментальным объектом информации в тактовых вычислениях.  Это может привести к неожиданному Q# возникновению состояния такта.  Вместо этого все состояния описываются только операциями, используемыми для их подготовки.  Предыдущий пример — это отличная иллюстрация этого.  Вместо того чтобы выражать единую подстановку для каждой строки тактового бита в регистре, результат можно представить как $ H ^ { \otimes n } \ket { 0 } $ .  Это экспоненциально-короткое описание состояния не только является преимуществом, которое можно реализовать в классическом виде, но оно также четко определяет операции, необходимые для распространения в стек программного обеспечения для реализации алгоритма.  По этой причине Q# она предназначена для создания последовательностей шлюзов, а не состояний тактов, однако на теоретическом уровне две перспективы эквивалентны.
