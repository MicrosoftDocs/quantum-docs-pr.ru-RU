---
title: Обозначения Дирака
description: Сведения об использовании нотации Дирак для представления тактовых состояний и имитации операций такта.
author: QuantumWriter
uid: microsoft.quantum.concepts.dirac
ms.author: nawiebe@microsoft.com
ms.date: 12/11/2017
ms.topic: article
no-loc:
- $
- $
- $
- $
- $
- $
- '\cdots'
- bmatrix
- '\ddots'
- '\equiv'
- '\sum'
- '\begin'
- '\end'
- '\sqrt'
- '\otimes'
- '{'
- '}'
- '\text'
- '\phi'
- '\kappa'
- '\psi'
- '\alpha'
- '\beta'
- '\gamma'
- '\delta'
- '\omega'
- '\bra'
- '\ket'
- '\boldone'
- '\\\\'
- '\\'
- =
- '\frac'
- '\text'
- '\mapsto'
- '\dagger'
- '\to'
- "\begin{cases}"
- "\end{cases}"
- '\operatorname'
- '\braket'
- '\id'
- '\expect'
- '\defeq'
- '\variance'
- '\dd'
- '&'
- "\begin{align}"
- "\end{align}"
- '\Lambda'
- '\lambda'
- '\Omega'
- '\mathrm'
- '\left'
- '\right'
- '\qquad'
- '\times'
- '\big'
- '\langle'
- '\rangle'
- '\bigg'
- '\Big'
- '|'
- '\mathbb'
- '\vec'
- '\in'
- '\texttt'
- '\ne'
- <
- '>'
- '\leq'
- '\geq'
- ~~
- "~"
- "\begin{bmatrix}"
- "\end{bmatrix}"
- '\_'
ms.openlocfilehash: f9dddfa25e9fd1e3d8aaf92b2e3b17c96ed8b72a
ms.sourcegitcommit: 0181e7c9e98f9af30ea32d3cd8e7e5e30257a4dc
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/23/2020
ms.locfileid: "85269512"
---
# <a name="dirac-notation"></a>Нотация Дирак

Хотя нотация векторов столбцов является повсеместной в линейной перерезке, она часто бывает очень громоздкими в тактовых вычислениях, особенно при работе с несколькими Кубитс.  Например, если определить $ \пси как $ вектор, явно не ясно, является ли $ \пси $ строкой или вектором столбца.  Таким образом, если $ \фи $ и $ \пси $ являются векторами, то не менее ясно, если значение $ \фи \пси $ определено, так как формы $ \фи $ и $ \пси $ могут быть неясными в контексте.  Помимо неоднозначности в фигурах векторов, выражения с простыми векторами с использованием линейной алгебраические нотации, представленной ранее, могут быть очень громоздкими. Например, если нам нужно описать $ состояние $n-кубит, где каждый кубит принимает значение $0, то это $ будет формально выражаться в состоянии 

$ $ \бегин{ bmatrix } 1 \\ \\ 0 \енд{ bmatrix } \отимес \кдотс \отимес \begin { bmatrix } 1 \\ \\ 0 \енд{ bmatrix } . $$  

Конечно, оценка этого продукта тензорные непрактична, поскольку вектор находится в экспоненциально больших пространствах, поэтому Эта нотация фактически является лучшим описанием состояния, которое может быть предоставлено с помощью предыдущей нотации.  

[*Нотация Дирак*](https://en.wikipedia.org/wiki/Bra%E2%80%93ket_notation) решает эти проблемы, предоставляя новый язык для удовлетворения точных потребностей механизма такта.  По этой причине мы рекомендуем читателям не просматривать примеры в этом разделе в качестве жесткого рецепта того, как описать состояния такта, а не Рекомендуйте читателю просматривать их в качестве предложений, которые можно использовать для краткого выражения тактовых идей.

Существует два типа векторов в нотации Дирак: вектор *неверное* и вектор *Сисакет* , так что они именуются, так как при объединении они образуют *двусторонний или внутренний* продукт.  Если $ \пси $ является вектором столбцов, то его можно записать в нотации Дирак как $ \кет { \пси } $, где $ \кет { \кдот } $ означает, что это вектор столбцов единиц, т. е. вектор *Сисакет* .  Аналогичным образом, вектор строки $ \пси ^ \дагжер $ выражается как $ \бра { \пси } $. Иными словами, $ \пси ^ \дагжер $ получается путем применения сложного конжугатион с пошаговым вводом к элементам перестановки $ \пси $ . Нотация неверное-Сисакет напрямую подразумевает, что $ \бракет { \пси | \пси } $ является внутренним произведением вектора $ \пси $ с самим собой, что определяется определением $1 $ .  

Более того, если $ \пси $ и $ \фи $ являются векторами состояния такта, их внутренний продукт — $ \бракет { \фи | \пси $. это } означает, что вероятность измерения состояния $ \кет { \пси } $ равна $ \кет { \фи } $ — $ | \бракет { \фи | \пси } | ^ 2 $ .  

Приведенное ниже соглашение используется для описания состояний тактов, которые задают значения 0 и One (однокубитные вычислительные состояния):

$ $ \бегин{ bmatrix } 1 \\ \\ 0 \енд{ bmatrix } = \ket{0 } , \ккуад \бегин{ bmatrix } 0 \\ \\ 1 \енд{ bmatrix } = \ket{1 } .
$$

### <a name="example-representing-the-hadamard-operation-with-dirac-notation"></a>Пример. представление операции Хадамард с нотацией Дирак

Следующая нотация часто используется для описания состояний, которые появляющиеся результатом применения вентиля Хадамард к $ \ket{0 } $ и $ \ket{1 } $ (что соответствует векторам единиц в направлениях $ + x $ и $-x в $ БЛОЧ Sphere):

$ $ \frac{1 } {\sqrt{2 } } \бегин{ bmatrix } 1 \\ \\ 1 \енд{ bmatrix } = H \ket {0 } = \кет { +}, \ккуад \frac{1 } {\sqrt{2 } } \бегин{ bmatrix } 1 \\ \\ -1 \енд{ bmatrix } = H \ket {1 } = \кет { -}.
$$

Эти состояния также можно расширить с помощью нотации Дирак как суммы $ \ket{0 } $ и $ \ket{1 } $:

$ $ \кет { +} = \frac{1 } {\sqrt{2 } } (\ket{0 } + \ket{1 } ), \ккуад \кет { -} = \frac{1 } {\sqrt{2 } } (\ket{0 } -\ket{1 } ).
$$

### <a name="computational-basis-vectors"></a>Векторы вычислительных операций
Это показывает, почему эти состояния часто называются *вычислительными*. Каждое состояние такта всегда может выражаться в виде сумм базисных векторов вычислений, а такие суммы легко выражаются с помощью нотации Дирак.  Обратное также значение true в том, что состояния $ \кет { +} $ и $ \кет { -} $ также формируют базу для состояний тактов.  Это видно из того факта, что

$ $ \ket{0 } = \frac{1 } {\sqrt{2 } } (\кет { +} + \кет { -}), \ккуад \ket{1 } = \frac{1 } {\sqrt{2 } } (\кет { +}-\кет { -}).
$$

В качестве примера нотации Дирак рассмотрите «\braket{0 | 1 } $», который является внутренним продуктом между $0 $ и $1 $ .  Его можно записать как 

$ $ \braket{0 | 1 } = \бегин{ bmatrix } 1 & 0 \енд{ bmatrix } \бегин{ bmatrix } 0 \\\\ 1 \end{bmatrix} = 0. $ $

Это говорит о том, что $ \ket{0 } $ и $ \ket{1 } $ являются ортогональными векторами, то есть $ \braket{0 | 1 } = \braket{1 | 0 } = 0 $ .  Также по определению $ \braket{0 | 0 } = \braket{1 | 1 } = 1 $ , что означает, что два вычислительных вектора также могут называться *орсонормал*.
Эти свойства орсонормал будут полезны в следующем примере. Если у нас есть состояние $ \кет { \пси } = {\frac{3 } {5 } } \ket{1 } + {\frac{4 } {5 } } \ket{0 } $, так как $ \braket{1 | 0 } = 0 $ вероятность измерения $1 $ составляет  

$ $ \биг | \braket{1 | \пси } \биг | ^ 2 = \лефт | \frac{3 } {5 } \braket{1 | 1 } + \frac{4 } {5 } \braket{1 | 0 } \ригхт | ^ 2 = \frac{9 } {25 } . $ $ 

### <a name="tensor-product-notation"></a>Запись продукта тензорные
Нотация Дирак также включает в себя неявную структуру продуктов тензорные.  Это важно, поскольку в тактовых вычислениях вектор состояния, описанный двумя некоррелированными тактовыми регистрами, является тензорные продуктами двух векторов состояния.  Чтобы объяснить тактовую информацию, необходимо кратко описать структуру продукта тензорные или ее отсутствие.  Структура продукта тензорные подразумевает, что мы можем написать $ \пси \отимес \фи $ для любых двух векторов состояния такта $ \фи $ и $ \пси $ как $ \кет { \пси } \кет { \фи } $, иногда явно написанных как $ \кет \пси \отимес \кет { } { \фи } $, однако по правилам написания $ \отимес $ в между векторами не требуется.  Например, состояние с двумя Кубитс, инициализированными в нулевом состоянии, присваивается следующим образом:

$ $ \бегин{ bmatrix } 1 \\ \\ 0 0 \\ \\ \\ \\ \енд{ bmatrix } = \бегин{ bmatrix } 1 \\ \\ 0 \енд{ bmatrix } \отимес \бегин{ bmatrix } 1 \\ \\ 0 \енд{ bmatrix } = \ket{0 } \отимес \ket{0 } = \ket{0 } \ket{0 } .
$$

Аналогично, состояние $ \кет{п } $ для integer $p $ представляет состояние такта, которое кодирует в двоичном представлении целого числа $p $ .  Например, если нам нужно выразить число $5, $ используя неподписанную двоичную кодировку, мы могли бы выразить это как

$ $ \ket{1 } \ket{0 } \ket{1 } = \ket{101 } = \ket{5 } .
$$

В этой нотации $ \ket{0 } $ не требуется ссылаться на состояние с одним кубит, а *кубит регистр* , в котором хранится двоичная кодировка $0 $ .  Различия между этими двумя нотациями обычно понятны из контекста.  Это соглашение полезно для упрощения первого примера, который может быть написан одним из следующих способов.

$ $ \бегин{ bmatrix } 1 \\ \\ 0 \енд{ bmatrix } \отимес \кдотс \отимес \begin { bmatrix } 1 \\ \\ 0 \енд{ bmatrix } = \ket{0 } \отимес \кдотс \отимес \ket{0 } = | 0 \cdots 0 \rangle = \ket{0 } ^ {\отимес n } = \ket{0 } .
$$

### <a name="example-describing-superposition-with-dirac-notation"></a>Пример. Описание Дирак с помощью нотации
Еще один пример того, как можно использовать нотацию Дирак для описания состояния такта, рассмотрим следующие эквивалентные способы записи состояния такта, которое является равным преположением в каждой возможной битовой строке длины $n$

$ $ H ^ {\отимес n } \ket{0 } = \frac{1 } {2 ^ {n/2 } } \ sum_ {j = 0 } ^ {2 ^ n-1 } \кет{ж } = \кет { +} ^ {\отимес n } .
$$

Здесь может возникнуть вопрос, почему сумма проходит от $0 $ до $2 ^ {n } -1 $ для $n $ бит.  Прежде всего, обратите внимание на то, что существует $2 ^ {n } $ различных конфигураций, которые $ могут потребоваться для $n BITS.  Это можно увидеть, отметив, что один бит может принимать $2 $ значений, но два бита могут принимать $ значения $4 и т. д. Как правило, это означает, что существует $2 ^ n $ различных возможных битовых строк, но наибольшее значение, закодированное в любом из них $1 \cdots 1 = 2 ^ n-1 $ и, следовательно, является верхним пределом суммы.
Обратите внимание, что в этом примере мы не использовали $ \кет { +} ^ {\отимес n } = \кет { +} $ в аналогии с $ \ket{0 } ^ {\отимес n } = \ket{0 $, } так как это соглашение об нотации обычно резервируется для вычислительного состояния с каждым кубит, инициализированным нулем.  Хотя такое соглашение будет разумным в этом случае, оно не будет использоваться в литературе для обработки тактов.

### <a name="expressing-linearity-with-dirac-notation"></a>Выражать линейность с помощью нотации Дирак
Еще одна удобная функция нотации Дирак — это тот факт, что он линейный.  Если мы хотим писать для любых четырех векторов состояния такта, 

$ $ (\алфа \кет { \пси } + \бета \ket { \фи } ) \отимес (\гамма \кет { \чи } + \делта \кет { \омега } ) = \алфа \gamma \кет { \пси } \кет { \chi } + \alpha \delta \ket { \psi } \ket { \omega } + \beta \gamma \ket { \Phi } \ket { \chi } \beta \delta \ket { \Phi } \ket { \omega } . $ $

Это означает, что вы можете распределить нотацию продукта тензорные в нотации Дирак, чтобы взять тензорные продукты между векторами состояния, которые будут выглядеть так же, как обычное умножение.

Векторы неверное соответствуют тому же соглашению, что и векторы Сисакет.  Например, вектор $ \бра { \пси } \бра { \фи } $ эквивалентен вектору состояния $ \пси ^ \дагжер \отимес \фи ^ \дагжер = (\пси \otimes \фи) ^ \дагжер $ . Если Сисакет Vector $ \кет { \пси } $ имеет значение $ \алфа \ket{0 } + \бета \ket{1 } $, то векторная версия неверное Vector — $ \бра { \пси } = \кет { \пси } ^ \дагжер = (\bra{0 } \алфа ^ * + \bra{1 } \бета ^ *) $.

В качестве примера представьте себе, что мы хотим рассчитать вероятность измерения состояния $ \кет { \пси } = \frac{3 } {5 } \ket{1 } + \frac{4 } {5 } \ket{0 } $ с помощью тактовой программы для измерения состояний как $ \кет { +} $ или $ \кет { -} $. Затем вероятность того, что устройство выводит состояние $ \кет { -} $ 

$ $ | \бракет { -| \пси } | ^ 2 = \лефт | \frac{1 } {\sqrt{2 } } (\bra{0 } -\bra{1 } ) (\frac{3 } {5 } \ket{1 } + \frac{4 } {5 } \ket{0 } ) \ригхт | ^ 2 = \лефт | -\frac{3 } {5 \sqrt {2 } } + \frac{4 } {5 \sqrt {2 } } \ригхт | ^ 2 = \frac{1 } {50 } . $ $

Тот факт, что отрицательный знак отображается в вычислении вероятности, является проявлением тактовых помех, которые являются одним из механизмов, с помощью которых тактовые вычисления получают преимущества по сравнению с классическими вычислениями.

## <a name="ketbra-or-outer-product"></a>кетбра или внешний продукт
Последним элементом, который стоит обсудить в нотации Дирак, является *кетбра* или внешний продукт.  Внешний продукт представлен в нотациях Дирак как $ \кет { \пси } \бра { \фи } $ и иногда называется кетбрас, так как Брас и КЕТС встречаются в обратном порядке как Бракетс.  Внешний продукт определяется посредством умножения матрицы как $ \кет { \пси } \бра { \фи } = \пси \фи ^ \дагжер $ для векторов состояния такта $ \пси $ и $ \фи $ .  Самый простой и, вероятно, наиболее распространенный пример этой нотации:

$ $ \ket{0 } \bra{0 } = \бегин{ bmatrix } 1 \\\\ 0 \енд{ bmatrix } \бегин{ bmatrix } 1&0 \енд{ bmatrix } = \бегин{ bmatrix } 1 &0 \\\\ 0 &0 \end{bmatrix} \ккуад \ket{1 } \bra{1 } = \бегин{ bmatrix } 0 \\\\ 1 \енд{ bmatrix } \бегин{ bmatrix } 0&1 \енд{ bmatrix } = \бегин{ bmatrix } 0 &0 \\\\ 0 &1 \end{bmatrix} .
$$

Кетбрас часто называются проекторами, так как они проецирует состояние такта в фиксированное значение.  Так как эти операции не являются едиными (и даже не сохраняют нормы вектора), они должны быть не удивительно, что тактовый компьютер не может детерминированно применять проектор.  Однако Проекторы представляют собой прекрасную задачу, описывающую действие, которое измерение имеет в состоянии такта.  Например, если измерение State $ \кет { \пси } $ должно быть $0, то результатом такого $ преобразования является то, что его состояние является результатом измерения.

  $ $ \кет { \пси } \ригхтарров \фрак { (\ket{0 } \bra{0 } ) \кет { \пси } } {| \braket{0 | \пси } |} = \ket{0 } , $ $

как и в случае, если необходимо измерить состояние и найти его как $ \ket{0 } $.  Чтобы повторно выполнить итерацию, такие Проекторы не могут быть применены к состоянию на компьютере-такте детерминированно.  Вместо этого они могут быть применены случайным образом, при этом результат $ \ket{0 } $ появлялся с фиксированной вероятностью.  Вероятность того, что такое измерение будет продолжено, можно записать как значение ожидания для тактовой репроектора в состоянии.

$ $ \бра { \пси } (\ket{0 } \bra{0 } ) \кет { \пси } = | \бракет { \пси | 0 } | ^ 2, $ $

Это показывает, что Проекторы просто предоставляют новый способ представления процесса измерения.

Если вместо этого мы рекомендуем измерять первый кубит состояния кубит до $1, $ мы можем также описать этот процесс, используя проекторы и нотацию Дирак:

$ $ P (\текст{Фирст кубит = 1 } ) = \бра { \пси } \лефт (\ket{1 } \bra{1 } \отимес \болдоне ^ {\отимес n-1 } \ригхт) \кет { \пси } .
$$

Здесь матрица идентификаторов можно легко написать в нотации Дирак.

$ $ \болдоне = \ket{0 } \bra{0 } + \ket{1 } \bra{1 } = \бегин{ bmatrix } 1&0 \\\\ 0&1 \енд{ bmatrix } .
$$

В случае с двумя Кубитс проектор можно расширить, как 

$ $ \ket{1 } \bra{1 } \отимес \ид = \ket{1 } \bra{1 } \отимес (\ket{0 } \bra{0 } + \ket{1 } \bra{1 } ) = \ket{10 } \bra{10 } + \ket{11 } \bra{11 } .
$$

Затем можно увидеть, что это согласуется с обсуждением вероятностей измерений для состояний мултикубит, использующих нотацию вектора столбцов:

$ $ P (\текст{Фирст кубит = 1 } ) = \пси ^ \дагжер (e \_ {10} e \_ {10 } ^ \дагжер + e \_ {11} e \_ {11 } ^ \дагжер) \пси = | e \_ {10 } ^ \дагжер \пси | ^ 2 + | e \_ {11 } ^ \дагжер \пси | ^ 2, $ $

который соответствует обсуждению кубит измерения.  Тем не менее, обобщение этого результата в кубит случае немного более проста для выражения с использованием нотации Дирак, чем нотация вектора столбцов, и полностью эквивалентно предыдущему излечения.

## <a name="density-operators"></a>Операторы плотности

Еще один полезный оператор для выражения с использованием нотации Дирак — это *оператор плотности*, иногда также называемый *оператором State*.
Оператор плотности для вектора состояния такта имеет вид $ \рхо = \кет { \пси } \бра { \пси } $.
Эта концепция, представляющая состояние как матрица, а не вектор, зачастую удобна, поскольку она предоставляет удобный способ представления вычислений вероятности, а также позволяет описать как статистическую неопределенность, так и неопределенность такта в одном и том же формальном процессе.
Общие операторы состояния такта, а не векторы, являются повсеместными в некоторых областях тактовых вычислений, но не являются обязательными для понимания основ поля.
Для заинтересованного читателя рекомендуется ознакомиться с одной из справочных книг, предоставленных в, [для получения дополнительных сведений](xref:microsoft.quantum.more-information).

## <a name="q-gate-sequences-equivalent-to-quantum-states"></a>Q число последовательностей шлюзов эквивалентно состояниям такта
В заключение стоит обратить внимание на тактовую нотацию и язык программирования Q #: в SES этого документа мы упоминали, что состояние такта является фундаментальным объектом информации в тактовых вычислениях.  В то же самое, в Q # нет понятия о состоянии такта.  Вместо этого все состояния описываются только операциями, используемыми для их подготовки.  Предыдущий пример — это отличная иллюстрация этого.  Вместо того чтобы выражать единую подстановку для каждой строки тактового бита в регистре, результат можно представить как $H ^ {\отимес n } \ket{0 } $.  Это экспоненциально-короткое описание состояния не только является преимуществом, которое можно реализовать в классическом виде, но оно также четко определяет операции, необходимые для распространения в стек программного обеспечения для реализации алгоритма.  По этой причине функция Q # предназначена для создания последовательностей шлюзов, а не состояний тактов. Однако на теоретическом уровне две перспективы эквивалентны.
