---
Title: несколько Кубитс Description: Узнайте, как выполнять операции с двумя или более Кубитс.
Автор: брадбен UID: Microsoft. такт. Основные сведения. несколько Кубитс MS. author: v-бенбра MS. Дата: 12/11/2017 MS. Topic: статья No-Loc:
- "Q#"
- "$$v"
- "$$"
- "$$"
- "$"
- "$"
- "$"
- "$$"
- "\cdots"
- "bmatrix"
- "\ddots"
- "\equiv"
- "\sum"
- "\begin"
- "\end"
- "\sqrt"
- "\otimes"
- "{"
- "}"
- "\text"
- "\phi"
- "\kappa"
- "\psi"
- "\alpha"
- "\beta"
- "\gamma"
- "\delta"
- "\omega"
- "\bra"
- "\ket"
- "\boldone"
- "\\\\"
- "\\"
- "="
- "\frac"
- "\text"
- "\mapsto"
- "\dagger"
- "\to"
- "\begin{cases}"
- "\end{cases}"
- "\operatorname"
- "\braket"
- "\id"
- "\expect"
- "\defeq"
- "\variance"
- "\dd"
- "&"
- "\begin{align}"
- "\end{align}"
- "\Lambda"
- "\lambda"
- "\Omega"
- "\mathrm"
- "\left"
- "\right"
- "\qquad"
- "\times"
- "\big"
- "\langle"
- "\rangle"
- "\bigg"
- "\Big"
- "|"
- "\mathbb"
- "\vec"
- "\in"
- "\texttt"
- "\ne"
- "<"
- ">"
- "\leq"
- "\geq"
- "~~"
- "~"
- "\begin{bmatrix}"
- "\end{bmatrix}"
- "\_"

---

# <a name="multiple-qubits"></a>Несколько Кубитс

Хотя однокубитные шлюзы обладают некоторыми интуитивно понятными функциями со счетчиками, например возможность находиться в нескольких состояниях в определенный момент времени, если все, что было на такте, было только один кубит, то у нас будет устройство с вычислительной мощностью, которое было бы дварфед даже калькулятором, что сделает только классический компьютер.
Истинная сила тактовых вычислений стала очевидной только при увеличении числа Кубитс.
Эта степень возникнет, в части, так как размер векторного пространства векторов состояния такта растет экспоненциально с числом Кубитс.
Это означает, что хотя один кубит может быть тривиально смоделирован, при моделировании вычисления такта 50-кубит, вероятно, будут принудительно относиться ограничения существующих компьютеров.
Увеличение размера вычислений за счет только одного дополнительного кубит *удваивает* объем памяти, необходимой для хранения состояния, и примерно *удваивает* вычислительное время.
Это самое быстрое удвоение вычислительной мощности заключается в том, почему тактовый компьютер с относительно небольшим количеством Кубитс может значительно превысить наиболее мощные, завтра и более широкие возможности для некоторых вычислительных задач.

Почему у нас есть экспоненциальное увеличение векторов состояния тактов?  Наша цель в этом разделе — Просмотреть правила, используемые для сборки кубит состояний из одного кубит состояния, а также обсудить операции с шлюзами, которые необходимо включить в наш шлюз, чтобы сформировать компьютер с универсальным множеством кубит.
Эти средства абсолютно необходимы для понимания наборов шлюзов, которые часто используются в коде, Q# а также для получения интуиция о том, почему тактовые эффекты, такие как замкнутые или помехи, визуализируют тактовые вычисления более мощными, чем классические вычисления.

## <a name="representing-two-qubits"></a>Представление двух Кубитс
Основное различие между двумя и кубит состояниями состоит в том, что два-кубит состояния представляют собой четыре измерения, а не две.
Это обусловлено тем, что вычислительная базис для двух-кубит состояний формируется продуктами тензорные в одном кубит состоянии.  Например, у нас есть \begin{align}
00 \equiv \begin{bmatrix} 1 \\\\ 0 \end{bmatrix} \otimes \begin{bmatrix} 1 \\\\ 0 1 0 0 \end{bmatrix} & = \begin{bmatrix} \\\\ \\\\ \\\\ \end{bmatrix} , \qquad 01 \equiv \begin{bmatrix} 1 \\\\ 0 \end{bmatrix} \otimes \begin{bmatrix} 0 \\\\ 1 \end{bmatrix} = \begin{bmatrix} 0 \\\\ 1 0 0 \\\\ \\\\ \end{bmatrix} ,\\\\
10 \equiv \begin{bmatrix} 0 \\\\ 1 \end{bmatrix} \otimes \begin{bmatrix} 1 \\\\ 0 0 \end{bmatrix} & = \begin{bmatrix} \\\\ 0 \\\\ 1 \\\\ 0 \end{bmatrix} , \qquad 11 \equiv \begin{bmatrix} 0 \\\\ 1 \end{bmatrix} \otimes \begin{bmatrix} 0 \\\\ 1 0 0 \end{bmatrix} = \begin{bmatrix} \\\\ \\\\ 0 \\\\ 1 \end{bmatrix} .
\end{align}

Можно легко увидеть, что, как правило, состояние такта $ n $ Кубитс представляется вектором единиц измерения $ 2 ^ n $ с помощью этой конструкции.  Вектор

$$
\begin{bmatrix}\alpha _ { 00 } 01 \\\\ 10 \alpha   _ { } \\\\ \alpha _ { 11 } \\\\ \alpha   _ { }  \end{bmatrix}
$$

представляет состояние такта для двух Кубитс, если $ | \alpha _ { 00 } | ^ 2 | \alpha +_ { 01 } | ^ 2 + | \alpha _ { 10 } | ^ 2 | \alpha +_ { 11 } | ^ 2 = 1 $ . Точно так же, как и в случае с одиночным Кубитс, вектор состояния такта нескольких Кубитс содержит всю информацию, необходимую для описания поведения системы.

Если у нас есть два отдельных Кубитс, один в состоянии, $ \begin{bmatrix} \alpha \\\\ \beta \end{bmatrix} $ а второй кубит в состоянии $ \begin{bmatrix} \gamma \\\\ \delta \end{bmatrix} $ , соответствующее состояние в два-кубит равно    

$$
\begin{bmatrix} \alpha \\\\  \beta \end{bmatrix} \otimes \begin{bmatrix} \gamma \\\\  \delta \end{bmatrix} 
=\begin{bmatrix} \alpha \begin{bmatrix} \gamma \\\\  \delta \end{bmatrix} \\\\ \beta \begin{bmatrix}\gamma \\\\  \delta \end{bmatrix} \end{bmatrix}
= \begin{bmatrix} \alpha\gamma \\\\  \alpha\delta \\\\  \beta\gamma \\\\  \beta\delta \end{bmatrix}, $$

, где операция $ \otimes $ называется продуктом тензорные (или кронеккер Product) векторов. Обратите внимание, что хотя мы всегда можем взять тензорныеное произведение двух кубитных состояний, чтобы сформировать штат из двух-кубит, не все два кубит состояния такта могут быть написаны в виде тензорные продукта двух однокубит состояний.
Например, нет состояний $ \psi = \begin{bmatrix} \alpha \\\\ \beta \end{bmatrix} $ и $ \phi = \begin{bmatrix} \gamma \\\\ \delta \end{bmatrix} $ так, что их тензорныеный продукт является состоянием     

$$\psi\otimes\phi = \begin{bmatrix} 1/ \sqrt { 2 } \\\\ 0 \\\\ \\\\ 1/ \sqrt { 2 } \end{bmatrix} .$$ 

Кубит состояние, которое не может быть записано в качестве тензорные продукта с одним кубит, называется «запутанными State»; два Кубитс говорят как [*запутанными*](https://en.wikipedia.org/wiki/Quantum_entanglement).  Слабо говоря, поскольку состояние такта не может рассматриваться как тензорныеное произведение одного кубит состояния, информация, которая хранится в состоянии, не ограничивается ни одним из Кубитс по отдельности.  Вместо этого информация хранится не локально в корреляциях между двумя состояниями.  Такая Нелокальная информация является одной из основных отличительных особенностей тактовых вычислений при работе с классическими вычислениями и имеет большое значение для ряда серверных протоколов, включая передачу данных в [тактовую](https://github.com/microsoft/Quantum/tree/main/samples/getting-started/teleportation) передачу и [исправление ошибок такта](xref:microsoft.quantum.libraries.error-correction).

## <a name="measuring-two-qubit-states"></a>Измерение двух кубит состояний ##
Измерение двух-кубит состояний очень похоже на однокубитные измерения. Измерение состояния

$$
    \begin{bmatrix}
        \alpha_ { 00 } 01 \\\\ \alpha _ { }\\\\ 
        \alpha_ { 10 } 11 \\\\ \alpha _ {}
    \end{bmatrix}
$$

Возвращает $ 00 $ с вероятностью $ | \alpha _ { 00 } | ^ 2 $ , $ 01 $ $ | с \alpha вероятностью _ { 01 } | ^ 2 $ , $ 10 $ с вероятностью $ | \alpha _ { 10 } | ^ 2 $ и $ 11 $ с $ вероятностью | 11 \alpha _ { } | ^ 2 $ . Переменные $ \alpha _ { 00 } , \alpha _ { 01 } , \alpha _ { 10 } $ и $ 11 \alpha _ { } $ были намеренно именованы, чтобы сделать это соединение открытым. После измерения, если результат равен 00, $ $ состояние такта кубит системы будет свернуто и теперь

$$
    100,00 \equiv
    \begin{bmatrix}
        одного \\\\ 
        0,0 \\\\ 
        0,0 \\\\ 
        0 \end{bmatrix} .
$$

Можно также измерять только один кубит состояния такта из двух кубит. В случаях, когда измеряется только один из Кубитс, влияние измерения незначительно отличается, так как все состояние не свернуто в вычислительное состояние, а только в одну подсистему.  Иными словами, в таких случаях измерение только одного кубит сворачивает только одну из подсистем, но не все из них.  

Чтобы увидеть это, оцените первую кубит следующего состояния, которое формируется путем применения Хадамард Transform $ H $ для двух Кубитс, изначально установленного в состояние "0": $$
H ^ 2 (1 0 1 0) 1 2 1 1 1 — 1 1-1 1-1 — 1 1-1-1 1 — один 1 0 0, { \otimes } \left \begin{bmatrix} \\\\ \end{bmatrix} \otimes \begin{bmatrix} \\\\ \end{bmatrix} \right = \frac { } { } \begin{bmatrix} & & & \\\\ & & & \\\\ & & & \\\\ & & & \end{bmatrix} \begin{bmatrix} \\\\ \\\\ \\\\ \end{bmatrix} = \frac { 1 2 1 1 1 1 } { } \begin{bmatrix} \\\\ \\\\ \\\\ \end{bmatrix} \mapsto \begin{cases} \text { , результат } = 0 & \frac { 1 2 1 1 } { \sqrt { } } \begin{bmatrix} \\\\ 0 0 \\\\ \\\\ \end{bmatrix} \\\\ \text { } = , результат 1 & \frac { 1 } { \sqrt { 2 } } \begin{bmatrix} 0 0 \\\\ \\\\ 1 \\\\ \end{bmatrix} \\\\ \end{cases} .  
$$
В обоих результатах возникает вероятность 50%.  Результат, равный 50% вероятности, может быть интуитед от того факта, что начальный вектор состояния такта является инвариантным при переключении $ 0 $ с $ 1 $ на первом кубит.

Математическое правило для измерения первой или второй кубит просто.  Если мы попробуем $ e_k $ быть $ { } $ однозначным вектором вычислений k ^ \рм и добавим $ $ набор всех $ e_k $ таким, что кубит в вопросе принимает значение $ 1 $ для этого значения $ k $ .  Например, если мы заинтересованы в измерении первого кубит, то $ $ будут состоять из $ e_1 \equiv 10 $ и $ e_3 \equiv 11 $ .  Аналогично, если мы заинтересованы во втором кубит, $ $ будет состоять из $ e_2 \equiv 01 $ и $ e_3 \equiv 11 $ .  Затем вероятность измерения выбранного кубита равна $ 1 $ для вектора состояния $\psi$

$$
P ( \text { результат } = 1) = \sum _ { e_k \text { в наборе } S } \psi ^ \dagger e_k e_k ^ \dagger \psi .
$$

> [!NOTE]
> В этом документе мы используем формат с прямым порядком байтов, чтобы обозначить вычислительную базу. В формате с прямым порядком байтов сначала наименее значащие биты. Например, число 4 в формате с прямым порядком байтов представлено строкой в битах 001.

Поскольку каждое измерение кубит может возвращать только $ 0 $ или $ 1 $ , вероятностью измерения $ 0 $ является просто $ 1 – P ( \text { результат } = 1) $ .  Именно поэтому мы явно выдаем формулу для вероятности измерения $ 1 $ .

Действие, в котором такое измерение имеет состояние, может быть выражено математическим образом.

$$
\psi\mapsto \frac{\sum _ { e_k \text { в наборе } S } e_k e_k ^ \dagger \psi } { \sqrt { P ( \text { результат } = 1) } } .
$$

Читатель с осторожностью может беспокоиться о том, что происходит, когда вероятность измерения равна нулю.  Хотя результирующее состояние технически не определено в этом случае, нам не нужно беспокоиться о таких возможностях, поскольку вероятность равна нулю!


Если мы будем использовать $ \psi $ однородный вектор состояния, заданный выше, и заинтересованы в измерении первого кубит, 

$$
P ( \text { измерение первых кубит } = 1) = ( \psi ^ \dagger e_1) (e_1 ^ \dagger \psi ) + ( \psi ^ \dagger e_3) (e_3 ^ \dagger \psi ) = | e_1 ^ \dagger \psi | ^ 2 + | e_3 ^ \dagger \psi | ^ 2.
$$

Обратите внимание, что это лишь сумма двух вероятностей, ожидаемых для измерения результатов $ 10 $ и 11 — $ все Кубитс, которые следует $ измерять.
В нашем примере результатом является

$$
\frac{1 } { 4 0 1 0 1 1 1 1 } \left | \begin{bmatrix} & & & \end{bmatrix} \begin{bmatrix} \\\\ \\\\ \\\\ \end{bmatrix} \right | ^ 2 + \frac { 1 } { 4 0 0 0 1 1 1 1 } \left | \begin{bmatrix} & & & \end{bmatrix} \begin{bmatrix} \\\\ \\\\ \\\\ \end{bmatrix} \right | ^ 2 = \frac { 1 } { 2 } .
$$

что вполне соответствует тому, что наш интуиция сообщает нам о вероятности.  Аналогично, состояние может быть записано как

$$
\frac{\frac{e_1 } { 2 } + \frac { e_3 } { 2 } } { \sqrt { \frac { 1 } { 2 } } } = \frac { 1 } { \sqrt { 2 } } \begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\\\ 1\end{bmatrix}
$$

еще раз в соответствии с нашим интуиция.

## <a name="two-qubit-operations"></a>Операции с двумя кубит
Как и в случае с одним кубит, любое единое преобразование является допустимой операцией в Кубитс. Как правило, единое преобразование в $ n $ Кубитс — это матрица $ U с $ размером $ 2 ^ n \times 2 ^ n $ (так что она работает с векторами размера $ 2 ^ n $ ), например $ u ^ { -1 } = U ^ \dagger $ .
Например, шлюз кнот (управляемый) является часто используемым кубитным шлюзом и представлен следующей единой матрицей:

$$
\operatorname{КНОТ } = \begin{bmatrix} 1 \ 0 \ 0 \ 0  \\\\  0 \ 1 \ 0 \ 0 \\\\  0 \ 0 \ 0 \ 1 \\\\  0 \ 0 \ 1 \ 0 \end{bmatrix}
$$

Также можно сформировать два кубит шлюза, применив шлюзы с одним кубит на Кубитс. Например, если мы применяем шлюз 

$$
\begin{bmatrix}
a \ b \\\\ c \ d \end{bmatrix}
$$

и

$$\begin{bmatrix}
e \ f \\\\ g \ h \end{bmatrix}
$$

к первому и второму Кубитс, соответственно, это эквивалентно применению двух-кубитых данных, находящиеся в их тензорные продукте: $$\begin{bmatrix}
a \ b \\\\ c \ d \end{bmatrix}
\otimes 
\begin{bmatrix}
e \ f \\\\ g \ h \end{bmatrix}=
    \begin{bmatrix}
    AE \ AF \ BF \\\\
    AG \ AH \ BG \ BH \\\\
    CE \ CF \ de \ DF \\\\
    CG \ CH \ \end{bmatrix} , DH.$$
Поэтому мы можем сформировать два кубит шлюза, приняв тензорные продукт некоторых известных шлюзов с одним кубитом. К примерам кубит шлюзов относятся $ h \otimes h $ , $ x \otimes \boldone $ и $ x \otimes Z $ .

Обратите внимание, что хотя любой из двух кубит шлюзов определяет кубитй шлюз с помощью продукта тензорные, это не так. Не все два кубита шлюза могут быть написаны как тензорные продукт с одним кубит.  Такой шлюз называется шлюзом *ентанглинг* . Одним из примеров шлюза ентанглинг является шлюз кнот.

Интуиция за контролируемый шлюз может быть обобщен к произвольным шлюзам.  Управляемый шлюз в общем случае — это шлюз, который выступает в роли Identity (IE не имеет действия), если только конкретный кубит не равен $ 1 $ .  Мы обмечаем управляемое единое, управляемое в данном случае для кубит $ с меткой x $ $ \Lambda \_ (U) $ .  Например, $ \Lambda _0 (u) e \_ { 1 } \otimes { \psi } = e \_ { 1 } \otimes U { \psi } $ и $ \Lambda \_ 0 (U) e \_ { 0 } \otimes { \psi } = e \_ { 0 } \otimes { \psi } $ , где $ e \_ 0 $ и $ e \_ 1 — это $ вычислительные векторы для одного кубит, соответствующего значениям $ 0 $ и $ 1 $ .  Например, рассмотрим следующий управляемый шлюз- $ Z, $ затем мы можем выразить это как $$
\Lambda\_0 (Z) 1 0 0 0 0 = \begin{bmatrix} & & & 1 0 0, 0 1 0 0 0 0 \\\\ & & & \\\\ & & & \\\\ & & & – 1 \end{bmatrix} = ( \boldone \otimes h) \operatorname { кнот } ( \boldone \otimes h).
$$

Очень сложно создавать контролируемые унитариес.  Самый простой способ реализации этого требует формирования базы данных с управляемыми версиями фундаментальных шлюзов и замены каждого фундаментального шлюза в исходной операции с управляемым аналогом.  Часто это довольно непроизводительна, и его можно использовать, чтобы просто заменить несколько шлюзов на контролируемые версии, чтобы добиться того же воздействия.  По этой причине мы предоставляем в нашей инфраструктуре возможность выполнения упрощенного метода управления или предоставления пользователю возможности определять управляемую версию единого, если известна оптимизированная вручную версия.

Шлюзы также можно контролировать с помощью классической информации.  Например, классический управляемый не шлюз — это просто обычный, но он применяется только в том случае, если Классический бит равен 1, а не $ $ биту.  В этом смысле классический управляемый шлюз можно рассматривать как оператор if в коде такта, где шлюз применяется только в одной ветви кода.


Как и в случае с одиночным кубит, набор кубитных шлюзов является универсальным, если какой-либо $ из четырех четырех однозначных \times $ матриц может быть приблизительным по продуктам шлюза, от этого набора до произвольной точности.
Одним из примеров универсального шлюза является шлюз Хадамард, T-шлюз и шлюз кнот. Используя продукты этих шлюзов, можно оценить любую единую матрицу на двух Кубитс.

## <a name="many-qubit-systems"></a>Многие кубит системы
Мы соблюдаем те же закономерности, которые просматривается в кубит случае, чтобы создать множество кубит состояний тактов из небольших систем.  Такие состояния создаются путем формирования тензорные продуктов с меньшими состояниями.  Например, рассмотрите возможность кодирования строки $ 1011001 $ на компьютере-такте.  Мы можем кодировать это как

$$
1011001 \equiv \begin{bmatrix} 0 \\\\ 1 \end{bmatrix} \otimes \begin{bmatrix} 1 \\\\ 0 \end{bmatrix} \otimes \begin{bmatrix} 0 \\\\ 1 \end{bmatrix} \otimes \begin{bmatrix} 0 \\\\ 1 \end{bmatrix} \otimes \begin{bmatrix} \\\\ \end{bmatrix} \otimes \begin{bmatrix} \\\\ \end{bmatrix} \otimes \begin{bmatrix} \\\\ \end{bmatrix} 1 0 1 0 0 1.
$$

Тактовый шлюз работает точно так же.  Например, если нужно применить $ $ шлюз X к первому кубит, а затем выполнить кнот между вторым и третьим Кубитс, мы можем выразить это преобразование как

\begin{align}
&(X \otimes \operatorname { кнот } _ { 304,8 } \otimes \boldone \otimes \boldone \otimes \boldone \otimes \boldone ) \begin{bmatrix} 0 \\\\ 1 \end{bmatrix} \otimes \begin{bmatrix} 1 \\\\ 0 \end{bmatrix} \otimes \begin{bmatrix} \\\\ \end{bmatrix} \otimes \begin{bmatrix} \\\\ \end{bmatrix} \otimes \begin{bmatrix} \\\\ \end{bmatrix} \otimes \begin{bmatrix} \\\\ \end{bmatrix} \otimes \begin{bmatrix} \\\\ 0 1 0 1 1 0 1 0 0 1\end{bmatrix}\\\\
&\qquad\qquad\equiv 0011001. \end{align}

Во многих кубит системах часто приходится распределять и освобождать Кубитс, которые служат временной памятью для тактового компьютера.  Такой кубит называется анЦилла.  По умолчанию предполагается, что состояние кубит инициализировано $ e_0 $ при выделении.  Далее предполагается, что он снова возвращается в $ e_0 $ перед освобождением.  Это предположение важно, поскольку если анЦилла кубит становится запутанными с другим кубит регистрацией после освобождения, процесс освобождения приведет к повреждению анЦилла.  По этой причине мы всегда Предположим, что такие Кубитс возвращены в исходное состояние до выпуска.

Наконец, хотя новые шлюзы, необходимые для добавления в наш шлюз для достижения универсальных тактовых вычислений для двух кубит тактов, новые шлюзы не должны вводиться в несколько кубит.  Шлюзы $ H $ , $ T $ и кнот формируют универсальный шлюз для многих Кубитс, так как любое общее преобразование можно разделить на ряд двух поворотов кубит.  Затем мы можем использовать теорию, разработанную для кубит корпуса, и повторить ее здесь, когда у нас много кубитсов.

Хотя алгебраическиеная нотация, которую мы использовали ранее, может быть использована для описания кубит состояний, она становится все более громоздкими по мере увеличения размера состояний.  Итоговый вектор столбца для строки длиной 7 бит, например, имеет $ $ Размер 128, что делает его более удобным, используя нотацию, описанную ранее очень громоздкими.  По этой причине мы рассмотрим общую нотацию в тактовых вычислениях, что позволяет нам кратко описать эти массивы больших объемов.
