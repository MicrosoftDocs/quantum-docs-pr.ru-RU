---
title: Несколько кубитов
description: Узнайте, как выполнять операции с двумя или более Кубитс.
author: QuantumWriter
uid: microsoft.quantum.concepts.multiple-qubits
ms.author: nawiebe@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: 2fa227c823cd87df9c799c043c699e4ce818b8e3
ms.sourcegitcommit: 6ccea4a2006a47569c4e2c2cb37001e132f17476
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/28/2020
ms.locfileid: "77907551"
---
# <a name="multiple-qubits"></a>Несколько Кубитс

Хотя однокубитные шлюзы обладают некоторыми интуитивно понятными функциями, такими как возможность наноситься в несколько состояний в определенный момент времени, если все, что мы находились на тактовой частоте, состояли из одного кубит шлюза, у нас будет устройство с вычислительной мощностью, дварфед даже калькулятор добавим только классический компьютер.
Истинная сила тактовых вычислений стала очевидной только при увеличении числа Кубитс.
Эта степень возникнет, в части, так как размер векторного пространства векторов состояния такта растет экспоненциально с числом Кубитс.
Это означает, что хотя один кубит может быть тривиально смоделирован, при моделировании вычисления такта 50-кубит, вероятно, будут принудительно относиться ограничения существующих компьютеров.
Увеличение размера вычислений за счет только одного дополнительного кубит *удваивает* объем памяти, необходимой для хранения состояния, и примерно *удваивает* вычислительное время.
Это самое быстрое удвоение вычислительной мощности заключается в том, почему тактовый компьютер с относительно небольшим количеством Кубитс может значительно превысить наиболее мощные, завтра и более широкие возможности для некоторых вычислительных задач.

Почему у нас есть экспоненциальное увеличение векторов состояния тактов?  Наша цель в этом разделе — Просмотреть правила, используемые для сборки кубит состояний из одного кубит состояния, а также обсудить операции с шлюзами, которые необходимо включить в наш шлюз, чтобы сформировать компьютер с универсальным множеством кубит.
Эти средства абсолютно необходимы для понимания наборов шлюзов, которые обычно используются в Q # Code, а также для получения интуиция о том, почему тактовые эффекты, такие как замкнутые или помехи, визуализируют тактовые вычисления более мощными, чем классические вычисления.

## <a name="representing-two-qubits"></a>Представление двух Кубитс
Основное различие между двумя и кубит состояниями состоит в том, что два-кубит состояния представляют собой четыре измерения, а не две.
Это обусловлено тем, что вычислительная базис для двух-кубит состояний формируется продуктами тензорные в одном кубит состоянии.  Например, у нас есть \бегин{алигн} 00 \екуив \begin{bmatrix}1 \\\\ 0 \енд{бматрикс}\отимес \begin{bmatrix}1 \\\\ 0 \енд{бматрикс} & = \begin{bmatrix}1 \\\\ 0\\\\ 0\\\\ 0 \енд{бматрикс}, \ккуад 01 \екуив \begin{bmatrix}1 \\\\ 0 \end{bmatrix}\otimes \begin{bmatrix}0 \\\\ 1 \end{bmatrix} = \begin{bmatrix}0 \\\\ 1\\\\ 0\\\\ 0 \енд{бматрикс},\\\\ 10 \екуив \begin{bmatrix}0 \\\\ 1 \енд{бматрикс}\отимес \begin{bmatrix}1 \\\\ 0 \енд{бматрикс} & = \begin{bmatrix}0 \\\\ 0\\\\ 1\\\\ 0 \енд{бматрикс}, \ккуад 11 \екуив \begin{bmatrix}0 \\\\ 1 \end{bmatrix}\otimes \begin{bmatrix}0 \\\\ 1 \end{bmatrix} = \begin{bmatrix}0 \\\\ 0\\\\ 0 @no__ t_40_ \\ 1 \енд{бматрикс}.\\
\енд{алигн}

Можно легко увидеть, что более обычное состояние такта в $n $ Кубитс представлено вектором единиц измерения $2 ^ n $ с помощью этой конструкции.  Вектор

$ $ \бегин{бматрикс} \ alpha_{00} \\\\ \ alpha_{01} \\\\ \ alpha_{10} \\\\ \ alpha_{11} \енд{бматрикс} $ $

представляет состояние такта для двух Кубитс, если $ | \ alpha_{00}| ^ 2 + | \ alpha_{01}| ^ 2 + | \ alpha_{10}| ^ 2 + | \ alpha_{11}| ^ 2 = 1 $. Точно так же, как и в случае с одиночным Кубитс, вектор состояния такта нескольких Кубитс содержит всю информацию, необходимую для описания поведения системы.

Если у нас есть два отдельных Кубитс, один из которых находится в состоянии $ \бегин{бматрикс} \алфа \\\\ \бета \енд{бматрикс} $, а второй кубит в состоянии $ \бегин{бматрикс} \гамма \\\\ \делта \end{bmatrix} $, соответствующее состояние в два-Qubit —

$ $ \бегин{бматрикс} \алфа \\\\ \бета \енд{бматрикс} \отимес \бегин{бматрикс} \гамма \\\\ \делта \енд{бматрикс} = \begin{bmatrix} \alpha \begin{bmatrix} \gamma \\\\ \delta \end{bmatrix} \\\\ \beta \begin{bmatrix}\gamma \\\\ \delta \end{bmatrix} \end{bmatrix} = \begin{bmatrix} \alpha\gamma \\\\ \alpha\delta \\\\ \beta\gamma \\\\ \beta\delta \end{bmatrix} , $$

где операция $ \отимес $ называется продуктом тензорные (или продуктом Кронеккер) векторов. Обратите внимание, что хотя мы всегда можем взять тензорныеное произведение двух кубитных состояний, чтобы сформировать штат из двух-кубит, не все два кубит состояния такта могут быть написаны в виде тензорные продукта двух однокубит состояний.
Например, отсутствуют состояния $ \пси = \бегин{бматрикс} \алфа \\\\ \бета \енд{бматрикс} $ и $ \фи = \бегин{бматрикс} \гамма \\\\ \делта \енд{бматрикс} $, чтобы их тензорные-продукт был в состоянии. 

$ $ \пси\отимес \фи = \бегин{бматрикс} 1/\ sqrt{2} \\\\ 0 \\\\ 0 \\\\ 1/\ sqrt{2} \енд{бматрикс}. $ $ 

Кубит состояние, которое не может быть записано в качестве тензорные продукта с одним кубит, называется «запутанными State»; два Кубитс говорят как [*запутанными*](https://en.wikipedia.org/wiki/Quantum_entanglement).  Слабо говоря, поскольку состояние такта не может рассматриваться как тензорныеное произведение одного кубит состояния, информация, которая хранится в состоянии, не ограничивается ни одним из Кубитс по отдельности.  Вместо этого информация хранится не локально в корреляциях между двумя состояниями.  Такая Нелокальная информация является одной из основных отличительных особенностей тактовых вычислений при работе с классическими вычислениями и имеет большое значение для ряда серверных протоколов, включая передачу данных в [тактовую](https://github.com/microsoft/Quantum/tree/master/samples/getting-started/teleportation) передачу и [исправление ошибок такта](xref:microsoft.quantum.libraries.error-correction).

## <a name="measuring-two-qubit-states"></a>Измерение двух кубит состояний ##
Измерение двух-кубит состояний очень похоже на однокубитные измерения. Измерение состояния

$ $ \бегин{бматрикс} \ alpha_{00} \\\\ \ alpha_{01} \\\\ \ alpha_{10} \\\\ \ alpha_{11} \енд{бматрикс} $ $

дает $0 $ с вероятностью $ | \ alpha_{00}| ^ $2, $1 $ с вероятностью $ | \ alpha_{01}| ^ $2, $10 $ with вероятность $ | \ alpha_{10}| ^ $2 и $11 $ с вероятностью $ | \ alpha_{11}| ^ $2. Переменные $ \ alpha_{00}, \ alpha_{01}, \ alpha_{10}, $ и $ \ alpha_{11}$ были преднамеренно именованы, чтобы сделать это подключение открытым. После измерения, если результат равен $0 $, состояние такта кубит системы будет свернуто и теперь

$ $0 \екуив \бегин{бматрикс} 1 \\\\ 0 \\\\ 0 \\\\ 0 \енд{бматрикс}.
$$

Можно также измерять только один кубит состояния такта из двух кубит. В случаях, когда измеряется только один из Кубитс, влияние измерения незначительно отличается, так как все состояние не свернуто в вычислительное состояние, а только в одну подсистему.  Иными словами, в таких случаях измерение только одного кубит сворачивает только одну из подсистем, но не все из них.  

Чтобы увидеть это, оцените первую кубит следующего состояния, которое формируется путем применения преобразования Хадамард $H $ на двух Кубитс изначально установлено в состояние "0": $ $ H ^ {\отимес 2} \лефт (\begin{bmatrix}1 \\\\ 0 \енд{бматрикс}\отимес \begin{bmatrix}1 \\\\ 0 \енд{бматрикс} \ригхт) = \фрак{1}{2}\begin{bmatrix}1 & 1 & 1 & 1 \\\\ 1 & 1 & 1 & 1 \\-1 \\ & & 1 & 1 &-1 & 1 \end{bmatrix}\begin{bmatrix}1\\\\ 0\\\\ 0\\\\ 0 \ End {бматрикс} = \фрак{1}{2}\begin{bmatrix}1\\\\ 1\\\\ 1\\\\ 1 \ End {бматрикс} \мапсто \бегин{Касес}\текст{ауткоме} = 0 & \фрак{1}{\скрт{2}} \begin{bmatrix}1\\\\ 1\\\\ 0\\\\ 0 \енд{бматрикс}\\\\ \текст{ауткоме} = 1 & \фрак{1}{\скрт{2}} \begin{bmatrix}0\\\\ 0\\\\ 1\\\\ 1 \енд{бматрикс}\\\\ \енд{Касес}.\\\\
$ $ В обоих результатах возникает вероятность 50%.  Результат, равный 50% вероятности, может быть интуитед от того факта, что начальный вектор состояния такта является инвариантным при переключении $0 $ с $1 $ на первый кубит.

Математическое правило для измерения первой или второй кубит просто.  Если мы разберем $e _k $ быть $k ^ {\рм TH} $ вычислительного вектора и позвольте $S $ быть набором всех $e _k $ таким, что кубит в вопросе принимает значение $1 $ для этого значения $k $.  Например, если нас интересует измерение первого кубит, то $S $ будет состоять из $e _2 \ equiv $10 и $e _3 \ equiv $11.  Аналогично, если мы заинтересованы во втором кубит $S $ будет состоять из $e _1 \ equiv $1 и $e _3 \екуив $11.  Затем вероятность измерения выбранного кубита равна $1 $ для вектора состояния $ \пси $

$ $ P (\текст{ауткоме} = 1) = \ sum_ {e_k \текст{в наборе} S} \пси ^ \дагжер e_k e_k ^ \дагжер \пси.
$$

Поскольку каждое измерение кубит может выдавать только $0 $ или $1 $, вероятность измерения $0 $ — просто $1-P (\текст{ауткоме} = 1) $.  Именно поэтому мы явно выдаем формулу для вероятности измерения $1 $.

Действие, в котором такое измерение имеет состояние, может быть выражено математическим образом.

$ $ \пси \мапсто \фрак{\ sum_ {e_k \текст{в наборе} S} e_k e_k ^ \дагжер \Пси}{\скрт{п (\текст{ауткоме} = 1)}}.
$$

Читатель с осторожностью может беспокоиться о том, что происходит, когда вероятность измерения равна нулю.  Хотя результирующее состояние технически не определено в этом случае, нам не нужно беспокоиться о таких возможностях, поскольку вероятность равна нулю!


Если мы принимаем $ \пси $ как однородный вектор состояния, заданный выше, и заинтересованы в измерении первого кубит, то 

$ $ P (\текст{меасуремент первого кубит} = 1) = (\пси ^ \дагжер e_2) (e_2 ^ \дагжер \пси) + (\пси ^ \дагжер e_3) (e_3 ^ \дагжер \пси) = | e_2 ^ \дагжер \пси | ^ 2 + | e_3 ^ \dagger \psi | ^ 2.
$$

Обратите внимание, что это лишь сумма двух вероятностей, ожидаемых для измерения результатов $10 $ и $11 $, которые были Кубитс.
В нашем примере результатом является

$ $ \фрак{1}{4}\лефт | \begin{bmatrix}0 & 0 & 1 & 0 \ End {бматрикс} \ начало {бматрикс} 1\\\\ 1\\\\ 1\\\\ 1 \ End {бматрикс} \ригхт | ^ 2 + \фрак{1}{4}\лефт | \begin{bmatrix}0 & 0 & 0 & 1 \ End {бматрикс} \ начало {бматрикс} 1\\\\ 1\\\\ 1\\\\ 1 \ End {бматрикс} \ригхт | ^ 2 = \фрак{1}{2}.
$$

что вполне соответствует тому, что наш интуиция сообщает нам о вероятности.  Аналогично, состояние может быть записано как

$ $ \фрак{\фрак{e_2}{2}+ \фрак{e_3}{2}} {\скрт{\фрак{1}{2}}} = \фрак{1}{\скрт{2}} \бегин{бматрикс} 0\\\\ 0\\\\ 1\\\\ 1 \ End {бматрикс} $ $

еще раз в соответствии с нашим интуиция.

## <a name="two-qubit-operations"></a>Операции с двумя кубит
Как и в случае с одним кубит, любое единое преобразование является допустимой операцией в Кубитс. В целом, единое преобразование для $n $ Кубитс является матрицей $U $ of размером $2 ^ n \тимес 2 ^ n $ (так что он обрабатывает векторы размера $2 ^ n $), что $U ^{-1} = U ^ \дагжер $. Например, шлюз кнот (управляемый) является часто используемым кубитным шлюзом и представлен следующей единой матрицей:

$ $ \Операторнаме{кнот} = \бегин{бматрикс} 1 \ 0 \ 0 \ 0 \\\\ 0 \ 1 \ 0 \ 0 \\\\ 0 \ 0 \ 0 \ 1 \\\\ 0 \ 0 \ 1 \ 0 \енд{бматрикс} $ $

Также можно сформировать два кубит шлюза, применив шлюзы с одним кубит на Кубитс. Например, если мы применяем шлюз 

$ $ \бегин{бматрикс} a \ b\\\\ c \ d \енд{бматрикс} $ $

и

$ $ \бегин{бматрикс} e \ f\\\\ g \ h \енд{бматрикс} $ $

к первому и второму Кубитс, соответственно, это эквивалентно применению двух-кубитых данных, находящиеся в их тензорные продукте: $ $ \бегин{бматрикс} a \ b\\\\ c \ d \енд{бматрикс} \отимес \бегин{бматрикс} e \ f\\\\ g \ h \енд{бматрикс} = \бегин{бматрикс} AE \ AF \ BF \\\\ AG \ AH \ BG \ BH \\\\ CE \ CF \ de \ DF \\\\ CG \ CH \ Qubit \ DH \end{bmatrix}. $ $, таким таким, мы можем сформировать шлюзы с двумя ами, потратив на тензорные один из известных одноqubit шлюзов. К некоторым примерам кубит шлюзов относятся $H \отимес H $, $X \отимес \болдоне $ и $X \отимес Z $.

Обратите внимание, что хотя любой из двух кубит шлюзов определяет кубитй шлюз с помощью продукта тензорные, это не так. Не все два кубита шлюза могут быть написаны как тензорные продукт с одним кубит.  Такой шлюз называется шлюзом *ентанглинг* . Одним из примеров шлюза ентанглинг является шлюз кнот.

Интуиция за контролируемый шлюз может быть обобщен к произвольным шлюзам.  Управляемый шлюз в общем случае — это шлюз, который выступает в роли Identity (IE не имеет действия), если только определенная кубит не имеет значение $1 $.  Мы об$x мечаем управляемое единое, управляемое в данном случае в кубит $, с помощью \Ламбда $\_x (U) $.  Например, $ \ Lambda_0 (U) e\_{1}\отимес {\пси} = e\_{1}\отимес U {\пси} $ and $ \Ламбда\_0 (U) e\_{0}\отимес {\пси} = e\_{0}\отимес{\пси} $, где $e\_$0 и $e\_$1 — это вычислительные векторы для одного кубит, соответствующего значениям $0 $ и $1 $.  Например, рассмотрим следующий управляемый $Z $ Gate, затем мы можем выразить это как $ $ \Ламбда\_0 (Z) = \begin{bmatrix}1 & 0 & 0 & 0\\\\0 & 1 & 1 & 0\\\\0 & 0 & 0 &-1 \енд{бматрикс} = (\болдоне\отимес H) \Операторнаме{кнот} (\болдоне\отимес H).\\\\
$$

Очень сложно создавать контролируемые унитариес.  Самый простой способ реализации этого требует формирования базы данных с управляемыми версиями фундаментальных шлюзов и замены каждого фундаментального шлюза в исходной операции с управляемым аналогом.  Часто это довольно непроизводительна, и его можно использовать, чтобы просто заменить несколько шлюзов на контролируемые версии, чтобы добиться того же воздействия.  По этой причине мы предоставляем в нашей инфраструктуре возможность выполнения упрощенного метода управления или предоставления пользователю возможности определять управляемую версию единого, если известна оптимизированная вручную версия.

Шлюзы также можно контролировать с помощью классической информации.  Например, классический контролируемый вентиль не является шлюзом, но он применяется только в том случае, если Классический бит равен $1 $, а не биту.  В этом смысле классический управляемый шлюз можно рассматривать как оператор if в коде такта, где шлюз применяется только в одной ветви кода.


Как и в случае с одиночным кубит, набор кубитных шлюзов является универсальным, если любое число $4 \ раз $4, которое может быть приблизительным по одной из следующих строк, можно приблизительно оценить с помощью продукта шлюза.
Одним из примеров универсального шлюза является шлюз Хадамард, T-шлюз и шлюз кнот. Используя продукты этих шлюзов, можно оценить любую единую матрицу на двух Кубитс.

## <a name="many-qubit-systems"></a>Многие кубит системы
Мы соблюдаем те же закономерности, которые просматривается в кубит случае, чтобы создать множество кубит состояний тактов из небольших систем.  Такие состояния создаются путем формирования тензорные продуктов с меньшими состояниями.  Например, рассмотрите возможность кодирования битовой строки $1011001 $ на компьютере-такте.  Мы можем кодировать это как

$ $1011001 \екуив \бегин{бматрикс} 0 \\\\ 1 \енд{бматрикс}\отимес \бегин{бматрикс} 1 \\\\ 0 \енд{бматрикс}\отимес \begin{bmatrix} 0 \\\\ 1 \end{bmatrix}\otimes \begin{bmatrix} 0 \\\\ 1 \end{bmatrix} \otimes \begin{bmatrix} 1 \\\\ 0 \end{bmatrix}\otimes \begin{bmatrix} 1 \\\\ 0 \end{bmatrix}\otimes \begin{bmatrix} 0 \\\\ 1 \end{bmatrix}.
$$

Тактовый шлюз работает точно так же.  Например, если нужно применить $X $ Gate к первому кубит, а затем выполнить кнот между вторым и третьим Кубитс, мы можем выразить это преобразование как

\бегин{алигн} & (X \отимес \operatorname{CNOT}_{12}\отимес \болдоне\отимес \болдоне \отимес \болдоне \отимес \болдоне) \begin{bmatrix} 0 \\\\ 1 \end{bmatrix}\otimes \begin{bmatrix} 1 \\\\ 0 \end{bmatrix}\otimes \begin{bmatrix} 0 \\\\ 1 \end{bmatrix}\otimes \begin{bmatrix} 0 \\\\ 1 \end{bmatrix} \otimes \begin{bmatrix} 1 \\\\ 0 \end{bmatrix}\otimes \begin{bmatrix} 1 \\\\ 0 \end{bmatrix}\otimes \бегин{бматрикс} 0 \\\\ 1 \енд{бматрикс}\\\\ & \ккуад\ккуад\екуив 0011001.
\енд{алигн}

Во многих кубит системах часто приходится распределять и освобождать Кубитс, которые служат временной памятью для тактового компьютера.  Такой кубит называется анЦилла.  По умолчанию предполагается, что состояние кубит инициализировано $e _0 $ после выделения.  Далее предполагается, что он снова возвращается в $e _0 $ перед отменой распределения.  Это предположение важно, поскольку если анЦилла кубит становится запутанными с другим кубит регистрацией при отмене выделения, процесс отмены распределения приведет к повреждению анЦилла.  По этой причине мы всегда Предположим, что такие Кубитс возвращены в исходное состояние до выпуска.

Наконец, хотя новые шлюзы, необходимые для добавления в наш шлюз для достижения универсальных тактовых вычислений для двух кубит тактов, новые шлюзы не должны вводиться в несколько кубит.  Шлюзы $H $, $T $ и кнот формируют универсальный шлюз для многих Кубитс, так как любое общее преобразование можно разделить на ряд двух поворотов кубит.  Затем мы можем использовать теорию, разработанную для кубит корпуса, и повторить ее здесь, когда у нас много кубитсов.

Хотя алгебраическиеная нотация, которую мы использовали ранее, может быть использована для описания кубит состояний, она становится все более громоздкими по мере увеличения размера состояний.  Итоговый вектор столбца для строки длиной 7 бит, например, имеет размер $128 $, что делает его более удобным, используя нотацию, описанную ранее очень громоздкими.  По этой причине мы рассмотрим общую нотацию в тактовых вычислениях, что позволяет нам кратко описать эти массивы больших объемов.
