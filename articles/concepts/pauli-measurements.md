---
Title: Паули измерения Description: Узнайте, как работать с одной и несколькими кубит Паулиными операциями измерений.
Автор: Куантумвритер UID: Microsoft. тактов. Основные сведения. Паули MS. author: nawiebe@microsoft.com MS. Дата: 12/11/2017 MS. Topic: статья No-Loc:
- "Q#"
- "$$v"
- "$$"
- "$$"
- "$"
- "$"
- "$"
- "$$"
- "\cdots"
- "bmatrix"
- "\ddots"
- "\equiv"
- "\sum"
- "\begin"
- "\end"
- "\sqrt"
- "\otimes"
- "{"
- "}"
- "\text"
- "\phi"
- "\kappa"
- "\psi"
- "\alpha"
- "\beta"
- "\gamma"
- "\delta"
- "\omega"
- "\bra"
- "\ket"
- "\boldone"
- "\\\\"
- "\\"
- "="
- "\frac"
- "\text"
- "\mapsto"
- "\dagger"
- "\to"
- "\begin{cases}"
- "\end{cases}"
- "\operatorname"
- "\braket"
- "\id"
- "\expect"
- "\defeq"
- "\variance"
- "\dd"
- "&"
- "\begin{align}"
- "\end{align}"
- "\Lambda"
- "\lambda"
- "\Omega"
- "\mathrm"
- "\left"
- "\right"
- "\qquad"
- "\times"
- "\big"
- "\langle"
- "\rangle"
- "\bigg"
- "\Big"
- "|"
- "\mathbb"
- "\vec"
- "\in"
- "\texttt"
- "\ne"
- "<"
- ">"
- "\leq"
- "\geq"
- "~~"
- "~"
- "\begin{bmatrix}"
- "\end{bmatrix}"
- "\_"

---

# <a name="pauli-measurements"></a>Паули измерения

В предыдущих обсуждениях мы посвящены измерениям вычислительной единицы.
На самом деле, в тактовых вычислениях существуют и другие распространенные измерения, которые удобны для вычисления измерений базисных показателей.
При работе с Q# наиболее распространенными измерениями, с которыми вы будете работать, скорее всего, будут *Паули измерения*, которые обобщает базовые показатели вычислений для включения измерений в другие базы данных и четности между различными Кубитс.
В таких случаях, как правило, рассматривается измерение оператора Паули в целом оператором, таким как $ X, Y, z $ или $ z \otimes z, x \otimes x, x \otimes Y $ и т. д.

> [!TIP]
> В Q# несколько кубит операторов Паули обычно представлены массивами типа `Pauli[]` .
> Например, для представления $ X \otimes Z \otimes Y $ можно использовать массив `[PauliX, PauliZ, PauliY]` .

Обсуждение измерения с точки зрения операторов Паули особенно распространено во подполе исправления ошибок такта.
В Q# мы соблюдаем аналогичное соглашение. Теперь мы объясним это альтернативное представление измерений.

Прежде чем углубляться в подробные сведения о том, как представить Паули измерение, полезно подумать о том, какой размер одного кубита в тактовой частоте в состоянии такта.
Представьте, что у нас есть $ n $ -кубитное состояние такта; затем измерение одного кубит сразу же правила выходит за пределы $ 2 ^ n $ возможностей, которые могут быть в состоянии.
Иными словами, измерение проецирует состояние такта на одну из двух половинных пробелов.
Мы можем обобщить способ, который мы думаем о измерении, чтобы отразить этот интуиция.

Для краткого выделения этих подпространств требуется язык для их описания.
Один из способов описания двух подразделений состоит в том, что они указываются через матрицу с двумя уникальными еиженвалуес, полученными по соглашению $ \пм 1 $ .
Для простого примера описания подпространства таким образом, рассмотрим $ Z $ :

$$
\begin{align}
  Z & = \begin{bmatrix} 1 & 0 \\\\ & — 1 \end{bmatrix} .
\end{align}
$$

Прочитав диагональные элементы матрицы Паули- $ z $ , можно увидеть, что $ у Z $ есть два основе собственных векторов, $ \ket { 0 } $ и $ \ket { 1 } $ с соответствующими еиженвалуес $ \пм 1 $ .
Таким образом, если мы измеряем кубит и получаем `Zero` (соответствующий состоянию $ \ket { 0 } $ ), мы понимаем, что состояние нашей кубит — $ + 1 $ еиженстате $ $ оператора Z.
Аналогичным образом, если мы получаем `One` , мы понимаем, что состояние нашего кубит — a $ – 1 $ еиженстате $ Z $ . Этот процесс упоминается в языке Паули измерений как «измерение Паули $ Z» $ и полностью эквивалентен вычислению базового измерения.

Любая $ \times Матрица размером 2 2 $ , которая является единым преобразованием $ Z, $ также удовлетворяет этим критериям.
То есть можно также использовать матрицу $ a = u ^ \dagger Z u $ , где $ U $ — любая другая единая матрица, чтобы получить матрицу, определяющую два результата измерения в его $ \пм 1 $ основе собственных векторов.
Нотация измерений Паули ссылается на это единое эквивалентное определение $ координат X, Y, Z $ в качестве эквивалентных измерений, которые можно сделать для получения информации из кубит.
Для удобства эти измерения приведены ниже.


||Единое преобразование Паули измерения|
|-------------------|------------------------|
|$ $ Z |               $\boldone$             |
|$ $ X | $З               $                    |
|По $ оси Y $ | $HS ^               {\dagger}$         |

То есть при использовании этого языка "мера $ Y $ " эквивалентна применению метода $ HS ^, \dagger $ а затем измеряется в вычислительной базе, где [`S`](xref:microsoft.quantum.intrinsic.s) — это внутренняя операция, которая иногда называется фазой фазы, и может быть смоделирована единой матрицей.

$$
\begin{align}
    С =\begin{bmatrix}
        1 & 0 \\\\ 0 & \end{bmatrix} .
\end{align}
$$

Это также эквивалентно применению метода $ HS ^ \dagger $ к вектору состояния такта, а затем измерению $ Z $ , что следующая операция эквивалентна `Measure([PauliY], [q])` :

```Q#
operation MeasureY(qubit : Qubit) : Result {
    mutable result = Zero;
    within {
        H(q);
        Adjoint S(q);
    } apply {
        set result = M(q);
    }
    return result;
}
```

После этого правильное состояние будет найдено путем преобразования обратно в вычислительную базу, что соответствует применению $ sh $ к вектору состояния такта; в приведенном выше фрагменте преобразование обратно в вычислительную базу выполняется автоматически при использовании `within … apply` блока.

В Q# мы говорим результат---то есть классическая информация, извлеченная из взаимодействия с состоянием--- `Result` , имеет значение $ j \in \\ { \texttt { Zero } , \texttt { } \\ } $ указывающее, находится ли результат в $ (-1) ^ j $ еиженспаце оператора Паули.


## <a name="multiple-qubit-measurements"></a>Кубит измерения

Измерения кубит операторов Паули определены аналогично, как показано в следующих случаях:

$$
Z \otimes z = \begin{bmatrix} 1 & 0 0 0 & -1 0 0 0 0 & \\\\ & & & \\\\ & & -1 0 0 0 & \\\\ & & & 1 \end{bmatrix} .
$$

Таким же тензорныеные продукты двух операторов Паули- $ Z $ образуют матрицу, состоящую из двух пробелов, состоящих из $ + 1 $ и $ -1 $ еиженвалуес.
Как и в случае с одним кубит, оба составляют половину пространства, означающее, что половина доступного векторного пространства принадлежит к $ + 1 $ еиженспаце и оставшейся половине до $ -1 $ еиженспаце.
Как правило, вы можете легко узнать от определения продукта тензорные, что любое тензорные произведение операторов Паули- $ Z $ и удостоверение также подчиняется этому.
Например, примененная к объекту директива

$$
\begin{align}
    \otimes \boldone Z =\begin{bmatrix}
        1 & 0 & 0 &\\\\
        0 &  1 &  0 &  0 \\\\
        0 &  0 & – 1 &  0 \\\\
        0 &  0 & & – 1 \end{bmatrix} .
\end{align}
$$

Как и ранее, любое единое преобразование таких матриц также описывает две пробелы, обозначенные $ \пм 1 $ еиженвалуес.
Например, $ x \otimes x = h \otimes h (z \otimes z) h h по \otimes $  идентификатору, $ хксх Z = $ .
Как и в случае с одним кубит, все два кубит Паули-измерения могут быть написаны как $ u ^ \dagger (Z \otimes \id ) u $ для $ 4 \times 4 $ единых матриц $ u $ . Перечислить преобразования в следующей таблице.

> [!NOTE]
>В таблице ниже мы используем $ \operatorname { подкачку } $ для обозначения матрицы > .$$
> \begin{align}
>     \operatorname{Поменять местами } &=
>     \left( \begin { Матрица}
>1 & 0 & 0 &\\\\
>         0 & 0 & 1 & 0 \\\\
>         0 & 1 & 0 & 0 \\\\
>0 0 0 & & & 1 > \end { Матрица } \right ) >     \end{align}
> $$
> используется для имитации внутренней операции [`SWAP`](xref:microsoft.quantum.intrinsic) .

||Единое преобразование Паули измерения|
|----------------------|------------------------|
|$ \otimes \boldone Z $ | $\boldone\otimes \boldone$|
|$ \otimes \boldone X $ | $ \otimes \boldone З $|
|По $ оси Y \otimes \boldone $ | $ HS \dagger \otimes \boldone ^ $|
|$\boldone \otimes $ | $ \operatorname { Переключение } по $ оси Z|
|$\boldone \otimes $ | $ \otimes \boldone \operatorname { Переключение } X (H $ )|
|$\boldone \otimes $ | $ \dagger \otimes \boldone \operatorname { Переключение } Y $ (HS ^)|
|$Z \otimes Z $ | $ \operatorname { кнот } \_ { 10 } $|
|$X \otimes Z $ | $ \operatorname { кнот } \_ { 10 } (H \otimes \boldone ) $|
|По $ оси Y \otimes Z $ | $ \operatorname { кнот } \_ { 10 } (HS ^ \dagger \otimes \boldone ) $|
|$Z \otimes X $ | $ \operatorname { кнот } \_ { 10 } ( \boldone \otimes H) $|
|$X \otimes X $ | $ \operatorname { кнот } \_ { 10 } (h \otimes h) $|
|По $ оси Y \otimes X $ | $ \operatorname { кнот } \_ { 10 } (HS ^ \dagger \otimes H) $|
|$Z \otimes Y $ | $ \operatorname { кнот } \_ { 10 } ( \boldone \otimes HS ^ \dagger ) $|
|$X \otimes Y $ | $ \operatorname { кнот } \_ { 10 } (H \otimes HS ^ \dagger ) $|
|По $ оси Y \otimes Y $ | $ \operatorname { кнот } \_ { 10 } (HS ^ \dagger \otimes HS ^ \dagger ) $|

Здесь [`CNOT`](xref:microsoft.quantum.intrinsic.cnot) операция отображается по следующей причине.
Каждое измерение Паули, не включающее в себя $ \boldone $ матрицу, эквивалентно $ \otimes $ описанной выше причине в z-z.
Еиженвалуес $ z \otimes z $ зависит только от четности Кубитс, составляющих каждый вектор вычислительных операций, а контролируемые операции не служат для вычисления этой контрольной суммы и ее сохранения в первый бит.
После того как первый бит будет измерен, мы можем восстановить удостоверение результирующей половины пространства, что эквивалентно измерению оператора Паули.

Еще одно Примечание. Хотя может показаться, что измерение z z аналогично $ \otimes $ последовательному измерению $ z \otimes \mathbb { 1, } $ а затем $ \mathbb { 1 } \otimes Z $ , это предположение будет ложным.
Причина в том, что измерение $ z \otimes z $ проецирует состояние такта в $ + 1 $ или $ -1 $ еиженстате этих операторов.
Измерение $ \otimes \mathbb { 1 } $ , а затем $ \mathbb { 1 } \otimes z $ Проецирует вектор состояния такта сначала на половину пространства $ Z \otimes \mathbb { 1 } $ , а затем на половину пространства, равное $ \mathbb { 1 } \otimes z $ . При наличии четырех векторов вычисления, выполнение обоих измерений приводит к уменьшению состояния до четвертого пространства и, следовательно, сокращает его до одного вычислительного вектора.

## <a name="correlations-between-qubits"></a>Корреляции между Кубитс
Другим способом измерения тензорные продуктов Паули матриц, таких как $ x \otimes x $ или $ z \otimes z $ , является то, что эти измерения позволяют просматривать сведения, хранящиеся в корреляциях между двумя Кубитс.
Измерение $ X \otimes \id $ позволяет просмотреть сведения, которые хранятся локально в первом кубит.
Несмотря на то что оба типа измерений в тактовых вычислениях одинаково важны, в бывшей степени используются возможности тактовых вычислений.
Это означает, что в тактовых вычислениях часто сведения, которые вы хотите изучить, не хранятся ни в одном кубит, а в отдельном месте, а не в локальной среде Кубитс, и поэтому только при просмотре с помощью совместного измерения (например, $ z \otimes z $ ) Эта информация становится манифестом.

Например, при исправлении ошибок мы часто хотели бы узнать, какая ошибка возникла при изучении состояния, которое мы пытаемся защитить.
В примере [кода с зеркальным отражением](https://github.com/microsoft/Quantum/tree/master/samples/error-correction/bit-flip-code) показан пример того, как это можно сделать с помощью таких измерений, как $ z z \otimes \otimes \id $ и $ \id \otimes z \otimes z $ . < --TODO: измените это значение на ссылку на браузер примеров, как только будет включена выборка с побитовым отражением. -->

Также можно измерять произвольные операторы Паули, например $ X \otimes Y \otimes Z \otimes \boldone $ .
Все такие тензорныеные продукты операторов Паули имеют только два еиженвалуес $ \пм 1 $ , и оба еиженспацес составляют половины пространства всего вектора.
Поэтому они совпадают с указанными выше требованиями.

В Q# подобные измерения возвращают $ j, $ Если измерение возвращает результат в еиженспаце знака $ (-1) ^ j $ .
Использование Паули измерений в качестве встроенной функции в Q# является полезным, поскольку при измерении таких операторов требуется использовать длинные цепочки управляемых и не основанных на механизмах преобразования, чтобы описать диагонализинг $ U, $ необходимый для выражения операции как тензорныеого произведения $ Z $ и $ \id $ .
Благодаря возможности указать, что вы хотите выполнить одно из этих предварительно определенных измерений, не нужно беспокоиться о том, как преобразовать базу таким образом, чтобы измерение базисных данных предваряет необходимую информацию.
Q# автоматически обрабатывает все необходимые преобразования.
Дополнительные сведения см. в разделе [`Measure`](xref:microsoft.quantum.intrinsic.measure) [`MeasurePaulis`](xref:microsoft.quantum.measurement.measurepaulis) операции и.

## <a name="the-no-cloning-theorem"></a>Теорема без клонирования

Сведения о такте являются мощными.
Это позволяет нам сделать незначительную работу, например, экспоненциальное количество факторов быстрее, чем лучшие известные классические алгоритмы, или эффективно моделировать коррелированные системы электронного представления, которые в классической степени потребовали экспоненциальной стоимости для корректной имитации.
Однако существуют ограничения на возможности тактовых вычислений.
Одно такое ограничение предоставляется *без клонирования Теорема*.

Теорема без клонирования — это выразился с именем.
Он запрещает клонирование универсальных состояний тактов на тактовый компьютер.
Проверка теоремаа очень проста.
Хотя полное подтверждение теоремаа без клонирования является слишком техническим для нашего обсуждения, в случае отсутствия дополнительного вспомогательного Кубитс в нашей области (вспомогательные кубитсы Кубитс используются для временных пространств во время вычисления и легко используются и управляются в Q# , см. раздел о [займах Кубитс](xref:microsoft.quantum.guide.qubits#borrowed-qubits)).

Для такого тактового компьютера операция клонирования должна быть описана единой матрицей.
Мы запрещаем измерение, так как это привело бы к повреждению состояния такта, которое мы пытаемся клонировать.
Для имитации операции клонирования требуется, чтобы в единой матрице использовалось свойство, которое $$
  U \ket { \psi } \ket { 0 } = \ket { \psi }\ket{\psi}
$$
для любого состояния $ \ket { \psi } $ .
Затем свойство линейного умножения матрицы подразумевает, что для любого второго состояния такта $ \ket { \phi } $ ,

$$
\begin{align}
    U \left [ \frac { 1 } { \sqrt { 2 } } \left ( \ket { \phi } + \ket { \psi } \right ) \right ] \ket { 0}
    &= \frac{ 1 } { \sqrt { 2 } } U \ket { \phi } \ket { 0}
      + \frac{1 } { \sqrt { 2 } } U \ket { \psi } \ket { 0 }\\\\
    &= \frac{ 1 } { \sqrt { 2 } } \left ( \ket { \phi } \ket { \phi }  +  \ket { \psi }\ket{\psi}
        \right) \\\\
    &\ne \left ( \frac { 1 } { \sqrt { 2 } } \left ( \ket { \phi } + \ket { \psi } \right ) \right ) \otimes \left ( \frac { 1 } { \sqrt { 2 } } \left ( \ket { \phi } + \ket { \psi } \right ) \right ).
\end{align}
$$

Это обеспечивает фундаментальный интуиция за пределами Теорема без клонирования: любое устройство, которое копирует неизвестное состояние такта, должно вызвать ошибки по крайней мере в некоторых из скопированных состояний.
Хотя в качестве ключевого предположения, что клонирование работает линейно во входном состоянии, может быть нарушено благодаря добавлению и измерению вспомогательных Кубитс, такое взаимодействие также приводит к утечке информации о системе через статистику измерений и предотвращает точную клонирование в таких случаях.
Более полное подтверждение Теорема без клонирования см. в разделе Дополнительные [сведения](xref:microsoft.quantum.more-information).

Теорема без клонирования важна для качественного понимания тактовых вычислений, так как если вы могли клонировать состояния такта недорого, вам будет предоставлена возможность почти Magical получать сведения о состояниях тактов.
Действительно, можно нарушать принцип неопределенности ваунтед Гейзенбега.
Кроме того, можно использовать оптимальный клон для получения одного примера из сложного распределения тактов и изучить все, что вы можете узнать об этом распространении, только из одного примера.
Это будет похоже на то, что вы передаете монет и просматривая головки, а затем сообщаете друзьям о результате, что они отвечают: "AH. распределение этого монет должно быть Бернулли с $ p = 0.512643 \ лдотс $ !"  Такой оператор будет не сенсикал, так как один бит информации (результат Head) просто не может предоставить множество данных, необходимых для кодирования распределения, без существенной информации.
Аналогично, без предварительной информации мы не можем точно клонировать состояние такта, так как мы не можем подготовить ансамблей таких монет, не зная $ p $ .

В тактовых вычислениях информация не предоставляется.
Каждый измеренный кубит предоставляет один небольшой объем информации, и теорема без клонирования показывает, что нет программы трояны, которые можно использовать для обхода фундаментального компромисса между информацией, полученной от системы, и вызываемой беспорядки.
