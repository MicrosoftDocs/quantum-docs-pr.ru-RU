---
title: Паули измерения
description: Узнайте, как работать с одной и несколькими кубит Паули измерениями.
author: QuantumWriter
uid: microsoft.quantum.concepts.pauli
ms.author: nawiebe@microsoft.com
ms.date: 12/11/2017
ms.topic: article
no-loc:
- $
- $
- $
- $
- $
- $
- '\cdots'
- bmatrix
- '\ddots'
- '\equiv'
- '\sum'
- '\begin'
- '\end'
- '\sqrt'
- '\otimes'
- '{'
- '}'
- '\text'
- '\phi'
- '\kappa'
- '\psi'
- '\alpha'
- '\beta'
- '\gamma'
- '\delta'
- '\omega'
- '\bra'
- '\ket'
- '\boldone'
- '\\\\'
- '\\'
- =
- '\frac'
- '\text'
- '\mapsto'
- '\dagger'
- '\to'
- "\begin{cases}"
- "\end{cases}"
- '\operatorname'
- '\braket'
- '\id'
- '\expect'
- '\defeq'
- '\variance'
- '\dd'
- '&'
- "\begin{align}"
- "\end{align}"
- '\Lambda'
- '\lambda'
- '\Omega'
- '\mathrm'
- '\left'
- '\right'
- '\qquad'
- '\times'
- '\big'
- '\langle'
- '\rangle'
- '\bigg'
- '\Big'
- '|'
- '\mathbb'
- '\vec'
- '\in'
- '\texttt'
- '\ne'
- <
- '>'
- '\leq'
- '\geq'
- ~~
- "~"
- "\begin{bmatrix}"
- "\end{bmatrix}"
- '\_'
ms.openlocfilehash: 7f10c4ad5eb325da97552d60ff47ea89a699f08d
ms.sourcegitcommit: 0181e7c9e98f9af30ea32d3cd8e7e5e30257a4dc
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/23/2020
ms.locfileid: "85269479"
---
# <a name="pauli-measurements"></a>Паули измерения

В предыдущих обсуждениях мы посвящены измерениям вычислительной единицы.
На самом деле, в тактовых вычислениях существуют и другие распространенные измерения, которые удобны для вычисления измерений базисных показателей.
При работе с Q # наиболее распространенные измерения, с которыми вы будете работать, скорее всего, будут *Паули измерениями*, которые обобщает базовые показатели вычислений, чтобы включить измерения в другие базовые показатели, и четность между различными Кубитс.
В таких случаях часто обсуждается измерение оператора Паули, в целом оператор, например $X, Y, Z $ или $Z \otimes Z, x \otimes x, x \otimes Y $ и т. д.

> [!TIP]
> В Q # операторы Multi-кубит Паули обычно представлены массивами типа `Pauli[]` .
> Например, чтобы представить $X \отимес Z \отимес Y $ , можно использовать массив `[PauliX, PauliZ, PauliY]` .

Обсуждение измерения с точки зрения операторов Паули особенно распространено во подполе исправления ошибок такта.
В Q # Мы соблюдаем аналогичное соглашение. Теперь мы объясним это альтернативное представление измерений.

Прежде чем углубляться в подробные сведения о том, как представить Паули измерение, полезно подумать о том, какой размер одного кубита в тактовой частоте в состоянии такта.
Представьте, что у нас есть $ состояние такта $n-кубит. затем измерение одного кубит сразу же правила выходит за пределы возможностей $2 ^ n $ , которые могут быть в состоянии.
Иными словами, измерение проецирует состояние такта на одну из двух половинных пробелов.
Мы можем обобщить способ, который мы думаем о измерении, чтобы отразить этот интуиция.

Для краткого выделения этих подпространств требуется язык для их описания.
Один из способов описания двух подразделений состоит в том, что они указываются через матрицу с двумя уникальными еиженвалуес, принятыми в соответствии с соглашением $ \пм 1 $ .
Простой пример описания подпространства таким образом можно $Z $ :

\бегин{алигн}
  Z & = \бегин{ bmatrix } 1 & 0 \\ \\ 0 &-1 \енд{ bmatrix } .
\енд{алигн}
$$

Прочитав диагональные элементы матрицы Паули-$Z $ , можно увидеть, что $Z $ имеет два основе собственных векторов, $ \ket{0 } $ и $ \ket{1 } $, с соответствующими еиженвалуес $ \пм 1 $ .
Таким образом, если мы измеряем кубит и получаем `Zero` (соответствующий состоянию $ \ket{0 } $), мы понимаем, что в качестве состояния нашего кубит используется $ еиженстате $ оператора $Z.
Аналогичным образом, если мы получаем `One` , мы понимаем, что состояние нашего кубит — $-1 $ еиженстате $Z $ .
Этот процесс упоминается в языке Паули измерений как «измерение Паули $Z» $ и полностью эквивалентен вычислению базового измерения.

Любая \times $ матрица $2 2, которая является единым преобразованием $Z $ также удовлетворяет этим критериям.
То есть можно также использовать матрицу $A = U ^ \дагжер Z U $ , где $U $ является любой другой единой матрицей, чтобы получить матрицу, определяющую два результата измерения в его основе собственных векторов $ \пм 1 $ .
Нотация измерений Паули ссылается на это единое эквивалентное определение $X, Y, Z $ в качестве эквивалентных измерений, которые можно сделать для получения информации из кубит.
Для удобства эти измерения приведены ниже.


|Измерение Паули  |Единое преобразование  |
|-------------------|------------------------|
| $Z$               | \болдоне$             |
| $X$               | $H$                    |
| $Y$               | $HS ^ {\дагжер}$         |

То есть при использовании этого языка "мера $Y $ " эквивалентен применению $HS ^ \дагжер, $ а затем измерению на основе вычислений, где [`S`](xref:microsoft.quantum.intrinsic.s) — это внутренняя операция такта, которая иногда называется фазой фазы, и может быть смоделирована единой матрицей.

\бегин{алигн}
    S = \бегин{bmatrix}
        1 & 0 \\ \\ 0 & я \енд{ bmatrix } .
\енд{алигн}
$$

Он также эквивалентен применению $HS ^ \дагжер $ к вектору состояния такта, а затем измерению $Z $ , чтобы следующая операция эквивалентна `Measure([PauliY], [q])` :

```Q#
operation MeasureY(qubit : Qubit) : Result {
    mutable result = Zero;
    within {
        H(q);
        Adjoint S(q);
    } apply {
        set result = M(q);
    }
    return result;
}
```

Затем правильное состояние будет найдено путем преобразования обратно в вычислительную базу, что соответствует применению $SH $ к вектору состояния такта; в приведенном выше фрагменте преобразование обратно в вычислительную базу выполняется автоматически при использовании `within … apply` блока.

В Q # мы говорим результат---то есть классическая информация, извлеченная из взаимодействия с---ом состояния, имеет `Result` значение $j \ин \\ {\Тексттт{зеро } , \тексттт{Оне } \\ } $, указывающее, находится ли результат в выражении $ (-1) ^ j $ еиженспаце оператора Паули.


## <a name="multiple-qubit-measurements"></a>Кубит измерения

Измерения кубит операторов Паули определены аналогично, как показано в следующих случаях:

$ $ Z \otimes Z = \бегин{ bmatrix } 1 &0 &0&0 \\\\ 0 & -1&0&0 \\\\ 0&0 & -1&0 \\\\ 0&0&0&1 \end{bmatrix} .
$$

Таким же тензорныеные продукты двух операторов Паули-$Z $ образуют матрицу, состоящую из двух пробелов, состоящих из $ + 1 $ и $-1 $ еиженвалуес.
Как и в случае с одним кубит, оба составляют половину пространства, означающее, что половина доступного векторного пространства принадлежит к еиженспаце $ + 1 $ , а оставшаяся половина — к $-1 $ еиженспаце.
Как правило, можно легко узнать от определения продукта тензорные, что любое тензорные произведение операторов Паули-$Z $ и удостоверение также подчиняется этому.
Например,

\бегин{алигн}
    Z \отимес \болдоне = \бегин{bmatrix}
        1 & 0 & 0 & 0 \\ \\ 0 & 1 & 0 & 0 \\ \\ 0 & 0 &-1 & 0 \\ \\ 0 & 0 & 0 &-1 \енд{ bmatrix } .
\енд{алигн}
$$

Как и раньше, любое единое преобразование таких матриц также описывает две пробелы с меткой $ \пм 1 $ еиженвалуес.
Например, $X \otimes X = h h \otimes (z \otimes z) h \otimes h по $ идентификатору, $Z = хксх $ .
Как и в случае с одним кубит, все два кубит Паули-измерения могут быть написаны как $U ^ \дагжер (Z \otimes \ид) U $ для $4 \times 4 $ единых матриц $U $ . Перечислить преобразования в следующей таблице.

> [!NOTE]
> В таблице ниже мы используем $ \Операторнаме{СВАП } $ для обозначения матрицы $ $ \бегин{алигн}
>     \Операторнаме{СВАП } & = \лефт (\бегин{Матрикс}
>         1 & 0 & 0 & 0 \\ \\ 0 & 0 & 1 & 0 \\ \\ 0 & 1 & 0 & 0 \\ \\ 0 & 0 & 0 & 1 \енд{Матрикс } \ригхт) \енд{алигн}
> $ $ используется для имитации внутренней операции [`SWAP`](xref:microsoft.quantum.intrinsic) .

|Измерение Паули     |Единое преобразование  |
|----------------------|------------------------|
| $Z \отимес \болдоне$ | $ \болдоне \отимес \болдоне$ |
| $Z \otimes \болдоне$ | \болдоне $ \болдоне \otimes$ |
| $X \otimes \болдоне$ | $H \otimes \болдоне$ |
| $Y \otimes \болдоне$ | $HS ^ \дагжер \otimes \болдоне$ |
| $ \болдоне \отимес Z$ | \Операторнаме{СВАП}$ |
| $ \болдоне \отимес X$ | $ (H \otimes \болдоне) \операторнаме{СВАП}$ |
| $ \болдоне \отимес Y$ | $ (HS ^ \дагжер \otimes \болдоне) \операторнаме{СВАП}$ |
| $Z \otimes Z$ | $ \Операторнаме{кнот } \_ {10}$ |
| $X \otimes Z$ | $ \Операторнаме{кнот } \_ {10 } (H \otimes \болдоне) $ |
| $Y \otimes Z$ | $ \Операторнаме{кнот } \_ {10 } (HS ^ \дагжер \otimes \болдоне) $ |
| $Z \otimes X$ | $ \Операторнаме{кнот } \_ {10 } (\болдоне \otimes H) $ |
| $X \otimes X$ | $ \Операторнаме{кнот } \_ {10 } (h \otimes h) $ |
| $Y \otimes X$ | $ \Операторнаме{кнот } \_ {10 } (HS ^ \дагжер \otimes H) $ |
| $Z \otimes Y$ | $ \Операторнаме{кнот } \_ {10 } (\болдоне \отимес HS ^ \дагжер) $ |
| $X \otimes Y$ | $ \Операторнаме{кнот } \_ {10 } (H \otimes HS ^ \дагжер) $ |
| $Y \otimes Y$ | $ \Операторнаме{кнот } \_ {10 } (HS ^ \дагжер \otimes HS ^ \дагжер) $ |

Здесь [`CNOT`](xref:microsoft.quantum.intrinsic.cnot) операция отображается по следующей причине.
Каждое измерение Паули, которое не включает матрицу $ \болдоне, $ эквивалентно $Z \otimes Z $ по описанным выше причинам.
$Z еиженвалуес \otimes Z $ зависят только от четности Кубитс, составляющих каждый вектор вычислительных операций, а контролируемые операции не служат для вычисления этой контрольной суммы и ее сохранения в первый бит.
После того как первый бит будет измерен, мы можем восстановить удостоверение результирующей половины пространства, что эквивалентно измерению оператора Паули.

Еще одно Примечание. Хотя может показаться, что измерение $Z Z аналогично \otimes $ последовательному измерению $Z \otimes \mathbb{1 } $, а затем $ \mathbb{1 } \отимес Z $ , это предположение будет ложным.
Причина в том, что измерение $Z \otimes Z $ проецирует состояние такта в $ + 1 $ или $-1 $ еиженстате этих операторов.
Измерение $Z \otimes \mathbb{1 } $, а затем $ \Mathbb{1 } \отимес Z $ Проецирует вектор состояния такта сначала на половину $Z \otimes \mathbb{1 } $, а затем в половину пространства, равное $ \mathbb{1 } \отимес Z $ . При наличии четырех векторов вычисления, выполнение обоих измерений приводит к уменьшению состояния до четвертого пространства и, следовательно, сокращает его до одного вычислительного вектора.

## <a name="correlations-between-qubits"></a>Корреляции между Кубитс
Другим способом измерения тензорныеных продуктов Паули матриц, таких как $X \otimes X $ или $Z \otimes Z $ , является то, что эти измерения позволяют просматривать сведения, хранящиеся в корреляциях между двумя Кубитс.
Измерение $X \otimes \ид $ позволяет просматривать информацию, которая хранится локально в первой кубит.
Несмотря на то что оба типа измерений в тактовых вычислениях одинаково важны, в бывшей степени используются возможности тактовых вычислений.
Он показывает, что в тактовых вычислениях часто сведения, которые вы хотите изучить, не хранятся ни в одном кубит, а в отдельном месте, а не в Кубитс, и, следовательно, только с помощью совместного измерения (например, $Z \otimes Z $ ) эти сведения становятся манифестом.

Например, при исправлении ошибок мы часто хотели бы узнать, какая ошибка возникла при изучении состояния, которое мы пытаемся защитить.
В примере [кода с зеркальным отражением](https://github.com/microsoft/Quantum/tree/master/samples/error-correction/bit-flip-code) показан пример того, как это можно сделать с помощью таких измерений, как $Z \отимес Z \отимес \ид $ and $ \ид \Отимес z \отимес z $ .
<!-- TODO: change this to a link to the samples browser as soon as the bit-flip code sample is on-boarded. -->

Также можно измерять произвольные операторы Паули, такие как $X \otimes Y \Отимес Z \отимес \болдоне $ .
Все такие тензорныеные продукты операторов Паули имеют только два еиженвалуес $ \пм 1 $ и оба еиженспацес составляют половины пространства всего вектора.
Поэтому они совпадают с указанными выше требованиями.

В Q # такие измерения возвращают $j, $ Если измерение возвращает результат в еиженспаце знака $ (-1) ^ j $ .
Использование Паули измерений в качестве встроенной функции в Q # полезно, так как при измерении таких операторов требуется использовать длинные цепочки из контролируемого шлюза и преобразования базисов для описания диагонализинг $U $ шлюза, необходимого для выражения операции как тензорныеного произведения $Z $ и $ \ид $ . Благодаря возможности указать, что вы хотите выполнить одно из этих предварительно определенных измерений, не нужно беспокоиться о том, как преобразовать базу таким образом, чтобы измерение базисных данных предваряет необходимую информацию.
Q # обрабатывает все необходимые преобразования автоматически.
Дополнительные сведения см. в разделе [`Measure`](xref:microsoft.quantum.intrinsic.measure) [`MeasurePaulis`](xref:microsoft.quantum.measurement.measurepaulis) операции и.

## <a name="the-no-cloning-theorem"></a>Теорема без клонирования

Сведения о такте являются мощными.
Это позволяет нам сделать незначительную работу, например, экспоненциальное количество факторов быстрее, чем лучшие известные классические алгоритмы, или эффективно моделировать коррелированные системы электронного представления, которые в классической степени потребовали экспоненциальной стоимости для корректной имитации.
Однако существуют ограничения на возможности тактовых вычислений.
Одно такое ограничение предоставляется *без клонирования Теорема*.

Теорема без клонирования — это выразился с именем.
Он запрещает клонирование универсальных состояний тактов на тактовый компьютер.
Проверка теоремаа очень проста.
Хотя полное подтверждение теоремаа без клонирования является слишком техническим для нашего обсуждения, в случае отсутствия дополнительного вспомогательного Кубитс в нашей области (вспомогательные кубитсы Кубитс используются для временных пространств во время вычислений и легко используются и управляются в Q #, см. раздел [позаимствование Кубитс](xref:microsoft.quantum.guide.qubits#borrowed-qubits)).

Для такого тактового компьютера операция клонирования должна быть описана единой матрицей.
Мы запрещаем измерение, так как это привело бы к повреждению состояния такта, которое мы пытаемся клонировать.
Для имитации операции клонирования требуется, чтобы в единой матрице использовалось свойство, которое $ $ U \кет { \пси } \ket{0 } = \кет { \пси } \кет { \пси}
$ $ для любого состояния $ \кет { \пси } $.
Затем свойство линейного умножения матрицы подразумевает, что для любого второго состояния такта $ \кет { \фи } $

\бегин{алигн}
    U \лефт [\frac{1 } {\sqrt{2 } } \лефт (\кет { \фи } + \кет { \пси } \ригхт) \ригхт] \ket{0}
    & = \frac{1 } {\sqrt{2 } } U \ket { \фи } \ket{0}
      + \frac{1 } {\sqrt{2 } } U \ket { \пси } \ket{0 } \\ \\ & = \frac{1 } {\sqrt{2 } } \лефт (\кет { \фи } \кет { \фи } + \кет { \пси } \кет { \пси}
        \ригхт) \\ \\ & \не \лефт (\frac{1 } {\sqrt{2 } } \лефт (\кет { \фи } + \кет { \пси } \ригхт) \ригхт) \отимес \лефт (\frac{1 } {\sqrt{2 } } \лефт (\кет { \фи } + \кет { \psi } \right) \right).
\енд{алигн}
$$

Это обеспечивает фундаментальный интуиция за пределами Теорема без клонирования: любое устройство, которое копирует неизвестное состояние такта, должно вызвать ошибки по крайней мере в некоторых из скопированных состояний.
Хотя в качестве ключевого предположения, что клонирование работает линейно во входном состоянии, может быть нарушено благодаря добавлению и измерению вспомогательных Кубитс, такое взаимодействие также приводит к утечке информации о системе через статистику измерений и предотвращает точную клонирование в таких случаях.
Более полное подтверждение Теорема без клонирования см. в разделе Дополнительные [сведения](xref:microsoft.quantum.more-information).

Теорема без клонирования важна для качественного понимания тактовых вычислений, так как если вы могли клонировать состояния такта недорого, вам будет предоставлена возможность почти Magical получать сведения о состояниях тактов.
Действительно, можно нарушать принцип неопределенности ваунтед Гейзенбега.
Кроме того, можно использовать оптимальный клон для получения одного примера из сложного распределения тактов и изучить все, что вы можете узнать об этом распространении, только из одного примера.
Это будет похоже на то, что вы передаете монет и просматривая головки, а затем сообщаете друзьям о результате, что они отвечают: "AH. распределение этого монет должно быть Бернулли с $p = 0.512643 \ лдотс $ !"  Такой оператор будет не сенсикал, так как один бит информации (результат Head) просто не может предоставить множество данных, необходимых для кодирования распределения, без существенной информации.
Аналогично, без предварительной информации мы не можем точно клонировать состояние такта, так как мы не можем подготовить ансамблей таких монет, не зная $p $ .

В тактовых вычислениях информация не предоставляется.
Каждый измеренный кубит предоставляет один небольшой объем информации, и теорема без клонирования показывает, что нет программы трояны, которые можно использовать для обхода фундаментального компромисса между информацией, полученной от системы, и вызываемой беспорядки.
