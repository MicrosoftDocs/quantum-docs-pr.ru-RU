---
title: Паули измерения
description: Узнайте, как работать с одной и несколькими кубит Паули измерениями.
author: QuantumWriter
uid: microsoft.quantum.concepts.pauli
ms.author: nawiebe@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: 08babbcb0d6c6c4d83622489bc4ecc811e64829a
ms.sourcegitcommit: a0e50c5f07841b99204c068cf5b5ec8ed087ffea
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/26/2020
ms.locfileid: "80320861"
---
# <a name="pauli-measurements"></a>Паули измерения

В предыдущих обсуждениях мы посвящены измерениям вычислительной единицы.
На самом деле, в тактовых вычислениях существуют и другие распространенные измерения, которые удобны для вычисления измерений базисных показателей.
При работе с Q # наиболее распространенные измерения, с которыми вы будете работать, скорее всего, будут *Паули измерениями*, которые обобщает базовые показатели вычислений, чтобы включить измерения в другие базовые показатели, и четность между различными Кубитс.
В таких случаях часто обсуждается измерение оператора Паули, в целом оператор, такой как $X, Y, Z $ или $Z \отимес Z, Кс\отимес X, Кс\отимес Y $ и т. д.

> [!TIP]
> В Q # операторы Multi-кубит Паули обычно представлены массивами типа `Pauli[]`.
> Например, чтобы представить $X \отимес Z \отимес Y $, можно использовать `[PauliX, PauliZ, PauliY]`массива.

Обсуждение измерения с точки зрения операторов Паули особенно распространено во подполе исправления ошибок такта.
В Q # Мы соблюдаем аналогичное соглашение. Теперь мы объясним это альтернативное представление измерений.

Прежде чем углубляться в подробные сведения о том, как представить Паули измерение, полезно подумать о том, какой размер одного кубита в тактовой частоте в состоянии такта.
Представьте, что у нас есть $nное состояние такта $-кубит. затем измерение одного кубит сразу же применяет половину из $2 ^ n $ возможностей, которые могут быть в состоянии.
Иными словами, измерение проецирует состояние такта на одну из двух половинных пробелов.
Мы можем обобщить способ, который мы думаем о измерении, чтобы отразить этот интуиция.

Для краткого выделения этих подпространств требуется язык для их описания.
Один из способов описания двух подразделений состоит в том, что они указываются через матрицу с двумя уникальными еиженвалуес, принятыми в соответствии с соглашением $ \пм $1.
Простой пример описания подпространства таким образом можно $Z $:

$ $ \бегин{алигн} Z & = \бегин{бматрикс} 1 & 0 \\\\ 0 &-1 \енд{бматрикс}.
\енд{алигн} $ $

Прочитав диагональные элементы матрицы Паули-$Z $, можно увидеть, что $Z $ имеет два основе собственных векторов, $ \кет{0}$ и $ \кет{1}$ с соответствующими еиженвалуес $ \пм $1.
Таким образом, если мы измеряем кубит и получаем `Zero` (в соответствии с состоянием $ \кет{0}$), мы понимаем, что состояние нашего кубит — $ + $1 еиженстате оператора $Z $.
Аналогичным образом, если мы получаем `One`, мы понимаем, что кубит $Z еиженстате $-$1.
Этот процесс упоминается в языке Паули измерений как «измерение Паули $Z $» и полностью эквивалентен вычислению базового измерения.

Любая матрица $2 \ раз $2, которая является единым преобразованием $Z $, также удовлетворяет этим критериям.
То есть можно также использовать матрицу $A = U ^ \дагжер Z U $, где $U $ — это любая другая единая матрица, чтобы получить матрицу, определяющую два результата измерения в его \пме $1 основе собственных векторов.
Нотация измерений Паули ссылается на это единое эквивалентное определение $X, Y, Z $ измерений в качестве эквивалентных измерений, которые можно сделать для получения информации из кубит.
Для удобства эти измерения приведены ниже.


|Измерение Паули  |Единое преобразование  |
|-------------------|------------------------|
| $Z $               | $ \болдоне $             |
| $X $               | $H $                    |
| $Y $               | $HS ^ {\дагжер} $         |

То есть при использовании этого языка "мера $Y $" эквивалентен применению $HS ^ \дагжер $, а затем измеряется в вычислительной базе, где [`S`](xref:microsoft.quantum.intrinsic.s) является внутренней операцией такта, которая иногда называется "фазой фазы", и может быть смоделирована единой матрицей.

$ $ \бегин{алигн} S = \бегин{бматрикс} 1 & 0 \\\\ 0 & i \енд{бматрикс}.
\енд{алигн} $ $

Он также эквивалентен применению $HS ^ \дагжер $ к вектору состояния такта, а затем измерению $Z $, чтобы следующая операция эквивалентна `Measure([PauliY], [q])`:

```Q#
operation MeasureY(qubit : Qubit) : Result {
    mutable result = Zero;
    within {
        H(q);
        Adjoint S(q);
    } apply {
        set result = M(q);
    }
    return result;
}
```

Затем правильное состояние будет найдено путем преобразования обратно в вычислительную базу, что соответствует применению $SH $ к вектору состояния такта; в приведенном выше фрагменте данных преобразование обратно в вычислительную базу обрабатывается автоматически с помощью блока `within … apply`.

В Q # мы говорим результат---то есть классическая информация, извлеченная из взаимодействия с---ом состояния, определяется значением `Result` $j \ин \\{\Тексттт{зеро}, \Тексттт{Оне}\\} $, указывающим, что результат находится в $ (-1) ^ j $ еиженспаце оператора Паули.


## <a name="multiple-qubit-measurements"></a>Кубит измерения

Измерения кубит операторов Паули определены аналогично, как показано в следующих случаях:

$ $ З\отимес Z = \begin{bmatrix}1 & 0 & 0 & 0\\\\ 0 &-1 & 0 & 0\\\\ 0 & 0 &-1 & 0\\\\ 0 & 0 & 0 & 1 \ {бматрикс}.
$$

Таким же тензорныеные продукты двух операторов Паули-$Z $ образуют матрицу, состоящую из двух пробелов: $ + $1 и $-$1 еиженвалуес.
Как и в случае с одним кубит, оба составляют половину пространства, означающее, что половина доступного векторного пространства принадлежит еиженспацеу $ + $1, а оставшаяся половина — еиженспаце $-$1.
Как правило, это легко видно из определения продукта тензорные, что любое тензорные произведение операторов Паули-$Z $ и удостоверение также подчиняется этому.
Например,

$ $ \бегин{алигн} Z \отимес \болдоне = \бегин{бматрикс} 1 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 &-1 & 0 \\\\ 0 & 0 & 0 &-1 \енд{бматрикс}.
\енд{алигн} $ $

Как и раньше, любое единое преобразование таких матриц также описывает две пробелы с меткой $ \пм $1 еиженвалуес.
Например, $X \отимес X = Х\отимес H (З\отимес Z) Х\отимес H $ по идентификатору, $Z = ХКСХ $.
Как и в случае с одним кубит, все два кубит Паули-измерения могут быть написаны как $U ^ \дагжер (З\отимес \ид) U $ для $4 \ раз $4 единые матрицы $U $. Перечислить преобразования в следующей таблице.

> [!NOTE]
> В таблице ниже мы используем $ \Операторнаме{СВАП} $ для указания матрицы $ $ \бегин{алигн} \Операторнаме{СВАП} & = \лефт (\бегин{Матрикс} 1 & 0 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 1 & 0 & 1 \енд{Матрикс}\ригхт) \end{align} $ $ используется для имитации [\\](xref:microsoft.quantum.intrinsic)внутренней операции.\\`SWAP`

|Измерение Паули     |Единое преобразование  |
|----------------------|------------------------|
| $Z \отимес \болдоне $ | $ \болдоне \отимес \болдоне $ |
| $Z \отимес \болдоне $ | $ \болдоне\отимес \болдоне $ |
| $X \отимес \болдоне $ | $H \отимес \болдоне $ |
| $Y \отимес \болдоне $ | $HS ^ \дагжер\отимес \болдоне $ |
| $ \болдоне \отимес Z $ | $ \Операторнаме{СВАП} $ |
| $ \болдоне \отимес X $ | $ (Х\отимес \болдоне) \Операторнаме{СВАП} $ |
| $ \болдоне \отимес Y $ | $ (HS ^ \дагжер\отимес \болдоне) \Операторнаме{СВАП} $ |
| $Z \отимес Z $ | $ \Операторнаме{кнот}\_{10}$ |
| $X \отимес Z $ | $ \Операторнаме{кнот}\_{10}(Х\отимес \болдоне) $ |
| $Y \отимес Z $ | $ \Операторнаме{кнот}\_{10}(HS ^ \дагжер\отимес \болдоне) $ |
| $Z \отимес X $ | $ \Операторнаме{кнот}\_{10}(\болдоне\отимес H) $ |
| $X \отимес X $ | $ \Операторнаме{кнот}\_{10}(Х\отимес H) $ |
| $Y \отимес X $ | $ \Операторнаме{кнот}\_{10}(HS ^ \дагжер\отимес H) $ |
| $Z \отимес Y $ | $ \Операторнаме{кнот}\_{10}(\болдоне \отимес HS ^ \дагжер) $ |
| $X \отимес Y $ | $ \Операторнаме{кнот}\_{10}(Х\отимес HS ^ \дагжер) $ |
| $Y \отимес Y $ | $ \Операторнаме{кнот}\_{10}(HS ^ \дагжер\отимес HS ^ \дагжер) $ |

Здесь [`CNOT`](xref:microsoft.quantum.intrinsic.cnot) операция отображается по следующей причине.
Каждое измерение Паули, которое не включает матрицу $ \болдоне $, эквивалентно $Z \отимес Z $ по описанным выше причинам.
Еиженвалуес $Z \отимес Z $ зависят только от четности Кубитс, которая состоит из каждого вычислительного вектора, а контролируемые операции не служат для вычисления этой контрольной суммы и ее сохранения в первый бит.
После того как первый бит будет измерен, мы можем восстановить удостоверение результирующей половины пространства, что эквивалентно измерению оператора Паули.

Еще одно Примечание. Хотя может показаться, что измерение $Z \отимес Z $ аналогично последовательному измерению $Z \отимес \масбб{1}$, а затем $ \масбб{1} \отимес Z $, это предположение будет ложным.
Причина в том, что измерение $Z \отимес Z $ проецирует состояние такта в еиженстате ($ + $1 или $-$1) этих операторов.
Измерение $Z \отимес \масбб{1}$, а затем $ \масбб{1} \отимес Z $ Проецирует вектор состояния такта сначала в половину пространства $Z \отимес \масбб{1}$, а затем в половину пространства $ \масбб{1} \отимес Z $.
При наличии четырех векторов вычисления, выполнение обоих измерений приводит к уменьшению состояния до четвертого пространства и, следовательно, сокращает его до одного вычислительного вектора.

## <a name="correlations-between-qubits"></a>Корреляции между Кубитс
Другим способом измерения тензорные продуктов матриц Паули, таких как $X \отимес X $ или $Z \отимес Z $, является то, что эти измерения позволяют просматривать сведения, хранящиеся в корреляциях между двумя Кубитс.
Измерение $X \отимес \ид $ позволяет просматривать информацию, которая хранится локально в первом кубит.
Несмотря на то что оба типа измерений в тактовых вычислениях одинаково важны, в бывшей степени используются возможности тактовых вычислений.
Он показывает, что в тактовых вычислениях часто сведения, которые вы хотите изучить, не хранятся ни в одном кубит, а в отдельном расположении, а не в локальной среде Кубитс, и поэтому только просматривая их с помощью совместного измерения (например, $Z \отимес Z $) делает это сведения становятся манифестом.

Например, при исправлении ошибок мы часто хотели бы узнать, какая ошибка возникла при изучении состояния, которое мы пытаемся защитить.
В примере [кода с зеркальным отражением](https://github.com/microsoft/Quantum/tree/master/samples/error-correction/bit-flip-code) показан пример того, как это можно сделать с помощью таких измерений, как $Z \отимес Z \отимес \ид $ and $ \Ид \отимес Z \отимес z $.
<!-- TODO: change this to a link to the samples browser as soon as the bit-flip code sample is on-boarded. -->

Также можно измерять произвольные операторы Паули, такие как $X \отимес Y \отимес Z \отимес \болдоне $.
Все такие тензорныеные продукты операторов Паули имеют только два еиженвалуес $ \пм $1 и оба еиженспацес составляют половины пространства всего вектора.
Поэтому они совпадают с указанными выше требованиями.

В Q # такие измерения возвращают $j $, если измерение возвращает результат в еиженспаце знака $ (-1) ^ j $.
Использование Паули измерений в качестве встроенной функции в Q # полезно, так как для измерения таких операторов требуются длинные цепочки управляемых и не основанных на шлюзах преобразования, чтобы описать диагонализинг $U $ Gate, необходимый для выражения операции как тензорныеного произведения $Z $ и $ \ид $.
Благодаря возможности указать, что вы хотите выполнить одно из этих предварительно определенных измерений, не нужно беспокоиться о том, как преобразовать базу таким образом, чтобы измерение базисных данных предваряет необходимую информацию.
Q # обрабатывает все необходимые преобразования автоматически.
Дополнительные сведения см. в разделе операции [`Measure`](xref:microsoft.quantum.intrinsic.measure) и [`MeasurePaulis`](xref:microsoft.quantum.measurement.measurepaulis) .

## <a name="the-no-cloning-theorem"></a>Теорема без клонирования

Сведения о такте являются мощными.
Это позволяет нам сделать незначительную работу, например, экспоненциальное количество факторов быстрее, чем лучшие известные классические алгоритмы, или эффективно моделировать коррелированные системы электронного представления, которые в классической степени потребовали экспоненциальной стоимости для корректной имитации.
Однако существуют ограничения на возможности тактовых вычислений.
Одно такое ограничение предоставляется *без клонирования Теорема*.

Теорема без клонирования — это выразился с именем.
Он запрещает клонирование универсальных состояний тактов на тактовый компьютер.
Проверка теоремаа очень проста.
Хотя полное подтверждение теоремаа без клонирования является слишком техническим для нашего обсуждения, в случае отсутствия дополнительного вспомогательного Кубитс в нашей области (вспомогательные кубитсы Кубитс используются для временного пространства во время вычислений и легко используются и управляются в Q #, см. <xref:microsoft.quantum.techniques.qubits>).

Для такого тактового компьютера операция клонирования должна быть описана единой матрицей.
Мы запрещаем измерение, так как это привело бы к повреждению состояния такта, которое мы пытаемся клонировать.
Для имитации операции клонирования требуется, чтобы в единой матрице использовалось свойство, которое $ $ U \кет{\пси} \кет{0} = \кет{\пси} \кет{\пси} $ $ для любого состояния $ \кет{\пси} $.
Затем свойство линейного умножения матрицы подразумевает, что для любого второго состояния такта $ \кет{\фи} $

$ $ \бегин{алигн} U \лефт [\фрак{1}{\скрт{2}} \лефт (\кет{\фи} + \кет{\пси} \ригхт) \ригхт] \кет{0} & = \фрак{1}{\скрт{2}} U\ket {\ фи} \ Сисакет{0} + \frac{1}{\sqrt{2}} U\ket {\ PSI} \ Сисакет{0} \\\\ & = \frac{1}{\sqrt{2}} \left (\ket{\Phi} \ket{\Phi} + \ket{\psi} \ket{\psi} \right) \\\\ & \ne \left (\frac{1}{\sqrt{2}} \left (\ket{\Phi} + \ket{\psi} \right) \right) \otimes \ Left (\фрак{1}{\скрт{2}} \лефт (\кет{\фи} + \кет{\пси} \ригхт) \ригхт).
\енд{алигн} $ $

Это обеспечивает фундаментальный интуиция за пределами Теорема без клонирования: любое устройство, которое копирует неизвестное состояние такта, должно вызвать ошибки по крайней мере в некоторых из скопированных состояний.
Хотя в качестве ключевого предположения, что клонирование работает линейно во входном состоянии, может быть нарушено благодаря добавлению и измерению вспомогательных Кубитс, такие взаимодействия также отключают сведения о системе через статистику измерений и не позволяют точнее также клонирование в таких случаях.
Более полное подтверждение Теорема без клонирования см. в разделе Дополнительные [сведения](xref:microsoft.quantum.more-information).

Теорема без клонирования важна для качественного понимания тактовых вычислений, так как если вы могли клонировать состояния такта недорого, вам будет предоставлена возможность почти Magical получать сведения о состояниях тактов.
Действительно, можно нарушать принцип неопределенности ваунтед Гейзенбега.
Кроме того, можно использовать оптимальный клон для получения одного примера из сложного распределения тактов и изучить все, что вы можете узнать об этом распространении, только из одного примера.
Это будет похоже на то, что вы передаете монет и просматривая головки, а затем сообщаете друзьям о результате, что они отвечают: "AH. распределение этого монет должно быть Бернулли с $p = 0.512643 \ лдотс $!"  Такой оператор будет не сенсикал, так как один бит информации (результат Head) просто не может предоставить множество данных, необходимых для кодирования распределения, без существенной информации.
Аналогично, без предварительной информации мы не можем точно клонировать состояние такта, так как мы не можем подготовить ансамблей таких монет, не зная $p $.

В тактовых вычислениях информация не предоставляется.
Каждый измеренный кубит предоставляет один небольшой объем информации, и теорема без клонирования показывает, что нет программы трояны, которые можно использовать для обхода фундаментального компромисса между информацией, полученной от системы, и вызываемой беспорядки.
