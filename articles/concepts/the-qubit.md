---
title: Кубит в тактовых вычислениях
description: Узнайте о Кубитс, фундаментальной единице информации в тактовых вычислениях.
author: QuantumWriter
uid: microsoft.quantum.concepts.qubit
ms.author: nawiebe@microsoft.com
ms.date: 12/11/2017
ms.topic: article
no-loc:
- $
- $
- $
- $
- $
- $
- '\cdots'
- bmatrix
- '\ddots'
- '\equiv'
- '\sum'
- '\begin'
- '\end'
- '\sqrt'
- '\otimes'
- '{'
- '}'
- '\text'
- '\phi'
- '\kappa'
- '\psi'
- '\alpha'
- '\beta'
- '\gamma'
- '\delta'
- '\omega'
- '\bra'
- '\ket'
- '\boldone'
- '\\\\'
- '\\'
- =
- '\frac'
- '\text'
- '\mapsto'
- '\dagger'
- '\to'
- "\begin{cases}"
- "\end{cases}"
- '\operatorname'
- '\braket'
- '\id'
- '\expect'
- '\defeq'
- '\variance'
- '\dd'
- '&'
- "\begin{align}"
- "\end{align}"
- '\Lambda'
- '\lambda'
- '\Omega'
- '\mathrm'
- '\left'
- '\right'
- '\qquad'
- '\times'
- '\big'
- '\langle'
- '\rangle'
- '\bigg'
- '\Big'
- '|'
- '\mathbb'
- '\vec'
- '\in'
- '\texttt'
- '\ne'
- <
- '>'
- '\leq'
- '\geq'
- ~~
- "~"
- "\begin{bmatrix}"
- "\end{bmatrix}"
- '\_'
ms.openlocfilehash: 0b768190137aa4effe0fbac9c764dff60ec00e16
ms.sourcegitcommit: 0181e7c9e98f9af30ea32d3cd8e7e5e30257a4dc
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/23/2020
ms.locfileid: "85269581"
---
# <a name="the-qubit"></a>Кубит

Точно так же, как бит — это фундаментальный объект информации в классических вычислениях, [*Кубитс*](https://en.wikipedia.org/wiki/Qubit) (Тактовый бит) является фундаментальным объектом информации в тактовых вычислениях.  Чтобы разобраться в этой корреспонденции, Рассмотрим простейший пример: один кубит.

## <a name="representing-a-qubit"></a>Представление кубит

Хотя бит или двоичная цифра может иметь значение $0 $ или $1 $ , кубит может иметь значение, которое является либо из этих значений, либо частью такта $0 $ и $1 $ .

Состояние одного кубит может описываться векторным столбцом, равным норме, то есть величина, квадратная часть ее записей, должна суммироваться до $1 $ . Этот вектор, называемый вектором состояния такта, содержит всю информацию, необходимую для описания однокубитной тактовой системы, точно так же, как один бит содержит всю информацию, необходимую для описания состояния двоичной переменной.

Любой двумерный вектор столбца с реальными или комплексными числами с нормой $1 $ представляет возможное состояние такта, удерживаемое кубит. Таким словами, $ \бегин{ bmatrix } \алфа \\ \\ \бета \енд{ bmatrix } $ представляет состояние кубит, если $ \алфа $ и $ \бета $ являются комплексными числами, удовлетворяющими $ | \алфа | ^ 2 + | \бета | ^ 2 = 1 $ . Некоторые примеры допустимых векторов состояния такта, представляющих Кубитс, включают

$ $ \бегин{ bmatrix } 1 \\ \\ 0 \енд{ bmatrix } , \бегин{ bmatrix } 0 \\ \\ 1 \енд{ bmatrix } , \бегин{ bmatrix } \frac{1 } {\sqrt{2 } } \\ \\ \frac{1 } {\sqrt{2 } } \енд{ bmatrix } , \бегин{ bmatrix } \frac{1 } {\sqrt{2 } } \\ \\ \фрак { -1 } {\sqrt{2 } } \енд{ bmatrix } , \текст { и} \бегин{ bmatrix } \frac{1 } {\sqrt{2 } } \\ \\ \фрак{и } {\sqrt{2 } } \енд{ bmatrix } . $ $

Векторы состояния такта $ \бегин{ bmatrix } 1 \\ \\ 0 \енд{ bmatrix } $ и $ \бегин{ bmatrix } 0 \\ \\ 1 \енд{ bmatrix } $ принимают особую роль. Эти два вектора формируют базу для векторного пространства, описывающего состояние кубит. Это означает, что любой вектор состояния такта может быть записан как сумма этих векторов. В частности, вектор $ \бегин{ bmatrix } x \\ \\ y \енд{ bmatrix } $ может быть написан как $x \бегин{ bmatrix } 1 \\ \\ 0 \енд{ bmatrix } + y \бегин{ bmatrix } 0 \\ \\ 1 \енд{ bmatrix } $. Хотя любой поворот этих векторов будет служить вполне допустимой базой для кубит, мы решили установить привилегию для этого, вызвав его *вычислительной основе*.

Мы принимаем эти два состояния тактов в соответствии с двумя состояниями классического бита, а именно $0 $ и $1 $ . Стандартным соглашением является выбор

$0 \equiv \бегин{ bmatrix } 1 \\ \\ 0 \енд{ bmatrix } , \ккуад 1 \екуив \бегин{ bmatrix } 0 \\ \\ 1 \енд{ bmatrix } , $ $

Хотя обратное решение также может быть принято. Таким словами, из-за неограниченного количества возможных векторов состояния однокубитного такта, только два соответствуют состояниям классических битов; все остальные состояния тактов не имеют.

## <a name="measuring-a-qubit"></a>Измерение кубит

Теперь, когда мы понимаем, как представлять кубит, мы можем получить некоторые интуиция, представляющие эти состояния, обсудим концепцию [*измерения*](https://en.wikipedia.org/wiki/Measurement_in_quantum_mechanics). Измерение соответствует неформальной идее «взгляда» на кубит, который немедленно сворачивает состояние такта в одно из двух классических состояний $ \бегин{ bmatrix } 1 \\ \\ 0 \енд{ bmatrix } $ или $ \бегин{ bmatrix } 0 \\ \\ 1 \енд{ bmatrix } $. Когда измеряется кубит, заданный с помощью вектора состояния такта $ \бегин{ bmatrix } \алфа \\ \\ \бета \енд{ bmatrix } $, мы получаем результат $0 $ с вероятностью $ | \алфа | ^ 2 $ и результатом $1 $ с вероятностью $ | \бета | ^ 2 $ . В результате $0 $ новое состояние кубит — $ \бегин{ bmatrix } 1 \\ \\ 0 \енд{ bmatrix } $; в результате $1 $ его состояние — $ \бегин{ bmatrix } 0 \\ \\ 1 \енд{ bmatrix } $. Обратите внимание, что эти вероятности суммируются до $1 $ из-за условия нормализации $ | \алфа | ^ 2 + | \бета | ^ 2 = 1 $ .

Свойства измерения также означают, что общий знак вектора состояния такта не имеет значения. Отрицание вектора эквивалентно $ \алфа \ригхтарров-\алфа $ и $ \бета \ригхтарров-\бета $ . Так как вероятность измерения $0 $ и $1 $ зависит от величины, заключенной в квадраты терминов, вставка таких знаков не влияет на вероятность. Такие этапы обычно называются [ `` *глобальными этапами*""](https://en.wikipedia.org/wiki/Phase_factor) , и в общем случае они могут иметь форму $e ^ {i \фи } $, а не только $ \пм 1 $ .

Последнее важное свойство измерения заключается в том, что оно не обязательно приводит к повреждению всех векторов состояния тактов. Если начать с кубит в состоянии $ \бегин{ bmatrix } 1 \\ \\ 0 \енд{ bmatrix } $, которое соответствует классу $0 классический $ , то измерение этого состояния всегда будет выдавать результат $0 $ и оставляет состояние такта без изменений. В этом смысле, если у нас есть только классические биты (т. е. Кубитс, которые имеют значение $ \бегин{ bmatrix } 1 \\ \\ 0 \енд{ bmatrix } $ или $ \бегин{ bmatrix } 0 \\ \\ 1 \енд{ bmatrix } $), измерение не повредит системе. Это означает, что мы можем реплицировать классические данные и манипулировать ими на компьютере-такте точно так же, как и на классическом компьютере. Однако возможность хранить информацию в обоих состояниях одновременно с тем, что повышает тактовую частоту, помимо того, что возможно на классической основе и более Робс тактовыми компьютерами возможности копирования тактовых данных неособым путем, см. также [Теорема без клонирования](https://en.wikipedia.org/wiki/No-cloning_theorem).

## <a name="visualizing-qubits-and-transformations-using-the-bloch-sphere"></a>Визуализация Кубитс и преобразований с помощью сферы БЛОЧ

Кубитс также может быть изображен в $3 $ D с помощью представления [*сферы БЛОЧ*](https://en.wikipedia.org/wiki/Bloch_sphere) .  Сфера БЛОЧ предоставляет способ описания однокубитого состояния такта (который является двумерным сложным вектором) в виде трехмерного вектора с реальным значением.  Это важно, так как это позволяет визуализировать кубит состояния и, таким образом, разрабатывать причины, которые могут оказаться бесполезными для понимания кубит Штатов (где, увы, сфера).  Сферу БЛОЧ можно выработать следующим образом:

<!--- ![](.\media\bloch.svg){ width=50% } --->
![БЛОЧ шар](~/media/concepts_bloch.png)

Стрелки на этой схеме показывают направление, в котором указывает вектор состояния такта, и каждое преобразование стрелки можно представить как поворот одной из осей кардинала.
Во время обдумывания вычисления такта как последовательности поворотов является мощным интуиция, трудно использовать этот интуиция для проектирования и описания алгоритмов. Q # устраняет эту проблему, предоставляя язык для описания таких поворотов.

## <a name="single-qubit-operations"></a>Операции с одним кубит

Тактовые компьютеры обрабатывают данные, применяя универсальный набор тактов, который может эмулировать любой поворот вектора состояния такта.
Это понятие универсальности является аналогом универсальности для традиционных (например, классических) вычислений, когда набор шлюзов считается универсальным, если каждое преобразование входных битов может быть выполнено с использованием цепи с ограничением длины.
В тактовых вычислениях Допустимые преобразования, которые мы разрешено выполнять в кубит, являются едиными преобразованиями и измерениями.
*Смежная операция* или комплексное сопряженное Перестановка — это крайне важная важность для создания тактовых вычислений, так как оно требуется для инвертирования квантов времени.
Q # отражает это, предоставляя методы для автоматической компиляции последовательностей шлюзов в соседние, что позволяет программисту в большинстве случаев аджоинтс код. Ниже приведен пример.

```qsharp
operation PrepareSuperposition(qubit : Qubit) : Unit
is Adj { // Auto-generate the adjoint of the operation
    H(qubit);
}
```

Хотя это тривиальный пример (как <xref:microsoft.quantum.intrinsic.h[!OP.NO-LOC(> ), операция является самосмежной), вы можете увидеть, как это становится неполезным для более сложных операций кубит.
Дополнительные сведения см. в разделе [операции и функции](xref:microsoft.quantum.guide.operationsfunctions).

Существует только четыре функции, которые соотносятся один бит к одному биту на классический компьютер. В отличие от этого, в одном кубит на тактовой системе существует бесконечное количество однозначных преобразований. Таким образом, отсутствие конечного набора операций-примитивных тактов, называемых [*шлюзами*](https://en.wikipedia.org/wiki/Quantum_logic_gate), может точно реплицировать неограниченный набор недопустимых преобразований в тактовых вычислениях. Это означает, что, в отличие от классических вычислений, на такте невозможно реализовать каждую возможную тактовую программу точно с конечным числом шлюзов. Таким же, тактовые компьютеры не могут быть универсальными в одном смысле с классическими компьютерами. В результате, когда мы говорим, что набор шлюзов является *универсальным* для тактовых вычислений, мы имеем в виду что-то немного более слабое, чем мы имеем в виду Классические вычисления.
Для универсальности требуется, чтобы тактовый компьютер был *приблизительным* только для каждой единой матрицы в пределах конечной ошибки, использующей последовательность шлюза с ограничением длины.
Иными словами, набор шлюзов — это универсальный шлюз, если любое единое преобразование может быть приблизительно написано как произведение шлюзов из этого набора. Необходимо, чтобы для любой привязанной ошибки существовало шлюзов $G _ {1 } , G_ {2 } , \лдотс, G_N $ из набора шлюзов таким, что

$ $ G_N G_ {N-1 } \кдотс G_2 G_1 \Аппрокс U. $ $

Обратите внимание, что, поскольку соглашение об умножении матрицы состоит в том, чтобы выполнить умножение справа налево на первую операцию Gate в этой последовательности, $G _N $ , фактически последний раз применяется к вектору состояния такта. Более формально мы говорим, что такой набор шлюзов является универсальным, если для каждой ошибки с допустимым количеством ошибок $ \епсилон>0 $ существует $G _1, \лдотс G_N, $ что расстояние между $G _N \лдотс G_1 $ и $U $ не превышает $ \епсилон $ . В идеале значение $N, $ необходимое для достижения этого расстояния от $ \епсилон, $ должно масштабировать поли-пропорциональны логарифму с $1/\ Эпсилон $ .

Что такой универсальный набор шлюза выглядит на практике?  Простейший универсальный шлюз для кубит шлюзов состоит только из двух шлюзов: Хадамард Gate $H $ и так называемого $T $ -шлюза (также называется шлюзом $ \ PI/8 $ ):

$ $ H = \frac{1 } {\sqrt{2 } } \бегин{ bmatrix } 1 & 1 \\ \\ 1 &-1 \енд{ bmatrix } , \ккуад T = \бегин{ bmatrix } 1 & 0 \\ \\ 0 & e ^ {i \ PI/4 } \енд{ bmatrix } .
$$

Однако для практичных причин, связанных с исправлением ошибок такта, может быть удобнее рассмотреть более крупный набор шлюзов, а именно один, который можно создать с помощью $H $ и $T $ .
Можно классифицировать каждый из этих шлюзов на две категории: Клиффорд Gates и $ шлюз $T.
Это подразделение полезно, поскольку во многих схемах исправления ошибок в такте очень легко реализовать так называемый шлюз Клиффорд. это требует очень мало ресурсов в плане операций и Кубитс для обеспечения отказоустойчивости, в то время как шлюзы, отличные от Клиффорд, являются весьма дорогостоящими, когда требуется отказоустойчивость. Стандартный набор шлюзов с одним кубит Клиффорд, [включенный по умолчанию в Q #](xref:microsoft.quantum.libraries.standard.prelude), include

$ $ H = \frac{1 } {\sqrt{2 } } \бегин{ bmatrix } 1 & 1 \\ \\ 1 &-1 \енд{ bmatrix } , \ккуад S = \бегин{ bmatrix } 1 & 0 \\ \\ 0 & i \енд{ bmatrix } = T ^ 2, \ккуад X = \бегин{ bmatrix } 0 &1 \\ \\ 1 & 0 \енд{ bmatrix } = HT ^, $ $

$ $ Y = \бегин{ bmatrix } 0 &-i \\ \\ & 0 \ЕНД{ bmatrix } = T ^ 2HT ^ 4 HT ^ 6, \ккуад Z = \бегин{ bmatrix } 1&0 \\\\ 0 & -1 \енд{ bmatrix } = T ^ 4.
$$

В данном случае операции $X $ , $Y $ и $Z $ используются особенно часто и называются [*операторами Паули*](https://en.wikipedia.org/wiki/Pauli_matrices) после их создателя Волфганг Паули.
Вместе с шлюзом, отличным от Клиффорд ($T $ ), эти операции могут составляться для приблизительного преобразования одного кубит.

Дополнительные сведения об этих операциях, представлениях БЛОЧ Sphere и реализациях Q # см. в разделе [встроенные операции и функции](xref:microsoft.quantum.libraries.standard.prelude#intrinsic-operations-and-functions).

В качестве примера того, как можно построить единые преобразования из этих примитивов, три преобразования, представленные в БЛОЧ шарик выше, соответствуют последовательности шлюзов $ \бегин{ bmatrix } 1 \\ \\ 0 \енд{ bmatrix } \мапсто хз \бегин{ bmatrix } 1 \\ \\ 0 \енд{ bmatrix } = \бегин{ bmatrix } 0 \\ \\ 1 \енд{ bmatrix } $.

Хотя предыдущее относится к наиболее популярным основным шлюзам для описания операций на логическом уровне стека (Представьте логический уровень в качестве уровня алгоритма такта), часто бывает удобно рассмотреть менее простые операции на уровне алгоритма, например операции ближе к уровню описания функции. К счастью, Q # также содержит методы, доступные для реализации унитариес более высокого уровня, которые, в свою очередь, позволяют реализовать высокоуровневые алгоритмы без явного разворачивания всех Клиффорд и $T $ -Gates.

Простейший такой примитив — это одно кубит вращение. Обычно рассматриваются три однокубитовых поворота: $R _x $ , $R _Y $ и $R _Z $ . Для визуализации действия поворота $R _x (\сета) $, например, представьте правый бегунок в направлении $xной $ оси блочной сферы и поверните вектор с помощью руки через угол $ \ тета/2 $ радиан. Этот непонятный фактор $2 $ возникает из того факта, что ортогональные векторы находятся на расстоянии $180 ^ \Цирк $ при отображении в блочной сфере, но фактически находятся на расстоянии от $90 ^ \Цирк $ градусов. Соответствующие одноединые матрицы:

\бегин{алигн *} &R_z (\сета) = e ^ {-и\сета z/2 } = \бегин{ bmatrix } e ^ {-i \ тета/2 } & 0 \\\\ 0 & e ^ {i \ тета/2 } \енд{ bmatrix } , \\ \\ &R_x (\сета) = e ^ {и\сета x/2 } = HR_z (\сета) H = \бегин{ bmatrix } \кос (\ тета/2) &-и\син (\ тета/2) \\ \\ -и\син (\ тета/2) & \cos (\ тета/2) \end{ bmatrix } , \\ \\ &R_y (\theta) = e ^ {i\theta y/2 } = SHR_z (\theta) HS ^ \dagger = \begin{ bmatrix } \cos (\ тета/2) &-\sin (\ тета/2) \\ \\ \sin (\ тета/2) & \cos (\ тета/2) \end{ bmatrix } . \end{align*}

Точно так же, как любой из трех поворотов можно объединить для выполнения произвольного вращения в трех измерениях, его можно увидеть из представления сферы БЛОЧ, что любая единая матрица может быть записана как последовательность из трех поворотов. В частности, для каждой единой матрицы $U $ существует $ \алфа, \бета, \гамма, \делта, $ $U = e ^ {i \alpha } R_x (\бета) R_z (\гамма) R_x (\делта) $. Таким $R _z (\сета) $ и $H $ также формируют универсальный шлюз, хотя он не является дискретным набором, так как $ \сета $ может принимать любое значение. По этой причине, и из-за приложений в симуляторе тактов, такие непрерывные шлюзы крайне важны для вычислений тактов, особенно на уровне проектирования алгоритма такта. Чтобы реализовать отказоустойчивую аппаратную реализацию, они, в конечном итоге, будут скомпилированы в дискретные последовательности шлюзов, которые точно приблизительно соответствуют этим поворотам.
