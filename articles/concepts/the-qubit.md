---
title: Кубит | Документация Майкрософт
description: Кубит
author: QuantumWriter
uid: microsoft.quantum.concepts.qubit
ms.author: nawiebe@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: f29319c3ec19fecc45f5a9f7c16061b9aa9f71ec
ms.sourcegitcommit: 8becfb03eb60ba205c670a634ff4daa8071bcd06
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/26/2019
ms.locfileid: "73183647"
---
# <a name="the-qubit"></a><span data-ttu-id="37c30-103">Кубит</span><span class="sxs-lookup"><span data-stu-id="37c30-103">The Qubit</span></span>

<span data-ttu-id="37c30-104">Точно так же, как бит — это фундаментальный объект информации в классических вычислениях, [*Кубитс*](https://en.wikipedia.org/wiki/Qubit) (Тактовый бит) является фундаментальным объектом информации в тактовых вычислениях.</span><span class="sxs-lookup"><span data-stu-id="37c30-104">Just as bits are the fundamental object of information in classical computing, [*qubits*](https://en.wikipedia.org/wiki/Qubit) (quantum bits) are the fundamental object of information in quantum computing.</span></span>  <span data-ttu-id="37c30-105">Чтобы разобраться в этой корреспонденции, Рассмотрим простейший пример: один кубит.</span><span class="sxs-lookup"><span data-stu-id="37c30-105">To understand this correspondence, let's look at the simplest example: a single qubit.</span></span>

## <a name="representing-a-qubit"></a><span data-ttu-id="37c30-106">Представление кубит</span><span class="sxs-lookup"><span data-stu-id="37c30-106">Representing a Qubit</span></span>

<span data-ttu-id="37c30-107">Хотя бит или двоичная цифра может иметь значение $0 $ или $1 $, кубит может иметь значение, которое является либо из этих значений, либо частью кванта в $0 $ и $1 $.</span><span class="sxs-lookup"><span data-stu-id="37c30-107">While a bit, or binary digit, can have value either $0$ or $1$, a qubit can have a value that is either of these or a quantum superposition of $0$ and $1$.</span></span>

<span data-ttu-id="37c30-108">Состояние одного кубит может описываться векторным столбцом, равным норме, то есть величина, квадратная часть ее записей, должна суммироваться до $1 $.</span><span class="sxs-lookup"><span data-stu-id="37c30-108">The state of a single qubit can be described by a two-dimensional column vector of unit norm, that is, the magnitude squared of its entries must sum to $1$.</span></span> <span data-ttu-id="37c30-109">Этот вектор, называемый вектором состояния такта, содержит всю информацию, необходимую для описания однокубитной тактовой системы, точно так же, как один бит содержит всю информацию, необходимую для описания состояния двоичной переменной.</span><span class="sxs-lookup"><span data-stu-id="37c30-109">This vector, called the quantum state vector, holds all the information needed to describe the one-qubit quantum system just as a single bit holds all of the information needed to describe the state of a binary variable.</span></span>

<span data-ttu-id="37c30-110">Любой двумерный вектор столбца вещественных или комплексных чисел с нормой $1 $ представляет возможное состояние такта, удерживаемое кубит.</span><span class="sxs-lookup"><span data-stu-id="37c30-110">Any two-dimensional column vector of real or complex numbers with norm $1$ represents a possible quantum state held by a qubit.</span></span> <span data-ttu-id="37c30-111">Таким словами, $ \бегин{бматрикс} \алфа \\\\ \бета \енд{бматрикс} $ представляет состояние кубит, если $ \алфа $ и $ \бета $ являются комплексными числами, удовлетворяющими $ | \алфа | ^ 2 + | \бета | ^ 2 = $1.</span><span class="sxs-lookup"><span data-stu-id="37c30-111">Thus $\begin{bmatrix} \alpha \\\\  \beta \end{bmatrix}$ represents a qubit state if $\alpha$ and $\beta$ are complex numbers satisfying $|\alpha|^2 + |\beta|^2 = 1$.</span></span> <span data-ttu-id="37c30-112">Некоторые примеры допустимых векторов состояния такта, представляющих Кубитс, включают</span><span class="sxs-lookup"><span data-stu-id="37c30-112">Some examples of valid quantum state vectors representing qubits include</span></span>

<span data-ttu-id="37c30-113">$ $ \бегин{бматрикс} 1 \\\\ 0 \енд{бматрикс}, \бегин{бматрикс} 0 \\\\ 1 \енд{бматрикс}, \бегин{бматрикс} \фрак{1}{\sqrt{2}} \\\\ \frac{1}{\sqrt{2}} \end{bmatrix} , \бегин{бматрикс} \фрак{1}{\скрт{2}} \\\\ \фрак{-1}{\скрт{2}} \енд{бматрикс}, \текст{и} \бегин{бматрикс} \фрак{1}{\скрт{2}} \\\\ \frac{i}{\sqrt{2}} \end{ бматрикс}. $ $</span><span class="sxs-lookup"><span data-stu-id="37c30-113">$$\begin{bmatrix} 1 \\\\  0 \end{bmatrix}, \begin{bmatrix} 0 \\\\  1 \end{bmatrix}, \begin{bmatrix} \frac{1}{\sqrt{2}} \\\\  \frac{1}{\sqrt{2}} \end{bmatrix}, \begin{bmatrix} \frac{1}{\sqrt{2}} \\\\  \frac{-1}{\sqrt{2}} \end{bmatrix}, \text{ and }\begin{bmatrix} \frac{1}{\sqrt{2}} \\\\  \frac{i}{\sqrt{2}} \end{bmatrix}.$$</span></span>

<span data-ttu-id="37c30-114">Векторы состояния такта $ \бегин{бматрикс} 1 \\\\ 0 \енд{бматрикс} $ и $ \бегин{бматрикс} 0 \\\\ 1 \енд{бматрикс} $ занимают особую роль.</span><span class="sxs-lookup"><span data-stu-id="37c30-114">The quantum state vectors $\begin{bmatrix} 1 \\\\  0 \end{bmatrix}$ and $\begin{bmatrix} 0 \\\\  1 \end{bmatrix}$ take a special role.</span></span> <span data-ttu-id="37c30-115">Эти два вектора формируют базу для векторного пространства, описывающего состояние кубит.</span><span class="sxs-lookup"><span data-stu-id="37c30-115">These two vectors form a basis for the vector space that describes the qubit's state.</span></span> <span data-ttu-id="37c30-116">Это означает, что любой вектор состояния такта может быть записан как сумма этих векторов.</span><span class="sxs-lookup"><span data-stu-id="37c30-116">This means that any quantum state vector can be written as a sum of these basis vectors.</span></span> <span data-ttu-id="37c30-117">В частности, вектор $ \бегин{бматрикс} x \\\\ y \енд{бматрикс} $ может быть написан как $x \бегин{бматрикс} 1 \\\\ 0 \енд{бматрикс} + y \бегин{бматрикс} 0 \\\\ 1 \енд{бматрикс} $.</span><span class="sxs-lookup"><span data-stu-id="37c30-117">Specifically, the vector $\begin{bmatrix} x \\\\  y \end{bmatrix}$ can be written as $x \begin{bmatrix} 1 \\\\ 0 \end{bmatrix} + y \begin{bmatrix} 0 \\\\  1 \end{bmatrix}$.</span></span> <span data-ttu-id="37c30-118">Хотя любой поворот этих векторов будет служить вполне допустимой базой для кубит, мы решили установить привилегию для этого, вызвав его *вычислительной основе*.</span><span class="sxs-lookup"><span data-stu-id="37c30-118">While any rotation of these vectors would serve as a perfectly valid basis for the qubit, we choose to privilege this one, by calling it the *computational basis*.</span></span>

<span data-ttu-id="37c30-119">Мы принимаем два состояния такта для соответствия двум состояниям классического бита, а именно $0 $ и $1 $.</span><span class="sxs-lookup"><span data-stu-id="37c30-119">We take these two quantum states to correspond to the two states of a classical bit, namely $0$ and $1$.</span></span> <span data-ttu-id="37c30-120">Стандартным соглашением является выбор</span><span class="sxs-lookup"><span data-stu-id="37c30-120">The standard convention is to choose</span></span>

<span data-ttu-id="37c30-121">$ $0 \ equiv \бегин{бматрикс} 1 \\\\ 0 \енд{бматрикс}, \ккуад 1 \екуив \бегин{бматрикс} 0 \\\\ 1 \енд{бматрикс}, $ $</span><span class="sxs-lookup"><span data-stu-id="37c30-121">$$0\equiv \begin{bmatrix} 1 \\\\  0 \end{bmatrix}, \qquad 1 \equiv \begin{bmatrix} 0 \\\\  1 \end{bmatrix},$$</span></span>

<span data-ttu-id="37c30-122">Хотя обратное решение также может быть принято.</span><span class="sxs-lookup"><span data-stu-id="37c30-122">although the opposite choice could equally well be taken.</span></span> <span data-ttu-id="37c30-123">Таким словами, из-за неограниченного количества возможных векторов состояния однокубитного такта, только два соответствуют состояниям классических битов; все остальные состояния тактов не имеют.</span><span class="sxs-lookup"><span data-stu-id="37c30-123">Thus, out of the infinite number of possible single-qubit quantum state vectors, only two correspond to states of classical bits; all other quantum states do not.</span></span>

## <a name="measuring-a-qubit"></a><span data-ttu-id="37c30-124">Измерение кубит</span><span class="sxs-lookup"><span data-stu-id="37c30-124">Measuring a Qubit</span></span>

<span data-ttu-id="37c30-125">Теперь, когда мы понимаем, как представлять кубит, мы можем получить некоторые интуиция, представляющие эти состояния, обсудим концепцию [*измерения*](https://en.wikipedia.org/wiki/Measurement_in_quantum_mechanics).</span><span class="sxs-lookup"><span data-stu-id="37c30-125">Now that we know how to represent a qubit, we can gain some intuition for what these states represent by discussing the concept of [*measurement*](https://en.wikipedia.org/wiki/Measurement_in_quantum_mechanics).</span></span> <span data-ttu-id="37c30-126">Измерение соответствует неформальной идее «взгляда» на кубит, который немедленно сворачивает состояние такта в одно из двух классических состояний $ \бегин{бматрикс} 1 \\\\ 0 \енд{бматрикс} $ или $ \бегин{бматрикс} 0 \\\\ 1 \енд{ бматрикс} $.</span><span class="sxs-lookup"><span data-stu-id="37c30-126">A measurement corresponds to the informal idea of “looking” at a qubit, which immediately collapses the quantum state to one of the two classical states  $\begin{bmatrix} 1 \\\\  0 \end{bmatrix}$ or  $\begin{bmatrix} 0 \\\\  1 \end{bmatrix}$.</span></span> <span data-ttu-id="37c30-127">При измерении кубит, заданной вектором состояния такта $ \бегин{бматрикс} \алфа \\\\ \бета \енд{бматрикс} $, мы получаем результат $0 $ с вероятностью $ | \алфа | ^ 2 $ и результатом $1 $ с вероятностью $ | \бета | ^ 2 $.</span><span class="sxs-lookup"><span data-stu-id="37c30-127">When a qubit given by the quantum state vector  $\begin{bmatrix} \alpha \\\\  \beta \end{bmatrix}$ is measured, we obtain the outcome $0$ with probability $|\alpha|^2$ and the outcome $1$  with probability $|\beta|^2$.</span></span> <span data-ttu-id="37c30-128">В результате $0 $ новое состояние кубит — $ \бегин{бматрикс} 1 \\\\ 0 \енд{бматрикс} $; в результате $1 $ его состояние — $ \бегин{бматрикс} 0 \\\\ 1 \енд{бматрикс} $.</span><span class="sxs-lookup"><span data-stu-id="37c30-128">On outcome $0$, the qubit's new state is $\begin{bmatrix} 1 \\\\  0 \end{bmatrix}$; on outcome $1$ its state is $\begin{bmatrix} 0 \\\\  1 \end{bmatrix}$.</span></span> <span data-ttu-id="37c30-129">Обратите внимание, что эти вероятности суммируются до $1 $ из-за условия нормализации $ | \алфа | ^ 2 + | \бета | ^ 2 = $1.</span><span class="sxs-lookup"><span data-stu-id="37c30-129">Note that these probabilities sum up to $1$ because of the normalization condition $|\alpha|^2 + |\beta|^2 = 1$.</span></span>

<span data-ttu-id="37c30-130">Свойства измерения также означают, что общий знак вектора состояния такта не имеет значения.</span><span class="sxs-lookup"><span data-stu-id="37c30-130">The properties of measurement also mean that the overall sign of the quantum state vector is irrelevant.</span></span> <span data-ttu-id="37c30-131">Отрицание вектора эквивалентно $ \алфа \ригхтарров-\алфа $ and $ \бета \ригхтарров-\бета $.</span><span class="sxs-lookup"><span data-stu-id="37c30-131">Negating a vector is equivalent to $\alpha \rightarrow -\alpha$ and $\beta \rightarrow -\beta$.</span></span> <span data-ttu-id="37c30-132">Так как вероятность измерения $0 $ и $1 $ зависит от величины квадрата, вставка таких знаков не влияет на вероятность.</span><span class="sxs-lookup"><span data-stu-id="37c30-132">Because the probability of measuring $0$ and $1$ depends on the magnitude squared of the terms, inserting such signs does not change the probabilities whatsoever.</span></span> <span data-ttu-id="37c30-133">Такие этапы обычно называются [\`\`*глобальными этапами*""](https://en.wikipedia.org/wiki/Phase_factor) , и в общем случае они могут иметь форму $e ^ {i \фи} $, а не только $ \пм $1.</span><span class="sxs-lookup"><span data-stu-id="37c30-133">Such phases are commonly called [\`\`*global phases*''](https://en.wikipedia.org/wiki/Phase_factor) and more generally can be of the form $e^{i \phi}$ rather than just $\pm 1$.</span></span>

<span data-ttu-id="37c30-134">Последнее важное свойство измерения заключается в том, что оно не обязательно приводит к повреждению всех векторов состояния тактов.</span><span class="sxs-lookup"><span data-stu-id="37c30-134">A final important property of measurement is that it does not necessarily damage all quantum state vectors.</span></span> <span data-ttu-id="37c30-135">Если начать с кубит в состоянии $ \бегин{бматрикс} 1 \\\\ 0 \енд{бматрикс} $, который соответствует классу $0 классический, то измерение этого состояния всегда будет давать результат $0 $ и оставляет состояние такта без изменений.</span><span class="sxs-lookup"><span data-stu-id="37c30-135">If we start with a qubit in the state $\begin{bmatrix} 1 \\\\  0 \end{bmatrix}$, which corresponds to the classical state $0$, measuring this state will always yield the outcome $0$ and leave the quantum state unchanged.</span></span> <span data-ttu-id="37c30-136">В этом смысле, если у нас есть только классические биты (т. е. Кубитс, которые имеют значение $ \begin{bmatrix}1 \\\\ 0 \енд{бматрикс} $ или $ \begin{bmatrix}0 \\\\ 1 \енд{бматрикс} $), измерение не повредит системе.</span><span class="sxs-lookup"><span data-stu-id="37c30-136">In this sense, if we only have classical bits (i.e., qubits that are either $\begin{bmatrix}1 \\\\  0 \end{bmatrix}$ or $\begin{bmatrix}0 \\\\  1 \end{bmatrix}$) then measurement does not damage the system.</span></span> <span data-ttu-id="37c30-137">Это означает, что мы можем реплицировать классические данные и манипулировать ими на компьютере-такте точно так же, как и на классическом компьютере.</span><span class="sxs-lookup"><span data-stu-id="37c30-137">This means that we can replicate classical data and manipulate it on a quantum computer just as one could do on a classical computer.</span></span> <span data-ttu-id="37c30-138">Однако возможность хранить информацию в обоих состояниях одновременно с тем, что повышает тактовую частоту, помимо того, что возможно на классической основе и более Робс тактовыми компьютерами возможности копировать данные такта неограниченно, см. также [Теорема без клонирования. ](https://en.wikipedia.org/wiki/No-cloning_theorem).</span><span class="sxs-lookup"><span data-stu-id="37c30-138">The ability, however, to store information in both states at once is what elevates quantum computing beyond what is possible classically and further robs quantum computers of the ability to copy quantum data indiscriminately, see also [the no-cloning theorem](https://en.wikipedia.org/wiki/No-cloning_theorem).</span></span>

## <a name="visualizing-qubits-and-transformations-using-the-bloch-sphere"></a><span data-ttu-id="37c30-139">Визуализация Кубитс и преобразований с помощью сферы БЛОЧ</span><span class="sxs-lookup"><span data-stu-id="37c30-139">Visualizing Qubits and Transformations using the Bloch Sphere</span></span>

<span data-ttu-id="37c30-140">Кубитс также может быть изображен в $3 $ D с помощью представления [*сферы БЛОЧ*](https://en.wikipedia.org/wiki/Bloch_sphere) .</span><span class="sxs-lookup"><span data-stu-id="37c30-140">Qubits may also be pictured in $3$D using the [*Bloch sphere*](https://en.wikipedia.org/wiki/Bloch_sphere) representation.</span></span>  <span data-ttu-id="37c30-141">Сфера БЛОЧ предоставляет способ описания однокубитого состояния такта (который является двумерным сложным вектором) в виде трехмерного вектора с реальным значением.</span><span class="sxs-lookup"><span data-stu-id="37c30-141">The Bloch sphere gives a way of describing a single-qubit quantum state (which is a two-dimensional complex vector) as a three-dimensional real-valued vector.</span></span>  <span data-ttu-id="37c30-142">Это важно, так как это позволяет визуализировать кубит состояния и, таким образом, разрабатывать причины, которые могут оказаться бесполезными для понимания кубит Штатов (где, увы, сфера).</span><span class="sxs-lookup"><span data-stu-id="37c30-142">This is important because it allows us to visualize single-qubit states and thereby develop reasoning that can be invaluable in understanding multi-qubit states (where sadly the Bloch sphere representation breaks down).</span></span>  <span data-ttu-id="37c30-143">Сферу БЛОЧ можно выработать следующим образом:</span><span class="sxs-lookup"><span data-stu-id="37c30-143">The Bloch sphere can be visualized as follows:</span></span>

<!--- ![](.\media\bloch.svg){ width=50% } --->
<span data-ttu-id="37c30-144">![БЛОЧ Sphere](~/media/concepts_bloch.png)</span><span class="sxs-lookup"><span data-stu-id="37c30-144">![Bloch sphere](~/media/concepts_bloch.png)</span></span>

<span data-ttu-id="37c30-145">Стрелки на этой схеме показывают направление, в котором указывает вектор состояния такта, и каждое преобразование стрелки можно представить как поворот одной из осей кардинала.</span><span class="sxs-lookup"><span data-stu-id="37c30-145">The arrows in this diagram show the direction in which the quantum state vector is pointing and each transformation of the arrow can be thought of as a rotation about one of the cardinal axes.</span></span>
<span data-ttu-id="37c30-146">Во время обдумывания вычисления такта как последовательности поворотов является мощным интуиция, трудно использовать этот интуиция для проектирования и описания алгоритмов.</span><span class="sxs-lookup"><span data-stu-id="37c30-146">While thinking about a quantum computation as a sequence of rotations is a powerful intuition, it is challenging to use this intuition to design and describe algorithms.</span></span> <span data-ttu-id="37c30-147">Q # устраняет эту проблему, предоставляя язык для описания таких поворотов.</span><span class="sxs-lookup"><span data-stu-id="37c30-147">Q# alleviates this issue by providing a language for describing such rotations.</span></span>

## <a name="single-qubit-operations"></a><span data-ttu-id="37c30-148">Операции с одним кубит</span><span class="sxs-lookup"><span data-stu-id="37c30-148">Single-Qubit Operations</span></span>

<span data-ttu-id="37c30-149">Тактовые компьютеры обрабатывают данные, применяя универсальный набор тактов, который может эмулировать любой поворот вектора состояния такта.</span><span class="sxs-lookup"><span data-stu-id="37c30-149">Quantum computers process data by applying a universal set of quantum gates that can emulate any rotation of the quantum state vector.</span></span>
<span data-ttu-id="37c30-150">Это понятие универсальности является аналогом универсальности для традиционных (например, классических) вычислений, когда набор шлюзов считается универсальным, если каждое преобразование входных битов может быть выполнено с использованием цепи с ограничением длины.</span><span class="sxs-lookup"><span data-stu-id="37c30-150">This notion of universality is akin to the notion of universality for traditional (i.e., classical) computing where a gate set is considered to be universal if every transformation of the input bits can be performed using a finite length circuit.</span></span>
<span data-ttu-id="37c30-151">В тактовых вычислениях Допустимые преобразования, которые мы разрешено выполнять в кубит, являются едиными преобразованиями и измерениями.</span><span class="sxs-lookup"><span data-stu-id="37c30-151">In quantum computing, the valid transformations that we are allowed to perform on a qubit are unitary transformations and measurement.</span></span>
<span data-ttu-id="37c30-152">*Смежная операция* или комплексное сопряженное Перестановка — это крайне важная важность для создания тактовых вычислений, так как оно требуется для инвертирования квантов времени.</span><span class="sxs-lookup"><span data-stu-id="37c30-152">The *adjoint operation* or the complex conjugate transpose is of crucial importance to quantum computing because it is needed to invert quantum transformations.</span></span>
<span data-ttu-id="37c30-153">Q # отражает это, предоставляя методы для автоматической компиляции последовательностей шлюзов в соседние, что позволяет программисту в большинстве случаев аджоинтс код.</span><span class="sxs-lookup"><span data-stu-id="37c30-153">Q# reflects this by providing methods to automatically compile gate sequences to their adjoint, which saves the programmer from having to hand code adjoints in many cases.</span></span> <span data-ttu-id="37c30-154">Ниже приведен пример.</span><span class="sxs-lookup"><span data-stu-id="37c30-154">An example of this is shown below:</span></span>

```qsharp
operation PrepareSuperposition(qubit : Qubit) : Unit
is Adj { // Auto-generate the adjoint of the operation
    H(qubit);
}
```

<span data-ttu-id="37c30-155">Хотя это тривиальный пример (так как операция <xref:microsoft.quantum.intrinsic.h> является самосмежной), вы можете увидеть, как это становится неполезным для более сложных операций кубит.</span><span class="sxs-lookup"><span data-stu-id="37c30-155">Although this is a trivial example (as the <xref:microsoft.quantum.intrinsic.h> operation is self-adjoint), you can see how this becomes invaluable for more complicated qubit operations.</span></span>
<span data-ttu-id="37c30-156">Дополнительные сведения см. в разделе [операции и функции](xref:microsoft.quantum.techniques.opsandfunctions).</span><span class="sxs-lookup"><span data-stu-id="37c30-156">For more information, see [Operations and Functions](xref:microsoft.quantum.techniques.opsandfunctions).</span></span>

<span data-ttu-id="37c30-157">Существует только четыре функции, которые соотносятся один бит к одному биту на классический компьютер.</span><span class="sxs-lookup"><span data-stu-id="37c30-157">There are only four functions that map one bit to one bit on a classical computer.</span></span> <span data-ttu-id="37c30-158">В отличие от этого, в одном кубит на тактовой системе существует бесконечное количество однозначных преобразований.</span><span class="sxs-lookup"><span data-stu-id="37c30-158">In contrast, there are an infinite number of unitary transformations on a single qubit on a quantum computer.</span></span> <span data-ttu-id="37c30-159">Таким образом, отсутствие конечного набора операций-примитивных тактов, называемых [*шлюзами*](https://en.wikipedia.org/wiki/Quantum_logic_gate), может точно реплицировать неограниченный набор недопустимых преобразований в тактовых вычислениях.</span><span class="sxs-lookup"><span data-stu-id="37c30-159">Therefore, no finite set of primitive quantum operations, called [*gates*](https://en.wikipedia.org/wiki/Quantum_logic_gate), can exactly replicate the infinite set of unitary transformations allowed in quantum computing.</span></span> <span data-ttu-id="37c30-160">Это означает, что, в отличие от классических вычислений, на такте невозможно реализовать каждую возможную тактовую программу точно с конечным числом шлюзов.</span><span class="sxs-lookup"><span data-stu-id="37c30-160">This means, unlike classical computing, it is impossible for a quantum computer to implement every possible quantum program exactly using a finite number of gates.</span></span> <span data-ttu-id="37c30-161">Таким же, тактовые компьютеры не могут быть универсальными в одном смысле с классическими компьютерами.</span><span class="sxs-lookup"><span data-stu-id="37c30-161">Thus quantum computers cannot be universal in the same sense of classical computers.</span></span> <span data-ttu-id="37c30-162">В результате, когда мы говорим, что набор шлюзов является *универсальным* для тактовых вычислений, мы имеем в виду что-то немного более слабое, чем мы имеем в виду Классические вычисления.</span><span class="sxs-lookup"><span data-stu-id="37c30-162">As a result, when we say that a set of gates is *universal* for quantum computing we actually mean something slightly weaker than we mean with classical computing.</span></span>
<span data-ttu-id="37c30-163">Для универсальности требуется, чтобы тактовый компьютер был *приблизительным* только для каждой единой матрицы в пределах конечной ошибки, использующей последовательность шлюза с ограничением длины.</span><span class="sxs-lookup"><span data-stu-id="37c30-163">For universality, we require that a quantum computer only *approximate* every unitary matrix within a finite error using a finite length gate sequence.</span></span>
<span data-ttu-id="37c30-164">Иными словами, набор шлюзов — это универсальный шлюз, если любое единое преобразование может быть приблизительно написано как произведение шлюзов из этого набора.</span><span class="sxs-lookup"><span data-stu-id="37c30-164">In other words, a set of gates is a universal gate set if any unitary transformation can be approximately written as a product of gates from this set.</span></span> <span data-ttu-id="37c30-165">Необходимо, чтобы для любой привязанной ошибки существовал шлюз $G _{1}, G_{2}, \лдотс, G_N $ из набора шлюзов, который</span><span class="sxs-lookup"><span data-stu-id="37c30-165">We require that for any prescribed error bound, there exist gates $G_{1}, G_{2},\ldots, G_N$ from the gate set such that</span></span>

<span data-ttu-id="37c30-166">$ $ G_N G_ {N-1} \кдотс G_2 G_1 \аппрокс U. $ $</span><span class="sxs-lookup"><span data-stu-id="37c30-166">$$ G_N G_{N-1} \cdots G_2 G_1 \approx U. $$</span></span>

<span data-ttu-id="37c30-167">Обратите внимание, что, поскольку соглашение об умножении матрицы состоит в том, чтобы умножить первую операцию шлюза в этой последовательности, $G _N $, на самом деле последняя применяется к вектору состояния такта.</span><span class="sxs-lookup"><span data-stu-id="37c30-167">Note that because the convention for matrix multiplication is to multiply from right to left the first gate operation in this sequence, $G_N$, is actually the last one applied to the quantum state vector.</span></span> <span data-ttu-id="37c30-168">Более формально мы говорим, что такой набор шлюзов является универсальным, если для каждой ошибки с допустимыми ошибками $ \епсилон > 0 $ существует $G _1, \лдотс, G_N $ таким, что расстояние между $G _N \ лдотс G_1 $ и $U $ не превышает $ \епсилон $.</span><span class="sxs-lookup"><span data-stu-id="37c30-168">More formally, we say that such a gate set is universal if for every error tolerance $\epsilon>0$ there exists $G_1,\ldots, G_N$ such that  the distance between $G_N\ldots G_1$ and $U$ is at most $\epsilon$.</span></span> <span data-ttu-id="37c30-169">В идеале значение $N $ требуется для достижения этого расстояния от $ \епсилон $ должно масштабировать поли-пропорциональны логарифму с $1/\ Эпсилон $.</span><span class="sxs-lookup"><span data-stu-id="37c30-169">Ideally the value of $N$ needed to reach this distance of $\epsilon$ should scale poly-logarithmically with $1/\epsilon$.</span></span>

<span data-ttu-id="37c30-170">Что такой универсальный набор шлюза выглядит на практике?</span><span class="sxs-lookup"><span data-stu-id="37c30-170">What does such a universal gate set look like in practice?</span></span>  <span data-ttu-id="37c30-171">Простейший универсальный шлюз для кубит шлюзов состоит только из двух шлюзов: шлюз Хадамард $H $ и так называемый $T $-Gate (также известный как $ \ PI/8 $ Gate):</span><span class="sxs-lookup"><span data-stu-id="37c30-171">The simplest such universal gate set for single-qubit gates consists of only two gates: the Hadamard gate $H$ and the so-called $T$-gate (also known as the $\pi/8$ gate):</span></span>

<span data-ttu-id="37c30-172">$ $ H = \фрак{1}{\скрт{2}} \бегин{бматрикс} 1 & 1 \\\\ 1 &-1 \енд{бматрикс}, \ккуад T = \бегин{бматрикс} 1 & 0 \\\\ 0 & e ^ {i \ PI/4} \енд{бматрикс}.</span><span class="sxs-lookup"><span data-stu-id="37c30-172">$$ H=\frac{1}{\sqrt{2}}\begin{bmatrix} 1 & 1 \\\\  1 &-1  \end{bmatrix},\qquad T=\begin{bmatrix} 1 & 0 \\\\  0 & e^{i\pi/4} \end{bmatrix}.</span></span>
$$

<span data-ttu-id="37c30-173">Однако для практичных причин, связанных с исправлением ошибок такта, может быть удобнее рассмотреть более крупный набор шлюзов, а именно один, который можно создать с помощью $H $ и $T $.</span><span class="sxs-lookup"><span data-stu-id="37c30-173">However, for practical reasons related to quantum error correction it can be more convenient to consider a larger gate set, namely one that can be generated using $H$ and $T$.</span></span>
<span data-ttu-id="37c30-174">Можно классифицировать каждый из этих шлюзов на две категории: Клиффорд Gates и $T $-Gate.</span><span class="sxs-lookup"><span data-stu-id="37c30-174">We can classify the quantum gates into two categories: Clifford gates and the $T$-gate.</span></span>
<span data-ttu-id="37c30-175">Это подразделение полезно, поскольку во многих схемах исправления ошибок в такте очень легко реализовать так называемый шлюз Клиффорд. это требует очень мало ресурсов в плане операций и Кубитс для обеспечения отказоустойчивости, в то время как шлюзы не Клиффорд очень дорого, когда необходима отказоустойчивость.</span><span class="sxs-lookup"><span data-stu-id="37c30-175">This subdivision is useful because in many quantum error correction schemes the so-called Clifford gates are easy to implement, that is they require very few resources in terms of operations and qubits to implement fault tolerantly, whereas non-Clifford gates are quite costly when requiring fault tolerance.</span></span> <span data-ttu-id="37c30-176">Стандартный набор шлюзов с одним кубит Клиффорд, [включенный по умолчанию в Q #](xref:microsoft.quantum.libraries.standard.prelude), include</span><span class="sxs-lookup"><span data-stu-id="37c30-176">The standard set of single-qubit Clifford gates, [included by default in Q#](xref:microsoft.quantum.libraries.standard.prelude), include</span></span>

<span data-ttu-id="37c30-177">$ $ H = \фрак{1}{\скрт{2}} \бегин{бматрикс} 1 & 1 \\\\ 1 &-1 \енд{бматрикс}, \ккуад S = \бегин{бматрикс} 1 & 0 \\\\ 0 & i \енд{бматрикс} = T ^ 2, \ккуад X = \begin{bmatrix} 0 & 1 \\\\ 1 & 0 \енд{бматрикс} = HT ^ налево, $ $</span><span class="sxs-lookup"><span data-stu-id="37c30-177">$$ H=\frac{1}{\sqrt{2}}\begin{bmatrix} 1 & 1 \\\\  1 &-1  \end{bmatrix} ,\qquad S =\begin{bmatrix} 1 & 0 \\\\  0 & i \end{bmatrix}= T^2,\qquad X=\begin{bmatrix} 0 &1 \\\\  1& 0 \end{bmatrix}= HT^4H, $$</span></span>

<span data-ttu-id="37c30-178">$ $ Y = \бегин{бматрикс} 0 &-i \\\\ я & 0 \енд{бматрикс} = T ^ 2HT ^ 4 HT ^ 6, \ккуад Z = \begin{bmatrix}1 & 0\\\\ 0 &-1 \енд{бматрикс} = T ^ 4.</span><span class="sxs-lookup"><span data-stu-id="37c30-178">$$ Y = \begin{bmatrix} 0 & -i \\\\  i & 0 \end{bmatrix}=T^2HT^4  HT^6, \qquad Z=\begin{bmatrix}1&0\\\\ 0&-1 \end{bmatrix}=T^4.</span></span>
$$

<span data-ttu-id="37c30-179">Здесь операции $X $, $Y $ и $Z $ используются особенно часто и называются [*операторами Паули*](https://en.wikipedia.org/wiki/Pauli_matrices) после их создателя Волфганг Паули.</span><span class="sxs-lookup"><span data-stu-id="37c30-179">Here the operations $X$, $Y$ and $Z$ are used especially frequently and are named [*Pauli operators*](https://en.wikipedia.org/wiki/Pauli_matrices) after their creator Wolfgang Pauli.</span></span>
<span data-ttu-id="37c30-180">Вместе с Клиффорд-шлюзом ($T $-Gate) эти операции могут составляться для приблизительного преобразования одного кубит.</span><span class="sxs-lookup"><span data-stu-id="37c30-180">Together with the non-Clifford gate (the $T$-gate), these operations can be composed to approximate any unitary transformation on a single qubit.</span></span>

<span data-ttu-id="37c30-181">Дополнительные сведения об этих операциях, представлениях БЛОЧ Sphere и реализациях Q # см. в разделе [встроенные операции и функции](xref:microsoft.quantum.libraries.standard.prelude#intrinsic-operations-and-functions).</span><span class="sxs-lookup"><span data-stu-id="37c30-181">For more information on these operations, their Bloch sphere representations and Q# implementations, see [Intrinsic Operations and Functions](xref:microsoft.quantum.libraries.standard.prelude#intrinsic-operations-and-functions).</span></span>

<span data-ttu-id="37c30-182">В качестве примера того, как можно построить единые преобразования из этих примитивов, три преобразования, представленные в БЛОЧ шарик выше, соответствуют последовательности шлюзов $ \бегин{бматрикс} 1 \\\\ 0 \енд{бматрикс} \мапсто хз \бегин{бматрикс} 1 \\\\ 0 \енд{бматрикс} = \бегин{бматрикс} 0 \\\\ 1 \енд{бматрикс} $ $.</span><span class="sxs-lookup"><span data-stu-id="37c30-182">As an example of how unitary transformations can be built from these primitives, the three transformations pictured in the Bloch spheres above correspond to the gate sequence $\begin{bmatrix} 1 \\\\  0 \end{bmatrix} \mapsto HZH \begin{bmatrix} 1 \\\\  0 \end{bmatrix} = \begin{bmatrix} 0 \\\\  1 \end{bmatrix}$.</span></span>

<span data-ttu-id="37c30-183">Хотя предыдущее относится к наиболее популярным основным шлюзам для описания операций на логическом уровне стека (рассматривать логический уровень как уровень алгоритма такта), часто бывает удобно рассмотреть меньше основных операций в алгоритме. уровень, например операции ближе к уровню описания функции.</span><span class="sxs-lookup"><span data-stu-id="37c30-183">While the previous constitute the most popular primitive gates for describing operations on the logical level of the stack (think of the logical level as the level of the quantum algorithm), it is often convenient to consider less basic operations at the algorithmic level, for example operations closer to a function description level.</span></span> <span data-ttu-id="37c30-184">К счастью, в Q # также есть методы, доступные для реализации унитариес более высокого уровня, которые, в свою очередь, позволяют реализовать высокоуровневые алгоритмы без явного разворачивания всех Клиффорд и $T $-Gates.</span><span class="sxs-lookup"><span data-stu-id="37c30-184">Fortunately, Q# also has methods available for implementing higher-level unitaries, which in turn allow high-level algorithms to be implemented without explicitly decomposing everything down to Clifford and $T$-gates.</span></span>

<span data-ttu-id="37c30-185">Простейший такой примитив — это одно кубит вращение.</span><span class="sxs-lookup"><span data-stu-id="37c30-185">The simplest such primitive is the single qubit-rotation.</span></span> <span data-ttu-id="37c30-186">Обычно рассматриваются три однокубитных поворота: $R _X $, $R _Y $ и $R _Z $.</span><span class="sxs-lookup"><span data-stu-id="37c30-186">Three single-qubit rotations are typically considered: $R_x$, $R_y$ and $R_z$.</span></span> <span data-ttu-id="37c30-187">Для визуализации действия поворота $R _X (\сета) $, например, представьте правый бегунок в направлении $x $-оси БЛОЧ Sphere и поверните вектор с помощью руки через угол $ \ тета/2 $ радиан.</span><span class="sxs-lookup"><span data-stu-id="37c30-187">To visualize the action of the rotation $R_x(\theta)$, for example, imagine pointing your right thumb along the direction of the $x$-axis of the Bloch sphere and rotating the vector with your hand through an angle of $\theta/2$ radians.</span></span> <span data-ttu-id="37c30-188">Этот непонятный фактор в $2 $ возникает из того факта, что ортогональные векторы находятся на расстоянии $180 ^ \Цирк $ друг от друга при отображении в блочной сфере, но на самом деле это $90 ^ \Цирк $ градусы, разделенные геометрической метрикой.</span><span class="sxs-lookup"><span data-stu-id="37c30-188">This confusing factor of $2$ arises from the fact that orthogonal vectors are $180^\circ$ apart when plotted on the Bloch sphere, yet are actually $90^\circ$ degrees apart geometrically.</span></span> <span data-ttu-id="37c30-189">Соответствующие одноединые матрицы:</span><span class="sxs-lookup"><span data-stu-id="37c30-189">The corresponding unitary matrices are:</span></span>

<span data-ttu-id="37c30-190">\бегин{алигн *} & R_z (\сета) = e ^ {-И\сета z/2} = \бегин{бматрикс} e ^ {-i \ тета/2} & 0\\\\ 0 & e ^ {i \ тета/2} \енд{бматрикс}, \\\\ & R_x (\сета) = e ^ {-И\сета x/2} = HR_z (\сета) H = \бегин{бматрикс} \cos (\ тета/2) &-и\син (\ тета/2)\\\\-и\син (\ тета/2) & \кос (\ тета/2) \енд{бматрикс}, \\\\ & R_y (\сета) = e ^ {-и\сета Y/2} = SHR_z (\сета) HS ^ \дагжер = \бегин{бматрикс} \кос (\ тета/2) &-\син (\ тета/2), @no__ t_9_ \\ \син (\ тета/2) & \кос (\ тета/2) \енд{бматрикс}. \енд{алигн*}</span><span class="sxs-lookup"><span data-stu-id="37c30-190">\begin{align *} &R_z(\theta) = e^{-i\theta Z/2} = \begin{bmatrix} e^{-i\theta/2} & 0\\\\  0& e^{i\theta/2} \end{bmatrix}, \\\\ &R_x(\theta) = e^{-i\theta X/2} = HR_z(\theta)H = \begin{bmatrix} \cos(\theta/2) & -i\sin(\theta/2)\\\\  -i\sin(\theta/2) & \cos(\theta/2) \end{bmatrix}, \\\\ &R_y(\theta) = e^{-i\theta Y/2} = SHR_z(\theta)HS^\dagger = \begin{bmatrix} \cos(\theta/2) & -\sin(\theta/2)\\\\  \sin(\theta/2) & \cos(\theta/2) \end{bmatrix}. \end{align*}</span></span>

<span data-ttu-id="37c30-191">Точно так же, как любой из трех поворотов можно объединить для выполнения произвольного вращения в трех измерениях, его можно увидеть из представления сферы БЛОЧ, что любая единая матрица может быть записана как последовательность из трех поворотов.</span><span class="sxs-lookup"><span data-stu-id="37c30-191">Just as any three rotations can be combined together to perform an arbitrary rotation in three dimensions, it can be seen from the Bloch sphere representation that any unitary matrix can be written as a sequence of three rotations as well.</span></span> <span data-ttu-id="37c30-192">В частности, для каждой единой матрицы $U $ существует $ \алфа, \бета, \гамма, \делта $, например $U = e ^ {и\алфа} R_x (\бета) R_z (\гамма) R_x (\делта) $.</span><span class="sxs-lookup"><span data-stu-id="37c30-192">Specifically, for every unitary matrix $U$ there exists $\alpha,\beta,\gamma,\delta$ such that $U= e^{i\alpha} R_x(\beta)R_z(\gamma)R_x(\delta)$.</span></span> <span data-ttu-id="37c30-193">Таким же $R _Z (\сета) $ и $H $ также формируют универсальный шлюз, хотя он не является дискретным набором, так как $ \сета $ может принимать любое значение.</span><span class="sxs-lookup"><span data-stu-id="37c30-193">Thus $R_z(\theta)$ and $H$ also form a universal gate set although it is not a discrete set because $\theta$ can take any value.</span></span> <span data-ttu-id="37c30-194">По этой причине, и из-за приложений в симуляторе тактов, такие непрерывные шлюзы крайне важны для вычислений тактов, особенно на уровне проектирования алгоритма такта.</span><span class="sxs-lookup"><span data-stu-id="37c30-194">For this reason, and due to applications in quantum simulation, such continuous gates are crucial for quantum computation, especially at the quantum algorithm design level.</span></span> <span data-ttu-id="37c30-195">Чтобы реализовать отказоустойчивую аппаратную реализацию, они, в конечном итоге, будут скомпилированы в дискретные последовательности шлюзов, которые точно приблизительно соответствуют этим поворотам.</span><span class="sxs-lookup"><span data-stu-id="37c30-195">To achieve fault-tolerant hardware implementation, they will ultimately be compiled into discrete gate sequences that closely approximate these rotations.</span></span>
