---
title: Кубит | Документация Майкрософт
description: Кубит
author: QuantumWriter
uid: microsoft.quantum.concepts.qubit
ms.author: nawiebe@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: f29319c3ec19fecc45f5a9f7c16061b9aa9f71ec
ms.sourcegitcommit: 8becfb03eb60ba205c670a634ff4daa8071bcd06
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/26/2019
ms.locfileid: "73183647"
---
# <a name="the-qubit"></a>Кубит

Точно так же, как бит — это фундаментальный объект информации в классических вычислениях, [*Кубитс*](https://en.wikipedia.org/wiki/Qubit) (Тактовый бит) является фундаментальным объектом информации в тактовых вычислениях.  Чтобы разобраться в этой корреспонденции, Рассмотрим простейший пример: один кубит.

## <a name="representing-a-qubit"></a>Представление кубит

Хотя бит или двоичная цифра может иметь значение $0 $ или $1 $, кубит может иметь значение, которое является либо из этих значений, либо частью кванта в $0 $ и $1 $.

Состояние одного кубит может описываться векторным столбцом, равным норме, то есть величина, квадратная часть ее записей, должна суммироваться до $1 $. Этот вектор, называемый вектором состояния такта, содержит всю информацию, необходимую для описания однокубитной тактовой системы, точно так же, как один бит содержит всю информацию, необходимую для описания состояния двоичной переменной.

Любой двумерный вектор столбца вещественных или комплексных чисел с нормой $1 $ представляет возможное состояние такта, удерживаемое кубит. Таким словами, $ \бегин{бматрикс} \алфа \\\\ \бета \енд{бматрикс} $ представляет состояние кубит, если $ \алфа $ и $ \бета $ являются комплексными числами, удовлетворяющими $ | \алфа | ^ 2 + | \бета | ^ 2 = $1. Некоторые примеры допустимых векторов состояния такта, представляющих Кубитс, включают

$ $ \бегин{бматрикс} 1 \\\\ 0 \енд{бматрикс}, \бегин{бматрикс} 0 \\\\ 1 \енд{бматрикс}, \бегин{бматрикс} \фрак{1}{\sqrt{2}} \\\\ \frac{1}{\sqrt{2}} \end{bmatrix} , \бегин{бматрикс} \фрак{1}{\скрт{2}} \\\\ \фрак{-1}{\скрт{2}} \енд{бматрикс}, \текст{и} \бегин{бматрикс} \фрак{1}{\скрт{2}} \\\\ \frac{i}{\sqrt{2}} \end{ бматрикс}. $ $

Векторы состояния такта $ \бегин{бматрикс} 1 \\\\ 0 \енд{бматрикс} $ и $ \бегин{бматрикс} 0 \\\\ 1 \енд{бматрикс} $ занимают особую роль. Эти два вектора формируют базу для векторного пространства, описывающего состояние кубит. Это означает, что любой вектор состояния такта может быть записан как сумма этих векторов. В частности, вектор $ \бегин{бматрикс} x \\\\ y \енд{бматрикс} $ может быть написан как $x \бегин{бматрикс} 1 \\\\ 0 \енд{бматрикс} + y \бегин{бматрикс} 0 \\\\ 1 \енд{бматрикс} $. Хотя любой поворот этих векторов будет служить вполне допустимой базой для кубит, мы решили установить привилегию для этого, вызвав его *вычислительной основе*.

Мы принимаем два состояния такта для соответствия двум состояниям классического бита, а именно $0 $ и $1 $. Стандартным соглашением является выбор

$ $0 \ equiv \бегин{бматрикс} 1 \\\\ 0 \енд{бматрикс}, \ккуад 1 \екуив \бегин{бматрикс} 0 \\\\ 1 \енд{бматрикс}, $ $

Хотя обратное решение также может быть принято. Таким словами, из-за неограниченного количества возможных векторов состояния однокубитного такта, только два соответствуют состояниям классических битов; все остальные состояния тактов не имеют.

## <a name="measuring-a-qubit"></a>Измерение кубит

Теперь, когда мы понимаем, как представлять кубит, мы можем получить некоторые интуиция, представляющие эти состояния, обсудим концепцию [*измерения*](https://en.wikipedia.org/wiki/Measurement_in_quantum_mechanics). Измерение соответствует неформальной идее «взгляда» на кубит, который немедленно сворачивает состояние такта в одно из двух классических состояний $ \бегин{бматрикс} 1 \\\\ 0 \енд{бматрикс} $ или $ \бегин{бматрикс} 0 \\\\ 1 \енд{ бматрикс} $. При измерении кубит, заданной вектором состояния такта $ \бегин{бматрикс} \алфа \\\\ \бета \енд{бматрикс} $, мы получаем результат $0 $ с вероятностью $ | \алфа | ^ 2 $ и результатом $1 $ с вероятностью $ | \бета | ^ 2 $. В результате $0 $ новое состояние кубит — $ \бегин{бматрикс} 1 \\\\ 0 \енд{бматрикс} $; в результате $1 $ его состояние — $ \бегин{бматрикс} 0 \\\\ 1 \енд{бматрикс} $. Обратите внимание, что эти вероятности суммируются до $1 $ из-за условия нормализации $ | \алфа | ^ 2 + | \бета | ^ 2 = $1.

Свойства измерения также означают, что общий знак вектора состояния такта не имеет значения. Отрицание вектора эквивалентно $ \алфа \ригхтарров-\алфа $ and $ \бета \ригхтарров-\бета $. Так как вероятность измерения $0 $ и $1 $ зависит от величины квадрата, вставка таких знаков не влияет на вероятность. Такие этапы обычно называются [``*глобальными этапами*""](https://en.wikipedia.org/wiki/Phase_factor) , и в общем случае они могут иметь форму $e ^ {i \фи} $, а не только $ \пм $1.

Последнее важное свойство измерения заключается в том, что оно не обязательно приводит к повреждению всех векторов состояния тактов. Если начать с кубит в состоянии $ \бегин{бматрикс} 1 \\\\ 0 \енд{бматрикс} $, который соответствует классу $0 классический, то измерение этого состояния всегда будет давать результат $0 $ и оставляет состояние такта без изменений. В этом смысле, если у нас есть только классические биты (т. е. Кубитс, которые имеют значение $ \begin{bmatrix}1 \\\\ 0 \енд{бматрикс} $ или $ \begin{bmatrix}0 \\\\ 1 \енд{бматрикс} $), измерение не повредит системе. Это означает, что мы можем реплицировать классические данные и манипулировать ими на компьютере-такте точно так же, как и на классическом компьютере. Однако возможность хранить информацию в обоих состояниях одновременно с тем, что повышает тактовую частоту, помимо того, что возможно на классической основе и более Робс тактовыми компьютерами возможности копировать данные такта неограниченно, см. также [Теорема без клонирования. ](https://en.wikipedia.org/wiki/No-cloning_theorem).

## <a name="visualizing-qubits-and-transformations-using-the-bloch-sphere"></a>Визуализация Кубитс и преобразований с помощью сферы БЛОЧ

Кубитс также может быть изображен в $3 $ D с помощью представления [*сферы БЛОЧ*](https://en.wikipedia.org/wiki/Bloch_sphere) .  Сфера БЛОЧ предоставляет способ описания однокубитого состояния такта (который является двумерным сложным вектором) в виде трехмерного вектора с реальным значением.  Это важно, так как это позволяет визуализировать кубит состояния и, таким образом, разрабатывать причины, которые могут оказаться бесполезными для понимания кубит Штатов (где, увы, сфера).  Сферу БЛОЧ можно выработать следующим образом:

<!--- ![](.\media\bloch.svg){ width=50% } --->
![БЛОЧ Sphere](~/media/concepts_bloch.png)

Стрелки на этой схеме показывают направление, в котором указывает вектор состояния такта, и каждое преобразование стрелки можно представить как поворот одной из осей кардинала.
Во время обдумывания вычисления такта как последовательности поворотов является мощным интуиция, трудно использовать этот интуиция для проектирования и описания алгоритмов. Q # устраняет эту проблему, предоставляя язык для описания таких поворотов.

## <a name="single-qubit-operations"></a>Операции с одним кубит

Тактовые компьютеры обрабатывают данные, применяя универсальный набор тактов, который может эмулировать любой поворот вектора состояния такта.
Это понятие универсальности является аналогом универсальности для традиционных (например, классических) вычислений, когда набор шлюзов считается универсальным, если каждое преобразование входных битов может быть выполнено с использованием цепи с ограничением длины.
В тактовых вычислениях Допустимые преобразования, которые мы разрешено выполнять в кубит, являются едиными преобразованиями и измерениями.
*Смежная операция* или комплексное сопряженное Перестановка — это крайне важная важность для создания тактовых вычислений, так как оно требуется для инвертирования квантов времени.
Q # отражает это, предоставляя методы для автоматической компиляции последовательностей шлюзов в соседние, что позволяет программисту в большинстве случаев аджоинтс код. Ниже приведен пример.

```qsharp
operation PrepareSuperposition(qubit : Qubit) : Unit
is Adj { // Auto-generate the adjoint of the operation
    H(qubit);
}
```

Хотя это тривиальный пример (так как операция <xref:microsoft.quantum.intrinsic.h> является самосмежной), вы можете увидеть, как это становится неполезным для более сложных операций кубит.
Дополнительные сведения см. в разделе [операции и функции](xref:microsoft.quantum.techniques.opsandfunctions).

Существует только четыре функции, которые соотносятся один бит к одному биту на классический компьютер. В отличие от этого, в одном кубит на тактовой системе существует бесконечное количество однозначных преобразований. Таким образом, отсутствие конечного набора операций-примитивных тактов, называемых [*шлюзами*](https://en.wikipedia.org/wiki/Quantum_logic_gate), может точно реплицировать неограниченный набор недопустимых преобразований в тактовых вычислениях. Это означает, что, в отличие от классических вычислений, на такте невозможно реализовать каждую возможную тактовую программу точно с конечным числом шлюзов. Таким же, тактовые компьютеры не могут быть универсальными в одном смысле с классическими компьютерами. В результате, когда мы говорим, что набор шлюзов является *универсальным* для тактовых вычислений, мы имеем в виду что-то немного более слабое, чем мы имеем в виду Классические вычисления.
Для универсальности требуется, чтобы тактовый компьютер был *приблизительным* только для каждой единой матрицы в пределах конечной ошибки, использующей последовательность шлюза с ограничением длины.
Иными словами, набор шлюзов — это универсальный шлюз, если любое единое преобразование может быть приблизительно написано как произведение шлюзов из этого набора. Необходимо, чтобы для любой привязанной ошибки существовал шлюз $G _{1}, G_{2}, \лдотс, G_N $ из набора шлюзов, который

$ $ G_N G_ {N-1} \кдотс G_2 G_1 \аппрокс U. $ $

Обратите внимание, что, поскольку соглашение об умножении матрицы состоит в том, чтобы умножить первую операцию шлюза в этой последовательности, $G _N $, на самом деле последняя применяется к вектору состояния такта. Более формально мы говорим, что такой набор шлюзов является универсальным, если для каждой ошибки с допустимыми ошибками $ \епсилон > 0 $ существует $G _1, \лдотс, G_N $ таким, что расстояние между $G _N \ лдотс G_1 $ и $U $ не превышает $ \епсилон $. В идеале значение $N $ требуется для достижения этого расстояния от $ \епсилон $ должно масштабировать поли-пропорциональны логарифму с $1/\ Эпсилон $.

Что такой универсальный набор шлюза выглядит на практике?  Простейший универсальный шлюз для кубит шлюзов состоит только из двух шлюзов: шлюз Хадамард $H $ и так называемый $T $-Gate (также известный как $ \ PI/8 $ Gate):

$ $ H = \фрак{1}{\скрт{2}} \бегин{бматрикс} 1 & 1 \\\\ 1 &-1 \енд{бматрикс}, \ккуад T = \бегин{бматрикс} 1 & 0 \\\\ 0 & e ^ {i \ PI/4} \енд{бматрикс}.
$$

Однако для практичных причин, связанных с исправлением ошибок такта, может быть удобнее рассмотреть более крупный набор шлюзов, а именно один, который можно создать с помощью $H $ и $T $.
Можно классифицировать каждый из этих шлюзов на две категории: Клиффорд Gates и $T $-Gate.
Это подразделение полезно, поскольку во многих схемах исправления ошибок в такте очень легко реализовать так называемый шлюз Клиффорд. это требует очень мало ресурсов в плане операций и Кубитс для обеспечения отказоустойчивости, в то время как шлюзы не Клиффорд очень дорого, когда необходима отказоустойчивость. Стандартный набор шлюзов с одним кубит Клиффорд, [включенный по умолчанию в Q #](xref:microsoft.quantum.libraries.standard.prelude), include

$ $ H = \фрак{1}{\скрт{2}} \бегин{бматрикс} 1 & 1 \\\\ 1 &-1 \енд{бматрикс}, \ккуад S = \бегин{бматрикс} 1 & 0 \\\\ 0 & i \енд{бматрикс} = T ^ 2, \ккуад X = \begin{bmatrix} 0 & 1 \\\\ 1 & 0 \енд{бматрикс} = HT ^ налево, $ $

$ $ Y = \бегин{бматрикс} 0 &-i \\\\ я & 0 \енд{бматрикс} = T ^ 2HT ^ 4 HT ^ 6, \ккуад Z = \begin{bmatrix}1 & 0\\\\ 0 &-1 \енд{бматрикс} = T ^ 4.
$$

Здесь операции $X $, $Y $ и $Z $ используются особенно часто и называются [*операторами Паули*](https://en.wikipedia.org/wiki/Pauli_matrices) после их создателя Волфганг Паули.
Вместе с Клиффорд-шлюзом ($T $-Gate) эти операции могут составляться для приблизительного преобразования одного кубит.

Дополнительные сведения об этих операциях, представлениях БЛОЧ Sphere и реализациях Q # см. в разделе [встроенные операции и функции](xref:microsoft.quantum.libraries.standard.prelude#intrinsic-operations-and-functions).

В качестве примера того, как можно построить единые преобразования из этих примитивов, три преобразования, представленные в БЛОЧ шарик выше, соответствуют последовательности шлюзов $ \бегин{бматрикс} 1 \\\\ 0 \енд{бматрикс} \мапсто хз \бегин{бматрикс} 1 \\\\ 0 \енд{бматрикс} = \бегин{бматрикс} 0 \\\\ 1 \енд{бматрикс} $ $.

Хотя предыдущее относится к наиболее популярным основным шлюзам для описания операций на логическом уровне стека (рассматривать логический уровень как уровень алгоритма такта), часто бывает удобно рассмотреть меньше основных операций в алгоритме. уровень, например операции ближе к уровню описания функции. К счастью, в Q # также есть методы, доступные для реализации унитариес более высокого уровня, которые, в свою очередь, позволяют реализовать высокоуровневые алгоритмы без явного разворачивания всех Клиффорд и $T $-Gates.

Простейший такой примитив — это одно кубит вращение. Обычно рассматриваются три однокубитных поворота: $R _X $, $R _Y $ и $R _Z $. Для визуализации действия поворота $R _X (\сета) $, например, представьте правый бегунок в направлении $x $-оси БЛОЧ Sphere и поверните вектор с помощью руки через угол $ \ тета/2 $ радиан. Этот непонятный фактор в $2 $ возникает из того факта, что ортогональные векторы находятся на расстоянии $180 ^ \Цирк $ друг от друга при отображении в блочной сфере, но на самом деле это $90 ^ \Цирк $ градусы, разделенные геометрической метрикой. Соответствующие одноединые матрицы:

\бегин{алигн *} & R_z (\сета) = e ^ {-И\сета z/2} = \бегин{бматрикс} e ^ {-i \ тета/2} & 0\\\\ 0 & e ^ {i \ тета/2} \енд{бматрикс}, \\\\ & R_x (\сета) = e ^ {-И\сета x/2} = HR_z (\сета) H = \бегин{бматрикс} \cos (\ тета/2) &-и\син (\ тета/2)\\\\-и\син (\ тета/2) & \кос (\ тета/2) \енд{бматрикс}, \\\\ & R_y (\сета) = e ^ {-и\сета Y/2} = SHR_z (\сета) HS ^ \дагжер = \бегин{бматрикс} \кос (\ тета/2) &-\син (\ тета/2), @no__ t_9_ \\ \син (\ тета/2) & \кос (\ тета/2) \енд{бматрикс}. \енд{алигн*}

Точно так же, как любой из трех поворотов можно объединить для выполнения произвольного вращения в трех измерениях, его можно увидеть из представления сферы БЛОЧ, что любая единая матрица может быть записана как последовательность из трех поворотов. В частности, для каждой единой матрицы $U $ существует $ \алфа, \бета, \гамма, \делта $, например $U = e ^ {и\алфа} R_x (\бета) R_z (\гамма) R_x (\делта) $. Таким же $R _Z (\сета) $ и $H $ также формируют универсальный шлюз, хотя он не является дискретным набором, так как $ \сета $ может принимать любое значение. По этой причине, и из-за приложений в симуляторе тактов, такие непрерывные шлюзы крайне важны для вычислений тактов, особенно на уровне проектирования алгоритма такта. Чтобы реализовать отказоустойчивую аппаратную реализацию, они, в конечном итоге, будут скомпилированы в дискретные последовательности шлюзов, которые точно приблизительно соответствуют этим поворотам.
