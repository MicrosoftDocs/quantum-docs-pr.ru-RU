---
title: Обзор программ Q#
description: Изучите базовую структуру тактовой программы и ее представление о преобразованиях состояний тактов.
author: QuantumWriter
ms.author: Christopher.Granade@microsoft.com
ms.date: 12/11/2017
ms.topic: article
uid: microsoft.quantum.techniques.file-structure
ms.openlocfilehash: 5c75bb5499efac2c49cbfc4555fd15b3e072181c
ms.sourcegitcommit: 6ccea4a2006a47569c4e2c2cb37001e132f17476
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/28/2020
ms.locfileid: "77907704"
---
# <a name="q-program-overview"></a><span data-ttu-id="40bec-103">Обзор программ Q#</span><span class="sxs-lookup"><span data-stu-id="40bec-103">Q# program overview</span></span>

<span data-ttu-id="40bec-104">Q # — это масштабируемый, многопарадигмный язык программирования на основе домена для тактовых вычислений.</span><span class="sxs-lookup"><span data-stu-id="40bec-104">Q# is a scalable, multi-paradigm, domain-specific programming language for quantum computing.</span></span> <span data-ttu-id="40bec-105">Q # — это язык программирования на такте, который можно использовать для описания выполнения инструкций на тактовых компьютерах.</span><span class="sxs-lookup"><span data-stu-id="40bec-105">Q# is a quantum programming language in that it can be used to describe how instructions are executed on quantum machines.</span></span> <span data-ttu-id="40bec-106">Компьютеры, которые могут быть нацелены на диапазон от симуляторов до фактического оборудования такта.</span><span class="sxs-lookup"><span data-stu-id="40bec-106">The machines that can be targeted range from simulators to actual quantum hardware.</span></span> <span data-ttu-id="40bec-107">Вопрос # является масштабируемым: он может использоваться для написания простых демонстрационных программ, таких как телепортируйтесь, которые выполняются на нескольких Кубитс, но также поддерживает написание больших и сложных программ, таких как моделирование сложных молекул, требующих больших компьютеров с миллионами Кубитс.</span><span class="sxs-lookup"><span data-stu-id="40bec-107">Q# is scalable: it can be used to write simple demonstration programs like teleport that run on a few qubits, but also supports writing large, sophisticated programs such as simulations of complex molecules that will require large machines with millions of qubits.</span></span> <span data-ttu-id="40bec-108">Несмотря на то, что крупные физические компьютеры по-прежнему остаются в будущем, Q # позволяет программисту программировать сложные тактовые алгоритмы.</span><span class="sxs-lookup"><span data-stu-id="40bec-108">Even though large physical machines are still in the future, Q# allows a programmer to program complex quantum algorithms now.</span></span> <span data-ttu-id="40bec-109">Что еще больше, Q # поддерживает различные задачи, такие как отладка, профилирование, оценка ресурсов и определенные специализированные модели, масштабируемым способом.</span><span class="sxs-lookup"><span data-stu-id="40bec-109">What is more, Q# supports various tasks such as debugging, profiling, resource estimation, and certain special-purpose simulations in a scalable way.</span></span> 

<span data-ttu-id="40bec-110">С технической точки зрения, тактовая программа может рассматриваться как определенный набор классических функций, которые при вызове создают тактовые цепи в качестве побочных эффектов.</span><span class="sxs-lookup"><span data-stu-id="40bec-110">From a technical perspective, a quantum program can be seen as a particular set of classical functions which, when called, generate quantum circuits as their side effects.</span></span> <span data-ttu-id="40bec-111">Важным следствием этого представления является то, что программа, написанная в Q #, напрямую не моделирует Кубитс, а описывает, как классический контрольный компьютер взаимодействует с этими Кубитс.</span><span class="sxs-lookup"><span data-stu-id="40bec-111">An important consequence of that view is that a program written in Q# does not directly model qubits themselves, but rather describes how a classical control computer interacts with those qubits.</span></span>
<span data-ttu-id="40bec-112">Таким образом, Q # не определяет состояния такта или другие свойства генератора тактов напрямую, а неявно делает это неявным образом посредством действий различных подпрограмм, определенных в языке.</span><span class="sxs-lookup"><span data-stu-id="40bec-112">By design, Q# thus does not define quantum states or other properties of quantum mechanics directly, but rather does so indirectly through the action of the various subroutines defined in the language.</span></span>
<span data-ttu-id="40bec-113">Например, рассмотрим состояние $ \кет{+} = \лефт (\кет{0} + \кет{1}\ригхт)/\скрт{2}$, обсуждаемое [в этом руководством](xref:microsoft.quantum.concepts.intro) .</span><span class="sxs-lookup"><span data-stu-id="40bec-113">For instance, consider the state $\ket{+} = \left(\ket{0} + \ket{1}\right) / \sqrt{2}$ discussed in the [Quantum Computing Concepts](xref:microsoft.quantum.concepts.intro) guide.</span></span>
<span data-ttu-id="40bec-114">Чтобы подготовить это состояние в Q #, мы используем факты, которые Кубитс инициализируются в $ \кет{0}$ State и что $ \кет{+} = Х\кет{0}$, где $H $ является Хадамард преобразованием:</span><span class="sxs-lookup"><span data-stu-id="40bec-114">To prepare this state in Q#, we use the facts that the qubits are initialized in the $\ket{0}$ state, and that $\ket{+} = H\ket{0}$, where $H$ is the Hadamard transform:</span></span>

```qsharp
using (qubit = Qubit()) {
    // At this point, qubit is in the state |0〉.
    H(qubit);
    // We've now applied H, such that our qubit is in H|0〉 = |+〉, as we wanted.
}
```
## <a name="q-tranformations-of-quantum-states"></a><span data-ttu-id="40bec-115">Q # транформатионс состояний тактов</span><span class="sxs-lookup"><span data-stu-id="40bec-115">Q# tranformations of quantum states</span></span>

<span data-ttu-id="40bec-116">Важно, что при написании приведенной выше программы мы не ссылались явно на состояние в Q #, а не описывали, как состояние было *преобразовано* нашей программой.</span><span class="sxs-lookup"><span data-stu-id="40bec-116">Importantly, in writing the above program, we did not explicitly refer to the state within Q#, but rather described how the state was *transformed* by our program.</span></span>
<span data-ttu-id="40bec-117">Таким образом, аналогично тому, как Программа графического шейдера накапливает Описание преобразований каждой вершины, тактовая программа в Q # накапливает преобразования в тактовые состояния.</span><span class="sxs-lookup"><span data-stu-id="40bec-117">Thus, similar to how a graphics shader program accumulates a description of transformations to each vertex, a quantum program in Q# accumulates transformations to quantum states.</span></span>
<span data-ttu-id="40bec-118">Это позволяет нам полностью *не* зависеть от состояния такта, даже на каждом целевом компьютере, для которого в зависимости от компьютера могут использоваться разные интерпретации.</span><span class="sxs-lookup"><span data-stu-id="40bec-118">This allows us to be entirely agnostic about what a quantum state even *is* on each target machine, which might have different interpretations depending on the machine.</span></span> 

<span data-ttu-id="40bec-119">С точки зрения программы Q # кубит является полностью непрозрачной ссылкой на внутреннюю структуру целевого компьютера.</span><span class="sxs-lookup"><span data-stu-id="40bec-119">From the perspective of a Q# program, a qubit is an entirely opaque reference to the internal structure of a target machine.</span></span>
<span data-ttu-id="40bec-120">Программа Q # не может интроспект в состояние кубит, его представление на целевом компьютере или даже того, является ли он тем же кубит, что и другие кубит, доступные для программы.</span><span class="sxs-lookup"><span data-stu-id="40bec-120">A Q# program has no ability to introspect into the state of a qubit, its representation on a target machine, or even whether it is the same qubit as any other qubit available to the program.</span></span>
<span data-ttu-id="40bec-121">Вместо этого программа может вызывать такие операции, как `Measure`, для получения информации из кубит и вызова операций, таких как `X` и `H`, чтобы действовать в состоянии кубит.</span><span class="sxs-lookup"><span data-stu-id="40bec-121">Rather, a program can call operations such as `Measure` to learn information from a qubit, and call operations such as `X` and `H` to act on the state of a qubit.</span></span>
<span data-ttu-id="40bec-122">Эти операции не имеют встроенного определения внутри языка и сделаны конкретными только целевым компьютером, используемым для запуска определенной программы Q #.</span><span class="sxs-lookup"><span data-stu-id="40bec-122">These operations have no intrinsic definition within the language, and are made concrete only by the target machine used to run a particular Q# program.</span></span>
<span data-ttu-id="40bec-123">Программа Q # повторно объединяет эти операции, как определено на целевом компьютере, для создания новых операций более высокого уровня для вычисления тактовых вычислений.</span><span class="sxs-lookup"><span data-stu-id="40bec-123">A Q# program recombines these operations as defined by a target machine to create new, higher-level operations to express quantum computation.</span></span>
<span data-ttu-id="40bec-124">Таким образом, Q # упрощает выражать логику базового и гибридного алгоритма, а также общие сведения относительно структуры целевого компьютера или симулятора.</span><span class="sxs-lookup"><span data-stu-id="40bec-124">In this way, Q# makes it easy to express the logic underlying quantum and hybrid quantum-classical algorithms, while also being general with respect to the structure of a target machine or simulator.</span></span>

## <a name="q-operations-and-functions"></a><span data-ttu-id="40bec-125">Q # операции и функции</span><span class="sxs-lookup"><span data-stu-id="40bec-125">Q# operations and functions</span></span>

<span data-ttu-id="40bec-126">Конкретная программа Q # состоит из одной или нескольких *операций*, одной или нескольких *функций*и определяемых пользователем типов.</span><span class="sxs-lookup"><span data-stu-id="40bec-126">Concretely, a Q# program is comprised of one or more *operations*, one or more *functions*, and user defined types.</span></span> <span data-ttu-id="40bec-127">Операции используются для описания преобразований тактового автомата и наиболее простого стандартного блока программ Q #.</span><span class="sxs-lookup"><span data-stu-id="40bec-127">Operations are used to describe the transformations of the state of a quantum machine and are the most basic building block of Q# programs.</span></span> <span data-ttu-id="40bec-128">Каждая операция, определенная в Q #, может затем вызывать любое количество других операций, включая встроенные *внутренние* операции, реализованные на целевом компьютере.</span><span class="sxs-lookup"><span data-stu-id="40bec-128">Each operation defined in Q# may then call any number of other operations, including the built-in *intrinsic* operations implemented by a target machine.</span></span>
<span data-ttu-id="40bec-129">При компиляции каждая операция представляется как тип класса .NET, который можно предоставить целевым компьютерам.</span><span class="sxs-lookup"><span data-stu-id="40bec-129">When compiled, each operation is represented as a .NET class type that can be provided to target machines.</span></span>

<span data-ttu-id="40bec-130">В отличие от операций, функции используются для описания чистого поведения и не имеют каких либо эффектов, помимо вычисления классических выходных значений.</span><span class="sxs-lookup"><span data-stu-id="40bec-130">In contrast to operations, functions are used to describe purely classical behavior and do not have any effects besides computing classical output values.</span></span> <span data-ttu-id="40bec-131">Q # является строго типизированным языком и поставляется с набором встроенных примитивных типов, а также поддержкой определяемых пользователем типов.</span><span class="sxs-lookup"><span data-stu-id="40bec-131">Q# is a strongly typed language and comes with a set of built-in primitive types as well as support for user defined types.</span></span> 

<span data-ttu-id="40bec-132">В оставшейся части этого руководства мы рассмотрим, как использовать различные языковые концепции и конструкции, чтобы помочь нам определить сложные тактовые программы с помощью основных стандартных блоков операций, функций и типов.</span><span class="sxs-lookup"><span data-stu-id="40bec-132">Throughout the rest of this guide, we will see how to use different language concepts and constructs to help us define complex quantum programs through the basic building blocks of operations, functions, and types.</span></span> 

## <a name="structure-of-q-source-files"></a><span data-ttu-id="40bec-133">Структура исходных файлов Q #</span><span class="sxs-lookup"><span data-stu-id="40bec-133">Structure of Q# Source Files</span></span>

<span data-ttu-id="40bec-134">Как минимум, исходный файл Q # состоит из *объявления пространства имен*, которое указывает пространство имен .NET, которое будет содержать определения в исходном файле.</span><span class="sxs-lookup"><span data-stu-id="40bec-134">Minimally, a Q# source file consists of a *namespace declaration*, which specifies a .NET namespace which will contain the definitions in the source file.</span></span>
<span data-ttu-id="40bec-135">Определения из других исходных файлов и библиотек Q # можно включать с помощью инструкции `open`.</span><span class="sxs-lookup"><span data-stu-id="40bec-135">Definitions from other Q# source files and libraries can be included using the `open` statement.</span></span>
<span data-ttu-id="40bec-136">Например, большинство операций, определяющих фундаментальные шлюзы, определяются в пространстве имен <xref:microsoft.quantum.intrinsic>.</span><span class="sxs-lookup"><span data-stu-id="40bec-136">For instance, most of the operations defining fundamental gates are defined in the <xref:microsoft.quantum.intrinsic> namespace.</span></span>
<span data-ttu-id="40bec-137">Чтобы сделать это доступным для нашего кода, мы просто `open` это пространство имен в верхней части каждого файла:</span><span class="sxs-lookup"><span data-stu-id="40bec-137">To make this available to our code, we simply `open` that namespace at the top of each file:</span></span>

```qsharp
namespace Example {
    open Microsoft.Quantum.Intrinsic;

    // ...
}
```

<span data-ttu-id="40bec-138">В пространстве имен каждый исходный файл Q # может определять любое сочетание *операций*, *функций*и *определяемых пользователем типов*.</span><span class="sxs-lookup"><span data-stu-id="40bec-138">Within a namespace, each Q# source file can define any combination of *operations*, *functions*, and *user-defined types*.</span></span>
<span data-ttu-id="40bec-139">В оставшейся части этого раздела мы рассмотрим каждую из них, а также приводятся примеры того, как их можно использовать на практике для создания полезных программных тактов.</span><span class="sxs-lookup"><span data-stu-id="40bec-139">In the rest of this section, we will describe each in turn and provide examples of how they can be used in practice to make useful quantum programs.</span></span>
