---
title: Обзор программ Q#
description: Изучите базовую структуру тактовой программы и ее представление о преобразованиях состояний тактов.
author: QuantumWriter
ms.author: Christopher.Granade@microsoft.com
ms.date: 12/11/2017
ms.topic: article
uid: microsoft.quantum.techniques.file-structure
ms.openlocfilehash: 5c75bb5499efac2c49cbfc4555fd15b3e072181c
ms.sourcegitcommit: 6ccea4a2006a47569c4e2c2cb37001e132f17476
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/28/2020
ms.locfileid: "77907704"
---
# <a name="q-program-overview"></a>Обзор программ Q#

Q # — это масштабируемый, многопарадигмный язык программирования на основе домена для тактовых вычислений. Q # — это язык программирования на такте, который можно использовать для описания выполнения инструкций на тактовых компьютерах. Компьютеры, которые могут быть нацелены на диапазон от симуляторов до фактического оборудования такта. Вопрос # является масштабируемым: он может использоваться для написания простых демонстрационных программ, таких как телепортируйтесь, которые выполняются на нескольких Кубитс, но также поддерживает написание больших и сложных программ, таких как моделирование сложных молекул, требующих больших компьютеров с миллионами Кубитс. Несмотря на то, что крупные физические компьютеры по-прежнему остаются в будущем, Q # позволяет программисту программировать сложные тактовые алгоритмы. Что еще больше, Q # поддерживает различные задачи, такие как отладка, профилирование, оценка ресурсов и определенные специализированные модели, масштабируемым способом. 

С технической точки зрения, тактовая программа может рассматриваться как определенный набор классических функций, которые при вызове создают тактовые цепи в качестве побочных эффектов. Важным следствием этого представления является то, что программа, написанная в Q #, напрямую не моделирует Кубитс, а описывает, как классический контрольный компьютер взаимодействует с этими Кубитс.
Таким образом, Q # не определяет состояния такта или другие свойства генератора тактов напрямую, а неявно делает это неявным образом посредством действий различных подпрограмм, определенных в языке.
Например, рассмотрим состояние $ \кет{+} = \лефт (\кет{0} + \кет{1}\ригхт)/\скрт{2}$, обсуждаемое [в этом руководством](xref:microsoft.quantum.concepts.intro) .
Чтобы подготовить это состояние в Q #, мы используем факты, которые Кубитс инициализируются в $ \кет{0}$ State и что $ \кет{+} = Х\кет{0}$, где $H $ является Хадамард преобразованием:

```qsharp
using (qubit = Qubit()) {
    // At this point, qubit is in the state |0〉.
    H(qubit);
    // We've now applied H, such that our qubit is in H|0〉 = |+〉, as we wanted.
}
```
## <a name="q-tranformations-of-quantum-states"></a>Q # транформатионс состояний тактов

Важно, что при написании приведенной выше программы мы не ссылались явно на состояние в Q #, а не описывали, как состояние было *преобразовано* нашей программой.
Таким образом, аналогично тому, как Программа графического шейдера накапливает Описание преобразований каждой вершины, тактовая программа в Q # накапливает преобразования в тактовые состояния.
Это позволяет нам полностью *не* зависеть от состояния такта, даже на каждом целевом компьютере, для которого в зависимости от компьютера могут использоваться разные интерпретации. 

С точки зрения программы Q # кубит является полностью непрозрачной ссылкой на внутреннюю структуру целевого компьютера.
Программа Q # не может интроспект в состояние кубит, его представление на целевом компьютере или даже того, является ли он тем же кубит, что и другие кубит, доступные для программы.
Вместо этого программа может вызывать такие операции, как `Measure`, для получения информации из кубит и вызова операций, таких как `X` и `H`, чтобы действовать в состоянии кубит.
Эти операции не имеют встроенного определения внутри языка и сделаны конкретными только целевым компьютером, используемым для запуска определенной программы Q #.
Программа Q # повторно объединяет эти операции, как определено на целевом компьютере, для создания новых операций более высокого уровня для вычисления тактовых вычислений.
Таким образом, Q # упрощает выражать логику базового и гибридного алгоритма, а также общие сведения относительно структуры целевого компьютера или симулятора.

## <a name="q-operations-and-functions"></a>Q # операции и функции

Конкретная программа Q # состоит из одной или нескольких *операций*, одной или нескольких *функций*и определяемых пользователем типов. Операции используются для описания преобразований тактового автомата и наиболее простого стандартного блока программ Q #. Каждая операция, определенная в Q #, может затем вызывать любое количество других операций, включая встроенные *внутренние* операции, реализованные на целевом компьютере.
При компиляции каждая операция представляется как тип класса .NET, который можно предоставить целевым компьютерам.

В отличие от операций, функции используются для описания чистого поведения и не имеют каких либо эффектов, помимо вычисления классических выходных значений. Q # является строго типизированным языком и поставляется с набором встроенных примитивных типов, а также поддержкой определяемых пользователем типов. 

В оставшейся части этого руководства мы рассмотрим, как использовать различные языковые концепции и конструкции, чтобы помочь нам определить сложные тактовые программы с помощью основных стандартных блоков операций, функций и типов. 

## <a name="structure-of-q-source-files"></a>Структура исходных файлов Q #

Как минимум, исходный файл Q # состоит из *объявления пространства имен*, которое указывает пространство имен .NET, которое будет содержать определения в исходном файле.
Определения из других исходных файлов и библиотек Q # можно включать с помощью инструкции `open`.
Например, большинство операций, определяющих фундаментальные шлюзы, определяются в пространстве имен <xref:microsoft.quantum.intrinsic>.
Чтобы сделать это доступным для нашего кода, мы просто `open` это пространство имен в верхней части каждого файла:

```qsharp
namespace Example {
    open Microsoft.Quantum.Intrinsic;

    // ...
}
```

В пространстве имен каждый исходный файл Q # может определять любое сочетание *операций*, *функций*и *определяемых пользователем типов*.
В оставшейся части этого раздела мы рассмотрим каждую из них, а также приводятся примеры того, как их можно использовать на практике для создания полезных программных тактов.
