---
title: 'Локальные переменные — методы Q #'
description: 'Узнайте, как определить локальные переменные и работать с ними в Q #.'
author: QuantumWriter
ms.author: Christopher.Granade@microsoft.com
ms.date: 12/11/2017
ms.topic: article
uid: microsoft.quantum.techniques.local-variables
ms.openlocfilehash: cb6c662137c31a13c3dd6e9ca3f67879c469f788
ms.sourcegitcommit: 6ccea4a2006a47569c4e2c2cb37001e132f17476
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/28/2020
ms.locfileid: "77906871"
---
# <a name="local-variables"></a>Локальные переменные #

Значение любого типа в Q # можно присвоить переменной для повторного использования в операции или функции с помощью ключевого слова `let`.
например

```qsharp
let measurementOperator = [PauliX, PauliZ, PauliZ, PauliX, PauliI];
```

Это назначает определенный массив операторов Паули переменной с именем `measurementOperator`.

> [!TIP]
> Обратите внимание, что нам не нужно явно указывать тип нашей новой переменной, так как выражение в правой части оператора `let` является неоднозначным и тип выводится компилятором. 

Переменные в Q # являются *неизменяемыми*. Это означает, что после того как переменная определена таким образом, она больше не может быть изменена каким-либо образом.
Это обеспечивает несколько выгодных оптимизаций, включая оптимизацию классической логики, действующей на переменные, для изменения порядка применения `Adjoint` варианта операции.

Переменные, определенные с помощью привязки `let`, как и выше, являются локальными для определенной области, например тело операции или содержимое цикла `for`.


## <a name="mutability"></a>Измен ##

В качестве альтернативы созданию переменной с `let`ключевое слово `mutable` создаст специальную изменяемую переменную, которая может быть повторно привязана после первоначального создания с помощью ключевого слова `set`.

```qsharp
operation RandomInts(maxInt : Int, nrSamples : Int) : Int[] {
    mutable samples = new Int[0];
    for (i in 1 .. nrSamples) {
        set samples += [RandomInt(maxInt)];
    }
    return samples;
}
```

Все типы в Q #, включая массивы, следуют семантике значений. В частности, невозможно обновить элементы массива. Чтобы изменить существующий массив, необходимо использовать механизм копирования и обновления, похожий на один для записей в F#. Используя средства библиотеки для массивов, предоставляемых в [`Microsoft.Quantum.Arrays`](xref:microsoft.quantum.arrays), мы можем, например, легко определить функцию, возвращающую массив пола, где Паули по индексу `i` принимает заданное значение, а все остальные записи являются идентификатором: 

```qsharp
function EmbedPauli (pauli : Pauli, i : Int, n : Int) : Pauli[] {
    
    let arr = ConstantArray(n, PauliI); // creates an array of filled with PauliI
    return arr w/ i <- pauli; // constructs a new array based on arr except that entry i is set to pauli
}
```

Мы подробнее рассмотрим работу с массивами при обсуждении инструкций и выражений Q #. 

Изменяемость в Q # — это концепция, которая применяется к *символу* , а не к типу или значению. В частности, он не имеет представления в системе типов, неявно или явно, а также от того, является ли привязка изменяемой (как указано ключевым словом `mutable`) или неизменяемой (как указано в `let`), не изменяет тип привязанных переменных. Это обеспечивает важный способ изоляции изменяемых функций в специализированных функциях и операциях.
В частности, несмотря на то, что во внешней специализации для операции, которая использует изменяемую переменную, не может быть создана автоматически, автоматическое создание автоматически выполняется для операции, вызывающей функцию, которая использует mutable.
По этой причине рекомендуется сделать функции и операции, которые используют изменяемость, как можно меньшее и сжимать, чтобы остальная часть тактовой программы могла быть написана с использованием обычных неизменяемых переменных.


## <a name="deconstruction"></a>Деконструкция ##

Помимо присвоения одной переменной, `let` и `mutable` ключевые слова — или на самом деле любые другие конструкции привязки — также позволяют распаковать содержимое [типа кортежа](xref:microsoft.quantum.language.type-model#tuple-types).
Назначение этой формы называется *деконструированием* элементов этого кортежа.
Например, если мы моделируем термин в Хамилтониан с помощью кортежа, то мы можем использовать деконструкцию для доступа к различным данным, которые необходимо смоделировать под этим термином:

```qsharp
// Represents H = 3.1 X_0 Z_1.
let (_, (paulis, idxQubits)) = ((3.1, 1.0), ([PauliX, PauliZ], [0, 1])); // paulis and idxQubits are both immutable variables
mutable ((c1, c2), _) = ((3.1, 1.0), ([PauliX, PauliZ], [0, 1])); // c1 and c2 are both mutable variables
```


