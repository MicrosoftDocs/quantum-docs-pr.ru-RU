---
title: 'Q # операции и функции'
description: 'Сведения об операциях и функциях Q #, а также о том, как они применяются в тактовой программе.'
uid: microsoft.quantum.techniques.opsandfunctions
author: QuantumWriter
ms.author: Christopher.Granade@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: 43f0cf2da192a607e514d0c7de57a9bdd067faf7
ms.sourcegitcommit: 6ccea4a2006a47569c4e2c2cb37001e132f17476
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/28/2020
ms.locfileid: "77907670"
---
# <a name="q-operations-and-functions"></a>Q # операции и функции

Программы Q # состоят из одной или нескольких *операций* , описывающих побочные эффекты, которые могут иметь тактовые операции, и одну или несколько *функций* , которые позволяют вносить изменения в классические данные. В отличие от операций, функции используются для описания чистого поведения и не имеют каких либо эффектов, помимо вычисления классических выходных значений.

Каждая операция, определенная в Q #, может затем вызывать любое количество других операций, включая встроенные внутренние операции, определенные в языке. Конкретный способ определения этих внутренних операций зависит от целевого компьютера. При компиляции каждая операция представляется как тип класса .NET, который можно предоставить целевым компьютерам.

## <a name="defining-new-operations"></a>Определение новых операций

Как описано выше, самый простой стандартный блок тактовой программы, написанный на Q #, — это *Операция*, которую можно вызывать из классических приложений .NET, например, с помощью симулятора или других операций в Q #.
Каждая операция принимает входные данные, создает выход и задает реализацию для одной или нескольких специализаций операций.
Например, следующая операция определяет только специализацию тела по умолчанию и принимает один кубит в качестве входных данных, а затем вызывает встроенную операцию `X` для этих входных данных:

```qsharp
operation BitFlip(target : Qubit) : Unit {
    X(target);
}
```

Ключевое слово `operation` начинает определение операции, за которым следует имя; Здесь `BitFlip`.
Далее тип входных данных определяется как `Qubit`, а также имя `target` для ссылки на входные данные в новой операции.
Аналогичным образом `Unit` определяет, что выходные данные операции пусты.
Он используется аналогично `void` в C# и других императивных языках и эквивалентен `unit` в F# и других функциональных языках.

> [!NOTE]
> Мы рассмотрим это более подробно, но каждая операция в Q # принимает ровно один вход и возвращает ровно один выход.
> После этого несколько входов и выходов представляются с помощью *кортежей*, которые собираются несколько значений вместе в одно значение.
> В неформальном случае мы говорим, что Q # — это «кортеж в кортеже».
> После этой концепции `()` следует считать "пустым" кортежом, который имеет тип `Unit`.

В новой операции реализация может быть указана непосредственно в объявлении, если только реализация специализации тела по умолчанию должна быть указана явно. Кроме того, можно определить реализации, например одну или несколько операций `functor`, как описано ниже. В приведенном выше примере единственным оператором является вызов встроенной операции Q # <xref:microsoft.quantum.intrinsic.x>.

Операции могут также возвращать более интересные типы, чем `Unit`.
Например, операция <xref:microsoft.quantum.intrinsic.m> возвращает выходные данные типа `Result`, представляющие выполнение измерения. Можно либо передать выходные данные операции в другую операцию, либо использовать ее с ключевым словом `let`, чтобы определить новую переменную.
<!-- Link to UID for superdense conceptual and example documentation. -->
Это позволяет представить классические вычисления, взаимодействующие с операциями тактов на низком уровне, например в очень плотной кодировке:

```qsharp
operation Superdense(here : Qubit, there : Qubit) : (Result, Result) {

    CNOT(there, here);
    H(there);

    let firstBit = M(there);
    let secondBit = M(here);

    return (firstBit, secondBit);
}
```
### <a name="functors-adjoint-and-controlled"></a>Операторов, прилегающий и управляемый
Если операция реализует единое преобразование, можно определить, как работает операция при *аджоинтед* или *управлении*. В примыкающей специализации операции указывается, как она действует при выполнении в обратную, в то время как управляемая специализация указывает, как работает операция при условии, что оно применено к состоянию регистра такта.
Существование этих специализаций можно объявить как часть сигнатуры операции: `is Adj + Ctl` в следующем примере. Затем соответствующая реализация для каждой такой неявно объявленной специализации создается компилятором. 

```qsharp
operation PrepareEntangledPair(here : Qubit, there : Qubit) : Unit
is Adj + Ctl { // implies the existence of an adjoint, a controlled, and a controlled adjoint specialization
    H(here);
    CNOT(here, there);
}
```

> [!NOTE]
> Многие операции в Q # представляют единые шлюзы.
> Если $U $ является единым шлюзом, представленным `U`операции, то `Adjoint U` представляет единую вентиль $U ^ \дагжер $.

В случае, если реализация не может быть создана компилятором, ее можно указать явно. Такие явные объявления специализации могут состоять из подходящей директивы создания или пользовательской реализации. Код в `PrepareEntangledPair` выше, например, эквивалентен приведенному ниже коду, содержащему явные объявления специализации: 

```qsharp
operation PrepareEntangledPair(here : Qubit, there : Qubit) : Unit {
    body (...) { // default body specialization
        H(here);
        CNOT(here, there);
    }

    adjoint auto; // auto-generate adjoint specialization
    controlled auto; // auto-generate controlled specialization
    controlled adjoint auto; // auto-generate controlled adjoint specialization
}
```
Ключевое слово `auto` указывает, что компилятор должен определить способ создания реализации специализации.
Если компилятор не может автоматически создать реализацию для определенной специализации или если может быть предоставлена более эффективная реализация, то реализация может быть также определена вручную.

```qsharp
operation PrepareEntangledPair(here : Qubit, there : Qubit) : Unit
is Ctl + Adj {
    body (...) { // default body specialization
        H(here);
        CNOT(here, there);
    }

    controlled (cs, ...) { // user defined implementation for the controlled specialization
        Controlled H(cs, here);
        Controlled X(cs + [here], there);
    }

    adjoint invert; 
    controlled adjoint invert; 
}
```
В приведенном выше примере `adjoint invert;` указывает, что примыкающая специализация должна быть создана путем инвертирования реализации тела, а `controlled adjoint invert;` указывает, что управляемая примыкающая специализация должна быть создана путем инвертирования заданной реализации управляемой специализации.

В [потоке управления более высокого порядка](xref:microsoft.quantum.concepts.control-flow)будут рассмотрены дополнительные примеры.

Чтобы вызвать специализацию операции, используйте ключевые слова `Adjoint` или `Controlled`.
Например, приведенный выше пример кода можно написать более компактно, используя смежную часть `PrepareEntangledPair` для преобразования запутанными состояния обратно в унентанглед пару Кубитс:

```qsharp
operation Superdense(here : Qubit, there : Qubit) : (Result, Result) {
    Adjoint PrepareEntangledPair(there, here);

    let firstBit = M(there);
    let secondBit = M(here);

    return (firstBit, secondBit);
}
```

При проектировании операций для использования с операторов необходимо учитывать ряд важных ограничений.
Как правило, специализации для операции, которая использует выходное значение любой другой операции, не могут быть созданы компилятором автоматически, так как это неоднозначно, как изменить порядок инструкций в такой операции, чтобы получить такой же результат.


## <a name="defining-new-functions"></a>Определение новых функций

Q # также позволяет определять *функции*, которые отличаются от операций тем, что они не могут иметь каких бы то ни было последствий, чем вычисление выходного значения.
В частности, функции не могут вызывать операции, действовать для Кубитс, примеры случайных чисел или иным образом зависят от состояния, превышающего входное значение функции.
Как следствие, функции Q # являются *чисто*, в том, что они всегда сопоставляют одинаковые входные значения с одними и теми же выходными значениями.
Это позволяет компилятору Q # безопасно изменять порядок и время вызова функций при создании специализаций операций.

Определение функции работает аналогично определению операции, за исключением того, что для функции нельзя определить ни прилегающие, ни контролируемые специализации.
например

```qsharp
function Square(x : Double) : (Double) {
    return x * x;
}
```
Когда это возможно, полезно писать классическую логику с точки зрения функций, а не операций, чтобы его можно было использовать в рамках операций.
Например, если бы в качестве операции было написано `Square`, компилятор не сможет гарантировать, что его вызов с теми же входными данными получит одинаковые выходные данные.

Чтобы подчеркнуть разницу между функциями и операциями, рассмотрим проблему с классической выборкой случайного числа в операции Q #:

```qsharp
operation U(target : Qubit) : Unit {

    let angle = RandomReal()
    Rz(angle, target)
}
```

Каждый раз, когда вызывается `U`, он будет иметь другое действие в `target`.
В частности, компилятор не может гарантировать, что если мы добавили объявление специализации `adjoint auto` для `U`, `U(target); Adjoint U(target);` будет выступать в качестве удостоверения (т. е. без операции).
Это нарушает определение примыкающего, которое мы видели в [векторах и матрицах](xref:microsoft.quantum.concepts.vectors), что позволяет автоматически формировать смежную специализацию в операции, в которой мы вызвали операцию <xref:microsoft.quantum.math.randomreal> нарушают гарантии, предоставляемые компилятором. <xref:microsoft.quantum.math.randomreal> — это операция, для которой не существует ни одной примыкающей или контролируемой версии.

С другой стороны, разрешение вызовов функций, таких как `Square`, является надежным, в том, что компилятор может быть уверенным в том, что необходимо сохранить входные данные для `Square`, чтобы обеспечить стабильную работу.
Таким образом, изоляция максимально возможной логики функций позволяет легко повторно использовать эту логику в других функциях и операциях.

## <a name="control-flow"></a>Поток управления

Внутри операции или функции каждая инструкция выполняется по порядку, аналогично наиболее распространенным императивным классическим языкам.
Однако этот поток управления можно изменить тремя разными способами:

- Операторы `if`
- Циклы `for`
- Циклы `until` -`repeat`

Мы относимся к рассказу о втором, пока не будем обсуждать каналы [повторения](xref:microsoft.quantum.techniques.qubits#measurements) .
Однако конструкции потока управления `if` и `for` имеют привычный смысл для большинства классических языков программирования.
В частности, оператор `if` может принять условие, за которым может следовать одна или несколько `elif`ных инструкций и может заканчиваться `else`:

```qsharp
if (pauli == PauliX) {
    X(qubit);
} elif (pauli == PauliY) {
    Y(qubit);
} elif (pauli == PauliZ) {
    Z(qubit);
} else {
    fail "Cannot use PauliI here.";
}
```

Аналогичным образом `for` циклы указывают на итерацию для диапазона целых чисел или элементов массива.

```qsharp
for (idxQubit in 0..nQubits - 1) {
    // Do something to idxQubit...
}
```

Что важнее, `for` циклы и операторы `if` можно использовать даже в операциях, для которых автоматически создаются специализации. В этом случае смежная часть цикла `for` меняет направление на противоположное и принимает смежную часть каждой итерации.
Это соответствует принципу "обувь-and-Socks": Если вы хотите отменить размещение по протоколу SOCKS, а затем обувь, необходимо отменить помещение обувь, а затем отменить последующую операцию по протоколу SOCKS.
Это решение работает менее эффективно, и вы можете использовать протокол Socks, пока вы по-прежнему людьмие обувь!

## <a name="operations-and-functions-as-first-class-values"></a>Операции и функции в качестве значений первого класса

Одной из важнейших методик для реализации потока управления и классической логики с помощью функций, а не операций является использование этих операций и функций в Q # — *первый класс*.
То есть все значения на языке имеют свое право.
Например, ниже приведен правильный код Q #, если немного косвенно:

```qsharp
operation FirstClassExample(target : Qubit) : Unit {
    let ourH = H;
    ourH(target);
}
```

Значение переменной, `ourH` в приведенном выше фрагменте, — это операция, <xref:microsoft.quantum.intrinsic.h>, так что мы можем вызвать это значение, как любую другую операцию.
Это позволяет нам писать операции, которые принимают операции в качестве части их входных данных, формируя основные понятия потока управления более высокого порядка.
Например, мы могли бы представить, что нужно "возкубит" операцию, применив ее дважды к той же цели.

```qsharp
operation ApplyTwice(op : (Qubit => Unit), target : Qubit) : Unit {
    op(target);
    op(target);
}
```

В этом примере стрелка `=>`, которая отображается в `(Qubit => Unit)` типа, означает, что поле ввода `op` является операцией, которая принимает в качестве входных данных тип `Qubit` и создает в качестве выходных данных пустой кортеж.
Кроме того, мы указываем характеристики типа операции, которые содержат сведения о поддерживаемых операторов.
Операция типа `(Qubit => Unit)` не поддерживает ни `Adjoint`, ни `Controlled` функтор. Если нам нужно указать, что операция этого типа должна поддерживать, например `Adjoint` функтор, нам нужно объявить ее как аджоинтабле. Это делается с помощью аннотации, `is Adj` типу. Аналогичным образом `(Qubit => Unit is Ctl)` указывает, что операция этого типа поддерживает `Controlled` функтор. Мы рассмотрим это Подробнее, когда мы обсудим [типы в разделе вопросы и ответы](xref:microsoft.quantum.language.type-model) .

Сейчас мы Подчеркните, что мы можем также возвращать операции как часть выходных данных, что позволяет изолировать некоторые виды классической условной логики в качестве классической функции, возвращающей описание тактовой программы в форме операции.
В качестве простого примера рассмотрим пример использования телепередачи, в котором сторона, получающая 2-разрядное классическое сообщение, должна использовать сообщение для декодирования их кубит в соответствующее состояние в режиме «в Организации».
Мы можем написать это с точки зрения функции, которая принимает эти два классических битов и возвращает правильную операцию декодирования.

```qsharp
function TeleporationDecoderForMessage(hereBit : Result, thereBit : Result)
: (Qubit => Unit is Adj + Ctl) {

    if (hereBit == Zero && thereBit == Zero) {
        return I;
    } elif (hereBit == One && thereBit == Zero) {
        return X;
    } elif (hereBit == Zero && thereBit == One) {
        return Z;
    } else {
        return Y;
    }
}
```

Эта новая функция действительно является функцией. в этом случае, если мы вызываем ее с теми же значениями `hereBit` и `thereBit`, мы всегда вернемся к той же операции.
Таким образом, декодер можно безопасно запускать внутри операций, не прибегая к причине того, как логика декодирования взаимодействует с определениями различных специализаций операций.
То есть, мы разимпунити классическую логику внутри функции, гарантируя компилятору, что вызов функции может быть переупорядочен с помощью, пока сохраняются входные данные.

Мы также можем рассматривать функции как значения первого класса, так как мы увидим более подробное описание [операций и типов функций](#operations-and-functions-as-first-class-values).

## <a name="partially-applying-operations-and-functions"></a>Частичное применение операций и функций

Мы можем значительно повысить эффективность работы функций, возвращающих операции с помощью *частичного приложения*, в котором мы можем предоставить одну или несколько частей входных данных функции или операции без фактического их вызова. Например, при повторном вызове приведенного выше примера `ApplyTwice` мы можем указать, что мы не хотим указывать, что нужно, чтобы кубит входную операцию:

```qsharp
operation PartialApplicationExample(op : (Qubit => Unit), target : Qubit) : Unit {
    let twiceOp = ApplyTwice(op, _);
    twiceOp(target);
}
```

В этом случае локальная переменная `twiceOp` содержит частично примененную операцию `ApplyTwice(op, _)`, где части входных данных, которые еще не были указаны, обозначаются `_`.
Когда мы вызываем `twiceOp` в следующей строке, мы передаем в качестве входных данных частично примененную операцию все оставшиеся части входных данных в исходную операцию.
Таким образом, приведенный выше фрагмент кода фактически идентичен вызову `ApplyTwice(op, target)` напрямую, сохранить для того, что мы предоставили новую локальную переменную, которая позволяет отложить вызов, предоставляя некоторые части входных данных.

Так как операция, которая была частично применена, фактически не вызывается до тех пор, пока не будет предоставлен весь ввод, можно безопасно частично применить операции даже в рамках функций.

```qsharp
function SquareOperation(op : (Qubit => Unit)) : (Qubit => Unit) {
    return ApplyTwice(op, _);
}
```

В принципе, классическая логика в `SquareOperation` может быть гораздо более сложной, но она по-прежнему изолирована от остальной части операции с помощью гарантий, что компилятор может предложить функции.
Этот подход будет использоваться в стандартной библиотеке Q # для выражения классического потока управления способом, который можно легко использовать в тактовых программах.
