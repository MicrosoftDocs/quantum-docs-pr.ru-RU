---
title: 'Поработайте с методами Q #'
description: 'Ознакомьтесь с дополнительными разделами в Q #, такими как создание универсальных функций и позаимствование Кубитс.'
author: QuantumWriter
ms.author: Christopher.Granade@microsoft.com
ms.date: 12/11/2017
ms.topic: article
uid: microsoft.quantum.techniques.going-further
ms.openlocfilehash: 46ebf544c1d6e56f152a06d06151305fa972011a
ms.sourcegitcommit: 6ccea4a2006a47569c4e2c2cb37001e132f17476
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/28/2020
ms.locfileid: "77906905"
---
# <a name="going-further"></a>Дальнейшие переходы #

Теперь, когда вы узнали, как написать интересные тактовые программы в Q #, в этом разделе вы узнаете о нескольких более сложных темах, которые должны быть полезны для пересылки.


## <a name="generic-operations-and-functions"></a>Универсальные операции и функции ##

> [!TIP]
> В этом разделе предполагается, что основные знания [универсальных C#шаблонов в ](https://docs.microsoft.com/dotnet/csharp/programming-guide/generics/introduction-to-generics), [универсальных F# ](https://docs.microsoft.com/dotnet/fsharp/language-reference/generics/) [ C++ шаблонах, шаблонов](https://docs.microsoft.com/cpp/cpp/templates-cpp)и аналогичных подходов к метапрограммирование в других языках.

Многие функции и операции, которые мы хотим определить, не сильно полагаются на типы входных данных, а только неявно используют их типы с помощью какой бы то ни было другой функции или операции.
Например, рассмотрим концепцию *Map* , общую для многих функциональных языков. При наличии функции $f (x) $ и коллекции значений $\{x_1, x_2, \дотс, x_n\}$, Map возвращает новую коллекцию $\{f (x_1), f (x_2), \дотс, f (x_n)\}$.
Чтобы реализовать это в Q #, мы можем воспользоваться преимуществами функций, которые являются первыми классами.
Давайте запишем краткий пример `Map`, используя ★ в качестве заполнителя, пока мы выберем, какие типы нам нужны.

```qsharp
function Map(fn : (★ -> ★), values : ★[]) : ★[] {
    mutable mappedValues = new ★[Length(values)];
    for (idx in 0..Length(values) - 1) {
        set mappedValues w/= idx <- fn(values[idx]);
    }
    return mappedValues;
}
```

Обратите внимание, что эта функция выглядит почти так же, независимо от фактических типов, которые мы заменяем.
, Например, карту из целых чисел в пол, похожа на карту из чисел с плавающей запятой в строки:

```qsharp
function MapIntsToPaulis(fn : (Int -> Pauli), values : Int[]) : Pauli[] {
    mutable mappedValues = new Pauli[Length(values)];
    for (idx in 0..Length(values) - 1) {
        set mappedValues w/= idx <- fn(values[idx]);
    }
    return mappedValues;
}

function MapDoublesToStrings(fn : (Double -> String), values : Double[]) : String[] {
    mutable mappedValues = new String[Length(values)];
    for (idx in 0..Length(values) - 1) {
        set mappedValues w/= idx <- fn(values[idx]);
    }
    return mappedValues;
}
```

В принципе, мы могли бы написать версию `Map` для каждой пары типов, которую мы столкнулись, но это порождает ряд трудностей.
Например, если в `Map`обнаружена ошибка, необходимо убедиться, что исправление применяется единообразно во всех версиях `Map`.
Более того, если мы создаем новый кортеж или определяемый пользователем тип, то теперь необходимо создать новый `Map` для перехода к новому типу.
Хотя это алгоритмизируемым для небольшого количества таких функций, так как мы соберем больше функций той же формы, что и `Map`, стоимость введения новых типов становится неоправданной в достаточно коротком порядке.

Однако большая часть этой сложности не дает компилятору сведения, необходимые для того, чтобы понять, как связаны разные версии `Map`.
Фактически мы хотим, чтобы компилятор обрабатывал `Map` как математические функции в Q # *types* to q # functions.
Это понятие формально позволяет функциям и операциям иметь *Параметры типа*, а также их обычные параметры кортежа.
В приведенных выше примерах мы хотели бы представить `Map` как имеющие параметры типа `Int, Pauli` в первом случае и `Double, String` во втором случае.
В большинстве случаев эти параметры типа можно использовать, как будто они являются обычными типами: мы используем значения параметров типа для создания массивов и кортежей, вызова функций и операций и присваивания обычным или изменяемым переменным.

> [!NOTE]
> Самый крайний случай косвенной зависимости заключается в том, что Кубитс, где программа Q # не может напрямую полагаться на структуру типа `Qubit`, но **должна** передавать подобные типы другим операциям и функциям.

Вернувшись к приведенному выше примеру, можно увидеть, что нам нужно `Map` иметь параметры типа, один для представления входных данных для `fn` и один для представления выходных данных `fn`.
В Q # это написано путем добавления угловых скобок (`<>`, а не Бракетс $ \бракет{}$!) после имени функции или операции в ее объявлении, а также путем перечисления каждого параметра типа.
Имя каждого параметра типа должно начинаться с деления `'`, что означает, что это параметр типа, а не обычный тип (также известен как *конкретный* тип).
Для `Map`мы пишем следующее:

```qsharp
function Map<'Input, 'Output>(fn : ('Input -> 'Output), values : 'Input[]) : 'Output[] {
    mutable mappedValues = new 'Output[Length(values)];
    for (idx in 0..Length(values) - 1) {
        set mappedValues w/= idx <- fn(values[idx]);
    }
    return mappedValues;
}
```

Обратите внимание, что определение `Map<'Input, 'Output>` очень похоже на версии, которые мы написали ранее.
Единственное различие заключается в том, что мы явно осведомлены о том, что компилятор, `Map`, напрямую не зависит от того, какие `'Input` и `'Output`, но работает для любых двух типов, используя их косвенно через `fn`.
Определив `Map<'Input, 'Output>` таким образом, можно вызвать его, как будто это обычная функция:

```qsharp
// Represent Z₀ Z₁ X₂ Y₃ as a list of ints.
let ints = [3, 3, 1, 2];
// Here, we assume IntToPauli : Int -> Pauli
// looks up PauliI by 0, PauliX by 1, so forth.
let paulis = Map(IntToPauli, ints);
```

> [!TIP]
> Написание универсальных функций и операций — это одно из мест, где «кортеж-в кортеже» — очень полезный способ подумать о функциях и операциях Q #.
> Поскольку каждая функция принимает ровно один вход и возвращает ровно один выход, входные данные типа `'T -> 'U` совпадают с *любыми* функциями Q #.
> Аналогичным образом любая операция может быть передана в вход типа `'T => 'U`.

Во втором примере рассмотрим задачу написания функции, возвращающей композицию двух других функций:

```qsharp
function ComposeImpl(outerFn : (B -> C), innerFn : (A -> B), input : A) : C {
    return outerFn(innerFn(input));
}

function Compose(outerFn : (B -> C), innerFn : (A -> B)) : (A -> C) {
    return ComposeImpl(outerFn, innerFn, _);
}
```

Здесь необходимо указать, что именно `A`, `B`и `C`, и, следовательно, существенно ограничивает служебную программу нашей новой функции `Compose`.
В конце концов, `Compose` зависит только от `A`, `B`и `C` *через* `innerFn` и `outerFn`.
В качестве альтернативы можно добавить параметры типа к `Compose`, которые указывают, что он работает для *любого* `A`, `B`и `C`, пока эти параметры соответствуют ожидаемым `innerFn` и `outerFn`:

```qsharp
function ComposeImpl<'A, 'B, 'C>(outerFn : ('B -> 'C), innerFn : ('A -> 'B), input : 'A) : 'C {
    return outerFn(innerFn(input));
}

function Compose<'A, 'B, 'C>(outerFn : ('B -> 'C), innerFn : ('A -> 'B)) : ('A -> 'C) {
    return ComposeImpl(outerFn, innerFn, _);
}
```

Стандартные библиотеки Q # предоставляют ряд таких операций и функций с параметрами, которые позволяют более быстро выражать поток управления с более высоким порядком.
Они описаны далее в статье [рекомендации по стандартной библиотеке Q #](xref:microsoft.quantum.libraries.standard.intro).

## <a name="borrowing-qubits"></a>Заимствование Кубитс ##

Механизм заимствования займов позволяет выделить Кубитс, который можно использовать в качестве вспомогательного пространства во время вычисления. Обычно эти Кубитс не находятся в чистом состоянии, т. е. они не обязательно инициализируются в известном состоянии, например $ \кет{0}$. Одна из них также говорит о «грязном» Кубитс, так как их состояние неизвестно и даже может быть запутанными с другими частями памяти компьютера-такта. Между известными случаями использования «грязных» Кубитс являются реализации многофункциональных кнот шлюзов, требующие лишь очень мало Кубитс и реализации инкрементов.

В Canon есть примеры, в которых используется ключевое слово `borrowing`, например функция, `MultiControlledXBorrow` определена ниже.
Если `controls` обозначает элемент управления Кубитс, который должен быть добавлен в операцию `X`, то в этой реализации будет добавлена общая `Length(controls)-2` много грязных анЦиллас.

```qsharp
operation MultiControlledXBorrow ( controls : Qubit[] , target : Qubit ) : Unit
is Adj + Ctl {

    body (...) {
        ... // skipping some case handling here
        let numberOfDirtyQubits = numberOfControls - 2;
        borrowing( dirtyQubits = Qubit[ numberOfDirtyQubits ] ) {

            let allQubits = [ target ] + dirtyQubits + controls;
            let lastDirtyQubit = numberOfDirtyQubits;
            let totalNumberOfQubits = Length(allQubits);

            let outerOperation1 = 
                CCNOTByIndexLadder(
                    numberOfDirtyQubits + 1, 1, 0, numberOfDirtyQubits , _ );
            
            let innerOperation = 
                CCNOTByIndex(
                    totalNumberOfQubits - 1, totalNumberOfQubits - 2, lastDirtyQubit, _ );
            
            WithA(outerOperation1, innerOperation, allQubits);
            
            let outerOperation2 = 
                CCNOTByIndexLadder(
                    numberOfDirtyQubits + 2, 2, 1, numberOfDirtyQubits - 1 , _ );
            
            WithA(outerOperation2, innerOperation, allQubits);
        }
    }

    controlled(extraControls, ...) {
        MultiControlledXBorrow( extraControls + controls, target );
    }
}
```

Обратите внимание, что широкое использование `With` объединения---в своей форме, которое применимо для операций, поддерживающих смежные элементы, т. е. `WithA`---был сделан в этом примере, что является хорошим стилем программирования, так как добавление элемента управления для структур, включающих `With`, только передает управление во внутреннюю операцию. Обратите внимание, что в дополнение к `body`у операции была явно предоставлена реализация `controlled` тела операции, а не инструкция `controlled auto`. Причина в том, что мы понимаем, что из структуры канала можно легко добавить дополнительные элементы управления, которые полезны по сравнению с добавлением элемента управления в каждый отдельный шлюз в `body`. 

Рекомендуется сравнить этот код с другой функцией Canon `MultiControlledXClean`, которая дает ту же цель реализации операции `X`, управляемой операцией умножения, но которая использует несколько чистых Кубитс с помощью механизма `using`. 
