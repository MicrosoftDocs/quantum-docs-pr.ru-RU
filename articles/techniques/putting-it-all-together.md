---
title: 'Все вместе — методы Q # | Документация Майкрософт'
description: 'Все вместе — методы Q #'
uid: microsoft.quantum.techniques.puttingittogether
author: QuantumWriter
ms.author: Christopher.Granade@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: 3605826da159757d4b321dbf4ec6acd7f4e6be05
ms.sourcegitcommit: f8d6d32d16c3e758046337fb4b16a8c42fb04c39
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/29/2020
ms.locfileid: "76820170"
---
# <a name="putting-it-all-together-teleportation"></a>Совместное размещение: телепередача #
Давайте вернемся к примеру канала телепереноса, определенного в [тактовой цепи](xref:microsoft.quantum.concepts.circuits). Мы будем использовать его для иллюстрации концепций, которые мы узнали до сих пор. Пояснения о телепортовой телетранспортировке приведены ниже для тех, кто не знаком с теории, за которым следует пошаговое руководство по реализации кода в Q #. 

## <a name="quantum-teleportation-theory"></a>Потактовая попорция: теория
Для отправки неизвестного состояния такта (которое мы будем называть "__сообщением__") из кубит в одном расположении в кубит в другом месте (мы будем ссылаться на эти Кубитс как "__здесь__"__и "in" соответственно__). Мы можем представить наше __сообщение__ в виде вектора с помощью нотации Дирак: 

$ $ \кет{\пси} = \алфа\кет{0} + \бета\кет{1} $ $

Состояние __сообщения__ кубит неизвестно нам, так как мы не понимаем значения $ \алфа $ и $ \бета $.

### <a name="step-1-create-an-entangled-state"></a>Шаг 1. Создание состояния запутанными
Чтобы отправить __сообщение__ , необходимо, __чтобы кубит,__ запутанными с кубит __там__. Это достигается путем применения шлюза Хадамард, за которым следует шлюз кнот. Давайте взглянем на математические части этих операций Gate.

Мы начнем с Кубитс __здесь__ , а также как в \кет, __так и в__ состоянии $:{0}$. После ентанглинг этих Кубитс они находятся в состоянии:

$ $ \кет{\фи ^ +} = \фрак{1}{\скрт{2}} (\кет{00} + \кет{11}) $ $

### <a name="step-2-send-the-message"></a>Шаг 2. Отправка сообщения
Чтобы отправить __сообщение__ , сначала ПРИМЕНИТе кнотный шлюз с __сообщением__ кубит, __а здесь__ кубит в качестве входных данных ( __сообщение__ кубит является элементом управления, а в данном __случае кубит — целевым кубит)__ . Входное состояние может быть написано:

$ $ \кет{\пси}\кет{\фи ^ +} = (\алфа\кет{0} + \бета\кет{1}) (\фрак{1}{\скрт{2}} (\кет{00} + \кет{11})) $ $

Это расширяется до:

$ $ \кет{\пси}\кет{\фи ^ +} = \фрак{\алфа}{\скрт{2}} \кет{000} + \фрак{\алфа}{\скрт{2}} \кет{011} + \фрак{\бета}{\скрт{2}} \ket{100} + \frac{\beta}{\sqrt{2}} \ket{111} $ $

Как напоминание, шлюз кнот переворачивает целевой кубит, когда элемент управления кубит равен 1. Например, входные данные $ \кет{000}$ не будут изменяться, так как первый кубит (элемент управления) равен 0. Однако возьмем случай, когда первый кубит имеет значение 1, например входные данные $ \кет{100}$. В этом экземпляре выходные данные имеют значение $ \кет{110}$, так как второй кубит (целевой объект) зеркально отражается шлюзом кнот.

Давайте теперь рассмотрим наши выходные данные, когда кнот ворота полагается на наши входные данные выше. Результат:

$ $ \фрак{\алфа}{\скрт{2}} \кет{000} + \фрак{\алфа}{\скрт{2}} \кет{011} + \фрак{\бета}{\скрт{2}} \кет{110} + \фрак{\бета}{\скрт{2}} \ket{101} $ $

Следующим шагом для отправки __сообщения__ является применение шлюза хадамард к __сообщению__ кубит (первое кубит каждого термина). 

Как напоминание, шлюз Хадамард выполняет следующие действия:

Входные данные | Выходные данные
---------------------------| ---------------------------------------------------------------
$ \кет{0}$  | $ \фрак{1}{\скрт{2}} (\кет{0} + \кет{1}) $
$ \кет{1}$  | $ \фрак{1}{\скрт{2}} (\кет{0} — \кет{1}) $

Если применить шлюз Хадамард к первому кубиту каждого из приведенных выше выходных данных, мы получаем следующий результат:

$ $ \фрак{\алфа}{\скрт{2}} (\фрак{1}{\скрт{2}} (\кет{0} + \кет{1})) \кет{00} + \фрак{\алфа}{\скрт{2}} (\фрак{1}{\скрт{2}} (\кет{0} + \кет{1})) \ket{11} + \frac{\beta}{\sqrt{2}} (\frac{1}{\sqrt{2}} (\ket{0}-\ket{1})) \ket{10} + \frac{\beta}{\sqrt{2}} (\frac{1}{\sqrt{2}} (\ket{0}-\ket{1})) \ket{01} $ $

Обратите внимание, что каждый термин имеет $2 \фрак{1}{\скрт{2}} $ факторов. Мы можем умножить эти данные, предоставив следующий результат:

$ $ \фрак{\алфа}{2}(\кет{0} + \кет{1}) \кет{00} + \фрак{\алфа}{2}(\кет{0} + \кет{1}) \кет{11} + \фрак{\бета}{2}(\кет{0}-\кет{1}) \кет{10} + \фрак{\бета}{2}(\ket{0}-\ket{1}) \ket{01} $ $

Параметр $ \фрак{1}{2}$ является общим для каждого термина, поэтому теперь его можно использовать за пределами квадратных скобок:

$ $ \фрак{1}{2}\биг [\алфа (\кет{0} + \кет{1}) \кет{00} + \алфа (\кет{0} + \кет{1}) \кет{11} + \бета (\кет{0}-\кет{1}) \кет{10} + \бета (\кет{0}-\кет{1}) \ket{01}\big] $ $

Затем можно умножить квадратные скобки для каждого термина:

$ $ \фрак{1}{2}\биг [\алфа\кет{000} + \алфа\кет{100} + \алфа\кет{011} + \алфа\кет{111} + \бета\кет{010}-\бета\кет{110} + \бета\кет{001}-\beta\ket{101}\big] $ $

### <a name="step-3-measure-the-result"></a>Шаг 3. Измерение результата

Из-за __того, что__ у вас __есть__ запутанными, любое измерение в __этом__ случае повлияет на его __состояние.__ Если мы измеряем первый и второй кубит (__сообщение__ и __здесь__), то можете узнать, какое состояние __есть__ в связи с этим свойством замкнутые. 

* Если мы измеряем и получаем результат 00, то в самом простом месте сворачивается только термин, который соответствует этому результату. Это $ \алфа\кет{000} + \бета\кет{001}$. Для этого можно выполнить рефакторинг до $ \кет{00}(\алфа\кет{0} + \бета\кет{1}) $. Поэтому при измерении первого и второго кубита до 00 мы __понимаем, что третий кубит, находится__в состоянии $ (\алфа\кет{0} + \бета\кет{1}) $.
* Если мы измеряем и получаем результат 01, то переворачивание будет приводить к тому, что покидает только термины, соответствующие этому результату. Это $ \алфа\кет{011} + \бета\кет{010}$. Для этого можно выполнить рефакторинг до $ \кет{01}(\алфа\кет{1} + \бета\кет{0}) $. Поэтому, если измерение первого и второго кубита равно 01, мы __понимаем, что третий кубит, находится__в состоянии $ (\алфа\кет{1} + \бета\кет{0}) $.
* Если мы измеряем и получаем результат 10, в нем сворачивается только термин, содержащий только те термины, которые соответствуют этому результату. Это $ \алфа\кет{100}-\бета\кет{101}$. Для этого можно выполнить рефакторинг для $ \кет{10}(\алфа\кет{0}-\бета\кет{1}) $. Поэтому при измерении первого и второго кубита до 10 мы __понимаем, что третья кубит, находится__в состоянии $ (\алфа\кет{0}-\бета\кет{1}) $.
* Если мы измеряем и получаем результат 11, то в самом простом месте сворачивается только термин, который соответствует этому результату. Это $ \алфа\кет{111}-\бета\кет{110}$. Для этого можно выполнить рефакторинг для $ \кет{11}(\алфа\кет{1}-\бета\кет{0}) $. Поэтому при измерении первого и второго кубита до 11 мы __понимаем, что третья кубит, находится__в состоянии $ (\алфа\кет{1}-\бета\кет{0}) $.

### <a name="step-4-interpret-the-result"></a>Шаг 4. анализ результата

Как напоминание, исходное __сообщение__ , которое мы хотели отправить:

$ $ \кет{\пси} = \алфа\кет{0} + \бета\кет{1} $ $

Нам нужно __получить кубит в__ этом состоянии, чтобы полученное состояние было назначено. 

* Если мы измеряем и получили результат __00, третье кубит, находится__в состоянии $ (\алфа\кет{0} + \бета\кет{1}) $. Так как это __сообщение__является предполагаемым, изменения не требуются.
* Если мы измеряем и получили результат __01, третье кубит, находится__в состоянии $ (\алфа\кет{1} + \бета\кет{0}) $. Это отличается от предполагаемого __сообщения__, но применение не шлюза дает нам требуемое состояние $ (\алфа\кет{0} + \бета\кет{1}) $.
* Если мы измеряем и получили результат __10, третье кубит, находится__в состоянии $ (\алфа\кет{0}-\бета\кет{1}) $. Это отличается от предполагаемого __сообщения__, однако применение шлюза Z дает нам требуемое состояние $ (\алфа\кет{0} + \бета\кет{1}) $.
* Если мы измеряем и получили результат __11, третье кубит, находится__в состоянии $ (\алфа\кет{1}-\бета\кет{0}) $. Это отличается от предполагаемого __сообщения__, однако применение нешлюза, за которым следует шлюз Z, дает нам требуемое состояние $ (\алфа\кет{0} + \бета\кет{1}) $.

Если мы измеряем, а первый кубит — 1, то применяется вентиль Z. Если мы измеряем, а второй кубит — 1, то применяется Шлюз NOT.

### <a name="summary"></a>Сводка
Ниже приведена тактовая цепь в виде текстовых пошаговых схем, в которой реализована телефонная линия. Перемещаясь слева направо, можно увидеть следующее:
- Шаг 1. Ентанглинг __здесь__ и в __нем__ применяет шлюз хадамард и шлюз кнот.
- Шаг 2. Отправка __сообщения__ с помощью шлюза кнот и шлюза хадамард.
- Шаг 3. Получение измерения первого и второго Кубитс, __сообщения__ и __здесь__.
- Шаг 4. применение шлюза, не шлюза или Z, в зависимости от результата измерения в шаге 3.

!["Телепортируйтесь (MSG: кубит, кубит): Unit"](~/media/teleportation.svg)

## <a name="quantum-teleportation-code"></a>Номер телепередачи такта: код

У нас есть наш канал для пов тактовую транспортировку:

!["Телепортируйтесь (MSG: кубит, кубит): Unit"](~/media/teleportation.svg)

Теперь мы можем преобразовать каждый шаг в этом такте в Q #.

### <a name="step-0-definition"></a>Шаг 0. определение
При выполнении телепередачи необходимо сообщить __сообщение__ , которое мы хотим отправить, и куда мы хотим отправить его (__там__). По этой причине мы начнем с определения новой операции телепортируйтесь, которая выдает два Кубитс в качестве аргументов, `msg` и `there`:

```qsharp
operation Teleport(msg : Qubit, there : Qubit) : Unit {
```

Также необходимо выделить кубит `here`, который мы достиг `using` блока:

```qsharp
    using (here = Qubit()) {
```

### <a name="step-1-create-an-entangled-state"></a>Шаг 1. Создание состояния запутанными
Затем можно создать пару запутанными между `here` и `there` с помощью операций @"microsoft.quantum.intrinsic.h" и @"microsoft.quantum.intrinsic.cnot":

```qsharp
        H(here);
        CNOT(here, there);
```

### <a name="step-2-send-the-message"></a>Шаг 2. Отправка сообщения
Затем мы используем следующий $ \Операторнаме{кнот} $ и $H $ Гейтс, чтобы переместить сообщение кубит:

```qsharp
        CNOT(msg, here);
        H(msg);
```

### <a name="step-3--4-measuring-and-interpreting-the-result"></a>Шаг 3 & 4. измерение и анализ результата
Наконец, мы используем @"microsoft.quantum.intrinsic.m" для выполнения измерений и выполнения необходимых операций Gate для получения требуемого состояния, как показано в инструкциях `if`:

```qsharp
        // Measure out the entanglement
        if (M(msg) == One)  { Z(there); }
        if (M(here) == One) { X(there); }
```

После этого определение оператора для передачи по номеру завершится, так что мы можем освободить `here`, завершить тело и завершить операцию.

```qsharp
    }
}
```
