---
title: Квантовые симуляторы и ведущие приложения | Документация Майкрософт
description: Здесь объясняется, как с помощью классического вычислительного языка .NET можно управлять квантовыми симуляторами, как правило, C# или Q#.
author: QuantumWriter
ms.author: Alan.Geller@microsoft.com
ms.date: 12/11/2017
ms.topic: article
uid: microsoft.quantum.machines
ms.openlocfilehash: 14aed75ed0ed192f88699b1c7dbacfae23f74642
ms.sourcegitcommit: aa5e6f4a2deb4271a333d3f1b1eb69b5bb9a7bad
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/02/2019
ms.locfileid: "73442223"
---
# <a name="quantum-simulators-and-host-applications"></a>Квантовые симуляторы и ведущие приложения

## <a name="what-youll-learn"></a>Цели обучения

> [!div class="checklist"]
> * Выполнение квантовых алгоритмов
> * Какие квантовые симуляторы включены в этот выпуск
> * Как написать драйвер C# для квантового алгоритма

## <a name="the-quantum-development-kit-execution-model"></a>Модель выполнения Microsoft Quantum Development Kit

В статье о [написании первой квантовой программы](xref:microsoft.quantum.write-program) мы выполнили квантовый алгоритм, передав объект `QuantumSimulator` в метод `Run` класса алгоритма.
Класс `QuantumSimulator` выполняет квантовый алгоритм путем полного моделирования вектора квантового состояния, что идеально подходит для выполнения и тестирования `Teleport`.
Дополнительные сведения о векторах квантового состояния см. в статье [Общие сведения о квантовых вычислениях](xref:microsoft.quantum.concepts.intro).

Для запуска квантового алгоритма можно использовать другие целевые машины.
Машина выполняет реализации квантовых примитивов для алгоритма.
Сюда входят примитивные операции, такие как H, CNOT и Measure, а также управление кубитами и их отслеживание.
Разные классы квантовых машин представляют разные модели выполнения для одного и того же квантового алгоритма.

Каждый тип квантовой машины может предоставлять различные реализации этих примитивов.
Например, симулятор трассировки квантового компьютера, входящий в комплект SDK, не выполняет никакого моделирования.
Вместо этого он отслеживает использование шлюза, кубита и других ресурсов для алгоритма.

### <a name="quantum-machines"></a>Квантовые машины

В будущем мы определим дополнительные классы квантовых машин для поддержки других типов моделирования и поддержки выполнения на топологических квантовых компьютерах.
Благодаря тому, что алгоритм остается постоянным при изменяющихся базовых реализациях машины, упрощается тестирование и отладка алгоритма в моделировании, а также его запуск на реальном оборудовании. При этом вы можете быть уверены, что алгоритм не изменился.

### <a name="whats-included-in-this-release"></a>Что входит в этот выпуск

В этот выпуск Quantum Developer Kit входит несколько классов квантовых машин.
Все они определены в пространстве имен `Microsoft.Quantum.Simulation.Simulators`.

* [Полный симулятор вектора состояния](xref:microsoft.quantum.machines.full-state-simulator), класс `QuantumSimulator`.
* [Простой оценщик ресурсов](xref:microsoft.quantum.machines.resources-estimator), класс `ResourcesEstimator`, позволяет проводить анализ ресурсов верхнего уровня, необходимый для выполнения квантового алгоритма.
* [Оценщик ресурсов на основе трассировки](xref:microsoft.quantum.machines.qc-trace-simulator.intro), класс `QCTraceSimulator`, позволяет выполнять расширенный анализ потребления ресурсов для всего графа вызовов алгоритма.
* [Симулятор Тоффоли](xref:microsoft.quantum.machines.toffoli-simulator), класс `ToffoliSimulator`.

## <a name="writing-a-host-application"></a>Создание основного приложения

В статье о [написании первой квантовой программы](xref:microsoft.quantum.write-program) мы написали простой драйвер C# для алгоритма телепортирования. Драйвер C# необходим для 4 основных целей:

* создание целевой машины;
* вычисление всех аргументов для квантового алгоритма;
* запуск квантового алгоритма с помощью симулятора;
* обработка результата операции.

Здесь мы рассмотрим каждый шаг подробнее.

### <a name="constructing-the-target-machine"></a>Создание целевой машины

Квантовые машины — это экземпляры обычных классов .NET, поэтому они создаются путем вызова своего конструктора, как любой другой класс .NET.
Некоторые симуляторы, в том числе `QuantumSimulator`, реализуют интерфейс <xref:System.IDisposable?displayProperty=nameWithType> .NET и поэтому должны быть заключены в инструкцию `using` C#.

### <a name="computing-arguments-for-the-algorithm"></a>Вычисление аргументов для алгоритма

В нашем примере `Teleport` мы рассчитали некоторые относительно искусственные аргументы для передачи в квантовый алгоритм.
Тем не менее в большинстве случаев для квантового алгоритма требуется значительный объем данных. Проще всего предоставить их из классического драйвера.

Например, при выполнении химических моделирований для квантового алгоритма требуется большая таблица интегралов взаимодействия молекулярных орбиталей.
Обычно они считываются из файла, который предоставляется при выполнении алгоритма.
Так как в Q# не предусмотрен механизм доступа к файловой системе, сбор данных этого типа лучше всего выполняется с помощью классического драйвера, а затем они передаются в метод `Run` квантового алгоритма.

Классический драйвер также играет ключевую роль в вариативных методах.
В этом классе алгоритмов квантовое состояние подготавливается на основе некоторых классических параметров, и это состояние используется для расчета интересующего значения.
Параметры корректируются путем поиска восхождением к вершине или с помощью алгоритма машинного обучения, а затем квантовый алгоритм выполняется снова.
Алгоритм поиска восхождением к вершине наилучшим образом реализуется в виде сугубо классической функции, которая вызывается классическим драйвером. Результаты поиска восхождением к вершине затем передаются в следующее выполнение квантового алгоритма.

### <a name="running-the-quantum-algorithm"></a>Выполнение квантового алгоритма

Как правило, эта часть очень проста.
Каждая операция Q# компилируется в класс, предоставляющий статический метод `Run`.
Аргументы для этого метода предоставляются плоским кортежем аргументов самой операции, а также дополнительный аргумент, который является симулятором для выполнения. Для операции, которая ожидает именованный кортеж типа `(a: String, (b: Double, c: Double))`, его плоский аналог относится к типу `(String a, Double b, Double c)`.


С передачей аргументов в метод `Run` связаны определенные тонкости:

* Массивы должны быть заключены в объект `Microsoft.Quantum.Simulation.Core.QArray<T>`.
    У класса `QArray` есть конструктор, который может принимать любую упорядоченную коллекцию (`IEnumerable<T>`) соответствующих объектов.
* Пустой кортеж, `()` на языке Q#, представлен `QVoid.Instance` на языке C#.
* Непустые кортежи представлены в виде экземпляров `ValueTuple` .NET.
* Пользовательские типы Q# передаются в качестве базового типа.
* Чтобы передать операцию или функцию в метод `Run`, необходимо получить экземпляр класса операции или функции, используя метод `Get<>` симулятора.

### <a name="processing-the-results"></a>Обработка результатов

Результаты квантового алгоритма возвращаются из метода `Run`.
Метод `Run` выполняется асинхронно, поэтому возвращает экземпляр <xref:System.Threading.Tasks.Task`1>.
Получить результаты фактической операции можно несколькими способами. Самый простой способ заключается в использовании свойства[`Result`](https://docs.microsoft.com/dotnet/api/system.threading.tasks.task-1.result) `Task`.

```csharp
    var res = BellTest.Run(sim, 1000, initial).Result;
```
Но другие приемы, такие как использование метода [`Wait`](https://docs.microsoft.com/dotnet/api/system.threading.tasks.task.wait) или ключевого слова [`await`](https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/await) C# также будут работать.

Как и в случае с аргументами, кортежи Q# представляются в виде экземпляров `ValueTuple`, а массивы Q# — в виде экземпляров `QArray`.
Пользовательские типы возвращаются в качестве базового типа.
Пустой кортеж, `()`, возвращается как экземпляр класса `QVoid`.

Для получения полезных ответов при использовании многих квантовых алгоритмов требуется значительная последующая обработка.
Например, квантовая часть алгоритма Шора — это всего лишь начало вычисления, позволяющего найти факторы числа.

В большинстве случаев это самый простой способ выполнить последующую обработку такого рода в классическом драйвере.
Только классический драйвер может передавать результаты пользователю или записывать их на диск.
Классический драйвер будет иметь доступ к аналитическим библиотекам и другим математическим функциям, не представленным в Q#.


## <a name="failures"></a>Сбои

При достижении инструкции Q# `fail` во время выполнения операции создается исключение `ExecutionFailException`.

В результате использования `System.Task` в методе `Run` исключение, выдаваемое в результате выполнения инструкции `fail`, будет заключено в `System.AggregateException`.
Чтобы найти фактическую причину сбоя, необходимо выполнить итерацию в `AggregateException` 
`InnerExceptions`, например:

```csharp

            try
            {
                using(var sim = new QuantumSimulator())
                {
                    /// call your operations here...
                }
            }
            catch (AggregateException e)
            {
                // Unwrap AggregateException to get the message from Q# fail statement.
                // Go through all inner exceptions.
                foreach (Exception inner in e.InnerExceptions)
                {
                    // If the exception of type ExecutionFailException
                    if (inner is ExecutionFailException failException)
                    {
                        // Print the message it contains
                        Console.WriteLine($" {failException.Message}");
                    }
                }
            }
```

## <a name="other-classical-languages"></a>Другие классические языки

Несмотря на то что предоставленные нами примеры, написаны на языке C#, F# и Python, Quantum Development Kit также поддерживает написание классических программных приложений на других языках.
Например, если необходимо написать основную программу в Visual Basic, [вы получите корректный результат](https://github.com/tcNickolas/MiscQSharp/blob/master/Quantum_VBNet/README.md#using-q-with-visual-basic-net).
