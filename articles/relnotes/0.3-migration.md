---
title: КДК 0,3. рекомендации по миграции и проверке языка
description: 'Описание новых функций в Microsoft Quantum Development Kit 0,3 и миграция существующих программ Q #.'
author: beheim
uid: microsoft.quantum.relnotes.migration-0-3
ms.author: bettina.heim@microsoft.com
ms.date: 10/29/2018
ms.topic: article
ms.openlocfilehash: df86bf163a300c1ce55d3959bd40aea3d8b8a973
ms.sourcegitcommit: 6ccea4a2006a47569c4e2c2cb37001e132f17476
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/28/2020
ms.locfileid: "77907738"
---
# <a name="qdk-03-language-release-notes-and-migration-guide"></a><span data-ttu-id="7f0d4-103">Заметки о выпуске и инструкции по миграции для КДК 0,3</span><span class="sxs-lookup"><span data-stu-id="7f0d4-103">QDK 0.3 language release notes and migration guide</span></span>

<span data-ttu-id="7f0d4-104">Мы рады рассказать о последнем обновлении пакета средств разработки тактов.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-104">We are excited to introduce the newest update to the Quantum Development Kit.</span></span>  <span data-ttu-id="7f0d4-105">На этой странице приводятся общие сведения о новых функциях языка Q # и описано, как [перенести](#Migration) существующие программы q # в новый синтаксис.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-105">This page gives an overview of the new Q# language features and describes how to [migrate](#Migration) existing Q# programs to the new syntax.</span></span>  <span data-ttu-id="7f0d4-106">Полное [Описание языка Q](xref:microsoft.quantum.language.intro)# см. в полной документации.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-106">See our complete documentation for the full description of the Q# language [here](xref:microsoft.quantum.language.intro).</span></span>


## <a name="whats-new"></a><span data-ttu-id="7f0d4-107">What's New</span><span class="sxs-lookup"><span data-stu-id="7f0d4-107">What's New</span></span> 

<span data-ttu-id="7f0d4-108">Обновление 0,3 поставляется с набором новых функций языка и редактора.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-108">The 0.3 update comes with a range of new language and editor features.</span></span>

### <a name="overview-of-features"></a><span data-ttu-id="7f0d4-109">Общие сведения о функциях</span><span class="sxs-lookup"><span data-stu-id="7f0d4-109">Overview of Features</span></span>

- <span data-ttu-id="7f0d4-110">Улучшенная интеграция средств разработки для Visual Studio и Visual Studio Code, включая:</span><span class="sxs-lookup"><span data-stu-id="7f0d4-110">Enhanced development tool integration for Visual Studio and Visual Studio Code, including:</span></span>
    - <span data-ttu-id="7f0d4-111">Динамическая компиляция и обратная связь по*вводу (то* есть</span><span class="sxs-lookup"><span data-stu-id="7f0d4-111">Live compilation and feedback on typing (*a.k.a.*</span></span> <span data-ttu-id="7f0d4-112">Подчеркивание волнистой линией).</span><span class="sxs-lookup"><span data-stu-id="7f0d4-112">squiggly underlining).</span></span>
    - <span data-ttu-id="7f0d4-113">Сведения о наведении, включая сводки документации и подписи типов.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-113">Hover information including documentation summaries and type signatures.</span></span>
    - <span data-ttu-id="7f0d4-114">Поддержка перехода к определению.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-114">Support for go to definition.</span></span>
    - <span data-ttu-id="7f0d4-115">Простой переход к объявлениям пространств имен, операций, функций и типов.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-115">Easy navigation to namespace, operation, function, and type declarations.</span></span>
    - <span data-ttu-id="7f0d4-116">Улучшенные диагностические сообщения.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-116">Improved diagnostic messages.</span></span>
- <span data-ttu-id="7f0d4-117">Улучшения языка</span><span class="sxs-lookup"><span data-stu-id="7f0d4-117">Language improvements</span></span>
    - <span data-ttu-id="7f0d4-118">Инициализация одиночных кубит и кортежей в пределах использования и заимствования</span><span class="sxs-lookup"><span data-stu-id="7f0d4-118">Single qubit and tuple initializations within using and borrowing</span></span>
    - <span data-ttu-id="7f0d4-119">Деконструкция кортежа для всех назначений</span><span class="sxs-lookup"><span data-stu-id="7f0d4-119">Tuple deconstruction on all assignments</span></span>
    - <span data-ttu-id="7f0d4-120">Итерация по массивам</span><span class="sxs-lookup"><span data-stu-id="7f0d4-120">Iteration over arrays</span></span>
    - <span data-ttu-id="7f0d4-121">Условные выражения</span><span class="sxs-lookup"><span data-stu-id="7f0d4-121">Conditional expressions</span></span>
    - <span data-ttu-id="7f0d4-122">Сокращенное обозначение специализации для операций по умолчанию</span><span class="sxs-lookup"><span data-stu-id="7f0d4-122">Default-specialization abbreviation for operations</span></span>
    - <span data-ttu-id="7f0d4-123">Автоматически созданные конструкторы типов</span><span class="sxs-lookup"><span data-stu-id="7f0d4-123">Auto-generated type constructors</span></span>
    - <span data-ttu-id="7f0d4-124">Модификаторы выражений</span><span class="sxs-lookup"><span data-stu-id="7f0d4-124">Expression modifiers</span></span>


## <a name="editor-features"></a><span data-ttu-id="7f0d4-125">Функции редактора</span><span class="sxs-lookup"><span data-stu-id="7f0d4-125">Editor Features</span></span>

<span data-ttu-id="7f0d4-126">Пакет разработки тактов теперь включает языковой сервер для Q #, а также интеграцию клиента для Visual Studio и Visual Studio Code.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-126">The Quantum Development Kit now includes a language server for Q#, as well as the client integrations for Visual Studio and Visual Studio Code.</span></span>
<span data-ttu-id="7f0d4-127">Это позволяет использовать дополнительный набор функций IntelliSense, а также получать в реальном времени обратную связь по вводимому коду в виде волнистых линий, подчеркивающих ошибки и предупреждения.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-127">This enables a new set of IntelliSense features along with live feedback on typing in form of squiggly underlinings of errors and warnings.</span></span>
<span data-ttu-id="7f0d4-128">В частности, теперь поддерживается переход к определению, и отображаются сведения о наведении указателя, содержащие сведения о типе, а также сведения о документировании комментариев.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-128">In particular, go to definition is now supported and hover information is displayed containing type information as well as information from documenting comments.</span></span> <span data-ttu-id="7f0d4-129">Кроме того, доступны символьные сведения об определенных пространствах имен, операциях, функциях и типах, что позволяет быстро переходить к объявлениям.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-129">Additionally, symbol information about defined namespaces, operations, functions, and types is available and allows to quickly navigate to declarations.</span></span>    
<span data-ttu-id="7f0d4-130">В этом обновлении в целом значительно улучшены диагностические сообщения, упрощена навигация и указание диапазонов для диагностических и других сведений во всплывающих подсказках.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-130">This update greatly improves diagnostic messages in general, with easy navigation to and precise ranges for diagnostics and additional details in the displayed hover information.</span></span> 

<span data-ttu-id="7f0d4-131">Для этого выпуска 0,3 языковой сервер, входящий в состав пакета средств разработки тактовой задержки, не поддерживает несколько рабочих областей.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-131">For this 0.3 release, the language server included with the Quantum Development Kit does not support multiple workspaces.</span></span>
<span data-ttu-id="7f0d4-132">Чтобы работать с проектом в VS Code, откройте корневую папку, содержащую сам проект, и все проекты, на которые имеются ссылки.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-132">In order to work with a project in VS Code, open the root folder containing the project itself and all referenced projects.</span></span>
<span data-ttu-id="7f0d4-133">Для работы с решением в Visual Studio все проекты, включенные в решение, нужно разместить в той же папке, что и решение, или в одной из вложенных в нее папок.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-133">In order to work with a solution in Visual Studio, all projects contained in the solution need to be in the same folder as the solution or in one of its subfolders.</span></span>

## <a name="language-features"></a><span data-ttu-id="7f0d4-134">Языковые возможности</span><span class="sxs-lookup"><span data-stu-id="7f0d4-134">Language Features</span></span>

<span data-ttu-id="7f0d4-135">С точки зрения языковых возможностей это обновление объединяет обработку различных языковых шаблонов.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-135">In terms of language features, this update unifies the treatment of a range of language patterns.</span></span>
<span data-ttu-id="7f0d4-136">В качестве примера конструкторы типов создаются для каждого определяемого пользователем типа и могут быть частично применены во многом подобно любой другой функции.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-136">Type constructors, as an example, are generated for each user defined type and can be partially applied much like any other function.</span></span>
<span data-ttu-id="7f0d4-137">Еще один пример — деконструкция кортежа, которая теперь полностью поддерживается во всех назначениях.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-137">Another example is tuple deconstruction, which is now fully supported within all assignments.</span></span> <span data-ttu-id="7f0d4-138">Сюда входят не только операторы let, mutable и Set, но и переменная итерации в for-loops, а также использование и освобождение ресурсов.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-138">This includes not only let-, mutable-, and set-statements, but also the iteration variable in for-loops as well as using- and borrowing-allocations.</span></span> <span data-ttu-id="7f0d4-139">Кроме того, частичные деконструкции поддерживаются только при обновлении 0,3. знаки подчеркивания в деконструкциях указывают на части значения, которые должны игнорироваться.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-139">Additionally, partial deconstructions are newly supported with the 0.3 update; underscores in deconstructions indicate parts of the value that are to be ignored.</span></span> 

<span data-ttu-id="7f0d4-140">В следующем коде показаны некоторые из новых возможностей.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-140">The following code illustrates some of the new features:</span></span>
```qsharp
    let tuples = [(1, 0), (0, 1)];
    mutable res = (0, 0, 0);

    // For-loops can iterate over arrays, and can destructure tuples.
    for ((i1, i2) in tuples) {

        // Mutable assignments can now destructure and ignore parts of tuples,
        // using the same syntax as let-bindings.
        mutable (r1, r2, _) = res;
        set (r1, r2) = (r1 ||| i1, r2 &&& i2);

        let (_, _, s) = res;
        // The new conditional operator can be used inside expressions, avoiding
        // the need for extraneous if-statements.
        set res = (r1, r2, r1 == r2 ? s | s + 1);
    }
```
<span data-ttu-id="7f0d4-141">В последнем операторе Set используется новый оператор ternary, представленный в обновлении 0,3 для поддержки условных выражений.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-141">The last set statement uses a new ternary operator that is introduced with the 0.3 update to support conditional expressions.</span></span>
<span data-ttu-id="7f0d4-142">Условное выражение является выражением формы `condition ? caseTrue | caseFalse`.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-142">A conditional expression is an expression of the form `condition ? caseTrue | caseFalse`.</span></span>
<span data-ttu-id="7f0d4-143">Как видно из приведенного выше примера, теперь также поддерживается итерация по массивам.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-143">As can be seen from the example above, iteration over arrays is now also supported.</span></span>

<span data-ttu-id="7f0d4-144">Выделения в `using` и `borrowing` доступны только для отдельных Кубитс, кубит массивов и вложенных кортежей.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-144">Allocations within `using` and `borrowing` are newly possible for single qubits, qubit arrays, and nested tuples thereof:</span></span>
```qsharp
    using (qubit = Qubit()) {
        // qubit contains a single qubit
    }

    borrowing ((qubits, qubit) = (Qubit[3], Qubit())) {
        // qubits contains an array of three qubits, and qubit contains a single qubit
    }
```

<span data-ttu-id="7f0d4-145">В дополнение к `auto` введены две новые директивы генератора специализации `invert` и `distribute`, чтобы усилить контроль над тем, как создаются специализации функтор.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-145">Two new specialization generator directives `invert` and `distribute` in addition to `auto` are introduced to increase control over how functor specializations are generated.</span></span>
<span data-ttu-id="7f0d4-146">Явное объявление специализации `body` по умолчанию в операциях больше не является обязательным.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-146">An explicit declaration of the default `body` specialization within operations is no longer mandatory.</span></span>
<span data-ttu-id="7f0d4-147">Аналогично функциям, инструкции могут быть непосредственно добавлены в объявление операции, если в операции не объявлена другая специализация.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-147">Similar to functions, statements may be directly added to the operation declaration itself if no other specialization is declared within the operation.</span></span>
<span data-ttu-id="7f0d4-148">Скрипт миграции включен в выпуск, чтобы упростить перенос существующего кода и воспользоваться преимуществами новых языковых функций (см. [раздел о сценарии миграции](#MigrationScript)).</span><span class="sxs-lookup"><span data-stu-id="7f0d4-148">A migration script is included in the release to help migrating existing code and taking advantage of new language features (see the [section on the migration script](#MigrationScript)).</span></span>

<span data-ttu-id="7f0d4-149">Основное изменение в том, как обрабатываются определяемые пользователем типы, входит в состав обновления 0,3.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-149">A major change in how user-defined types are treated comes with the 0.3 update.</span></span> <span data-ttu-id="7f0d4-150">Хотя предыдущие выпуски обрабатывают определяемые пользователем типы как подтипы базового типа, это больше не происходит (см. также [раздел об критических изменениях](#BreakingChanges)).</span><span class="sxs-lookup"><span data-stu-id="7f0d4-150">While prior releases treated user defined types as subtypes of their underlying type, this is no longer the case going forward (see also the [section on breaking changes](#BreakingChanges)).</span></span>  
<span data-ttu-id="7f0d4-151">В рамках этого изменения мы представляем модификаторы выражений, которые можно применить к определенным выражениям.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-151">As part of this change we introduce expression modifiers that can be applied to certain expressions.</span></span> <span data-ttu-id="7f0d4-152">Выражения "Atomic", к которым могут применяться модификаторы, — это идентификаторы, выражения элементов массива и кортежи с арностью 1.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-152">The "atomic" expressions that modifiers can be applied to are identifiers, array item expressions, and arity-1 tuples.</span></span>
<span data-ttu-id="7f0d4-153">Модификаторы привязываются к тесному, чем `)``(` к любому другому выражению объединения.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-153">Modifiers bind tighter than any other expression combinator, and in particular tighter than the call-expression combinator `(` `)`.</span></span> 
<span data-ttu-id="7f0d4-154">`Adjoint`, `Controlled`и новый постфиксный оператор "Unwrap" `!` обрабатываются как модификаторы выражений.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-154">`Adjoint`, `Controlled`, and a new "unwrap" postfix operator `!` are treated as expression modifiers.</span></span> <span data-ttu-id="7f0d4-155">Рассмотрение `Adjoint` и `Controlled` в качестве модификаторов выражений устраняет необходимость в круглых скобках для многих случаев.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-155">Treating `Adjoint` and `Controlled` as expression modifiers eliminates the need for parenthesis for a lot of cases.</span></span> <span data-ttu-id="7f0d4-156">Приведенные ниже выражения для примера являются допустимыми для `Op`, отдельной операции, `opArr` массива операций и `arg` подходящего аргумента:</span><span class="sxs-lookup"><span data-stu-id="7f0d4-156">The expressions below for example are valid going forward for `Op`, a unitary operation, `opArr` an array of unitary operations, and `arg` a suitable argument:</span></span> 
```qsharp
    Adjoint Op (arg);
    Controlled opArr[i] (arg);
```
<span data-ttu-id="7f0d4-157">Сценарий миграции удалит большую часть ненужных скобок и будет использовать все преимущества новых функций.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-157">The migration script will drop most of the unnecessary parenthesis and take full advantage of the new features.</span></span> <span data-ttu-id="7f0d4-158">Однако следует иметь в виду, что сценарий не интерпретирует код и не будет учитывать различные интерпретации `Controlled` функтор в редких случаях (только в сочетании с частичными приложениями).</span><span class="sxs-lookup"><span data-stu-id="7f0d4-158">However, be advised that the script does not interpret the code, and will not account for the different interpretation of the `Controlled` functor in rare cases (only relevant in combination with partial applications).</span></span>

<span data-ttu-id="7f0d4-159">Модификатор new `!` приводит определяемый пользователем тип к его базовому типу.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-159">The new modifier `!` casts a user-defined type to its underlying type.</span></span> <span data-ttu-id="7f0d4-160">Это приведение рассматривалось в предыдущих выпусках и было выполнено автоматически.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-160">This cast has been considered an upcast in previous releases and was executed automatically.</span></span> <span data-ttu-id="7f0d4-161">С новой интерпретацией определяемых пользователем типов это больше не так, а приведение необходимо сделать явным.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-161">With the new interpretation of user defined types this is no longer the case and the cast needs to be made explicit.</span></span>    
<span data-ttu-id="7f0d4-162">В следующем примере показано, как использовать модификатор new:</span><span class="sxs-lookup"><span data-stu-id="7f0d4-162">The following example illustrates how to use the new modifier:</span></span> 
```qsharp
    newtype Unitary = (Qubit => Unit: Adjoint, Controlled);

    operation Foo (unitaries : Unitary[], qubit : Qubit) : Unit {

        for (unitary in unitaries[1 .. Length(unitaries)-1]) {
            // Each element of unitaries is an instance of the user-defined
            // type Unitary, so unitary! unwraps each element to an operation
            // type that we can call.
            unitary! (qubit);
            // The unwrap operator can also be used as a part of functor
            // expressions and when indexing into arrays.
            Adjoint unitary! (qubit);
            Adjoint unitaries[0]! (qubit);
        }
    }
```
<span data-ttu-id="7f0d4-163">Как видно из примера, `!` привязывается теснее модификаторов префикса, таких как `Controlled` и `Adjoint`.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-163">As can be seen from the example, `!` binds tighter than prefix modifiers, like `Controlled` and `Adjoint`.</span></span>

## <a name="BreakingChanges"></a><span data-ttu-id="7f0d4-164">Критические изменения</span><span class="sxs-lookup"><span data-stu-id="7f0d4-164">Breaking Changes</span></span> 

<span data-ttu-id="7f0d4-165">Обновление 0,3 поставляется с новым компилятором и содержит несколько критических изменений.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-165">The 0.3 update comes with a new compiler and contains a handful of breaking changes.</span></span>
<span data-ttu-id="7f0d4-166">Чтобы упростить обновление существующего кода, компилятор также предоставляет параметр форматирования, который компилирует допустимый или недопустимый код и выдает форматированный код Q # на основе построенной компиляции.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-166">To facilitate updating existing code, the compiler also provides a formatting option that compiles valid or invalid code and emits formatted Q# code based on the built compilation.</span></span>
<span data-ttu-id="7f0d4-167">Все изменения синтаксиса будут обработаны автоматически предоставленным средством.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-167">All syntax changes will be processed automatically by the provided tool.</span></span> <span data-ttu-id="7f0d4-168">Однако изменения в способе интерпретации допустимого кода (семантические изменения), возможно, потребуется выполнить вручную.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-168">However, changes in how valid code is interpreted (semantic changes) may need to be made manually.</span></span> 

<span data-ttu-id="7f0d4-169">В дополнение к приведенным ниже изменениям шаблон `__*__`, где \* — любая последовательность символов, отличных от пробела, зарезервирована для внутреннего использования и не может использоваться в качестве имени символа.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-169">In addition to the changes listed below, the pattern `__*__` where \* is any sequence of non-whitespace characters is reserved for internal use and cannot be used as a symbol name.</span></span>  

## <a name="syntax-changes"></a><span data-ttu-id="7f0d4-170">Изменения синтаксиса</span><span class="sxs-lookup"><span data-stu-id="7f0d4-170">Syntax Changes</span></span> 

- <span data-ttu-id="7f0d4-171">Начиная с версии 0,3 элементы массива больше не разделяются точкой с запятой, а вместо них разделяются запятыми.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-171">Starting with the version 0.3, array items are no longer separated by semicolons, but are separated by commas instead.</span></span>
- <span data-ttu-id="7f0d4-172">После директивы автоматического формирования для объявлений специализации требуется точка с запятой.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-172">A semicolon on the other hand is required after an auto-generation directive for specialization declarations.</span></span>
- <span data-ttu-id="7f0d4-173">Условия в if-, elif-и until-предложениях должны быть заключены в круглые скобки.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-173">Conditions in if-, elif-, and until-clauses need to be encapsulated in parenthesis.</span></span> 

<span data-ttu-id="7f0d4-174">Для всех других изменений синтаксиса компилятор просто создает предупреждение, если используется старый синтаксис.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-174">For all other syntax changes the compiler will simply generate a warning if the old syntax is used.</span></span>     
<span data-ttu-id="7f0d4-175">Одним из примеров такого изменения является кортеж символов в пользовательских специализациях.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-175">One example for such a change is the symbol tuple in user-defined specializations.</span></span> <span data-ttu-id="7f0d4-176">В предыдущих версиях управляемое или управляемое объявление специализации задается с помощью одного аргумента символа, начиная с 0,3. рекомендуется предоставить такой кортеж символов для всей специализации с `...`, указывающей, что компилятор должен переносить символы из вызываемого объявления при необходимости.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-176">While in previous releases a controlled or controlled-adjoint specialization declaration specified a single symbol argument, starting in 0.3 it is encouraged to provide such a symbol tuple for all specialization with `...` indicating that the compiler should migrate the symbols from the callable declaration if needed.</span></span> 

## <a name="semantic-changes"></a><span data-ttu-id="7f0d4-177">Семантические изменения</span><span class="sxs-lookup"><span data-stu-id="7f0d4-177">Semantic Changes</span></span> 

<span data-ttu-id="7f0d4-178">Самым значительным нарушением в выпуске 0,3 является то, как определяемые пользователем типы интегрируются в систему типов.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-178">The most impactful breaking for the 0.3 release is how user-defined types are integrated into the type system.</span></span> <span data-ttu-id="7f0d4-179">В предыдущих выпусках пользовательские типы рассматривались как подтипы их базового типа.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-179">In prior releases user defined types were considered to be a subtype of their underlying type.</span></span> <span data-ttu-id="7f0d4-180">В этом выпуске это больше не так.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-180">With this release and going forward this is no longer the case.</span></span> <span data-ttu-id="7f0d4-181">Определяемые пользователем типы теперь считаются собственными отдельными типами и не имеют автоматического приведения между определяемым пользователем типом и базовым типом.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-181">User defined types are now considered to be their own distinct type, and no automatic cast between a user defined type and its underlying type exists.</span></span> <span data-ttu-id="7f0d4-182">Все приведения должны быть явными с помощью оператора "Unwrap" `!`, а для доступа к содержимому объекта определяемого пользователем типа требуется приведение.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-182">All casts need to be made explicit via an "unwrap" operator `!`, and a cast is needed in particular to access the content of a object of user defined type.</span></span>  

<span data-ttu-id="7f0d4-183">Изменения системы типов также включают в себя поведение массивов и обработку параметризованных объектов типа.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-183">The modifications to the type system also include the variance behavior of arrays, and the treatment of type parameterized objects.</span></span> <span data-ttu-id="7f0d4-184">Начиная с 0,3, изменяемые и неизменяемые массивы являются инвариантными.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-184">Starting in 0.3, both mutable and immutable arrays are invariant.</span></span> <span data-ttu-id="7f0d4-185">Кроме того, аргументы, передаваемые в вызываемый метод, не могут быть параметризованы.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-185">Additionally, arguments passed to a callable cannot be type parameterized.</span></span> <span data-ttu-id="7f0d4-186">В этих случаях аргументы типа должны передаваться вместе с идентификатором.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-186">In these cases, type arguments must be passed along with the identifer.</span></span>

<span data-ttu-id="7f0d4-187">Предыдущие выпуски компилятора Q # позволяли указывать значение функции там, где ожидалось значение операции, при условии, что значение функции имеет правильные входные и выходные типы.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-187">Previous releases of the Q# compiler allowed a function value to be provided where an operation value was expected, as long as the function value had the correct input and output types.</span></span> <span data-ttu-id="7f0d4-188">Это было непреднамеренное поведение, которое не указано в спецификации языка Q #.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-188">This was unintended behavior that is not specified in the Q# language specification.</span></span>
<span data-ttu-id="7f0d4-189">В компиляторе 0,3 мы удалили это поведение, чтобы значения функций больше не рассматривались как значения операций.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-189">In the 0.3 compiler, we have removed this behavior so that function values are no longer considered operation values.</span></span>
<span data-ttu-id="7f0d4-190">Чтобы минимизировать перерыв в работе существующего кода, основанного на этой ошибке, мы добавили функцию Туператион в пространство имен Microsoft. тактов. Canon, которое явно преобразует функцию в операцию с теми же типами входных и выходных данных.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-190">To minimize the disruption to existing code that relied on this bug, we have added the ToOperation function in the Microsoft.Quantum.Canon namespace that will explicitly convert a function into an operation with the same input and output types.</span></span>

<span data-ttu-id="7f0d4-191">В следующем примере показано, как использовать функцию `ToOperation`, чтобы изменить `Square` функции на `op`операции.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-191">The following example illustrates how to use the `ToOperation` function to change a function `Square` to an operation `op`:</span></span> 
```qsharp
namespace Microsoft.Quantum.Tests {
    open Microsoft.Quantum.Primitive;
    open Microsoft.Quantum.Canon;

    function Square(x : Int) : Int {
        return x * x;
    }

    operation ApplyOp<'T, 'U>(op : ('T => 'U), input : 'T) : 'U {
        return op(input);
    }

    operation ToOperationTest() : Unit {
        let op = ToOperation(Square);
        AssertIntEqual(ApplyOp(op, 3), 9, "ToOperation failed with Square.");
    }
}
```

## <a name="requirements"></a><span data-ttu-id="7f0d4-192">Требования</span><span class="sxs-lookup"><span data-stu-id="7f0d4-192">Requirements</span></span> 

<span data-ttu-id="7f0d4-193">Выпуск поддерживается в Visual Studio 2017 версии 15,8 или более поздней для Windows 10, а также на Visual Studio Code версии 1.27.2 или более поздней для Windows 10, macOS и Linux.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-193">The release is supported on Visual Studio 2017 version 15.8 or later for Windows 10, and on Visual Studio Code version 1.27.2 or later for Windows 10, macOS, and Linux.</span></span>

<span data-ttu-id="7f0d4-194">В пакете разработки тактов используется пакет SDK для .NET Core (2,0 или более поздней версии).</span><span class="sxs-lookup"><span data-stu-id="7f0d4-194">The Quantum Development Kit uses the .NET Core SDK (2.0 or later).</span></span>

## <a name="installation"></a><span data-ttu-id="7f0d4-195">Установка</span><span class="sxs-lookup"><span data-stu-id="7f0d4-195">Installation</span></span>  

<span data-ttu-id="7f0d4-196">Следуйте инструкциям по установке [здесь](../install-guide/index.md).</span><span class="sxs-lookup"><span data-stu-id="7f0d4-196">Follow the installation instructions [here](../install-guide/index.md).</span></span>

<span data-ttu-id="7f0d4-197">Могут появиться предупреждения ("обнаружены конфликты между разными версиями" System. Reflection. Metadata ", которые не удалось разрешить)"), если текущая версия пакет SDK для .NET Core не актуальна.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-197">You may see warnings ("Found conflicts between different versions of "System.Reflection.Metadata" that could not be resolved.") if your current version of .NET Core SDK is not up to date.</span></span>  <span data-ttu-id="7f0d4-198">Однако при использовании пакет SDK для .NET Core (2,0 или более поздней версии) эти предупреждения можно игнорировать.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-198">However, if you are using .NET Core SDK (2.0 or later), these warnings may be ignored.</span></span>


- <span data-ttu-id="7f0d4-199">Выпуск предоставляется вместе с несколькими различными примерами, показывающими, как использовать как существующие функции пакета разработки такта, так и новые функции, доступные в этом выпуске.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-199">The release is provided along with a number of different samples showing how to use both existing features of the Quantum Development Kit, and the new features available with this release.</span></span> <span data-ttu-id="7f0d4-200">Эти примеры можно найти на сайте GitHub в репозитории [Microsoft/такта](https://github.com/Microsoft/Quantum) .</span><span class="sxs-lookup"><span data-stu-id="7f0d4-200">These samples can be can be found on GitHub at the [Microsoft/Quantum](https://github.com/Microsoft/Quantum) repository.</span></span>


## <a name="Migration"></a><span data-ttu-id="7f0d4-201">Перенос существующих проектов в Q # 0,3</span><span class="sxs-lookup"><span data-stu-id="7f0d4-201">Migrating Existing Projects to Q# 0.3</span></span> 

<span data-ttu-id="7f0d4-202">Если у вас есть проекты Q # с версии 0,2 пакета средств разработки тактов, выполните следующие действия для переноса этих проектов в последнюю версию.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-202">If you have existing Q# projects from version 0.2 of the Quantum Development Kit, the following are the steps to migrate those projects to the newest version.</span></span> <span data-ttu-id="7f0d4-203">Мы также предоставляем [сценарий миграции](#MigrationScript) , который поможет вам в процессе.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-203">We also provide a [migration script](#MigrationScript) to help you with the process.</span></span>

> [!NOTE]
> <span data-ttu-id="7f0d4-204">Проекты необходимо обновлять по порядку.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-204">Projects need to be upgraded in order.</span></span> <span data-ttu-id="7f0d4-205">Если имеется решение с несколькими проектами, обновите каждый проект в том порядке, в котором они указываются.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-205">If you have a solution with multiple projects update each project in the order they are referenced.</span></span>


1. <span data-ttu-id="7f0d4-206">В командной строке запустите `dotnet clean`, чтобы удалить все существующие двоичные файлы и промежуточные данные.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-206">From a command line, Run `dotnet clean` to remove all existing binaries and intermediate files.</span></span>
2. <span data-ttu-id="7f0d4-207">В текстовом редакторе измените CSPROJ-файл, чтобы изменить версию всех `PackageReference` Microsoft. тактов до версии 0.3.1811.2802-Preview, например:</span><span class="sxs-lookup"><span data-stu-id="7f0d4-207">In a text editor, edit the .csproj file to change the version of all the "Microsoft.Quantum" `PackageReference` to version 0.3.1811.2802-preview, for example:</span></span>
```xml
    <PackageReference Include="Microsoft.Quantum.Canon" Version="0.3.1811.2802" />
    <PackageReference Include="Microsoft.Quantum.Development.Kit" Version="0.3.1811.2802" />
```
4. <span data-ttu-id="7f0d4-208">В командной строке используйте средство форматирования, интегрированное в компилятор командной строки, чтобы устранить все изменения синтаксиса, выполнив следующую команду: `dotnet msbuild /t:qsharpformat`</span><span class="sxs-lookup"><span data-stu-id="7f0d4-208">From the command line, use the formatting tool integrated into the command line compiler to address all syntax changes by running this command: `dotnet msbuild /t:qsharpformat`</span></span>  
    - <span data-ttu-id="7f0d4-209">Файлы будут перенесены на месте.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-209">Your files will be migrated in-place.</span></span> <span data-ttu-id="7f0d4-210">Резервная копия всех исходных файлов будет скопирована в `obj\qsharp\.backup`</span><span class="sxs-lookup"><span data-stu-id="7f0d4-210">A backup of all the original files will be copied to `obj\qsharp\.backup`</span></span>
    - <span data-ttu-id="7f0d4-211">Средство форматирования компилирует проект, игнорируя все ошибки компиляции, и создаст форматированный код Q # на основе компиляции сборки.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-211">The formatting tool will compile the project ignoring all compilation errors and generate formatted Q# code based on the build compilation.</span></span> 
       <span data-ttu-id="7f0d4-212">Любой нераспознанный символ (например, неопределенное имя переменной) будет заменен замещающим текстом, который необходимо заменить вручную после форматирования.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-212">Any unrecognized symbol (e.g. an undefined variable name) will be replaced by a placeholder text that needs to be replaced manually after formatting.</span></span> <span data-ttu-id="7f0d4-213">В этом случае форматирование будет выполняться при формировании предупреждения для затронутого файла.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-213">In this case, the formatting succeeds while generating a warning for the affected file.</span></span>     
    - <span data-ttu-id="7f0d4-214">Форматирование и, в частности, любые пробелы в файле будут изменены в созданном коде.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-214">The formatting and in particular any white space in the file will be changed in the emitted code.</span></span> <span data-ttu-id="7f0d4-215">Комментарии будут сохранены.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-215">Comments will be preserved.</span></span>   
5. <span data-ttu-id="7f0d4-216">После выполнения этого может потребоваться вручную устранить семантические изменения в случаях, когда Семантическая Интерпретация кода изменилась.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-216">After running this, you might still need to manually address semantic changes in cases where the semantic interpretation of the code has changed.</span></span> <span data-ttu-id="7f0d4-217">Все эти ошибки будут сообщать IntelliSense в Visual Studio или Visual Studio Code.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-217">All these errors will be reported by IntelliSense in Visual Studio or Visual Studio Code.</span></span>
    - <span data-ttu-id="7f0d4-218">Откройте корневую папку проекта или содержащего решение в Visual Studio 2017 или Visual Studio Code.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-218">Open the root folder of the project or the containing solution in Visual Studio 2017 or Visual Studio Code.</span></span>
    - <span data-ttu-id="7f0d4-219">Открыв в редакторе QS-файл, вы увидите выходные данные расширения языка Q# в окне вывода.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-219">After opening a .qs file in the editor, you should see the output of the Q# language extension in the output window.</span></span>
    - <span data-ttu-id="7f0d4-220">После успешной загрузки проекта (отображается в окне вывода) откройте каждый файл и вручную устраните все сохранившиеся проблемы.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-220">After the project has loaded successfully (indicated in the output window) open each file and manually to address all remaining issues.</span></span>


> [!NOTE]
> * <span data-ttu-id="7f0d4-221">Для выпуска 0,3 языковой сервер, входящий в состав пакета средств разработки тактовой задержки, не поддерживает несколько рабочих областей.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-221">For the 0.3 release, the language server included with the Quantum Development Kit does not support multiple workspaces.</span></span>
> * <span data-ttu-id="7f0d4-222">Чтобы работать с проектом в Visual Studio Code, откройте корневую папку с самим проектом и всеми проектами, на которые он ссылается.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-222">In order to work with a project in Visual Studio Code, open the root folder containing the project itself and all referenced projects.</span></span>   
> * <span data-ttu-id="7f0d4-223">Для работы с решением в Visual Studio все проекты, включенные в решение, нужно разместить в той же папке, что и решение, или в одной из вложенных в нее папок.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-223">In order to work with a solution in Visual Studio, all projects contained in the solution need to be in the same folder as the solution or in one of its subfolders.</span></span>  
> * <span data-ttu-id="7f0d4-224">Ссылки между проектами, перенесенными в 0,3 и более поздние версии, и проекты с более старыми версиями пакетов **не** поддерживаются.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-224">References between projects migrated to 0.3 and higher and projects using older package versions are **not** supported.</span></span>




## <a name="MigrationScript"></a><span data-ttu-id="7f0d4-225">Скрипт миграции</span><span class="sxs-lookup"><span data-stu-id="7f0d4-225">Migration script</span></span> 

<span data-ttu-id="7f0d4-226">Для упрощения миграции проектов предоставляется сценарий PowerShell, который можно скачать [здесь](https://raw.githubusercontent.com/Microsoft/Quantum/release/v0.3.1810/utilities/qdk-migrate.ps1).</span><span class="sxs-lookup"><span data-stu-id="7f0d4-226">In order to facilitate project migration, a PowerShell script is provided that can be downloaded [here](https://raw.githubusercontent.com/Microsoft/Quantum/release/v0.3.1810/utilities/qdk-migrate.ps1).</span></span>
<span data-ttu-id="7f0d4-227">Этот сценарий помогает перенести проекты с версии 0,2 пакета средств разработки тактов для использования версии 0,3.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-227">This script helps migrate projects from version 0.2 of the Quantum Development Kit to use version 0.3.</span></span>

> [!NOTE]
> <span data-ttu-id="7f0d4-228">Для выполнения сценария миграции требуется Windows PowerShell или PowerShell Core.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-228">The migration script requires Windows PowerShell or PowerShell Core to run.</span></span>
> <span data-ttu-id="7f0d4-229">Windows PowerShell устанавливается вместе с Windows 10.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-229">Windows PowerShell comes pre-installed with Windows 10.</span></span>
> <span data-ttu-id="7f0d4-230">Скачайте PowerShell Core для Windows, macOS или Linux по адресу https://github.com/PowerShell/PowerShell.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-230">Download PowerShell Core for Windows, macOS, or Linux at https://github.com/PowerShell/PowerShell.</span></span>

<span data-ttu-id="7f0d4-231">Сценарий выполняет следующие четыре шага:</span><span class="sxs-lookup"><span data-stu-id="7f0d4-231">The script executes the following four steps:</span></span>

- <span data-ttu-id="7f0d4-232">Проект создается с использованием предыдущей версии пакета средств разработки такта, чтобы обеспечить успешную миграцию.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-232">The project is built with the previous version of the Quantum Development Kit to ensure that migration is likely to succeed.</span></span> <span data-ttu-id="7f0d4-233">Этот шаг можно пропустить с помощью параметра `-Force` скрипта.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-233">This step can be skipped by using the `-Force` parameter to the script.</span></span>
- <span data-ttu-id="7f0d4-234">Будут установлены новые шаблоны проектов.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-234">New project templates are installed.</span></span>
- <span data-ttu-id="7f0d4-235">Проект будет обновлен для использования текущей версии пакета средств разработки тактов.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-235">The project is updated to use the current version of the Quantum Development Kit.</span></span>
- <span data-ttu-id="7f0d4-236">Средство форматирования, входящее в пакет SDK для версии 0,3, применяется для автоматического устранения большинства критических изменений, описанных выше.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-236">The formatting tool provided with version 0.3 of the Quantum Development Kit is applied to automatically address most of the breaking changes documented above.</span></span>

<span data-ttu-id="7f0d4-237">После выполнения этих четырех шагов могут возникнуть другие проблемы с миграцией, которые необходимо обработать вручную.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-237">After these four steps complete, there may be some remaining migration issues which must be handled manually.</span></span>
<span data-ttu-id="7f0d4-238">Использование последней версии расширений пакета разработки тактов для Visual Studio 2017 и Visual Studio Code может помочь легко найти эти проблемы.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-238">Using the latest version of the Quantum Development Kit extensions for Visual Studio 2017 and Visual Studio Code can help find these issues easily.</span></span>

<span data-ttu-id="7f0d4-239">Документацию по сценарию можно получить, выполнив одну из следующих команд в папке, в которой находится сценарий:</span><span class="sxs-lookup"><span data-stu-id="7f0d4-239">The documentation for the script can be obtained by running one of the following commands in the folder where the script is located:</span></span>

```powershell
Get-Help ./qdk-migrate.ps1
Get-Help -Online ./qdk-migrate.ps1
```

> [!NOTE]
> <span data-ttu-id="7f0d4-240">По умолчанию Windows предотвращает выполнение скриптов в качестве меры безопасности.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-240">By default, Windows prevents the execution of any scripts as a security measure.</span></span>
> <span data-ttu-id="7f0d4-241">Чтобы разрешить выполнение сценариев, таких как `qdk-migrate.ps1`, в Windows, может потребоваться изменить политику выполнения.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-241">To allow scripts such as `qdk-migrate.ps1` to run on Windows, you may need to change the execution policy.</span></span>
> <span data-ttu-id="7f0d4-242">Для этого выполните команду `Set-ExecutionPolicy`.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-242">To do so, run the `Set-ExecutionPolicy` command:</span></span>
> ```powershell
> Set-ExecutionPolicy RemoteSigned -Scope Process
> ```
> <span data-ttu-id="7f0d4-243">После выхода из PowerShell политика выполнения будет возвращена.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-243">The execution policy will then be reverted when you exit PowerShell.</span></span>
> <span data-ttu-id="7f0d4-244">Если вы хотите сохранить политику выполнения, используйте другое значение для `-Scope`.</span><span class="sxs-lookup"><span data-stu-id="7f0d4-244">If you would like to save the execution policy, use a different value for `-Scope`:</span></span>
> ```powershell
> Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
> ```

