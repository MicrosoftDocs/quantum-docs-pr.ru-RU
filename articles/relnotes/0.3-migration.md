---
title: КДК 0,3. рекомендации по миграции и проверке языка
description: 'Описание новых функций в Microsoft Quantum Development Kit 0,3 и миграция существующих программ Q #.'
author: beheim
uid: microsoft.quantum.relnotes.migration-0-3
ms.author: bettina.heim@microsoft.com
ms.date: 10/29/2018
ms.topic: article
ms.openlocfilehash: df86bf163a300c1ce55d3959bd40aea3d8b8a973
ms.sourcegitcommit: 6ccea4a2006a47569c4e2c2cb37001e132f17476
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/28/2020
ms.locfileid: "77907738"
---
# <a name="qdk-03-language-release-notes-and-migration-guide"></a>Заметки о выпуске и инструкции по миграции для КДК 0,3

Мы рады рассказать о последнем обновлении пакета средств разработки тактов.  На этой странице приводятся общие сведения о новых функциях языка Q # и описано, как [перенести](#Migration) существующие программы q # в новый синтаксис.  Полное [Описание языка Q](xref:microsoft.quantum.language.intro)# см. в полной документации.


## <a name="whats-new"></a>What's New 

Обновление 0,3 поставляется с набором новых функций языка и редактора.

### <a name="overview-of-features"></a>Общие сведения о функциях

- Улучшенная интеграция средств разработки для Visual Studio и Visual Studio Code, включая:
    - Динамическая компиляция и обратная связь по*вводу (то* есть Подчеркивание волнистой линией).
    - Сведения о наведении, включая сводки документации и подписи типов.
    - Поддержка перехода к определению.
    - Простой переход к объявлениям пространств имен, операций, функций и типов.
    - Улучшенные диагностические сообщения.
- Улучшения языка
    - Инициализация одиночных кубит и кортежей в пределах использования и заимствования
    - Деконструкция кортежа для всех назначений
    - Итерация по массивам
    - Условные выражения
    - Сокращенное обозначение специализации для операций по умолчанию
    - Автоматически созданные конструкторы типов
    - Модификаторы выражений


## <a name="editor-features"></a>Функции редактора

Пакет разработки тактов теперь включает языковой сервер для Q #, а также интеграцию клиента для Visual Studio и Visual Studio Code.
Это позволяет использовать дополнительный набор функций IntelliSense, а также получать в реальном времени обратную связь по вводимому коду в виде волнистых линий, подчеркивающих ошибки и предупреждения.
В частности, теперь поддерживается переход к определению, и отображаются сведения о наведении указателя, содержащие сведения о типе, а также сведения о документировании комментариев. Кроме того, доступны символьные сведения об определенных пространствах имен, операциях, функциях и типах, что позволяет быстро переходить к объявлениям.    
В этом обновлении в целом значительно улучшены диагностические сообщения, упрощена навигация и указание диапазонов для диагностических и других сведений во всплывающих подсказках. 

Для этого выпуска 0,3 языковой сервер, входящий в состав пакета средств разработки тактовой задержки, не поддерживает несколько рабочих областей.
Чтобы работать с проектом в VS Code, откройте корневую папку, содержащую сам проект, и все проекты, на которые имеются ссылки.
Для работы с решением в Visual Studio все проекты, включенные в решение, нужно разместить в той же папке, что и решение, или в одной из вложенных в нее папок.

## <a name="language-features"></a>Языковые возможности

С точки зрения языковых возможностей это обновление объединяет обработку различных языковых шаблонов.
В качестве примера конструкторы типов создаются для каждого определяемого пользователем типа и могут быть частично применены во многом подобно любой другой функции.
Еще один пример — деконструкция кортежа, которая теперь полностью поддерживается во всех назначениях. Сюда входят не только операторы let, mutable и Set, но и переменная итерации в for-loops, а также использование и освобождение ресурсов. Кроме того, частичные деконструкции поддерживаются только при обновлении 0,3. знаки подчеркивания в деконструкциях указывают на части значения, которые должны игнорироваться. 

В следующем коде показаны некоторые из новых возможностей.
```qsharp
    let tuples = [(1, 0), (0, 1)];
    mutable res = (0, 0, 0);

    // For-loops can iterate over arrays, and can destructure tuples.
    for ((i1, i2) in tuples) {

        // Mutable assignments can now destructure and ignore parts of tuples,
        // using the same syntax as let-bindings.
        mutable (r1, r2, _) = res;
        set (r1, r2) = (r1 ||| i1, r2 &&& i2);

        let (_, _, s) = res;
        // The new conditional operator can be used inside expressions, avoiding
        // the need for extraneous if-statements.
        set res = (r1, r2, r1 == r2 ? s | s + 1);
    }
```
В последнем операторе Set используется новый оператор ternary, представленный в обновлении 0,3 для поддержки условных выражений.
Условное выражение является выражением формы `condition ? caseTrue | caseFalse`.
Как видно из приведенного выше примера, теперь также поддерживается итерация по массивам.

Выделения в `using` и `borrowing` доступны только для отдельных Кубитс, кубит массивов и вложенных кортежей.
```qsharp
    using (qubit = Qubit()) {
        // qubit contains a single qubit
    }

    borrowing ((qubits, qubit) = (Qubit[3], Qubit())) {
        // qubits contains an array of three qubits, and qubit contains a single qubit
    }
```

В дополнение к `auto` введены две новые директивы генератора специализации `invert` и `distribute`, чтобы усилить контроль над тем, как создаются специализации функтор.
Явное объявление специализации `body` по умолчанию в операциях больше не является обязательным.
Аналогично функциям, инструкции могут быть непосредственно добавлены в объявление операции, если в операции не объявлена другая специализация.
Скрипт миграции включен в выпуск, чтобы упростить перенос существующего кода и воспользоваться преимуществами новых языковых функций (см. [раздел о сценарии миграции](#MigrationScript)).

Основное изменение в том, как обрабатываются определяемые пользователем типы, входит в состав обновления 0,3. Хотя предыдущие выпуски обрабатывают определяемые пользователем типы как подтипы базового типа, это больше не происходит (см. также [раздел об критических изменениях](#BreakingChanges)).  
В рамках этого изменения мы представляем модификаторы выражений, которые можно применить к определенным выражениям. Выражения "Atomic", к которым могут применяться модификаторы, — это идентификаторы, выражения элементов массива и кортежи с арностью 1.
Модификаторы привязываются к тесному, чем `)``(` к любому другому выражению объединения. 
`Adjoint`, `Controlled`и новый постфиксный оператор "Unwrap" `!` обрабатываются как модификаторы выражений. Рассмотрение `Adjoint` и `Controlled` в качестве модификаторов выражений устраняет необходимость в круглых скобках для многих случаев. Приведенные ниже выражения для примера являются допустимыми для `Op`, отдельной операции, `opArr` массива операций и `arg` подходящего аргумента: 
```qsharp
    Adjoint Op (arg);
    Controlled opArr[i] (arg);
```
Сценарий миграции удалит большую часть ненужных скобок и будет использовать все преимущества новых функций. Однако следует иметь в виду, что сценарий не интерпретирует код и не будет учитывать различные интерпретации `Controlled` функтор в редких случаях (только в сочетании с частичными приложениями).

Модификатор new `!` приводит определяемый пользователем тип к его базовому типу. Это приведение рассматривалось в предыдущих выпусках и было выполнено автоматически. С новой интерпретацией определяемых пользователем типов это больше не так, а приведение необходимо сделать явным.    
В следующем примере показано, как использовать модификатор new: 
```qsharp
    newtype Unitary = (Qubit => Unit: Adjoint, Controlled);

    operation Foo (unitaries : Unitary[], qubit : Qubit) : Unit {

        for (unitary in unitaries[1 .. Length(unitaries)-1]) {
            // Each element of unitaries is an instance of the user-defined
            // type Unitary, so unitary! unwraps each element to an operation
            // type that we can call.
            unitary! (qubit);
            // The unwrap operator can also be used as a part of functor
            // expressions and when indexing into arrays.
            Adjoint unitary! (qubit);
            Adjoint unitaries[0]! (qubit);
        }
    }
```
Как видно из примера, `!` привязывается теснее модификаторов префикса, таких как `Controlled` и `Adjoint`.

## <a name="BreakingChanges"></a>Критические изменения 

Обновление 0,3 поставляется с новым компилятором и содержит несколько критических изменений.
Чтобы упростить обновление существующего кода, компилятор также предоставляет параметр форматирования, который компилирует допустимый или недопустимый код и выдает форматированный код Q # на основе построенной компиляции.
Все изменения синтаксиса будут обработаны автоматически предоставленным средством. Однако изменения в способе интерпретации допустимого кода (семантические изменения), возможно, потребуется выполнить вручную. 

В дополнение к приведенным ниже изменениям шаблон `__*__`, где * — любая последовательность символов, отличных от пробела, зарезервирована для внутреннего использования и не может использоваться в качестве имени символа.  

## <a name="syntax-changes"></a>Изменения синтаксиса 

- Начиная с версии 0,3 элементы массива больше не разделяются точкой с запятой, а вместо них разделяются запятыми.
- После директивы автоматического формирования для объявлений специализации требуется точка с запятой.
- Условия в if-, elif-и until-предложениях должны быть заключены в круглые скобки. 

Для всех других изменений синтаксиса компилятор просто создает предупреждение, если используется старый синтаксис.     
Одним из примеров такого изменения является кортеж символов в пользовательских специализациях. В предыдущих версиях управляемое или управляемое объявление специализации задается с помощью одного аргумента символа, начиная с 0,3. рекомендуется предоставить такой кортеж символов для всей специализации с `...`, указывающей, что компилятор должен переносить символы из вызываемого объявления при необходимости. 

## <a name="semantic-changes"></a>Семантические изменения 

Самым значительным нарушением в выпуске 0,3 является то, как определяемые пользователем типы интегрируются в систему типов. В предыдущих выпусках пользовательские типы рассматривались как подтипы их базового типа. В этом выпуске это больше не так. Определяемые пользователем типы теперь считаются собственными отдельными типами и не имеют автоматического приведения между определяемым пользователем типом и базовым типом. Все приведения должны быть явными с помощью оператора "Unwrap" `!`, а для доступа к содержимому объекта определяемого пользователем типа требуется приведение.  

Изменения системы типов также включают в себя поведение массивов и обработку параметризованных объектов типа. Начиная с 0,3, изменяемые и неизменяемые массивы являются инвариантными. Кроме того, аргументы, передаваемые в вызываемый метод, не могут быть параметризованы. В этих случаях аргументы типа должны передаваться вместе с идентификатором.

Предыдущие выпуски компилятора Q # позволяли указывать значение функции там, где ожидалось значение операции, при условии, что значение функции имеет правильные входные и выходные типы. Это было непреднамеренное поведение, которое не указано в спецификации языка Q #.
В компиляторе 0,3 мы удалили это поведение, чтобы значения функций больше не рассматривались как значения операций.
Чтобы минимизировать перерыв в работе существующего кода, основанного на этой ошибке, мы добавили функцию Туператион в пространство имен Microsoft. тактов. Canon, которое явно преобразует функцию в операцию с теми же типами входных и выходных данных.

В следующем примере показано, как использовать функцию `ToOperation`, чтобы изменить `Square` функции на `op`операции. 
```qsharp
namespace Microsoft.Quantum.Tests {
    open Microsoft.Quantum.Primitive;
    open Microsoft.Quantum.Canon;

    function Square(x : Int) : Int {
        return x * x;
    }

    operation ApplyOp<'T, 'U>(op : ('T => 'U), input : 'T) : 'U {
        return op(input);
    }

    operation ToOperationTest() : Unit {
        let op = ToOperation(Square);
        AssertIntEqual(ApplyOp(op, 3), 9, "ToOperation failed with Square.");
    }
}
```

## <a name="requirements"></a>Требования 

Выпуск поддерживается в Visual Studio 2017 версии 15,8 или более поздней для Windows 10, а также на Visual Studio Code версии 1.27.2 или более поздней для Windows 10, macOS и Linux.

В пакете разработки тактов используется пакет SDK для .NET Core (2,0 или более поздней версии).

## <a name="installation"></a>Установка  

Следуйте инструкциям по установке [здесь](../install-guide/index.md).

Могут появиться предупреждения ("обнаружены конфликты между разными версиями" System. Reflection. Metadata ", которые не удалось разрешить)"), если текущая версия пакет SDK для .NET Core не актуальна.  Однако при использовании пакет SDK для .NET Core (2,0 или более поздней версии) эти предупреждения можно игнорировать.


- Выпуск предоставляется вместе с несколькими различными примерами, показывающими, как использовать как существующие функции пакета разработки такта, так и новые функции, доступные в этом выпуске. Эти примеры можно найти на сайте GitHub в репозитории [Microsoft/такта](https://github.com/Microsoft/Quantum) .


## <a name="Migration"></a>Перенос существующих проектов в Q # 0,3 

Если у вас есть проекты Q # с версии 0,2 пакета средств разработки тактов, выполните следующие действия для переноса этих проектов в последнюю версию. Мы также предоставляем [сценарий миграции](#MigrationScript) , который поможет вам в процессе.

> [!NOTE]
> Проекты необходимо обновлять по порядку. Если имеется решение с несколькими проектами, обновите каждый проект в том порядке, в котором они указываются.


1. В командной строке запустите `dotnet clean`, чтобы удалить все существующие двоичные файлы и промежуточные данные.
2. В текстовом редакторе измените CSPROJ-файл, чтобы изменить версию всех `PackageReference` Microsoft. тактов до версии 0.3.1811.2802-Preview, например:
```xml
    <PackageReference Include="Microsoft.Quantum.Canon" Version="0.3.1811.2802" />
    <PackageReference Include="Microsoft.Quantum.Development.Kit" Version="0.3.1811.2802" />
```
4. В командной строке используйте средство форматирования, интегрированное в компилятор командной строки, чтобы устранить все изменения синтаксиса, выполнив следующую команду: `dotnet msbuild /t:qsharpformat`  
    - Файлы будут перенесены на месте. Резервная копия всех исходных файлов будет скопирована в `obj\qsharp\.backup`
    - Средство форматирования компилирует проект, игнорируя все ошибки компиляции, и создаст форматированный код Q # на основе компиляции сборки. 
       Любой нераспознанный символ (например, неопределенное имя переменной) будет заменен замещающим текстом, который необходимо заменить вручную после форматирования. В этом случае форматирование будет выполняться при формировании предупреждения для затронутого файла.     
    - Форматирование и, в частности, любые пробелы в файле будут изменены в созданном коде. Комментарии будут сохранены.   
5. После выполнения этого может потребоваться вручную устранить семантические изменения в случаях, когда Семантическая Интерпретация кода изменилась. Все эти ошибки будут сообщать IntelliSense в Visual Studio или Visual Studio Code.
    - Откройте корневую папку проекта или содержащего решение в Visual Studio 2017 или Visual Studio Code.
    - Открыв в редакторе QS-файл, вы увидите выходные данные расширения языка Q# в окне вывода.
    - После успешной загрузки проекта (отображается в окне вывода) откройте каждый файл и вручную устраните все сохранившиеся проблемы.


> [!NOTE]
> * Для выпуска 0,3 языковой сервер, входящий в состав пакета средств разработки тактовой задержки, не поддерживает несколько рабочих областей.
> * Чтобы работать с проектом в Visual Studio Code, откройте корневую папку с самим проектом и всеми проектами, на которые он ссылается.   
> * Для работы с решением в Visual Studio все проекты, включенные в решение, нужно разместить в той же папке, что и решение, или в одной из вложенных в нее папок.  
> * Ссылки между проектами, перенесенными в 0,3 и более поздние версии, и проекты с более старыми версиями пакетов **не** поддерживаются.




## <a name="MigrationScript"></a>Скрипт миграции 

Для упрощения миграции проектов предоставляется сценарий PowerShell, который можно скачать [здесь](https://raw.githubusercontent.com/Microsoft/Quantum/release/v0.3.1810/utilities/qdk-migrate.ps1).
Этот сценарий помогает перенести проекты с версии 0,2 пакета средств разработки тактов для использования версии 0,3.

> [!NOTE]
> Для выполнения сценария миграции требуется Windows PowerShell или PowerShell Core.
> Windows PowerShell устанавливается вместе с Windows 10.
> Скачайте PowerShell Core для Windows, macOS или Linux по адресу https://github.com/PowerShell/PowerShell.

Сценарий выполняет следующие четыре шага:

- Проект создается с использованием предыдущей версии пакета средств разработки такта, чтобы обеспечить успешную миграцию. Этот шаг можно пропустить с помощью параметра `-Force` скрипта.
- Будут установлены новые шаблоны проектов.
- Проект будет обновлен для использования текущей версии пакета средств разработки тактов.
- Средство форматирования, входящее в пакет SDK для версии 0,3, применяется для автоматического устранения большинства критических изменений, описанных выше.

После выполнения этих четырех шагов могут возникнуть другие проблемы с миграцией, которые необходимо обработать вручную.
Использование последней версии расширений пакета разработки тактов для Visual Studio 2017 и Visual Studio Code может помочь легко найти эти проблемы.

Документацию по сценарию можно получить, выполнив одну из следующих команд в папке, в которой находится сценарий:

```powershell
Get-Help ./qdk-migrate.ps1
Get-Help -Online ./qdk-migrate.ps1
```

> [!NOTE]
> По умолчанию Windows предотвращает выполнение скриптов в качестве меры безопасности.
> Чтобы разрешить выполнение сценариев, таких как `qdk-migrate.ps1`, в Windows, может потребоваться изменить политику выполнения.
> Для этого выполните команду `Set-ExecutionPolicy`.
> ```powershell
> Set-ExecutionPolicy RemoteSigned -Scope Process
> ```
> После выхода из PowerShell политика выполнения будет возвращена.
> Если вы хотите сохранить политику выполнения, используйте другое значение для `-Scope`.
> ```powershell
> Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
> ```

