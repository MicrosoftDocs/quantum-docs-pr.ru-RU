---
title: Операции и функции в Q#
description: Определение и вызов операций и функций, а также управляемых и примыкающих специализаций операций.
author: gillenhaalb
ms.author: a-gibec@microsoft.com
ms.date: 03/05/2020
ms.topic: article
uid: microsoft.quantum.guide.operationsfunctions
no-loc:
- Q#
- $$v
ms.openlocfilehash: c2ce999ea2a0fe7204f402fedb4cd3a3c15bd44b
ms.sourcegitcommit: 8256ff463eb9319f1933820a36c0838cf1e024e8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/17/2020
ms.locfileid: "90759430"
---
# <a name="operations-and-functions-in-no-locq"></a>Операции и функции в Q#

## <a name="defining-new-operations"></a>Определение новых операций

Операции являются ядром Q# .
После объявления их можно вызывать из классических приложений .NET, например с помощью симулятора или других операций в Q# .
Каждая операция, определенная в Q# , может вызывать любое количество других операций, включая встроенные внутренние операции, определенные в языке. Конкретный способ, который Q# определяет эти внутренние операции, зависит от целевого компьютера.
При компиляции каждая операция представляется как тип класса .NET, который можно предоставить целевым компьютерам.

Каждый Q# исходный файл может определять любое количество операций.
Имена операций должны быть уникальными в пределах пространства имен и не могут конфликтовать с именами типа или функции.

Объявление операции состоит из ключевого слова `operation` , за которым следует символ, который представляет собой имя операции, кортеж типизированного идентификатора, определяющий аргументы для операции, двоеточие `:` , аннотацию типа, которая описывает тип результата операции, при необходимости заметку с характеристиками операции, открывающую фигурную скобку, а затем текст объявления операции, заключенный в фигурные скобки `{ }` .

Каждая операция принимает входные данные, создает выход и задает реализацию для одной или нескольких специализаций операций.
Возможные специализации, а также способы их определения и вызова описаны в различных разделах этой статьи.
Сейчас рассмотрим следующую операцию, которая определяет только специализацию тела по умолчанию и принимает одну кубит в качестве входных данных, а затем вызывает встроенную <xref:microsoft.quantum.intrinsic.x> операцию над этими входными данными:

```qsharp
operation BitFlip(target : Qubit) : Unit {
    X(target);
}
```

Ключевое слово `operation` начинается с определения операции, за которым следует имя; здесь, `BitFlip` .
Затем тип входных данных определяется ( `Qubit` ) вместе с именем, `target` для ссылки на входные данные в новой операции.
Наконец, `Unit` определяет, что выходные данные операции пусты.
`Unit` используется аналогично `void` в C# и других императивных языках и эквивалентен `unit` в F # и других функциональных языках.

Операции также могут возвращать более интересные типы `Unit` , чем.
Например, <xref:microsoft.quantum.intrinsic.m> операция возвращает выходные данные типа `Result` , представляющие выполнение измерения.  Его можно передать из операции в другую операцию или использовать с `let` ключевым словом для определения новой переменной.

Такой подход позволяет представить классические вычисления, взаимодействующие с операциями тактов на низком уровне, например в очень [плотной кодировке](https://github.com/microsoft/QuantumKatas/tree/main/SuperdenseCoding):

```qsharp
operation DecodeSuperdense(here : Qubit, there : Qubit) : (Result, Result) {

    CNOT(there, here);
    H(there);

    let firstBit = M(there);
    let secondBit = M(here);

    return (firstBit, secondBit);
}
```

> [!NOTE]
> Каждая операция Q# принимает ровно один вход и возвращает ровно один выход.
> Несколько входов и выходов представлены с помощью *кортежей*, которые собираются несколько значений вместе в одно значение.
> В этом отношении Q# — это «кортеж-в кортеже».
> После этой концепции набор пустых круглых скобок, `()` должен считаться пустым кортежем, который имеет тип `Unit` .

## <a name="controlled-and-adjoint-operations"></a>Контролируемые и смежные операции

Если операция реализует единое преобразование, как в случае многих операций в Q# , то можно определить, как работает операция при *аджоинтед* или *управлении*. В *примыкающей* специализации операции указывается, как действует "Инверсия" операции, а *управляемая* Специализация определяет, как работает операция, когда ее приложение записывается в состояние конкретного регистра такта.

Аджоинтсие операций с тактами крайне важно для многих аспектов тактовых вычислений. Пример одной из таких ситуаций, обсуждаемой наряду с полезным Q# методом программирования, см. в разделе [лиц](#conjugations) в этой статье. 

Управляемая версия операции — это новая операция, которая фактически применяет базовую операцию только в том случае, если все элементы управления Кубитс находятся в указанном состоянии.
Если элемент управления Кубитс в самом положении, то базовая операция применяется к соответствующей части детального размещения.
Поэтому управляемые операции часто используются для создания замкнутые.

Естественно, также может существовать *управляемая примыкающая* специализация, указывающая управляемое приложение для примыкающей операции.

> [!NOTE]
> Если $U $ является единым преобразованием, реализованным операцией `U` , то `Adjoint U` представляет собой единое преобразование $U ^ \дагжер $, которое является комплексно-сопряженным преобразованием.
> Успешное применение операции, а затем ее примыкающая к состоянию оставляет состояние без изменений, как показано на тот факт, что $UU ^ \дагжер = U ^ \дагжер U = \ид $, матрица Identity.
> Единое представление управляемой операции немного сложнее, но дополнительные сведения см. в разделе [концепции тактовых вычислений: несколько Кубитс](xref:microsoft.quantum.concepts.multiple-qubits).

В следующем разделе описывается вызов этих различных специализаций в Q# коде и определение операций для их поддержки.

### <a name="calling-operation-specializations"></a>Действия при вызове специализаций операций

*Функтор* в Q# — это фабрика, которая определяет новую операцию на основе другой операции.
Два стандартных операторов в Q# — `Adjoint` и `Controlled` .

Операторов имеет доступ к реализации базовой операции при определении реализации новой операции.
Таким же операторов может выполнять более сложные функции, чем традиционные функции более высокого уровня. Операторов не имеют представления в Q# системе типов. Таким образом, сейчас невозможно привязать их к переменной или передать в качестве аргументов. 

Используйте функтор, применив его к операции, которая возвращает новую операцию.
Например, применение `Adjoint` функтор к `Y` операции возвращает новую операцию `Adjoint Y` . Новую операцию можно вызвать, как и любые другие операции.
Чтобы операция поддерживала приложение `Adjoint` или `Controlled` операторов, ее тип возвращаемого значения обязательно должен быть `Unit` . 

#### <a name="adjoint-functor"></a>`Adjoint` Функтор

Таким же действие `Adjoint Y(q1)` применяет `Adjoint` функтор к `Y` операции для создания новой операции и применяет эту новую операцию к `q1` .
Новая операция имеет ту же сигнатуру и тип, что и базовая операция `Y` .
В частности, новая операция также поддерживает и `Adjoint` поддерживает `Controlled` только в том случае, если базовая операция выполнена.
`Adjoint`Функтор является собственным инверсией, то есть всегда совпадает с `Adjoint Adjoint Op` `Op` .

#### <a name="controlled-functor"></a>`Controlled` Функтор

Аналогично, `Controlled X(controls, target)` применяет `Controlled` функтор к `X` операции для создания новой операции и применяет эту новую операцию к `controls` и `target` .

> [!NOTE]
> В Q# контролируемые версии всегда принимают массив элементов управления Кубитс, и управление всегда основано на всех элементах управления Кубитс, находящихся в состоянии вычисления ( `PauliZ` ) `One` , $ \кет {1} $.
> Управление на основе других состояний достигается путем применения соответствующей единой операции к элементу управления, Кубитс перед управляемой операцией, и последующего применения обратной операции после выполнения операции.
> Например, применение `X` операции к элементу управления, кубит до и после управляемой операции, приводит к тому, что операция управляет `Zero` состоянием ($ \кет {0} $) для этого кубит; применение `H` операции до и после элементов управления в `PauliX` `One` состоянии, то есть-1 еиженвалуе Паули X, $ \кет {-} \масрел{: =} (\кет {0} -\кет {1} )/\скрт {2} $, а не `PauliZ` `One` состояния.

При наличии выражения операции можно сформировать новое выражение операции с помощью `Controlled` функтор.
Сигнатура новой операции основана на сигнатуре исходной операции.
Тип результата такой же, но тип входных данных — это кортеж с массивом кубит, содержащий элемент управления кубит в качестве первого элемента и аргументы исходной операции в качестве второго элемента.
Новая операция поддерживает и `Controlled` будет поддерживать `Adjoint` только в том случае, если была выполнена исходная операция.

Если исходная операция заняла только один аргумент, то здесь поступает [эквивалентность одноэлементного кортежа](xref:microsoft.quantum.guide.types) .
Например, `Controlled X` является управляемой версией `X` операции. 
`X` имеет тип `(Qubit => Unit is Adj + Ctl)` , поэтому `Controlled X` имеет тип `((Qubit[], (Qubit)) => Unit is Adj + Ctl)` ; из-за равенства одноэлементных кортежей это то же самое, что `((Qubit[], Qubit) => Unit is Adj + Ctl)` .

Если базовая операция заняла несколько аргументов, не забудьте заключить соответствующие аргументы управляемой версии операции в круглые скобки, чтобы преобразовать их в кортеж.
Например, `Controlled Rz` является управляемой версией `Rz` операции. 
`Rz` имеет тип `((Double, Qubit) => Unit is Adj + Ctl)` , поэтому `Controlled Rz` имеет тип `((Qubit[], (Double, Qubit)) => Unit is Adj + Ctl)` .
Таким образом, будет `Controlled Rz(controls, (0.1, target))` допустимым вызовом `Controlled Rz` (Обратите внимание на круглые скобки `0.1, target` ).

В качестве другого примера `CNOT(control, target)` можно реализовать как `Controlled X([control], target)` . Если целевой объект должен управляться двумя элементами управления Кубитс (ККНОТ), используйте `Controlled X([control1, control2], target)` инструкцию.

#### `Controlled Adjoint` 

`Controlled`И `Adjoint` операторов работы, поэтому нет никакой разницы между применением `Controlled Adjoint Op` или `Adjoint Controlled Op` .


## <a name="defining-controlled-and-adjoint-implementations"></a>Определение управляемых и смежных реализаций

В объявлении первой операции в предыдущих примерах операции `BitFlip` и `DecodeSuperdense` были определены с помощью сигнатур `(Qubit => Unit)` и `((Qubit, Qubit) => (Result, Result))` соответственно.
Как `DecodeSuperdense` и в случае с измерениями, это не единая операция, поэтому не может существовать ни управляемая несмежная специализация (отозвать связанное требование, возвращаемое операцией `Unit` ).
Однако, как `BitFlip` просто выполняет единую <xref:microsoft.quantum.intrinsic.x> операцию, вы могли бы определить ее с обеими специализациями.

В этом разделе подробно описано, как включить существование специализаций в Q# объявлениях операций, таким образом давая им возможность вызывать в сочетании с параметром `Adjoint` или `Controlled` операторов.
Дополнительные сведения о некоторых ситуациях, в которых он является допустимым или недопустимым для объявления определенных специализаций, см. в разделе [условия для правильного определения специализаций](#circumstances-for-validly-defining-specializations) в этой статье.

Характеристики операции определяют типы операторов, которые можно применить к объявленной операции, и их воздействие. Существование этих специализаций можно объявить как часть сигнатуры операции, в частности через заметку с характеристиками операции: `is Adj` , `is Ctl` или `is Adj + Ctl` .
Фактическая реализация каждой специализации *может быть либо явно,* либо *явно* определена.

### <a name="implicitly-specifying-implementations"></a>Неявное указание реализаций

В этом случае тело объявления операции состоит только из реализации по умолчанию. Пример:

```qsharp
operation PrepareEntangledPair(here : Qubit, there : Qubit) : Unit 
is Adj + Ctl { // implies the existence of an adjoint, a controlled, and a controlled adjoint specialization
    H(here);
    CNOT(here, there);
}
```
В этом случае соответствующая реализация для каждой такой неявно объявленной специализации автоматически создается компилятором, который будет выполняться при `Adjoint` использовании или `Controlled` операторов.

Таким образом, вызов будет приводить к тому, что `Adjoint PrepareEntangledPair` компилятор реализует смежную часть `CNOT` , а затем прилегающая `H` .
Эти отдельные операции являются самостоятельными, поэтому итоговая `Adjoint PrepareEntangledPair` операция будет просто состоять из применения, `CNOT(here, there)` а затем `H(here)` .
Таким образом, вы можете использовать его для записи `DecodeSuperdense` в предыдущем примере более компактно, используя смежную часть `PrepareEntangledPair` для преобразования состояния запутанными обратно в унентанглед пару Кубитс:

```qsharp
operation DecodeSuperdense(here : Qubit, there : Qubit) : (Result, Result) {
    Adjoint PrepareEntangledPair(there, here);

    let firstBit = M(there);
    let secondBit = M(here);

    return (firstBit, secondBit);
}
```

Заметка с характеристиками операций в объявлении полезна для того, чтобы компилятор создавал на основе реализации по умолчанию другие специализации. 

При проектировании операций для использования с операторов необходимо учитывать ряд важных ограничений.
Как правило, специализации для операции, которая использует выходное значение любой другой операции, *не могут* быть созданы компилятором автоматически, так как это неоднозначно, как изменить порядок инструкций в такой операции, чтобы получить такой же результат.

Таким образом, часто бывает полезно явно указывать различные реализации.

### <a name="explicitly-specifying-implementations"></a>Явное указание реализаций

Если компилятор не может создать реализацию, можно указать его явным образом. Такие явные объявления специализации могут состоять из подходящей *директивы создания* или определяемой пользователем реализации.
Ниже приведен полный спектр возможностей, а также некоторые примеры явной специализации. 


#### <a name="explicit-specialization-declarations"></a>Явные объявления специализации

Q# операции могут содержать следующие явные объявления специализации:

- В `body` специализации указывается реализация операции без применения операторов.
- В `adjoint` специализации указывается реализация операции с `Adjoint` примененным функтор.
- В `controlled` специализации указывается реализация операции с `Controlled` примененным функтор.
- `controlled adjoint`Специализация задает реализацию операции с `Adjoint` `Controlled` примененными к и операторов.
  Эту специализацию также можно присвоить имя `adjoint controlled` , так как две операторов работы.


Специализация операции состоит из тега специализации (например, `body` или), `adjoint` за которым следует одно из следующих:

- Явное объявление, как описано в следующем примере.
- *Директива* , сообщающая компилятору, *как* создать специализацию, одним из следующих:
  - `intrinsic`, что указывает на то, что целевой компьютер предоставляет специализацию.
  - `distribute`, используемый с `controlled` `controlled adjoint` специализациями и.
    При использовании с параметр указывает на то `controlled` , что компилятор должен вычислить специализацию, применяя `Controlled` ко всем операциям в `body` .
    При использовании с параметр указывает на то `controlled adjoint` , что компилятор должен вычислить специализацию, применяя `Controlled` ко всем операциям в `adjoint` специализации.
  - `invert`, который указывает, что компилятор должен вычислить `adjoint` специализацию путем инвертирования `body` , например для реверсирования порядка операций и применения прилегающих к каждому из них.
    Если используется с `adjoint controlled` , это означает, что компилятор должен вычислить специализацию путем инвертирования `controlled` специализации.
  - `self`, чтобы указать, что прилегающий специализации совпадает с `body` специализацией.
    Использование `self` является допустимым для `adjoint` `adjoint controlled` специализаций и.
    Для `adjoint controlled` , `self` предполагает, что `adjoint controlled` специализация является той же, что и `controlled` специализация.
  - `auto`, чтобы указать, что компилятор должен выбрать соответствующую директиву для применения.
    Нельзя использовать `auto` для `body` специализации.

Для директив и `auto` ALL требуется закрывающая точка с запятой `;` .
`auto`Директива разрешается в следующую созданную директиву, если предоставлено явное объявление объекта `body` .

- `adjoint`Специализация создается в соответствии с директивой `invert` .
- `controlled`Специализация создается в соответствии с директивой `distribute` .
- `adjoint controlled`Специализация создается в соответствии с директивой `invert` , если явное объявление для задано `controlled` , но не для `adjoint` , и `distribute` в противном случае.

> [!TIP]   
> Если операция является самопримыкающей, явно укажите либо примыкающую, либо управляемую смежную специализацию с помощью директивы поколения, `self` чтобы компилятор использовал эту информацию в целях оптимизации.

Объявление специализации, содержащее определяемую пользователем реализацию, состоит из кортежа аргументов, за которым следует блок операторов с Q# кодом, реализующим специализацию.
В списке arguments `...` используется для представления аргументов, объявленных для операции в целом.
Для `body` и `adjoint` список аргументов всегда должен иметь значение `(...)` ; для `controlled` и `adjoint controlled` список аргументов должен быть символом, представляющим массив элементов управления Кубитс, за которым следует `...` ключ, заключенный в круглые скобки, например `(controls,...)` .

### <a name="examples"></a>Примеры

Объявление операции может быть простым, как показано ниже, которое определяет операцию примитива Паули X:

```qsharp
operation X (qubit : Qubit) : Unit
is Adj + Ctl {
    body intrinsic;
    adjoint self;
}
```
Обратите внимание, что смежная операция Паули X определяется с помощью директивы, `self` так как по определению `X` является обратным.

В предыдущем `PrepareEntangledPair` примере код эквивалентен следующему коду, содержащему явные объявления специализации: 

```qsharp
operation PrepareEntangledPair(here : Qubit, there : Qubit) : Unit 
is Ctl + Adj {
    body (...) { // default body specialization
        H(here);
        CNOT(here, there);
    }

    adjoint auto; // auto-generate adjoint specialization
    controlled auto; // auto-generate controlled specialization
    controlled adjoint auto; // auto-generate controlled adjoint specialization
}
```
Ключевое слово `auto` указывает, что компилятор должен определить, как создать реализацию специализации.

#### <a name="user-defined-specialization-implementation"></a>Реализация пользовательской специализации

Если компилятор не может автоматически создать реализацию для определенной специализации или если может быть предоставлена более эффективная реализация, можно вручную определить реализацию.

```qsharp
operation PrepareEntangledPair(here : Qubit, there : Qubit) : Unit
is Ctl + Adj {
    body (...) { // default body specialization
        H(here);
        CNOT(here, there);
    }

    controlled (cs, ...) { // user-defined implementation for the controlled specialization
        Controlled H(cs, here);
        Controlled X(cs + [here], there);
    }

    adjoint invert; 
    controlled adjoint invert; 
}
```
В предыдущем примере `adjoint invert;` указывает, что примыкающая специализация должна быть создана путем инвертирования реализации тела, и `controlled adjoint invert;` указывает, что управляемая примыкающая специализация должна создаваться путем инвертирования заданной реализации управляемой специализации.

Если необходимо явно объявить одну или несколько специализаций, кроме тела по умолчанию, то реализация тела по умолчанию должна быть заключена в подходящее объявление специализации:

```qsharp
operation CountOnes(qubits: Qubit[]) : Int {

    body (...) // default body specialization
    {
        mutable n = 0;
        for (qubit in qubits) {
            set n += M(q) == One ? 1 | 0;
        }
        return n;
    }

    ...
```

### <a name="circumstances-for-validly-defining-specializations"></a>Условия для корректного определения специализаций

#### <a name="operation-declarations-with-adjointcontrolled"></a>Объявления операций с примыкающими и управляемыми данными

Допускается указание операции без смежных или контролируемых версий. Например, операции измерения не имеют ни одного из них, так как они не являются обратимыми или управляемыми.

Операция поддерживает `Adjoint` и операторов, `Controlled` если ее объявление содержит неявное или неявное объявление соответствующих специализаций.

Явная объявленная специализация с прилегающая, управляемой, подразумевает наличие примыкающей или управляемой специализации. 

Для операции, текст которой содержит циклы повторения, инструкции SET, измерения, операторы Return или вызовы других операций, которые не поддерживают `Adjoint` функтор, автоматическое создание примыкающей специализации, следующей за `invert` директивой или, невозможно `auto` .

Для операции, текст которой содержит вызовы других операций, не поддерживающих `Controlled` функтор, автоматическое создание управляемой специализации, следующей за `distribute` директивой или, невозможно `auto` .

#### <a name="controlled-adjoint"></a>Управляемый соседний

Управляемая смежная версия операции указывает, как реализовать управляемую тактом версию примыкающей операции.
Допускается указание операции без управляемой примыкающей версии; Например, операции измерения не имеют контролируемой версии, так как они не являются управляемыми и необратимыми.

Управляемая примыкающая специализация для операции должна существовать только в том случае, если существует и смежная, и управляемая специализация. В этом случае определяется существование управляемой примыкающей специализации. Если реализация не определена явно, то компиляция создает соответствующую специализацию.

Для операции, тело которой содержит вызовы других операций, не имеющих управляемой примыкающей версии, автоматическое создание примыкающей специализации, следующей за `invert` `distribute` директивой, или, невозможно `auto` .


### <a name="type-compatibility"></a>Совместимость типов

Используйте операцию с дополнительным операторов в любом месте, где используется операция с меньшим числом операторов, но с одинаковой сигнатурой. Например, используйте операцию типа в `(Qubit => Unit is Adj)` любом месте, где используется операция типа `(Qubit => Unit)` .

Q# является *ковариантным* по отношению к вызываемым возвращаемым типам: вызываемый метод, возвращающий тип, `'A` совместим с вызываемым с тем же входным типом и типом результата, совместимым с `'A` .

Q# является *контравариантным* по отношению к типам входных данных: вызываемый тип, который принимает в `'A` качестве входных данных, совместим с вызываемым с тем же типом результата и типом входных данных, совместимым с `'A` .

Это имеет значение, учитывая следующие определения:

```qsharp
operation Invert(qubits : Qubit[]) : Unit 
is Adj {...} 

operation ApplyUnitary(qubits : Qubit[]) : Unit 
is Adj + Ctl {...} 

function ConjugateInvertWith(
    inner : (Qubit[] => Unit is Adj),
    outer : (Qubit[] => Unit is Adj))
: (Qubit[] => Unit is Adj) {...}

function ConjugateUnitaryWith(
    inner : (Qubit[] => Unit is Adj + Ctl),
    outer : (Qubit[] => Unit is Adj))
: (Qubit[] => Unit is Adj + Ctl) {...}
```

Вы можете

- Вызовите функцию `ConjugateInvertWith` с `inner` аргументом либо `Invert` или `ApplyUnitary` .
- Вызовите функцию `ConjugateUnitaryWith` с `inner` аргументом `ApplyUnitary` , но не `Invert` .
- Возврат значения типа `(Qubit[] => Unit is Adj + Ctl)` из `ConjugateInvertWith` .

> [!IMPORTANT]
> Q# 0,3 представил существенную разницу в поведении определяемых пользователем типов.

Определяемые пользователем типы обрабатываются как упакованная версия базового типа, а не как подтип.
Это означает, что значение определяемого пользователем типа не может использоваться в тех случаях, когда предполагается, что значение базового типа равно.


### <a name="conjugations"></a>Лиц

В отличие от классических битов освобождение памяти такта немного сложнее, так как в результате нежелательного сброса Кубитс может иметь нежелательные последствия для оставшихся вычислений, если Кубитс все еще запутанными. Эти эффекты можно избежать, правильно выполнив вычисления перед освобождением памяти. Общий шаблон в тактовых вычислениях, следовательно, является следующим: 

```qsharp
operation ApplyWith<'T>(
    outerOperation : ('T => Unit is Adj), 
    innerOperation : ('T => Unit), 
    target : 'T) 
: Unit {

    outerOperation(target);
    innerOperation(target);
    Adjoint outerOperation(target);
}
```

Начиная с нашего выпуска 0,9, Q# поддерживает инструкцию конжугатион, которая реализует предыдущее преобразование. С помощью этой инструкции операция `ApplyWith` может быть реализована следующим образом:

```qsharp
operation ApplyWith<'T>(
    outerOperation : ('T => Unit is Adj), 
    innerOperation : ('T => Unit), 
    target : 'T) 
: Unit {

    within{ 
        outerOperation(target);
    }
    apply {
        innerOperation(target);
    }
}
```
Такой оператор конжугатион гораздо более полезен, если внешние и внутренние преобразования недоступны в качестве операций, а более удобны для описания блоком, состоящим из нескольких инструкций. 

Обратное преобразование для инструкций, определенных в блоке внутри блока, автоматически создается компилятором и запускается после завершения блока Apply.
Поскольку любые изменяемые переменные, используемые в качестве части блока in, не могут быть повторно привязаны в блоке применения, созданное преобразование гарантируется как прилегающие вычисления в блоке внутри блока. 


## <a name="defining-new-functions"></a>Определение новых функций

Функции являются исключительно детерминированными, классическими подпрограммыми в Q# , которые отличаются от операций тем, что они не могут иметь каких бы то ни было последствий, чем вычисление выходного значения.
В частности, функции не могут вызывать операции; Применяйте, выделяйте или позаимствование Кубитс; Примеры случайных чисел; или, в противном случае, зависит от состояния, превышающего входное значение функции.
Как следствие, Q# функции являются *чисто*, в том, что они всегда сопоставляют одинаковые входные значения с одними и теми же выходными значениями.
Такое поведение позволяет Q# компилятору безопасно изменять порядок и время вызова функций при создании специализаций операций.

Каждый Q# исходный файл может определять любое количество функций.
Имена функций должны быть уникальными в пределах пространства имен и не могут конфликтовать с именами операций или типов.

Определение функции работает аналогично определению операции, за исключением того, что для функции нельзя определить ни прилегающие, ни контролируемые специализации.
например

```qsharp
function Square(x : Double) : (Double) {
    return x * x;
}
```

или 

```qsharp
function DotProduct(a : Double[], b : Double[]) : Double {
    if (Length(a) != Length(b)) {
        fail "Arrays are not compatible";
    }

    mutable accum = 0.0;
    for (i in 0..Length(a)-1) {
        set accum += a[i] * b[i];
    }
    return accum;
}
```

### <a name="classical-logic-in-functions--good"></a>Классическая логика в функциях = = хорошее

Когда это возможно, полезно написать классическую логику с точки зрения функций, а не операций, чтобы операции могли использовать ее более эффективно. Например, если вы написали предыдущее `Square` объявление в качестве *операции*, компилятор не сможет гарантировать, что его вызов с теми же входными данными получит одинаковые выходные данные.

Чтобы подчеркнуть разницу между функциями и операциями, рассмотрим проблему классической выборки случайного числа в рамках Q# операции:

```qsharp
operation U(target : Qubit) : Unit {

    let angle = RandomReal()
    Rz(angle, target)
}
```

Каждый раз `U` при вызове он имеет другое действие `target` .
В частности, компилятор не может гарантировать, что при добавлении `adjoint auto` объявления специализации в `U` , а затем `U(target); Adjoint U(target);` выступает в качестве удостоверения (т. е. без операции).
Это нарушает определение примыкающего, определенного в [векторах и матрицах](xref:microsoft.quantum.concepts.vectors), что позволяет компилятору автоматически формировать смежную специализацию в операции, при которой вызов операции <xref:microsoft.quantum.math.randomreal> приведет к нарушению гарантий, предоставляемых компилятором; <xref:microsoft.quantum.math.randomreal> — это операция, для которой не существует ни одной примыкающей или контролируемой версии.

С другой стороны, обеспечивая безопасность вызовов функций, таких как, `Square` и гарантирует, что компилятору нужно сохранить только входные данные, чтобы `Square` обеспечить стабильность его вывода.
Таким образом, изоляция максимально возможной логики функций позволяет легко повторно использовать эту логику в других функциях и операциях.


## <a name="generic-type-parameterized-callables"></a>Универсальные вызываемые типы (параметризованные)

Многие функции и операции, которые вы можете определить, не сильно полагаются на типы входных данных, а только неявно используют их типы с помощью какой бы то ни было другой функции или операции.
Например, рассмотрим концепцию *Map* , общую для многих функциональных языков. При наличии функции $f (x) $ и коллекции значений $ \{ x_1, x_2, \дотс, x_n \} $, Map возвращает новую коллекцию $ \{ f (x_1), f (x_2), \дотс, f (x_n) \} $.
Чтобы реализовать это в Q# , воспользуйтесь преимуществами того факта, что функции являются первыми классами.
Ниже приведен краткий пример `Map` использования `T` в качестве заполнителя для определения необходимых типов.

```qsharp
function Map(fn : (T -> T), values : T[]) : T[] {
    mutable mappedValues = new T[Length(values)];
    for (idx in 0..Length(values) - 1) {
        set mappedValues w/= idx <- fn(values[idx]);
    }
    return mappedValues;
}
```

Обратите внимание, что эта функция выглядит почти так же, независимо от фактических типов, которые вы заменяете.
, Например, карту из целых чисел в пол, похожа на карту из чисел с плавающей запятой в строки:

```qsharp
function MapIntsToPaulis(fn : (Int -> Pauli), values : Int[]) : Pauli[] {
    mutable mappedValues = new Pauli[Length(values)];
    for (idx in 0..Length(values) - 1) {
        set mappedValues w/= idx <- fn(values[idx]);
    }
    return mappedValues;
}

function MapDoublesToStrings(fn : (Double -> String), values : Double[]) : String[] {
    mutable mappedValues = new String[Length(values)];
    for (idx in 0..Length(values) - 1) {
        set mappedValues w/= idx <- fn(values[idx]);
    }
    return mappedValues;
}
```

В принципе, можно написать версию `Map` для каждой пары типов, которую вы сталкиваетесь, но в этом случае возникают некоторые сложности.
Например, если обнаружена ошибка в `Map` , необходимо обеспечить единообразное применение исправления во всех версиях `Map` .
Более того, при создании нового кортежа или определяемого пользователем типа необходимо также создать новый объект `Map` для перехода с новым типом.
Хотя это алгоритмизируемым для небольшого количества таких функций, поскольку вы соберете больше функций той же формы, что и `Map` , стоимость введения новых типов становится неоправданной в достаточно коротком порядке.

Тем не менее, значительная часть этой сложности возникает из-за того, что компилятор не предоставил сведения, необходимые для того, чтобы понять, как связаны разные версии `Map` .
Фактически необходимо, чтобы компилятор рассматривал `Map` как часть математических функций от Q# *типов* до Q# функций.

Q# Формализация этого понятия позволяет функциям и операциям иметь *Параметры типа*, а также их обычные параметры кортежа.
В предыдущих примерах вы хотели бы представить, `Map` что параметры типа имеют `Int, Pauli` в первом случае и во `Double, String` втором случае.
В большинстве случаев используйте эти параметры типа, как если бы они были обычными типами. Используйте значения параметров типа, чтобы создать массивы и кортежи, вызывайте функции и операции и присвойте их обычным или изменяемым переменным.

> [!NOTE]
> Самый крайний случай косвенной зависимости заключается в том, что Кубитс, где Q# программа не может напрямую полагаться на структуру `Qubit` типа, но **должна** передавать подобные типы другим операциям и функциям.

Вернувшись к предыдущему примеру, вы увидите, что должны `Map` иметь параметры типа, один для представления входных данных `fn` и один для представления выходных данных `fn` .
В Q# это написано путем добавления угловых скобок (то есть `<>` не Бракетс $ \бракет {} $!) после имени функции или операции в ее объявлении, а также путем перечисления каждого параметра типа.
Имя каждого параметра типа должно начинаться с такта `'` , что означает, что это параметр типа, а не обычный тип (также известен как *конкретный* тип).
Таким образом, `Map` записывается:

```qsharp
function Map<'Input, 'Output>(fn : ('Input -> 'Output), values : 'Input[]) : 'Output[] {
    mutable mappedValues = new 'Output[Length(values)];
    for (idx in 0..Length(values) - 1) {
        set mappedValues w/= idx <- fn(values[idx]);
    }
    return mappedValues;
}
```

Обратите внимание, что определение `Map<'Input, 'Output>` выглядит очень похоже на версии превиоиус.
Единственное отличие заключается в том, что вы явным образом сообщили компилятору, что `Map` не зависит от того `'Input` , что и `'Output` есть, но работает для всех двух типов, напрямую используя их `fn` .
Определив `Map<'Input, 'Output>` таким образом, вы можете вызвать его, как будто это обычная функция:

```qsharp
// Represent Z₀ Z₁ X₂ Y₃ as a list of ints.
let ints = [3, 3, 1, 2];
// Here, assume IntToPauli : Int -> Pauli
// looks up PauliI by 0, PauliX by 1, so forth.
let paulis = Map(IntToPauli, ints);
```

> [!TIP]
> Написание универсальных функций и операций — это одно из мест, где «кортеж — в кортеже» — очень полезный способ подумать о Q# функциях и операциях.
> Поскольку каждая функция принимает ровно один вход и возвращает ровно один выход, вход типа `'T -> 'U` соответствует *любой* Q# функции.
> Аналогичным образом можно передать любую операцию в входные данные типа `'T => 'U` .

Во втором примере рассмотрим задачу написания функции, возвращающей композицию двух других функций:

```qsharp
function ComposeImpl(outerFn : (B -> C), innerFn : (A -> B), input : A) : C {
    return outerFn(innerFn(input));
}

function Compose(outerFn : (B -> C), innerFn : (A -> B)) : (A -> C) {
    return ComposeImpl(outerFn, innerFn, _);
}
```

Здесь необходимо точно указать, что, `A` `B` и, и `C` , следовательно, существенно ограничить служебную программу нашей новой `Compose` функции.
В конце концов, `Compose` только они зависят от `A` , `B` и `C` *через* `innerFn` и `outerFn` .
В качестве альтернативы можно добавить параметры типа к `Compose` , которые указывают, что он работает для *всех* `A` , `B` и `C` , пока эти параметры соответствуют ожидаемым `innerFn` и `outerFn` :

```qsharp
function ComposeImpl<'A, 'B, 'C>(outerFn : ('B -> 'C), innerFn : ('A -> 'B), input : 'A) : 'C {
    return outerFn(innerFn(input));
}

function Compose<'A, 'B, 'C>(outerFn : ('B -> 'C), innerFn : ('A -> 'B)) : ('A -> 'C) {
    return ComposeImpl(outerFn, innerFn, _);
}
```

Q#Стандартные библиотеки предоставляют ряд таких операций и функций с параметризованными параметрами, которые упрощают выражать поток управления более высокого порядка.
Они рассматриваются далее в [ Q# стандартном руководству по библиотеке](xref:microsoft.quantum.libraries.standard.intro).


## <a name="callables-as-first-class-values"></a>Вызываемые как значения первого класса

Одной из важнейших методик для реализации потока управления и классической логики с помощью функций, а не операций является использование этих операций и функций в Q# — *первый класс*.
То есть все значения на языке имеют свое право.
Например, следующий код является вполне допустимым Q# , если немного косвенно:

```qsharp
operation FirstClassExample(target : Qubit) : Unit {
    let ourH = H;
    ourH(target);
}
```

Значение переменной `ourH` в предыдущем фрагменте кода — это операция <xref:microsoft.quantum.intrinsic.h> , которая позволяет вызывать это значение, как любая другая операция.
Благодаря этой возможности можно писать операции, которые принимают операции в качестве части их входных данных, формируя основные понятия потока управления более высокого порядка.
Например, можно представить, что нужно «возкубит» операцию, применив ее дважды к той же цели.

```qsharp
operation ApplyTwice(op : (Qubit => Unit), target : Qubit) : Unit {
    op(target);
    op(target);
}
```

### <a name="returning-operations-from-a-function"></a>Возвращение операций из функции

Важно подчеркнуть, что можно также возвращать операции как часть выходных данных, что позволяет изолировать некоторые виды классической условной логики в качестве классической функции, которая возвращает описание тактовой программы в форме операции.
В качестве простого примера рассмотрим пример использования телепередачи, в котором сторона, получающая 2-разрядное классическое сообщение, должна использовать сообщение для декодирования их кубит в соответствующее состояние в режиме «в Организации».
Это можно написать с точки зрения функции, которая принимает эти два классических битов и возвращает правильную операцию декодирования.

```qsharp
function TeleporationDecoderForMessage(hereBit : Result, thereBit : Result)
: (Qubit => Unit is Adj + Ctl) {

    if (hereBit == Zero && thereBit == Zero) {
        return I;
    } elif (hereBit == One && thereBit == Zero) {
        return X;
    } elif (hereBit == Zero && thereBit == One) {
        return Z;
    } else {
        return Y;
    }
}
```

Эта новая функция действительно является функцией. в этом случае, если вы вызываете ее с теми же значениями `hereBit` и `thereBit` , вы всегда получаете ту же операцию.
Таким образом, декодер может безопасно выполняться внутри операций, не прибегая к попричине того, как логика декодирования взаимодействует с определениями различных специализаций операций.
То есть классическая логика внутри функции изолирована, что гарантирует компилятору, что вызов функции может быть переупорядочен с помощью импунити, пока сохраняются входные данные.


## <a name="partial-application"></a>Частичное приложение

Вы можете значительно увеличить количество функций, возвращающих операции с помощью *частичного приложения*, в котором вы предоставляете одну или несколько частей входных данных функции или операции, не вызывая их фактически. В приведенном выше `ApplyTwice` примере можно указать, что вы не хотите указывать, сразу же, к которому кубит входную операцию:

```qsharp
operation PartialApplicationExample(op : (Qubit => Unit), target : Qubit) : Unit {
    let twiceOp = ApplyTwice(op, _);
    twiceOp(target);
}
```

В этом случае локальная переменная `twiceOp` содержит операцию частичного применения `ApplyTwice(op, _)` , где `_` указывает части входных данных, которые еще не были указаны.
При вызове `twiceOp` в следующей строке вы передаете в качестве входных данных частично примененную операцию все оставшиеся части входных данных в исходную операцию.
Таким образом, предыдущий фрагмент фактически аналогичен вызову `ApplyTwice(op, target)` напрямую, метод Save для того, что вы предоставили новую локальную переменную, чтобы можно было отложить вызов, предоставляя некоторые части входных данных.

Так как операция, которая была частично применена, фактически не вызывается до тех пор, пока не будет предоставлен весь ввод, можно безопасно частично применить операции даже из функций.

```qsharp
function SquareOperation(op : (Qubit => Unit)) : (Qubit => Unit) {
    return ApplyTwice(op, _);
}
```

В принципе, классическая логика внутри `SquareOperation` может быть гораздо более сложной, но она по-прежнему изолирована от остальной части операции с помощью гарантий, что компилятор может предложить функции. Q#Стандартная библиотека использует этот подход для выражения классического потока управления так, чтобы можно было легко использовать его в качестве генератора.


## <a name="recursion"></a>Рекурсия

Q# вызываемые могут быть прямо или косвенно рекурсивными.
Это значит, что операция или функция может вызвать саму себя или вызвать другой вызываемый метод, который напрямую или косвенно вызывает вызываемую операцию.

Однако существует два важных комментария об использовании рекурсии.

- Использование рекурсии в операциях, скорее всего, мешает некоторым оптимизациям.
  Эти помехи могут оказать значительное влияние на время выполнения алгоритма.
- При запуске на фактическом устройстве-такте пространство стека может быть ограничено, так что глубокая рекурсия может привести к ошибке времени выполнения.
  В частности, Q# компилятор и среда выполнения не выявляет и не оптимизируют заключительную рекурсию.

## <a name="next-steps"></a>Дальнейшие действия

Сведения о [переменных](xref:microsoft.quantum.guide.variables) в Q# .