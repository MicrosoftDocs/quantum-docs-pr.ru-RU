---
title: 'Q # Интродутион'
description: 'Краткое введение в тактовые программы в Q #'
author: beheim
ms.author: beheim
ms.date: 11/08/2020
ms.topic: article
uid: microsoft.quantum.guide.programs
ms.openlocfilehash: 975bcda5e0042406b465a83f17f1d2d3f5a1ec4f
ms.sourcegitcommit: b930bb59a1ba8f41d2edc9ed98197109aa8c7f1b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/26/2020
ms.locfileid: "96234323"
---
# <a name="q-quantum-programming-language"></a>Язык программирования на такт Q #

Все, что необходимо знать о языке программирования Q #, подробно описано в статье о [языке q #](xref:microsoft.quantum.qsharp.index). Как и все остальное, наш [процесс проектирования языка](https://github.com/microsoft/qsharp-language#q-language-and-core-libraries-design) — это открытый исходный код, и мы будем рады Вашим вкладам.
Дополнительные сведения об основах и мотивации в Q # см. в разделе [почему нам требуется q #?](https://devblogs.microsoft.com/qsharp/why-do-we-need-q/).  
Q # поставляется в составе пакета средств разработки тактов (КДК) для краткого обзора. Ознакомьтесь [с тем, что такое КДК?](xref:microsoft.quantum.overview.q-sharp). 

## <a name="what-is-a-quantum-program"></a>Что такое тактовая программа?

Тактовая программа может рассматриваться как определенный набор классических подпрограмм, которые при вызове выполняют вычисления путем взаимодействия с тактовой системой. Программа, написанная в Q #, не моделирует состояние такта напрямую, а описывает, как классический контрольный компьютер взаимодействует с Кубитс.
Это позволяет нам полностью *не* зависеть от состояния такта, даже на каждом целевом компьютере, для которого в зависимости от компьютера могут использоваться разные интерпретации. 

Важным следствием этого является то, что Q # не имеет возможности интроспект в состояние кубит или других свойств тактовой частоты напрямую, что гарантирует, что программа Q # может быть физически выполнена на тактовой системе.
Вместо этого программа может вызывать такие операции, как [`Measure`](xref:Microsoft.Quantum.Intrinsic.Measure) Извлечение классической информации из кубит.

После выделения кубит можно передать в операции и функции, которые также называются *вызываемыми*. В определенном смысле, это все, что программа Q # может делать с кубит; Любые прямые действия с состоянием кубит определяются *встроенными* вызываемыми функциями, такими как [`X`](xref:Microsoft.Quantum.Intrinsic.X) и [`H`](xref:Microsoft.Quantum.Intrinsic.H) -т. е. вызываемые объекты, реализации которых не определяются в Q #, а определяются целевым компьютером. *Фактически эти операции делаются* только на целевом компьютере, используемом для запуска конкретной программы Q #.

Например, если запустить программу в [симуляторе полного состояния](xref:microsoft.quantum.machines.full-state-simulator), симулятор выполняет соответствующие математические операции с имитацией тактовой системы.
Но в будущем, когда целевой компьютер является реальным компьютером-тактом, вызов таких операций в Q # направляет компьютер-такт для выполнения соответствующих *реальных* операций в *реальной* тактовой системе (например, для точного времени лазерных импульсов).

Программа Q # повторно объединяет эти операции, как определено на целевом компьютере, для создания новых операций более высокого уровня для вычисления тактовых вычислений.
Таким образом, Q # упрощает выражать логику базового и гибридного такта, а также общие алгоритмы в отношении структуры целевого компьютера или симулятора.

Простой пример — Следующая программа, которая выделяет один кубит в состоянии $ \кет {0} $, затем применяет `H` к ней операцию хадамард и измеряет результат на `PauliZ` основе.

```qsharp
@EntryPoint()
operation MeasureOneQubit() : Result {
    // The following using block creates a fresh qubit and initializes it
    // in the |0〉 state.
    using (qubit = Qubit()) {
        // We apply a Hadamard operation H to the state, thereby preparing the
        // state 1 / sqrt(2) (|0〉 + |1〉).
        H(qubit);
        // Now we measure the qubit in Z-basis.
        let result = M(qubit);
        // As the qubit is now in an eigenstate of the measurement operator,
        // we reset the qubit before releasing it.
        if (result == One) { X(qubit); }
        // Finally, we return the result of the measurement.
        return result;
    }
}
```

Наш [тактовый Катас](https://github.com/microsoft/QuantumKatas#introduction) дает хорошее представление о [концепциях тактовых вычислений](https://github.com/microsoft/QuantumKatas#quantum-computing-concepts-qubits-and-gates) , таких как общие операции с тактами, а также об управлении Кубитс. Дополнительные примеры также можно найти в [подставляемых операциях и функциях](xref:microsoft.quantum.libraries.standard.prelude).



