---
title: 'Приложения в стандартных библиотеках Q #'
description: Узнайте о двух фундаментальных приложениях в Хамилтониан моделирования и алгоритме поиска Шор.
author: QuantumWriter
uid: microsoft.quantum.libraries.applications
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: 25b06ac697c958b15a756191fb8a4ac49644edd7
ms.sourcegitcommit: 0181e7c9e98f9af30ea32d3cd8e7e5e30257a4dc
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/23/2020
ms.locfileid: "85275795"
---
# <a name="applications"></a>Приложения #

## <a name="hamiltonian-simulation"></a>Гамильтоново моделирование ##

Имитация тактовых систем является одним из самых интересных приложений вычислений тактов.
На классическом компьютере сложность имитации тактового генератора в целом масштабируется с помощью измерения $N $ из представления вектора состояния.
Так как это представление экспоненциально растет с числом $n $ Кубитс $N = 2 ^ n $, признаком, известным также как « [рекурсивное](xref:microsoft.quantum.concepts.multiple-qubits)», является недоступным для классического оборудования.

Однако ситуация может сильно различаться на тактовой аппаратуре. Наиболее распространенный вариант моделирования тактов называется независимым от времени проблемой моделирования Хамилтониан. В нем имеется описание System Хамилтониан $H $, Хермитиан матрица, и некоторое начальное состояние такта $ \кет{\пси (0)} $, которое кодируется в $n $ Кубитс на тактовый компьютер. По мере того, как состояния такта в закрытых системах развиваются в уравнении Шредингер $ $ \бегин{алигн} и\фрак {d \кет{\пси (t)}} {d t} & = H \кет{\пси (t)}, \енд{алигн} $ $ целью является реализация единого оператора времени развития $U (t) = e ^ {-ИХТ} $ в фиксированное время $t $, где $ \кет{\пси (t)} = U (t) \кет{\пси (0)} $ разрешает уравнение Шредингер.
Аналогично, проблема Хамилтониан моделирования, зависящая от времени, решает одно и то же уравнение, но с $H (t) $ теперь является функцией времени.

Имитация хамилтониан является основным компонентом многих других проблем моделирования тактов, а решениями для проблем моделирования Хамилтониан являются алгоритмами, описывающими последовательность примитивов-простых тактов, для синтезирования приблизительного целого числа $ \Тилде{у} $ с ошибкой $ \\ | \тилде{у}-U (t) \\ | \ле \епсилон $ в [норме Спектрал](xref:microsoft.quantum.concepts.matrix-advanced). Сложность этих алгоритмов очень сильно зависит от того, как описание Хамилтониана становится доступным для тактового компьютера. Например, в худшем случае, если $H $ действует на $n $ Кубитс в виде списка чисел $2 ^ n \тимес 2 ^ n $, по одному для каждого элемента Matrix, простое чтение данных уже потребовало экспоненциального времени. В лучшем случае можно предположить доступ к черного ящика, что $O \кет{т}\кет{\пси (0)} = \Кет{т}у (t) \кет{\пси (0)} $ тривиально решает проблему. Ни одна из этих моделей не особенно интересна — первое, что лучше, чем классические подходы, а второе — как черный квадрат скрывает примитивную сложность своей реализации, которая может быть экспоненциальной в числе Кубитс.

### <a name="descriptions-of-hamiltonians"></a>Описание Хамилтонианс ###

Поэтому требуются дополнительные предположения для формата входных данных. Оптимальный баланс между входными моделями, которые достаточно описательны для того, чтобы охватить интересные Хамилтонианс, такие как для реалистичных физических систем или интересных вычислительных проблем, а также модели ввода, которые достаточно ограничены для эффективной реализации на тактовой системе. В литературе может быть обнаружено множество нетривиальных моделей ввода, которые находятся в диапазоне от такта до классического. 

В качестве примеров для моделей входных данных, [основанных на образцах, хамилтониан моделирования](http://www.nature.com/articles/s41534-017-0013-7) предполагает доступ с помощью черного ящика к операциям-тактам, которые создают копии матрицы плотности $ \рхо $, которые принимаются хамилтониан $H $. В [единой модели доступа](https://arxiv.org/abs/1202.5822) Предположим, что хамилтониан не разбивается на сумму унитариес $ $ \бегин{алигн} H & = \сум ^ {d-1} \_ {j = 0} a \_ j \хат{у} \_ j, \енд{алигн} $ $, где $a \_ j>$0 являются коэффициентами, а $ \хат{у} \_ j $ — унитариес. Предполагается, что один из них имеет черный доступ к единой Oracle $V = \сум ^ {d-1} \_ {j = 0} \Кет{ж}\бра{ж}\отимес \хат{у} \_ j $, который выбирает нужный $ \хат{у} \_ j $, и Oracle $A \кет {0} = \сум ^ {d-1} \_ {j = 0} \скрт{а \_ j/\ Sum ^ {d-1} \_ {k = 0} \алфа \_ j} \кет{ж} $, которые создают кодирование состояния тактов этих коэффициентов. В случае [имитации разреженного хамилтониана](https://arxiv.org/abs/quant-ph/0301023)предполагается, что хамилтониан является разреженной матрицей только $d = \маскал{о} (\Текст{Полилог} (N)) $ ненулевой элемент в каждой строке. Кроме того, одна из них предполагает существование эффективных тактов тактовой задержки, которые выводят расположение этих ненулевых элементов, а также их значения. Сложность [алгоритмов имитации хамилтониан](xref:microsoft.quantum.more-information) оценивается с точки зрения количества запросов к этим черным ящикам, а сложность шлюза-примитива зависит от сложности реализации этих черных ящиков.

> [!NOTE]
> Нотация больших объемов обычно используется для описания сложного масштабирования алгоритмов. Учитывая две реальные функции $f, g $, выражение $g (x) = \Маскал{о} (f (x)) $ означает, что существует абсолютная положительная константа $x \_ 0, c>$0, что $g (x) \ле c f (x) $ для всех $x \же x \_ $0. 

В большинстве приложений, которые должны быть реализованы на тактовый компьютер, эти черные рамки должны быть эффективно реализованы, т. е. с $ \Маскал{о} (\текст{Полилог} (N)) $-примитивами-тактовыми шлюзами. Более строго, эффективно симулабле Хамилтонианс должен иметь некоторое достаточное для них описание в виде классической части. В одном из таких формулировку предполагается, что Хамилтониан разбивается на сумму Хермитиан частей $ $ \бегин{алигн} H & = \сум ^ {d-1} _ {j = 0} H_j.
\енд{алигн} $ $ более того, предполагается, что каждая часть, Хамилтониан $H \_ j $, легко имитируется. Это означает, что единая $e ^ {-iH \_ j} $ для любого времени $t $ может быть реализована точно с использованием $ \маскал{о} (1) $-примитивных тактов-шлюзов. Например, это справедливо в особом случае, когда каждый $H \_ j $ являются локальными операторами Паули, то есть тензорные продуктами $ \маскал{о} (1) $ не-Identity Паули Operators, которые работают с пространственными закрывающими Кубитс. Эта модель особенно применима к физическим системам с ограниченным и локальным взаимодействием, так как число терминов равно $d = \Маскал{о} (\текст{Полилог} (N)) $ и может быть четко записано, т. е. с классической точки зрения в отношении времени.

> [!TIP]
> Хамилтонианс, которые разбиваются на сумму частей, можно описать с помощью библиотеки представления динамического генератора. Дополнительные сведения см. в разделе представление динамического генератора в [структурах данных](xref:microsoft.quantum.libraries.data-structures).

### <a name="simulation-algorithms"></a>Алгоритмы моделирования ###

Алгоритм моделирования такта преобразует заданное описание Хамилтониан в последовательность простых тактов-шлюзов, которая, в целом, приблизительное развитие времени, называется Хамилтониан.

В особом случае, когда Хамилтониан разбивается на сумму Хермитиан частей, декомпозиция Троттер-Сузуки является особенно простым и интуитивно понятным алгоритмом моделирования Хамилтонианс, разобразующихся в сумме Хермитиан компонентов. Например, интегратор первого заказа в этом семействе приблизительный $ $ \бегин{алигн} U (t) & = \лефт (e ^ {-iH \_ 0 t/r} e ^ {-IH \_ 1 t/r} \кдотс e ^ {-IH \_ {d-1} t/r} \ригхт) ^ {r} + \маскал{о} (d ^ 2 \ max_j \\ | H \_ j \\ | ^ 2 t ^ 2/r), \енд{алигн} $ $, используя продукт $r d $ условия. 

> [!TIP]
> В примерах рассматриваются приложения алгоритма моделирования Троттер-Сузуки.
> Для модели Исинг, использующей только внутренние операции, предоставляемые каждым целевым компьютером, см. [пример **симплеисинг** ](https://github.com/microsoft/Quantum/blob/master/samples/simulation/ising/simple).
> Для модели Исинг с использованием структуры управления библиотекой Троттер-Сузуки см. [пример **исингтроттер** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/trotter-evolution).
> Сведения о молекулярное водофункции с помощью структуры управления библиотекой Троттер-Сузуки см. в [образце **моделирования H2** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line).

Во многих случаях мы хотели бы реализовать алгоритм моделирования, но не заинтересованы в деталях его реализации. Например, интегратор второго порядка приближен к $ $ \бегин{алигн} U (t) & = \лефт (e ^ {-iH \_ 0 t/2R} e ^ {IH \_ 1 t/2R} \кдотс e ^ {IH \_ {d-1} t/2R} e ^ {-IH \_ {d-1} t/2R} \кдотс e ^ {-IH \_ 1 t/2R} e ^ {-IH \_ 0 t/2R} \ригхт) ^ {r} + \маскал{о} (d ^ 3 \ max_j \\ | H \_ j \\ | ^ 3 t ^ 3/r ^ 2), \енд{алигн} $ $ с использованием продукта $2rd $ термов. Более крупные заказы будут содержать еще больше терминов, а оптимизированные варианты могут потребовать очень нетривиальных заказов по экспоненте. Другие расширенные алгоритмы также могут использовать анЦилла Кубитс в промежуточных шагах. Таким образом, мы упаковываем алгоритмы моделирования в Canon как определяемый пользователем тип

```qsharp
newtype SimulationAlgorithm = ((Double, EvolutionGenerator, Qubit[]) => Unit is Adj + Ctl);
```

Первый параметр `Double` — это время моделирования, второй параметр `EvolutionGenerator` , который рассматривается в разделе «представление динамического генератора» [структуры данных](xref:microsoft.quantum.libraries.data-structures), является классическим описанием независимого от времени хамилтониан пакета с инструкциями о том, как каждый термин в хамилтониан может имитироваться тактовой частотой. Типы этой формы приблизительны на единую операцию $e ^ {-ИХТ} $ на третьем параметре `Qubit[]` , который является регистром, в котором хранится состояние такта моделируемой системы. Точно так же, как и в случае с зависимым временем, мы определяем определяемый пользователем тип с `EvolutionSchedule` типом, который является классическим описанием зависимого от времени хамилтониан.

```qsharp
newtype TimeDependentSimulationAlgorithm = ((Double, EvolutionSchedule, Qubit[]) => Unit : Adjoint, Controlled);
```

Например, декомпозиция Троттер-Сузуки может быть вызвана с помощью следующих функций Canon с параметрами, `trotterStepSize` изменяющими продолжительность имитации в каждой экспоненциальной модели, и `trotterOrder` в порядке требуемого интегратора.

```qsharp
function TrotterSimulationAlgorithm(
    trotterStepSize : Double, 
    trotterOrder : Int) 
: SimulationAlgorithm {
    ...
}

function TimeDependentTrotterSimulationAlgorithm(
    trotterStepSize : Double, 
    trotterOrder : Int) 
: TimeDependentSimulationAlgorithm {
    ...
}
```

> [!TIP]
> В примерах рассматриваются приложения библиотеки моделирования. Сведения об оценке этапов в модели Исинг с помощью `SimulationAlgorithm` см. в [ **примере исингфасистиматион** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/phase-estimation).
> Сведения о подготовке состояния адиабатик в модели Исинг с помощью `TimeDependentSimulationAlgorithm` см. в [ **примере адиабатиЦисинг** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/adiabatic).


### <a name="adiabatic-state-preparation--phase-estimation"></a>Оценка этапа & подготовки состояния адиабатик ###

Одним из распространенных приложений моделирования Хамилтониан является подготовка адиабатик State. Здесь есть два Хамилтонианс $H \_ {\текст{старт}} $ и $H \_ {\текст{енд}} $, и состояние такта $ \кет{\пси (0)} $, которое является состоянием заземления для start хамилтониан $H \_ {\текст{старт}} $. Как правило, $H \_ {\текст{старт}} $ выбирается так, что $ \кет{\пси (0)} $ можно легко подготовить из вычислительного состояния $ \ket{0\cdots 0} $. Интерполяция между этими Хамилтониансми в задаче моделирования, зависящей от времени, достаточно медленно, возможно, с высокой вероятностью, в состоянии заземления окончательной Хамилтониан $H \_ {\текст{енд}} $. Хотя подготовка правильных приближений к Хамилтонианм состояниям заземления может быть продолжена таким образом, вызывая на зависимые от времени алгоритмы моделирования Хамилтониан в качестве подпрограммы, другие концептуально отличающиеся подходы, такие как ный такт еиженсолвер, возможны.

Еще одно приложение, повсеместно представленное в тактовой химия, оценивает энергию штата земли Хамилтонианс, представляющих промежуточные шаги химических реакции. Такая схема может, например, полагаться на подготовку состояния адиабатик, чтобы создать состояние заземления, а затем включить независимую от времени имитацию Хамилтониан в качестве подпрограммы в процессе оценки фазы, чтобы извлечь эту энергию с некоторой конечной ошибкой и вероятностью успеха. 

Абстрактные алгоритмы моделирования как определяемые пользователем типы `SimulationAlgorithm` и `TimeDependentSimulationAlgorithm` позволяют легко внедрять свои функции в более сложные алгоритмы обработки тактов. Это мотивация нас в том, что мы делаем то же самое для часто используемых подпрограмм.

Таким способом мы определим удобную функцию

```qsharp
function InterpolatedEvolution(
        interpolationTime : Double, 
        evolutionGeneratorStart : EvolutionGenerator,
        evolutionGeneratorEnd : EvolutionGenerator,
        timeDependentSimulationAlgorithm : TimeDependentSimulationAlgorithm)
: (Qubit[] => Unit is Adj + Ctl) {
        ...
}
 
```

Это возвращает единую операцию, которая реализует все шаги подготовки состояния адиабатик. Первый параметр `interpolatedTime` определяет время, на протяжении которого линейная интерполяция между начальным хамилтониан, описанным вторым параметром, `evolutionGeneratorStart` и End хамилтониан, описанными третьим параметром `evolutionGeneratorEnd` . Четвертый параметр заключается в том, что `timeDependentSimulationAlgorithm` один выбирает алгоритм моделирования. Обратите внимание, что если `interpolatedTime` значение слишком велико, начальное состояние заземления остается неизменным состоянием заземления хамилтониан на протяжении всей длительности моделирования, и поэтому завершается в состоянии заземления конечного хамилтониан.

Мы также определим полезную операцию, которая автоматически выполняет все шаги типичного химияного эксперимента. Например, у нас есть следующий пример, который возвращает оценку энергии для состояния, полученного при подготовке адиабатик State.

```qsharp
operation EstimateAdiabaticStateEnergy(
    nQubits : Int,
    statePrepUnitary : (Qubit[] => Unit),
    adiabaticUnitary : (Qubit[] => Unit),
    qpeUnitary: (Qubit[] => Unit is Adj + Ctl),
    phaseEstAlgorithm : ((DiscreteOracle, Qubit[]) => Double))
: Double {
...
}
```

`nQubits`число Кубитс, использованных для кодирования начального состояния такта. `statePrepUnitary`подготавливает начальное состояние от вычислительной базы $ \ket{0\cdots 0} $. `adiabaticUnitary`является единой операцией, реализующей подготовку адиабатик State, например созданной `InterpolatedEvolution` функцией. `qpeUnitary`— это единая операция, которая используется для оценки этапа в результате выполнения состояния такта. `phaseEstAlgorithm`является нашим выбором алгоритма оценки этапа.

> [!TIP]
> В примерах рассматриваются приложения для подготовки состояния адиабатик. Для модели Исинг с помощью реализации подготовки состояния адиабатик вручную и `AdiabaticEvolution` функции используйте [пример **адиабатиЦисинг** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/adiabatic).
> Сведения об оценке этапа и подготовке состояния адиабатик в модели Исинг см. в примере [ **исингфасистиматион** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/phase-estimation).

> [!TIP]
> [Имитация молекулярное водорода](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line) — это интересный и краткий пример. Модель и экспериментальные результаты выводятся в [O'Malley) et. al.](https://arxiv.org/abs/1512.06860) требуются только матрицы Паули и принимает форму $ \хат H = g \_ {0} I \_ 0i \_ 1 + g \_ 1 {z \_ 0} + g \_ 2 {Z \_ 1} + g \_ 3 {z 0} {z \_ \_ \_ \_ \_ \_ \_ \_ 1} + g 4 {Y 0} {y 1} + g 5 {x 0} {x 1} $. Это эффективный Хамилтониан, требующий только 2 Кубитс, где константы $g $ вычисляются по расстоянию $R $ между двумя атомами водорода. С помощью функций Canon Пол преобразуется в унитариес, а затем развивается за короткий период времени с помощью декомпозиции Троттер-Сузуки. Хорошее приближение к $H _2 $ земля может быть создано без использования подготовки адиабатик состояния, поэтому энергия состояния земли можно найти напрямую, используя оценку фазы из Canon.

## <a name="shors-algorithm"></a>Алгоритм Шора ##
Алгоритм Шор остается одним из самых значительных нововведений в тактовых вычислениях, поскольку он показал, что для решения важных, в настоящее время невероятных неполадок можно было использовать тактовые компьютеры.
Алгоритм Шор обеспечивает быстрый способ факторинга больших чисел с помощью тактового компьютера — проблемы, называемой *факторингом*.
Безопасность множества криптосистемсов в день на данный момент основана на предположении, что для факторинга не существует быстрого алгоритма.
Таким способом, алгоритм Шор имеет более глубокое влияние на безопасность в пост-такте.

Алгоритм Шор можно рассматривать как гибридный алгоритм.
Компьютер-такт используется для выполнения вычислительной задачи, которая называется поиском периода.
Затем результаты поиска по периоду будут классической обработаны для оценки факторов.
Мы рассмотрим эти два шага ниже.

### <a name="period-finding"></a>Поиск по периоду ###

Просмотрели принцип работы преобразования Фурье и оценки фазы (см. раздел [алгоритмы такта](xref:microsoft.quantum.libraries.standard.algorithms)), мы можем использовать эти средства для решения классической, трудной вычислительной задачи, называемой *поиском периода*.  В следующем разделе будет показано, как применить Поиск периода для факторинга.

Учитывая два целых числа $a $ и $N $, где $a<N $, цель периода поиска, также называемая нахождением заказа, заключается в поиске _заказа_ $r $ of $a $ \екуив $N $, где $r $ определяется как наименьшее положительное целое число, которое $a ^ r 1 \текст{mod} N $.  

Чтобы найти заказ с помощью тактового компьютера, можно использовать алгоритм оценки этапа, применяемый к следующему оператору $U _a $: $ $ U_a \кет{КС} \екуив \кет{(AX) \текст{mod} N}. $ $ основе собственных векторов $U _a $ предназначены для целочисленных $s $ и $0 \ LEQ s \лек r-$1, $ $ \кет{x_s} \екуив 1/\скрт{р} \сум \_ {k = 0} ^ {r-1} e ^ {\frac{-2\pi i SK} {r}} \кет{а ^ к\текст {mod} N}, $ $ — _еиженстатес_ $U _A $.
Еиженвалуес $U _a $ — это $ $ U \_ a \кет{КС \_ s} = e ^ {2 \ PI i s/r} \кет{КС \_ s}. $$

Таким способом, Оценка этапа выводит еиженвалуес $e ^ {2 \ PI i s/r} $, из которого $r $ может быть [эффективно получен с](https://en.wikipedia.org/wiki/Continued_fraction) помощью прочего $s/r $.

Схема цепи для поиска тактового периода:

![Схема цепи для поиска тактового периода](~/media/QPE.svg)

Здесь $2N $ Кубитс инициализируются значением $ \кет {0} $, а $n $ Кубитс инициализируются значением $ \кет {1} $.
Читатель снова может заинтересоваться тем, почему регистр такта для хранения еиженстатес инициализируется значением $ \кет {1} $.
Так как он не знает порядок $r $ заранее, мы не можем фактически подготавливать $ \кет{x_s} $ States напрямую.
К счастью, $1/\ sqrt {r} \сум \_ {s = 0} ^ {r-1} \кет{КС \_ s} = \кет {1} $.
Нам не нужно действительно подготавливать $ \кет{КС} $!
Можно просто подготовить тактовый регистр $n $ Кубитс в штате $ \кет {1} $. 

Цепь содержит Кфт и несколько управляемых шлюзов.
Шлюз Кфт был описан [ранее](xref:microsoft.quantum.libraries.standard.algorithms).
Управляемый-$U _a $ Gate сопоставляет $ \кет{КС} $ с $ \кет{(AX) \текст{mod} N} $, если элемент управления кубит имеет значение $ \кет {1} $, и сопоставляет $ \кет{КС} $ с $ \кет{КС} $ в противном случае.

Чтобы достичь $ (a ^ NX) \текст{mod} N $, мы можем просто применить контролируемый $U _ {a ^ N} $, где мы вычисляем $a ^ n \текст{mod} N $ Classic, чтобы подключаться к тактовой цепи.  
Цепи для достижения таких модульных арифметических операций были описаны в [документации по арифметическим тактам](./algorithms.md#arithmetic). в частности, нам требуется модульное возведение в степень для реализации управляемых $U \_ {a ^ i} $.

Хотя Вышеприведенная цепь соответствует [оценке этапа такта](xref:microsoft.quantum.characterization.quantumphaseestimation) и явно включает поиск заказов, мы можем сократить количество Кубитс. Мы можем проследить за методом Беаурегард для поиска, как описано [на стр. 8 из арксив: Куант-pH/0205095v3](https://arxiv.org/pdf/quant-ph/0205095v3.pdf#page=8), или использовать одну из подпрограмм оценки этапа, доступных в Microsoft. тактов. charactering. Например, в ходе [надежной оценки этапа](xref:microsoft.quantum.characterization.robustphaseestimation) также используется один дополнительный кубит.
 
### <a name="factoring"></a>Учитывая ###
Целью факторинга является определение двух простых факторов целочисленного $N $, где $N $ является $n $-битным числом.  
Факторинг состоит из описанных ниже действий. Шаги делятся на три части: классическая процедура предварительной обработки (1-4); Подсистема тактовых вычислений для поиска порядка $a \текст{mod} N $ (5); и классическая процедура создания последовательностей для получения простых факторов из заказа (6-9).

Классическая процедура предварительной обработки состоит из следующих этапов.
1. Если $N $ является четным, возвращается простой фактор $2 $.
2. Если $N = p ^ q $ для $p \geq1 $, $q \geq2 $, возвратите простой фактор $p $.  Этот шаг выполняется в классическом виде.
3. Выберите случайное число $a $ например, $1 < < N-$1.
4. Если $ \текст{ГКД} (a, N) >$1, возвращайте простой фактор $ \текст{ГКД} (a, N) $. Этот шаг вычисляются с помощью алгоритма Еуклид.
Если простой фактор не был возвращен, мы переходим к тактовой подпрограмме:
5. Вызовите алгоритм поиска тактового периода, чтобы вычислить порядок $r $ of $a \текст{mod} N $. Используйте $r $ в классической процедуре обработки, чтобы определить простые факторы:
6. Если $r $ нечетен, вернитесь к этапу предварительной обработки (3).
7. Если $r $ является четным и $a ^ {r/2} =-1 \ Text {mod} N $, вернитесь к шагу предварительной обработки (3).
8. Если $ \текст{ГКД} (a ^ {r/2} + 1, N) $ является нетривиальным фактором $N $, возвращайте $ \текст{ГКД} (a ^ {r/2} + 1, N) $.
9. Если $ \текст{ГКД} (a ^ {r/2}-1, N) $ является нетривиальным фактором $N $, возвращайте $ \текст{ГКД} (a ^ {r/2}-1, N) $.


Алгоритм факторинга — вероятностная: он может показать, что с вероятностью не менее одной половины, что $r $ будет даже и $a ^ {r/2} \нек-1 \текст{mod} N $, что приведет к созданию простого фактора.  (Дополнительные [сведения](xref:microsoft.quantum.more-information)см. в [статье об исходном документе Шор](https://doi.org/10.1109/SFCS.1994.365700) или в одном из *основных текстов тактовых вычислений* в разделе.)
Если простой фактор не возвращается, мы просто повторим алгоритм из шага (1).  После $n $ попыток, вероятность того, что каждая попытка не удалась, не превышает $2 ^ {-n} $.
Таким же результатом, после повторения алгоритма небольшое количество случаев успешного выполнения практически гарантированно.
