---
title: 'Приложения в Q# стандартных библиотеках'
description: Узнайте о двух фундаментальных приложениях в Хамилтониан моделирования и алгоритме поиска Шор.
author: QuantumWriter
uid: microsoft.quantum.libraries.applications
ms.author: martinro
ms.date: 12/11/2017
ms.topic: article
no-loc:
- 'Q#'
- '$$v'
ms.openlocfilehash: 5a29dcc74c638cb8ecbeb1f924d0e50d40d19f66
ms.sourcegitcommit: 29e0d88a30e4166fa580132124b0eb57e1f0e986
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/27/2020
ms.locfileid: "92692169"
---
# <a name="applications"></a><span data-ttu-id="1c135-103">Приложения</span><span class="sxs-lookup"><span data-stu-id="1c135-103">Applications</span></span> #

## <a name="hamiltonian-simulation"></a><span data-ttu-id="1c135-104">Гамильтоново моделирование</span><span class="sxs-lookup"><span data-stu-id="1c135-104">Hamiltonian Simulation</span></span> ##

<span data-ttu-id="1c135-105">Имитация тактовых систем является одним из самых интересных приложений вычислений тактов.</span><span class="sxs-lookup"><span data-stu-id="1c135-105">The simulation of quantum systems is one of the most exciting applications of quantum computation.</span></span>
<span data-ttu-id="1c135-106">На классическом компьютере сложность имитации тактового генератора в целом масштабируется с помощью измерения $N $ из представления вектора состояния.</span><span class="sxs-lookup"><span data-stu-id="1c135-106">On a classical computer, the difficulty of simulating quantum mechanics, in general, scales with the dimension $N$ of its state-vector representation.</span></span>
<span data-ttu-id="1c135-107">Так как это представление экспоненциально растет с числом $n $ Кубитс $N = 2 ^ n $, признаком, известным также как « [рекурсивное](xref:microsoft.quantum.concepts.multiple-qubits)», является недоступным для классического оборудования.</span><span class="sxs-lookup"><span data-stu-id="1c135-107">As this representation grows exponentially with the number of $n$ qubits $N=2^n$, a trait known also known as the [curse of dimensionality](xref:microsoft.quantum.concepts.multiple-qubits), quantum simulation on classical hardware is intractable.</span></span>

<span data-ttu-id="1c135-108">Однако ситуация может сильно различаться на тактовой аппаратуре.</span><span class="sxs-lookup"><span data-stu-id="1c135-108">However, the situation can be very different on quantum hardware.</span></span> <span data-ttu-id="1c135-109">Наиболее распространенный вариант моделирования тактов называется независимым от времени проблемой моделирования Хамилтониан.</span><span class="sxs-lookup"><span data-stu-id="1c135-109">The most common variation of quantum simulation is called the time-independent Hamiltonian simulation problem.</span></span> <span data-ttu-id="1c135-110">В нем имеется описание System Хамилтониан $H $, Хермитиан матрица, и некоторое начальное состояние такта $ \кет{\пси (0)} $, которое кодируется в $n $ Кубитс на тактовый компьютер.</span><span class="sxs-lookup"><span data-stu-id="1c135-110">There, one is provided with a description of the system Hamiltonian $H$, which is a Hermitian matrix, and some initial quantum state $\ket{\psi(0)}$ that is encoded in some basis on $n$ qubits on a quantum computer.</span></span> <span data-ttu-id="1c135-111">По мере того, как состояния такта в закрытых системах развиваются в уравнении Шредингер $ $ \бегин{алигн} и\фрак {d \кет{\пси (t)}} {d t} & = H \кет{\пси (t)}, \енд{алигн} $ $ целью является реализация единого оператора времени развития $U (t) = e ^ {-ИХТ} $ в фиксированное время $t $, где $ \кет{\пси (t)} = U (t) \кет{\пси (0)} $ разрешает уравнение Шредингер.</span><span class="sxs-lookup"><span data-stu-id="1c135-111">As quantum states in closed systems evolve under the Schrödinger equation $$ \begin{align} i\frac{d \ket{\psi(t)}}{d t} & = H \ket{\psi(t)}, \end{align} $$ the goal is to implement the unitary time-evolution operator $U(t)=e^{-iHt}$ at some fixed time $t$, where $\ket{\psi(t)}=U(t)\ket{\psi(0)}$ solves the Schrödinger equation.</span></span>
<span data-ttu-id="1c135-112">Аналогично, проблема Хамилтониан моделирования, зависящая от времени, решает одно и то же уравнение, но с $H (t) $ теперь является функцией времени.</span><span class="sxs-lookup"><span data-stu-id="1c135-112">Analogously, the time-dependent Hamiltonian simulation problem solves the same equation, but with $H(t)$ now a function of time.</span></span>

<span data-ttu-id="1c135-113">Имитация хамилтониан является основным компонентом многих других проблем моделирования тактов, а решениями для проблем моделирования Хамилтониан являются алгоритмами, описывающими последовательность примитивов-простых тактов, для синтезирования приблизительного целого числа $ \Тилде{у} $ с ошибкой $ \\ | \тилде{у}-U (t) \\ | \ле \епсилон $ в [норме Спектрал](xref:microsoft.quantum.concepts.matrix-advanced).</span><span class="sxs-lookup"><span data-stu-id="1c135-113">Hamiltonian simulation is a major component of many other quantum simulation problems, and solutions to Hamiltonian simulation problem are algorithms that describes a sequence of primitive quantum gates for synthesizing an approximating unitary $\tilde{U}$ with error $\\|\tilde{U} - U(t)\\| \le \epsilon$ in the [spectral norm](xref:microsoft.quantum.concepts.matrix-advanced).</span></span> <span data-ttu-id="1c135-114">Сложность этих алгоритмов очень сильно зависит от того, как описание Хамилтониана становится доступным для тактового компьютера.</span><span class="sxs-lookup"><span data-stu-id="1c135-114">The complexity of these algorithms depend very strongly on how a description of the Hamiltonian of interest is made accessible by a quantum computer.</span></span> <span data-ttu-id="1c135-115">Например, в худшем случае, если $H $ действует на $n $ Кубитс в виде списка чисел $2 ^ n \тимес 2 ^ n $, по одному для каждого элемента Matrix, простое чтение данных уже потребовало экспоненциального времени.</span><span class="sxs-lookup"><span data-stu-id="1c135-115">For instance, in the worst-case, if $H$ acting on $n$ qubits were to be provided as a list of $2^n \times 2^n$ numbers, one for each matrix element, simply reading the data would already require exponential time.</span></span> <span data-ttu-id="1c135-116">В лучшем случае можно предположить доступ к черного ящика, что $O \кет{т}\кет{\пси (0)} = \Кет{т}у (t) \кет{\пси (0)} $ тривиально решает проблему.</span><span class="sxs-lookup"><span data-stu-id="1c135-116">In the best case, one could assume access to a black-box unitary that $O\ket{t}\ket{\psi(0)}=\ket{t}U(t)\ket{\psi(0)}$ trivially solves the problem.</span></span> <span data-ttu-id="1c135-117">Ни одна из этих моделей не особенно интересна — первое, что лучше, чем классические подходы, а второе — как черный квадрат скрывает примитивную сложность своей реализации, которая может быть экспоненциальной в числе Кубитс.</span><span class="sxs-lookup"><span data-stu-id="1c135-117">Neither of these input models are particularly interesting -- the former as it is no better than classical approaches, and the latter as the black-box hides the primitive gate complexity of its implementation, which could be exponential in the number of qubits.</span></span>

### <a name="descriptions-of-hamiltonians"></a><span data-ttu-id="1c135-118">Описание Хамилтонианс</span><span class="sxs-lookup"><span data-stu-id="1c135-118">Descriptions of Hamiltonians</span></span> ###

<span data-ttu-id="1c135-119">Поэтому требуются дополнительные предположения для формата входных данных.</span><span class="sxs-lookup"><span data-stu-id="1c135-119">Additional assumptions of the format of the input are therefore required.</span></span> <span data-ttu-id="1c135-120">Оптимальный баланс между входными моделями, которые достаточно описательны для того, чтобы охватить интересные Хамилтонианс, такие как для реалистичных физических систем или интересных вычислительных проблем, а также модели ввода, которые достаточно ограничены для эффективной реализации на тактовой системе.</span><span class="sxs-lookup"><span data-stu-id="1c135-120">A fine balance must be struck between input models that are sufficiently descriptive to encompass interesting Hamiltonians, such as those for realistic physical systems or interesting computational problems, and input models that are sufficiently restrictive to be efficiently implementable on a quantum computer.</span></span> <span data-ttu-id="1c135-121">В литературе может быть обнаружено множество нетривиальных моделей ввода, которые находятся в диапазоне от такта до классического.</span><span class="sxs-lookup"><span data-stu-id="1c135-121">A variety of non-trivial input model may be found in the literature, and they range from quantum to classical.</span></span> 

<span data-ttu-id="1c135-122">В качестве примеров для моделей входных данных, [основанных на образцах, хамилтониан моделирования](http://www.nature.com/articles/s41534-017-0013-7) предполагает доступ с помощью черного ящика к операциям-тактам, которые создают копии матрицы плотности $ \рхо $, которые принимаются хамилтониан $H $.</span><span class="sxs-lookup"><span data-stu-id="1c135-122">As examples of quantum input models, [sample-based Hamiltonian simulation](http://www.nature.com/articles/s41534-017-0013-7) assumes black-box access to quantum operations that produce copies of a density matrix $\rho$, which are taken to be the Hamiltonian $H$.</span></span> <span data-ttu-id="1c135-123">В [единой модели доступа](https://arxiv.org/abs/1202.5822) Предположим, что хамилтониан не разбивается на сумму унитариес $ $ \бегин{алигн} H & = \сум ^ {d-1} \_ {j = 0} a \_ j \хат{у} \_ j, \енд{алигн} $ $, где $a \_ j>$0 являются коэффициентами, а $ \хат{у} \_ j $ — унитариес.</span><span class="sxs-lookup"><span data-stu-id="1c135-123">In the [unitary access model](https://arxiv.org/abs/1202.5822) one supposes that the Hamiltonian instead decomposes into a sum of unitaries $$ \begin{align} H & = \sum^{d-1}\_{j=0} a\_j \hat{U}\_j, \end{align} $$ where $a\_j>0$ are coefficients, and $\hat{U}\_j$ are unitaries.</span></span> <span data-ttu-id="1c135-124">Предполагается, что один из них имеет черный доступ к единой Oracle $V = \сум ^ {d-1} \_ {j = 0} \Кет{ж}\бра{ж}\отимес \хат{у} \_ j $, который выбирает нужный $ \хат{у} \_ j $, и Oracle $A \кет {0} = \сум ^ {d-1} \_ {j = 0} \скрт{а \_ j/\ Sum ^ {d-1} \_ {k = 0} \алфа \_ j} \кет{ж} $, которые создают кодирование состояния тактов этих коэффициентов.</span><span class="sxs-lookup"><span data-stu-id="1c135-124">It is then assumed that one has black-box access to the unitary oracle $V=\sum^{d-1}\_{j=0}\ket{j}\bra{j}\otimes \hat{U}\_j$ that selects the desired $\hat{U}\_j$, and the oracle $A\ket{0}=\sum^{d-1}\_{j=0}\sqrt{a\_j/\sum^{d-1}\_{k=0}\alpha\_j}\ket{j}$ that create a quantum state encoding these coefficients.</span></span> <span data-ttu-id="1c135-125">В случае [имитации разреженного хамилтониана](https://arxiv.org/abs/quant-ph/0301023)предполагается, что хамилтониан является разреженной матрицей только $d = \маскал{о} (\Текст{Полилог} (N)) $ ненулевой элемент в каждой строке.</span><span class="sxs-lookup"><span data-stu-id="1c135-125">In the case of [sparse Hamiltonian simulation](https://arxiv.org/abs/quant-ph/0301023), one assumes that the Hamiltonian is a sparse matrix with only $d=\mathcal{O}(\text{polylog}(N))$ non-zero element in every row.</span></span> <span data-ttu-id="1c135-126">Кроме того, одна из них предполагает существование эффективных тактов тактовой задержки, которые выводят расположение этих ненулевых элементов, а также их значения.</span><span class="sxs-lookup"><span data-stu-id="1c135-126">Moreover, one assumes the existence of efficient quantum circuits that output the location of these non-zero elements, as well as the their values.</span></span> <span data-ttu-id="1c135-127">Сложность [алгоритмов имитации хамилтониан](xref:microsoft.quantum.more-information) оценивается с точки зрения количества запросов к этим черным ящикам, а сложность шлюза-примитива зависит от сложности реализации этих черных ящиков.</span><span class="sxs-lookup"><span data-stu-id="1c135-127">The complexity of [Hamiltonian simulation algorithms](xref:microsoft.quantum.more-information) is evaluated in terms of number of queries to these black-boxes, and the primitive gate complexity then depends very much on the difficulty of implementing these black-boxes.</span></span>

> [!NOTE]
> <span data-ttu-id="1c135-128">Нотация больших объемов обычно используется для описания сложного масштабирования алгоритмов.</span><span class="sxs-lookup"><span data-stu-id="1c135-128">The big-O notation is commonly used to describe the complexity scaling of algorithms.</span></span> <span data-ttu-id="1c135-129">Учитывая две реальные функции $f, g $, выражение $g (x) = \Маскал{о} (f (x)) $ означает, что существует абсолютная положительная константа $x \_ 0, c>$0, что $g (x) \ле c f (x) $ для всех $x \же x \_ $0.</span><span class="sxs-lookup"><span data-stu-id="1c135-129">Given two real functions $f,g$, the expression $g(x)=\mathcal{O}(f(x))$ means that there exists an absolute positive constant $x\_0, c>0$ such that $g(x) \le c f(x)$ for all $x\ge x\_0$.</span></span> 

<span data-ttu-id="1c135-130">В большинстве приложений, которые должны быть реализованы на тактовый компьютер, эти черные рамки должны быть эффективно реализованы, т. е. с $ \Маскал{о} (\текст{Полилог} (N)) $-примитивами-тактовыми шлюзами.</span><span class="sxs-lookup"><span data-stu-id="1c135-130">In most practical applications to be implemented on a quantum computer, these black-boxes must be efficiently implementable, that is with $\mathcal{O}(\text{polylog}(N))$ primitive quantum gates.</span></span> <span data-ttu-id="1c135-131">Более строго, эффективно симулабле Хамилтонианс должен иметь некоторое достаточное для них описание в виде классической части.</span><span class="sxs-lookup"><span data-stu-id="1c135-131">More strongly, efficiently simulable Hamiltonians must have some sufficiently sparse classical description.</span></span> <span data-ttu-id="1c135-132">В одном из таких формулировку предполагается, что Хамилтониан разбивается на сумму Хермитиан частей $ $ \бегин{алигн} H & = \сум ^ {d-1} _ {j = 0} H_j.</span><span class="sxs-lookup"><span data-stu-id="1c135-132">In one such formulation, it is assumed that the Hamiltonian decomposes into a sum of Hermitian parts $$ \begin{align} H & = \sum^{d-1}_{j=0} H_j.</span></span>
<span data-ttu-id="1c135-133">\енд{алигн} $ $ более того, предполагается, что каждая часть, Хамилтониан $H \_ j $, легко имитируется.</span><span class="sxs-lookup"><span data-stu-id="1c135-133">\end{align} $$ Moreover, it is assumed that each part, a Hamiltonian $H\_j$, is easy to simulate.</span></span> <span data-ttu-id="1c135-134">Это означает, что единая $e ^ {-iH \_ j} $ для любого времени $t $ может быть реализована точно с использованием $ \маскал{о} (1) $-примитивных тактов-шлюзов.</span><span class="sxs-lookup"><span data-stu-id="1c135-134">This means that the unitary $e^{-iH\_j t}$ for any time $t$ may be implemented exactly using $\mathcal{O}(1)$ primitive quantum gates.</span></span> <span data-ttu-id="1c135-135">Например, это справедливо в особом случае, когда каждый $H \_ j $ являются локальными операторами Паули, то есть тензорные продуктами $ \маскал{о} (1) $ не-Identity Паули Operators, которые работают с пространственными закрывающими Кубитс.</span><span class="sxs-lookup"><span data-stu-id="1c135-135">For instance, this is true in the special case where each $H\_j$ are local Pauli operators, meaning that they are of tensor products of $\mathcal{O}(1)$ non-identity Pauli operators that act on spatially close qubits.</span></span> <span data-ttu-id="1c135-136">Эта модель особенно применима к физическим системам с ограниченным и локальным взаимодействием, так как число терминов равно $d = \Маскал{о} (\текст{Полилог} (N)) $ и может быть четко записано, т. е. с классической точки зрения в отношении времени.</span><span class="sxs-lookup"><span data-stu-id="1c135-136">This model is particularly applicable to physical systems with bounded and local interaction, as the number of terms is $d=\mathcal{O}(\text{polylog}(N))$, and may clearly be written down, i.e. classically described, in polynomial time.</span></span>

> [!TIP]
> <span data-ttu-id="1c135-137">Хамилтонианс, которые разбиваются на сумму частей, можно описать с помощью библиотеки представления динамического генератора.</span><span class="sxs-lookup"><span data-stu-id="1c135-137">Hamiltonians that decompose into a sum of parts may be described using the Dynamical Generator Representation library.</span></span> <span data-ttu-id="1c135-138">Дополнительные сведения см. в разделе представление динамического генератора в [структурах данных](xref:microsoft.quantum.libraries.data-structures).</span><span class="sxs-lookup"><span data-stu-id="1c135-138">For more information, see the Dynamical Generator Representation section in [data structures](xref:microsoft.quantum.libraries.data-structures).</span></span>

### <a name="simulation-algorithms"></a><span data-ttu-id="1c135-139">Алгоритмы моделирования</span><span class="sxs-lookup"><span data-stu-id="1c135-139">Simulation Algorithms</span></span> ###

<span data-ttu-id="1c135-140">Алгоритм моделирования такта преобразует заданное описание Хамилтониан в последовательность простых тактов-шлюзов, которая, в целом, приблизительное развитие времени, называется Хамилтониан.</span><span class="sxs-lookup"><span data-stu-id="1c135-140">A quantum simulation algorithm converts a given description of a Hamiltonian into a sequence of primitive quantum gates that, as a whole, approximate time-evolution by said Hamiltonian.</span></span>

<span data-ttu-id="1c135-141">В особом случае, когда Хамилтониан разбивается на сумму Хермитиан частей, Trotter-Suzuki декомпозиция является особенно простым и интуитивно понятным алгоритмом моделирования Хамилтонианс, разобразующихся в сумме Хермитиан компонентов.</span><span class="sxs-lookup"><span data-stu-id="1c135-141">In the special case where the Hamiltonian decomposes into a sum of Hermitian parts, the Trotter-Suzuki decomposition is a particularly simple and intuitive algorithm for simulating Hamiltonians that decompose into a sum of Hermitian components.</span></span> <span data-ttu-id="1c135-142">Например, интегратор первого заказа в этом семействе приблизительный $ $ \бегин{алигн} U (t) & = \лефт (e ^ {-iH \_ 0 t/r} e ^ {-IH \_ 1 t/r} \кдотс e ^ {-IH \_ {d-1} t/r} \ригхт) ^ {r} + \маскал{о} (d ^ 2 \ max_j \\ | H \_ j \\ | ^ 2 t ^ 2/r), \енд{алигн} $ $, используя продукт $r d $ условия.</span><span class="sxs-lookup"><span data-stu-id="1c135-142">For instance, a first-order integrator of this family approximates $$ \begin{align} U(t) & = \left( e^{-iH\_0 t / r} e^{-iH\_1 t / r} \cdots e^{-iH\_{d-1} t / r} \right)^{r} + \mathcal{O}(d^2 \max_j\\|H\_j\\|^2 t^2/r), \end{align} $$ using a product of $r d$ terms.</span></span> 

> [!TIP]
> <span data-ttu-id="1c135-143">В примерах рассматриваются приложения алгоритма моделирования Trotter-Suzuki.</span><span class="sxs-lookup"><span data-stu-id="1c135-143">Applications of the Trotter-Suzuki simulation algorithm are covered in the samples.</span></span>
> <span data-ttu-id="1c135-144">Для модели Исинг, использующей только внутренние операции, предоставляемые каждым целевым компьютером, см. [пример **симплеисинг**](https://github.com/microsoft/Quantum/blob/main/samples/simulation/ising/simple).</span><span class="sxs-lookup"><span data-stu-id="1c135-144">For the Ising model using only the intrinsic operations provided by each target machine, please see the [**SimpleIsing** sample](https://github.com/microsoft/Quantum/blob/main/samples/simulation/ising/simple).</span></span>
> <span data-ttu-id="1c135-145">Сведения о модели Исинг с помощью структуры управления библиотекой Trotter-Suzuki см. в [примере **исингтроттер**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/trotter-evolution).</span><span class="sxs-lookup"><span data-stu-id="1c135-145">For the Ising model using the Trotter-Suzuki library control structure, please see the [**IsingTrotter** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/trotter-evolution).</span></span>
> <span data-ttu-id="1c135-146">Сведения о молекулярное водофункции с помощью структуры управления библиотекой Trotter-Suzuki см. в [образце **моделирования H2**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line).</span><span class="sxs-lookup"><span data-stu-id="1c135-146">For molecular Hydrogen using the Trotter-Suzuki library control structure, please see the [**H2 simulation** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line).</span></span>

<span data-ttu-id="1c135-147">Во многих случаях мы хотели бы реализовать алгоритм моделирования, но не заинтересованы в деталях его реализации.</span><span class="sxs-lookup"><span data-stu-id="1c135-147">In many cases, we would like to implement the simulation algorithm, but are not interested in the details of its implementation.</span></span> <span data-ttu-id="1c135-148">Например, интегратор второго порядка приближен к $ $ \бегин{алигн} U (t) & = \лефт (e ^ {-iH \_ 0 t/2R} e ^ {IH \_ 1 t/2R} \кдотс e ^ {IH \_ {d-1} t/2R} e ^ {-IH \_ {d-1} t/2R} \кдотс e ^ {-IH \_ 1 t/2R} e ^ {-IH \_ 0 t/2R} \ригхт) ^ {r} + \маскал{о} (d ^ 3 \ max_j \\ | H \_ j \\ | ^ 3 t ^ 3/r ^ 2), \енд{алигн} $ $ с использованием продукта $2rd $ термов.</span><span class="sxs-lookup"><span data-stu-id="1c135-148">For instance, the second-order integrator approximates $$ \begin{align} U(t) & = \left( e^{-iH\_0 t / 2r} e^{-iH\_1 t / 2r} \cdots e^{-iH\_{d-1} t / 2r} e^{-iH\_{d-1} t / 2r}  \cdots e^{-iH\_1 t / 2r} e^{-iH\_0 t / 2r} \right)^{r} + \mathcal{O}(d^3 \max_j\\|H\_j\\|^3 t^3/r^2), \end{align} $$ using a product of $2rd$ terms.</span></span> <span data-ttu-id="1c135-149">Более крупные заказы будут содержать еще больше терминов, а оптимизированные варианты могут потребовать очень нетривиальных заказов по экспоненте.</span><span class="sxs-lookup"><span data-stu-id="1c135-149">Larger orders will involve even more terms and optimized variants may require highly non-trivial orderings on the exponentials.</span></span> <span data-ttu-id="1c135-150">Другие расширенные алгоритмы также могут использовать анЦилла Кубитс в промежуточных шагах.</span><span class="sxs-lookup"><span data-stu-id="1c135-150">Other advanced algorithms may also involve the use of ancilla qubits in intermediate steps.</span></span> <span data-ttu-id="1c135-151">Таким образом, мы упаковываем алгоритмы моделирования в Canon как определяемый пользователем тип</span><span class="sxs-lookup"><span data-stu-id="1c135-151">Thus we package simulation algorithms in the canon as the user-defined type</span></span>

```qsharp
newtype SimulationAlgorithm = ((Double, EvolutionGenerator, Qubit[]) => Unit is Adj + Ctl);
```

<span data-ttu-id="1c135-152">Первый параметр `Double` — это время моделирования, второй параметр `EvolutionGenerator` , который рассматривается в разделе «представление динамического генератора» [структуры данных](xref:microsoft.quantum.libraries.data-structures), является классическим описанием независимого от времени хамилтониан пакета с инструкциями о том, как каждый термин в хамилтониан может имитироваться тактовой частотой.</span><span class="sxs-lookup"><span data-stu-id="1c135-152">The first parameter `Double` is the time of simulation, the second parameter `EvolutionGenerator`, covered in the Dynamical Generator Representation section of [data-structures](xref:microsoft.quantum.libraries.data-structures), is a classical description of a time-independent Hamiltonian packaged with instructions on how each term in the Hamiltonian may be simulated by a quantum circuit.</span></span> <span data-ttu-id="1c135-153">Типы этой формы приблизительны на единую операцию $e ^ {-ИХТ} $ на третьем параметре `Qubit[]` , который является регистром, в котором хранится состояние такта моделируемой системы.</span><span class="sxs-lookup"><span data-stu-id="1c135-153">Types of this form approximate the unitary operation $e^{-iHt}$ on the third parameter `Qubit[]`, which is the register storing the quantum state of the simulated system.</span></span> <span data-ttu-id="1c135-154">Точно так же, как и в случае с зависимым временем, мы определяем определяемый пользователем тип с `EvolutionSchedule` типом, который является классическим описанием зависимого от времени хамилтониан.</span><span class="sxs-lookup"><span data-stu-id="1c135-154">Similarly for the time-dependent case, we define a user-defined type with an `EvolutionSchedule` type instead, which is a classical description of a time-dependent Hamiltonian.</span></span>

```qsharp
newtype TimeDependentSimulationAlgorithm = ((Double, EvolutionSchedule, Qubit[]) => Unit : Adjoint, Controlled);
```

<span data-ttu-id="1c135-155">В качестве примера можно вызвать декомпозицию Trotter-Suzuki с помощью следующих функций Canon с параметрами, `trotterStepSize` изменяющими продолжительность имитации в каждом экспоненциальном порядке, и `trotterOrder` для порядка требуемого интегратора.</span><span class="sxs-lookup"><span data-stu-id="1c135-155">As an example, the Trotter-Suzuki decomposition may be called using the following canon functions, with parameters `trotterStepSize` modifying the duration of simulation in each exponential, and `trotterOrder` for the order of the desired integrator.</span></span>

```qsharp
function TrotterSimulationAlgorithm(
    trotterStepSize : Double, 
    trotterOrder : Int) 
: SimulationAlgorithm {
    ...
}

function TimeDependentTrotterSimulationAlgorithm(
    trotterStepSize : Double, 
    trotterOrder : Int) 
: TimeDependentSimulationAlgorithm {
    ...
}
```

> [!TIP]
> <span data-ttu-id="1c135-156">В примерах рассматриваются приложения библиотеки моделирования.</span><span class="sxs-lookup"><span data-stu-id="1c135-156">Applications of the simulation library are covered in the samples.</span></span> <span data-ttu-id="1c135-157">Сведения об оценке этапов в модели Исинг с помощью `SimulationAlgorithm` см. в [ **примере исингфасистиматион**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/phase-estimation).</span><span class="sxs-lookup"><span data-stu-id="1c135-157">For phase estimation in the Ising model using `SimulationAlgorithm`, please see the [**IsingPhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/phase-estimation).</span></span>
> <span data-ttu-id="1c135-158">Сведения о подготовке состояния адиабатик в модели Исинг с помощью `TimeDependentSimulationAlgorithm` см. в [ **примере адиабатиЦисинг**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/adiabatic).</span><span class="sxs-lookup"><span data-stu-id="1c135-158">For adiabatic state preparation in the Ising model using `TimeDependentSimulationAlgorithm`, please see the [**AdiabaticIsing** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/adiabatic).</span></span>


### <a name="adiabatic-state-preparation--phase-estimation"></a><span data-ttu-id="1c135-159">Оценка этапа & подготовки состояния адиабатик</span><span class="sxs-lookup"><span data-stu-id="1c135-159">Adiabatic State Preparation & Phase Estimation</span></span> ###

<span data-ttu-id="1c135-160">Одним из распространенных приложений моделирования Хамилтониан является подготовка адиабатик State.</span><span class="sxs-lookup"><span data-stu-id="1c135-160">One common application of Hamiltonian simulation is adiabatic state preparation.</span></span> <span data-ttu-id="1c135-161">Здесь есть два Хамилтонианс $H \_ {\текст{старт}} $ и $H \_ {\текст{енд}} $, и состояние такта $ \кет{\пси (0)} $, которое является состоянием заземления для start хамилтониан $H \_ {\текст{старт}} $.</span><span class="sxs-lookup"><span data-stu-id="1c135-161">Here, one is provided with two Hamiltonians $H\_{\text{start}}$ and $H\_{\text{end}}$, and a quantum state $\ket{\psi(0)}$ that is a ground state of the start Hamiltonian $H\_{\text{start}}$.</span></span> <span data-ttu-id="1c135-162">Как правило, $H \_ {\текст{старт}} $ выбирается так, что $ \кет{\пси (0)} $ можно легко подготовить из вычислительного состояния $ \ket{0\cdots 0} $.</span><span class="sxs-lookup"><span data-stu-id="1c135-162">Typically, $H\_{\text{start}}$ is chosen such that $\ket{\psi(0)}$ is easy to prepare from a computational basis state $\ket{0\cdots 0}$.</span></span> <span data-ttu-id="1c135-163">Интерполяция между этими Хамилтониансми в задаче моделирования, зависящей от времени, достаточно медленно, возможно, с высокой вероятностью, в состоянии заземления окончательной Хамилтониан $H \_ {\текст{енд}} $.</span><span class="sxs-lookup"><span data-stu-id="1c135-163">By interpolating between these Hamiltonians in the time-dependent simulation problem sufficiently slowly, it is possible to end up, with high probability, in a ground state of the final Hamiltonian $H\_{\text{end}}$.</span></span> <span data-ttu-id="1c135-164">Хотя подготовка правильных приближений к Хамилтонианм состояниям заземления может быть продолжена таким образом, вызывая на зависимые от времени алгоритмы моделирования Хамилтониан в качестве подпрограммы, другие концептуально отличающиеся подходы, такие как ный такт еиженсолвер, возможны.</span><span class="sxs-lookup"><span data-stu-id="1c135-164">Though preparing good approximations to Hamiltonian ground states could proceed in this manner by calling upon on time-dependent Hamiltonian simulation algorithms as a subroutine, other conceptually different approaches such as the variational quantum eigensolver are possible.</span></span>

<span data-ttu-id="1c135-165">Еще одно приложение, повсеместно представленное в тактовой химия, оценивает энергию штата земли Хамилтонианс, представляющих промежуточные шаги химических реакции.</span><span class="sxs-lookup"><span data-stu-id="1c135-165">Yet another application ubiquitous in quantum chemistry is estimating the ground state energy of Hamiltonians representing the intermediate steps of chemical reaction.</span></span> <span data-ttu-id="1c135-166">Такая схема может, например, полагаться на подготовку состояния адиабатик, чтобы создать состояние заземления, а затем включить независимую от времени имитацию Хамилтониан в качестве подпрограммы в процессе оценки фазы, чтобы извлечь эту энергию с некоторой конечной ошибкой и вероятностью успеха.</span><span class="sxs-lookup"><span data-stu-id="1c135-166">Such a scheme could, for instance, rely on adiabatic state preparation to create the ground state, and then incorporate time-independent Hamiltonian simulation as a subroutine in phase estimation characterization to extract this energy with some finite error and probability of success.</span></span> 

<span data-ttu-id="1c135-167">Абстрактные алгоритмы моделирования как определяемые пользователем типы `SimulationAlgorithm` и `TimeDependentSimulationAlgorithm` позволяют легко внедрять свои функции в более сложные алгоритмы обработки тактов.</span><span class="sxs-lookup"><span data-stu-id="1c135-167">Abstracting simulation algorithms as the user-defined types `SimulationAlgorithm` and `TimeDependentSimulationAlgorithm` allow us to conveniently incorporate their functionality into more sophisticated quantum algorithms.</span></span> <span data-ttu-id="1c135-168">Это мотивация нас в том, что мы делаем то же самое для часто используемых подпрограмм.</span><span class="sxs-lookup"><span data-stu-id="1c135-168">This motivates us to do the same for these commonly used subroutines.</span></span>

<span data-ttu-id="1c135-169">Таким способом мы определим удобную функцию</span><span class="sxs-lookup"><span data-stu-id="1c135-169">Thus we define the convenient function</span></span>

```qsharp
function InterpolatedEvolution(
        interpolationTime : Double, 
        evolutionGeneratorStart : EvolutionGenerator,
        evolutionGeneratorEnd : EvolutionGenerator,
        timeDependentSimulationAlgorithm : TimeDependentSimulationAlgorithm)
: (Qubit[] => Unit is Adj + Ctl) {
        ...
}
 
```

<span data-ttu-id="1c135-170">Это возвращает единую операцию, которая реализует все шаги подготовки состояния адиабатик.</span><span class="sxs-lookup"><span data-stu-id="1c135-170">This returns a unitary operation that implements all steps of adiabatic state preparation.</span></span> <span data-ttu-id="1c135-171">Первый параметр `interpolatedTime` определяет время, на протяжении которого линейная интерполяция между начальным хамилтониан, описанным вторым параметром, `evolutionGeneratorStart` и End хамилтониан, описанными третьим параметром `evolutionGeneratorEnd` .</span><span class="sxs-lookup"><span data-stu-id="1c135-171">The first parameter `interpolatedTime` defines the time over which we linearly interpolate between the start Hamiltonian described by the second parameter `evolutionGeneratorStart` and the end Hamiltonian described by the third parameter `evolutionGeneratorEnd`.</span></span> <span data-ttu-id="1c135-172">Четвертый параметр заключается в том, что `timeDependentSimulationAlgorithm` один выбирает алгоритм моделирования.</span><span class="sxs-lookup"><span data-stu-id="1c135-172">The fourth parameter `timeDependentSimulationAlgorithm` is where one makes the choice of simulation algorithm.</span></span> <span data-ttu-id="1c135-173">Обратите внимание, что если `interpolatedTime` значение слишком велико, начальное состояние заземления остается неизменным состоянием заземления хамилтониан на протяжении всей длительности моделирования, и поэтому завершается в состоянии заземления конечного хамилтониан.</span><span class="sxs-lookup"><span data-stu-id="1c135-173">Note that if `interpolatedTime` is long enough, an initial ground state remains an instantaneous ground state of the Hamiltonian over the entire duration of time-dependent simulation, and thus ends in the ground state of the end Hamiltonian.</span></span>

<span data-ttu-id="1c135-174">Мы также определим полезную операцию, которая автоматически выполняет все шаги типичного химияного эксперимента.</span><span class="sxs-lookup"><span data-stu-id="1c135-174">We also define a helpful operation that automatically performs all steps of a typical quantum chemistry experiment.</span></span> <span data-ttu-id="1c135-175">Например, у нас есть следующий пример, который возвращает оценку энергии для состояния, полученного при подготовке адиабатик State.</span><span class="sxs-lookup"><span data-stu-id="1c135-175">For instance we have the following, which returns an energy estimate of the state produced by adiabatic state preparation:</span></span>

```qsharp
operation EstimateAdiabaticStateEnergy(
    nQubits : Int,
    statePrepUnitary : (Qubit[] => Unit),
    adiabaticUnitary : (Qubit[] => Unit),
    qpeUnitary: (Qubit[] => Unit is Adj + Ctl),
    phaseEstAlgorithm : ((DiscreteOracle, Qubit[]) => Double))
: Double {
...
}
```

<span data-ttu-id="1c135-176">`nQubits` число Кубитс, использованных для кодирования начального состояния такта.</span><span class="sxs-lookup"><span data-stu-id="1c135-176">`nQubits` is the number of qubits used to encode the initial quantum state.</span></span> <span data-ttu-id="1c135-177">`statePrepUnitary` подготавливает начальное состояние от вычислительной базы $ \ket{0\cdots 0} $.</span><span class="sxs-lookup"><span data-stu-id="1c135-177">`statePrepUnitary` prepares the start state from the computational basis $\ket{0\cdots 0}$.</span></span> <span data-ttu-id="1c135-178">`adiabaticUnitary` является единой операцией, реализующей подготовку адиабатик State, например созданной  `InterpolatedEvolution` функцией.</span><span class="sxs-lookup"><span data-stu-id="1c135-178">`adiabaticUnitary` is the unitary operation that implements adiabatic state preparation, such as produced by the  `InterpolatedEvolution` function.</span></span> <span data-ttu-id="1c135-179">`qpeUnitary` — это единая операция, которая используется для оценки этапа в результате выполнения состояния такта.</span><span class="sxs-lookup"><span data-stu-id="1c135-179">`qpeUnitary` is the unitary operation that is used to perform phase estimation on the resulting quantum state.</span></span> <span data-ttu-id="1c135-180">`phaseEstAlgorithm` является нашим выбором алгоритма оценки этапа.</span><span class="sxs-lookup"><span data-stu-id="1c135-180">`phaseEstAlgorithm` is our choice of phase estimation algorithm.</span></span>

> [!TIP]
> <span data-ttu-id="1c135-181">В примерах рассматриваются приложения для подготовки состояния адиабатик.</span><span class="sxs-lookup"><span data-stu-id="1c135-181">Applications of adiabatic state preparation are covered in the samples.</span></span> <span data-ttu-id="1c135-182">Для модели Исинг с помощью реализации подготовки состояния адиабатик вручную и `AdiabaticEvolution` функции используйте [пример **адиабатиЦисинг**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/adiabatic).</span><span class="sxs-lookup"><span data-stu-id="1c135-182">For the Ising model using a manual implementation of adiabatic state preparation versus using the `AdiabaticEvolution` function, please see the [**AdiabaticIsing** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/adiabatic).</span></span>
> <span data-ttu-id="1c135-183">Сведения об оценке этапа и подготовке состояния адиабатик в модели Исинг см. в примере [ **исингфасистиматион**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/phase-estimation).</span><span class="sxs-lookup"><span data-stu-id="1c135-183">For phase estimation and adiabatic state preparation in the Ising model, please see the [**IsingPhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/phase-estimation).</span></span>

> [!TIP]
> <span data-ttu-id="1c135-184">[Имитация молекулярное водорода](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line) — это интересный и краткий пример.</span><span class="sxs-lookup"><span data-stu-id="1c135-184">The [simulation of molecular Hydrogen](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line) is an interesting and brief sample.</span></span> <span data-ttu-id="1c135-185">Модель и экспериментальные результаты выводятся в [O'Malley) et. al.](https://arxiv.org/abs/1512.06860)</span><span class="sxs-lookup"><span data-stu-id="1c135-185">The model and experimental results reported in [O'Malley et. al.](https://arxiv.org/abs/1512.06860)</span></span> <span data-ttu-id="1c135-186">требуются только матрицы Паули и принимает форму $ \хат H = g \_ {0} I \_ 0i \_ 1 + g \_ 1 {z \_ 0} + g \_ 2 {Z \_ 1} + g \_ 3 {z 0} {z \_ \_ \_ \_ \_ \_ \_ \_ 1} + g 4 {Y 0} {y 1} + g 5 {x 0} {x 1} $.</span><span class="sxs-lookup"><span data-stu-id="1c135-186">only requires Pauli matrices and takes the form $\hat H = g\_{0}I\_0I\_1+g\_1{Z\_0}+g\_2{Z\_1}+g\_3{Z\_0}{Z\_1}+g\_4{Y\_0}{Y\_1}+g\_5{X\_0}{X\_1}$.</span></span> <span data-ttu-id="1c135-187">Это эффективный Хамилтониан, требующий только 2 Кубитс, где константы $g $ вычисляются по расстоянию $R $ между двумя атомами водорода.</span><span class="sxs-lookup"><span data-stu-id="1c135-187">This is an effective Hamiltonian only requiring only 2 qubits, where the constants $g$ are computed from the distance $R$ between the two Hydrogen atoms.</span></span> <span data-ttu-id="1c135-188">С помощью функций Canon Пол преобразуется в унитариес, а затем развивается за короткий период времени с помощью Trotter-Suzuki декомпозиции.</span><span class="sxs-lookup"><span data-stu-id="1c135-188">Using canon functions, the Paulis are converted to unitaries and then evolved over short periods of time using the Trotter-Suzuki decomposition.</span></span> <span data-ttu-id="1c135-189">Хорошее приближение к $H _2 $ земля может быть создано без использования подготовки адиабатик состояния, поэтому энергия состояния земли можно найти напрямую, используя оценку фазы из Canon.</span><span class="sxs-lookup"><span data-stu-id="1c135-189">A good approximation to the $H_2$ ground state can be created without using adiabatic state preparation, and so the ground state energy may be found directly by utilizing phase estimation from the canon.</span></span>

## <a name="shors-algorithm"></a><span data-ttu-id="1c135-190">Алгоритм Шора</span><span class="sxs-lookup"><span data-stu-id="1c135-190">Shor's Algorithm</span></span> ##
<span data-ttu-id="1c135-191">Алгоритм Шор остается одним из самых значительных нововведений в тактовых вычислениях, поскольку он показал, что для решения важных, в настоящее время невероятных неполадок можно было использовать тактовые компьютеры.</span><span class="sxs-lookup"><span data-stu-id="1c135-191">Shor's algorithm remains one of the most significant developments in quantum computing because it showed that quantum computers could be used to solve important, currently classically intractable problems.</span></span>
<span data-ttu-id="1c135-192">Алгоритм Шор обеспечивает быстрый способ факторинга больших чисел с помощью тактового компьютера — проблемы, называемой *факторингом* .</span><span class="sxs-lookup"><span data-stu-id="1c135-192">Shor's algorithm provides a fast way to factor large numbers using a quantum computer, a problem called *factoring* .</span></span>
<span data-ttu-id="1c135-193">Безопасность множества криптосистемсов в день на данный момент основана на предположении, что для факторинга не существует быстрого алгоритма.</span><span class="sxs-lookup"><span data-stu-id="1c135-193">The security of many present-day cryptosystems is based on the assumption that no fast algorithm exists for factoring.</span></span>
<span data-ttu-id="1c135-194">Таким способом, алгоритм Шор имеет более глубокое влияние на безопасность в пост-такте.</span><span class="sxs-lookup"><span data-stu-id="1c135-194">Thus Shor's algorithm has had a profound impact on how we think about security in a post-quantum world.</span></span>

<span data-ttu-id="1c135-195">Алгоритм Шор можно рассматривать как гибридный алгоритм.</span><span class="sxs-lookup"><span data-stu-id="1c135-195">Shor's algorithm can be thought of as a hybrid algorithm.</span></span>
<span data-ttu-id="1c135-196">Компьютер-такт используется для выполнения вычислительной задачи, которая называется поиском периода.</span><span class="sxs-lookup"><span data-stu-id="1c135-196">The quantum computer is used to perform a computationally hard task known as period finding.</span></span>
<span data-ttu-id="1c135-197">Затем результаты поиска по периоду будут классической обработаны для оценки факторов.</span><span class="sxs-lookup"><span data-stu-id="1c135-197">The results from period finding are then classically processed to estimate the factors.</span></span>
<span data-ttu-id="1c135-198">Мы рассмотрим эти два шага ниже.</span><span class="sxs-lookup"><span data-stu-id="1c135-198">We review these two steps below.</span></span>

### <a name="period-finding"></a><span data-ttu-id="1c135-199">Поиск по периоду</span><span class="sxs-lookup"><span data-stu-id="1c135-199">Period Finding</span></span> ###

<span data-ttu-id="1c135-200">Просмотрели принцип работы преобразования Фурье и оценки фазы (см. раздел [алгоритмы такта](xref:microsoft.quantum.libraries.standard.algorithms)), мы можем использовать эти средства для решения классической, трудной вычислительной задачи, называемой *поиском периода* .</span><span class="sxs-lookup"><span data-stu-id="1c135-200">Having seen how the quantum Fourier transform and phase estimation work (see [Quantum algorithms](xref:microsoft.quantum.libraries.standard.algorithms)), we can use these tools to solve a classically hard computational problem called *period finding* .</span></span>  <span data-ttu-id="1c135-201">В следующем разделе будет показано, как применить Поиск периода для факторинга.</span><span class="sxs-lookup"><span data-stu-id="1c135-201">In the next section, we will see how to apply period finding to factoring.</span></span>

<span data-ttu-id="1c135-202">Учитывая два целых числа $a $ и $N $, где $a<N $, цель периода поиска, также называемая нахождением заказа, заключается в поиске _заказа_ $r $ of $a $ \екуив $N $, где $r $ определяется как наименьшее положительное целое число, которое $a ^ r 1 \текст{mod} N $.</span><span class="sxs-lookup"><span data-stu-id="1c135-202">Given two integers $a$ and $N$, where $a<N$, the goal of period finding, also called order finding, is to find the _order_ $r$ of $a$ modulo $N$, where $r$ is defined to be the least positive integer such that $a^r \equiv 1 \text{ mod } N$.</span></span>  

<span data-ttu-id="1c135-203">Чтобы найти заказ с помощью тактового компьютера, можно использовать алгоритм оценки этапа, применяемый к следующему оператору $U _a $: $ $ U_a \кет{КС} \екуив \кет{(AX) \текст{mod} N}. $ $ основе собственных векторов $U _a $ предназначены для целочисленных $s $ и $0 \ LEQ s \лек r-$1, $ $ \кет{x_s} \екуив 1/\скрт{р} \сум \_ {k = 0} ^ {r-1} e ^ {\frac{-2\pi i SK} {r}} \кет{а ^ к\текст {mod} N}, $ $ — _еиженстатес_ $U _A $.</span><span class="sxs-lookup"><span data-stu-id="1c135-203">To find the order using a quantum computer, we can use the phase estimation algorithm applied to the following unitary operator $U_a$: $$ U_a\ket{x} \equiv \ket{(ax)\text{ mod }N} .$$ The eigenvectors of $U_a$ are for integer $s$ and $0\leq s \leq r - 1$, $$\ket{x_s} \equiv 1 / \sqrt{r} \sum\_{k=0}^{r-1} e^{\frac{-2\pi i sk}{r}} \ket{a^k\text{ mod }N},$$ are _eigenstates_ of $U_a$.</span></span>
<span data-ttu-id="1c135-204">Еиженвалуес $U _a $ — это $ $ U \_ a \кет{КС \_ s} = e ^ {2 \ PI i s/r} \кет{КС \_ s}.</span><span class="sxs-lookup"><span data-stu-id="1c135-204">The eigenvalues of $U_a$ are $$ U\_a \ket{x\_s} = e^{2\pi i s / r} \ket{x\_s} .</span></span> $$

<span data-ttu-id="1c135-205">Таким способом, Оценка этапа выводит еиженвалуес $e ^ {2 \ PI i s/r} $, из которого $r $ может быть [эффективно получен с](https://en.wikipedia.org/wiki/Continued_fraction) помощью прочего $s/r $.</span><span class="sxs-lookup"><span data-stu-id="1c135-205">Phase estimation thus outputs the eigenvalues $e^{2\pi i s / r}$ from which $r$ can be learned efficiently using [continued fractions](https://en.wikipedia.org/wiki/Continued_fraction) from $s / r$.</span></span>

<span data-ttu-id="1c135-206">Схема цепи для поиска тактового периода:</span><span class="sxs-lookup"><span data-stu-id="1c135-206">The circuit diagram for quantum period finding is:</span></span>

![Схема цепи для поиска тактового периода](~/media/QPE.svg)

<span data-ttu-id="1c135-208">Здесь $2N $ Кубитс инициализируются значением $ \кет {0} $, а $n $ Кубитс инициализируются значением $ \кет {1} $.</span><span class="sxs-lookup"><span data-stu-id="1c135-208">Here $2n$ qubits are initialized to $\ket{0}$ and $n$ qubits are initialized to $\ket{1}$.</span></span>
<span data-ttu-id="1c135-209">Читатель снова может заинтересоваться тем, почему регистр такта для хранения еиженстатес инициализируется значением $ \кет {1} $.</span><span class="sxs-lookup"><span data-stu-id="1c135-209">The reader again may wonder why the quantum register to hold the eigenstates is initialized to $\ket{1}$.</span></span>
<span data-ttu-id="1c135-210">Так как он не знает порядок $r $ заранее, мы не можем фактически подготавливать $ \кет{x_s} $ States напрямую.</span><span class="sxs-lookup"><span data-stu-id="1c135-210">As one does not know the order $r$ in advance, we cannot actually prepare $\ket{x_s}$ states directly.</span></span>
<span data-ttu-id="1c135-211">К счастью, $1/\ sqrt {r} \сум \_ {s = 0} ^ {r-1} \кет{КС \_ s} = \кет {1} $.</span><span class="sxs-lookup"><span data-stu-id="1c135-211">Luckily, it turns out that $1/\sqrt{r} \sum\_{s=0}^{r-1} \ket{x\_s} = \ket{1}$.</span></span>
<span data-ttu-id="1c135-212">Нам не нужно действительно подготавливать $ \кет{КС} $!</span><span class="sxs-lookup"><span data-stu-id="1c135-212">We don't need to actually prepare $\ket{x}$!</span></span>
<span data-ttu-id="1c135-213">Можно просто подготовить тактовый регистр $n $ Кубитс в штате $ \кет {1} $.</span><span class="sxs-lookup"><span data-stu-id="1c135-213">We can just prepare a quantum register of $n$ qubits in state $\ket{1}$.</span></span> 

<span data-ttu-id="1c135-214">Цепь содержит Кфт и несколько управляемых шлюзов.</span><span class="sxs-lookup"><span data-stu-id="1c135-214">The circuit contains the QFT and several controlled gates.</span></span>
<span data-ttu-id="1c135-215">Шлюз Кфт был описан [ранее](xref:microsoft.quantum.libraries.standard.algorithms).</span><span class="sxs-lookup"><span data-stu-id="1c135-215">The QFT gate has been described [previously](xref:microsoft.quantum.libraries.standard.algorithms).</span></span>
<span data-ttu-id="1c135-216">Управляемый-$U _a $ Gate сопоставляет $ \кет{КС} $ с $ \кет{(AX) \текст{mod} N} $, если элемент управления кубит имеет значение $ \кет {1} $, и сопоставляет $ \кет{КС} $ с $ \кет{КС} $ в противном случае.</span><span class="sxs-lookup"><span data-stu-id="1c135-216">The controlled-$U_a$ gate maps $\ket{x}$ to $\ket{(ax)\text{ mod } N}$ if the control qubit is $\ket{1}$, and maps $\ket{x}$ to $\ket{x}$ otherwise.</span></span>

<span data-ttu-id="1c135-217">Чтобы достичь $ (a ^ NX) \текст{mod} N $, мы можем просто применить контролируемый $U _ {a ^ N} $, где мы вычисляем $a ^ n \текст{mod} N $ Classic, чтобы подключаться к тактовой цепи.</span><span class="sxs-lookup"><span data-stu-id="1c135-217">To achieve $(a^nx)\text{ mod } N$,  we can simply apply controlled-$U_{a^n}$, where we calculate $a^n \text{ mod } N$ classically to plug into the quantum circuit.</span></span>  
<span data-ttu-id="1c135-218">Цепи для достижения таких модульных арифметических операций были описаны в [документации по арифметическим тактам](./algorithms.md#arithmetic). в частности, нам требуется модульное возведение в степень для реализации управляемых $U \_ {a ^ i} $.</span><span class="sxs-lookup"><span data-stu-id="1c135-218">The circuits to achieve such modular arithmetic have been described in the [quantum arithmetic documentation](./algorithms.md#arithmetic), specifically we require a modular exponentiation circuit to implement the controlled-$U\_{a^i}$ operations.</span></span>

<span data-ttu-id="1c135-219">Хотя Вышеприведенная цепь соответствует [оценке этапа такта](xref:Microsoft.Quantum.Characterization.QuantumPhaseEstimation) и явно включает поиск заказов, мы можем сократить количество Кубитс.</span><span class="sxs-lookup"><span data-stu-id="1c135-219">While the circuit above corresponds to [Quantum Phase Estimation](xref:Microsoft.Quantum.Characterization.QuantumPhaseEstimation) and explicitly enables order finding, we can reduce the number of qubits required.</span></span> <span data-ttu-id="1c135-220">Мы можем проследить за методом Беаурегард для поиска, как описано [на стр. 8 из арксив: Куант-pH/0205095v3](https://arxiv.org/pdf/quant-ph/0205095v3.pdf#page=8), или использовать одну из подпрограмм оценки этапа, доступных в Microsoft. тактов. charactering.</span><span class="sxs-lookup"><span data-stu-id="1c135-220">We can either follow Beauregard's method for order finding as described [on Page 8 of arXiv:quant-ph/0205095v3](https://arxiv.org/pdf/quant-ph/0205095v3.pdf#page=8), or use one of the phase estimation routines available in Microsoft.Quantum.Characterization.</span></span> <span data-ttu-id="1c135-221">Например, в ходе [надежной оценки этапа](xref:microsoft.quantum.characterization.robustphaseestimation) также используется один дополнительный кубит.</span><span class="sxs-lookup"><span data-stu-id="1c135-221">For example, [Robust Phase Estimation](xref:microsoft.quantum.characterization.robustphaseestimation) also uses one extra qubit.</span></span>

### <a name="factoring"></a><span data-ttu-id="1c135-222">Учитывая</span><span class="sxs-lookup"><span data-stu-id="1c135-222">Factoring</span></span> ###
<span data-ttu-id="1c135-223">Целью факторинга является определение двух простых факторов целочисленного $N $, где $N $ является $n $-битным числом.</span><span class="sxs-lookup"><span data-stu-id="1c135-223">The goal of factoring is to determine the two prime factors of integer $N$, where $N$ is an $n$-bit number.</span></span>  
<span data-ttu-id="1c135-224">Факторинг состоит из описанных ниже действий.</span><span class="sxs-lookup"><span data-stu-id="1c135-224">Factoring consists of the steps described below.</span></span> <span data-ttu-id="1c135-225">Шаги делятся на три части: классическая процедура предварительной обработки (1-4); Подсистема тактовых вычислений для поиска порядка $a \текст{mod} N $ (5); и классическая процедура создания последовательностей для получения простых факторов из заказа (6-9).</span><span class="sxs-lookup"><span data-stu-id="1c135-225">The steps are split into three parts: a classical preprocessing routine (1-4); a quantum computing routine to find the order of $a \text{ mod } N$ (5); and a classical postprocessing routine to derive the prime factors from the order (6-9).</span></span>

<span data-ttu-id="1c135-226">Классическая процедура предварительной обработки состоит из следующих этапов.</span><span class="sxs-lookup"><span data-stu-id="1c135-226">The classical preprocessing routine consists of the following steps:</span></span>
1. <span data-ttu-id="1c135-227">Если $N $ является четным, возвращается простой фактор $2 $.</span><span class="sxs-lookup"><span data-stu-id="1c135-227">If $N$ is even, return the prime factor $2$.</span></span>
2. <span data-ttu-id="1c135-228">Если $N = p ^ q $ для $p \geq1 $, $q \geq2 $, возвратите простой фактор $p $.</span><span class="sxs-lookup"><span data-stu-id="1c135-228">If $N=p^q$ for $p\geq1$, $q\geq2$, return the prime factor $p$.</span></span>  <span data-ttu-id="1c135-229">Этот шаг выполняется в классическом виде.</span><span class="sxs-lookup"><span data-stu-id="1c135-229">This step is performed classically.</span></span>
3. <span data-ttu-id="1c135-230">Выберите случайное число $a $ например, $1 < < N-$1.</span><span class="sxs-lookup"><span data-stu-id="1c135-230">Choose a random number $a$ such that $1 < a < N-1$.</span></span>
4. <span data-ttu-id="1c135-231">Если $ \текст{ГКД} (a, N) >$1, возвращайте простой фактор $ \текст{ГКД} (a, N) $.</span><span class="sxs-lookup"><span data-stu-id="1c135-231">If $\text{gcd}(a,N)>1$, return the prime factor $\text{gcd}(a,N)$.</span></span> <span data-ttu-id="1c135-232">Этот шаг вычисляются с помощью алгоритма Еуклид.</span><span class="sxs-lookup"><span data-stu-id="1c135-232">This step is computed using Euclid's algorithm.</span></span>
<span data-ttu-id="1c135-233">Если простой фактор не был возвращен, мы переходим к тактовой подпрограмме:</span><span class="sxs-lookup"><span data-stu-id="1c135-233">If no prime factor has been returned, we proceed to the quantum routine:</span></span>
5. <span data-ttu-id="1c135-234">Вызовите алгоритм поиска тактового периода, чтобы вычислить порядок $r $ of $a \текст{mod} N $.</span><span class="sxs-lookup"><span data-stu-id="1c135-234">Call the quantum period finding algorithm to calculate the order $r$ of $a \text{ mod } N$.</span></span> <span data-ttu-id="1c135-235">Используйте $r $ в классической процедуре обработки, чтобы определить простые факторы:</span><span class="sxs-lookup"><span data-stu-id="1c135-235">Use $r$ in the classical postprocessing routine to determine the prime factors:</span></span>
6. <span data-ttu-id="1c135-236">Если $r $ нечетен, вернитесь к этапу предварительной обработки (3).</span><span class="sxs-lookup"><span data-stu-id="1c135-236">If $r$ is odd, go back to preprocessing step (3).</span></span>
7. <span data-ttu-id="1c135-237">Если $r $ является четным и $a ^ {r/2} =-1 \ Text {mod} N $, вернитесь к шагу предварительной обработки (3).</span><span class="sxs-lookup"><span data-stu-id="1c135-237">If $r$ is even and $a^{r/2} = -1\text{ mod }N$, go back to preprocessing step (3).</span></span>
8. <span data-ttu-id="1c135-238">Если $ \текст{ГКД} (a ^ {r/2} + 1, N) $ является нетривиальным фактором $N $, возвращайте $ \текст{ГКД} (a ^ {r/2} + 1, N) $.</span><span class="sxs-lookup"><span data-stu-id="1c135-238">If $\text{gcd}(a^{r/2}+1, N)$ is a non-trivial factor of $N$, return $\text{gcd}(a^{r/2}+1, N)$.</span></span>
9. <span data-ttu-id="1c135-239">Если $ \текст{ГКД} (a ^ {r/2}-1, N) $ является нетривиальным фактором $N $, возвращайте $ \текст{ГКД} (a ^ {r/2}-1, N) $.</span><span class="sxs-lookup"><span data-stu-id="1c135-239">If $\text{gcd}(a^{r/2}-1, N)$ is a non-trivial factor of $N$, return $\text{gcd}(a^{r/2}-1, N)$.</span></span>


<span data-ttu-id="1c135-240">Алгоритм факторинга — вероятностная: он может показать, что с вероятностью не менее одной половины, что $r $ будет даже и $a ^ {r/2} \нек-1 \текст{mod} N $, что приведет к созданию простого фактора.</span><span class="sxs-lookup"><span data-stu-id="1c135-240">The factoring algorithm is probabilistic: it can been shown that with probability at least one half that $r$ will be even and $a^{r/2} \neq -1 \text{ mod }N$, thus producing a prime factor.</span></span>  <span data-ttu-id="1c135-241">(Дополнительные [сведения](xref:microsoft.quantum.more-information)см. в [статье об исходном документе Шор](https://doi.org/10.1109/SFCS.1994.365700) или в одном из *основных текстов тактовых вычислений* в разделе.)</span><span class="sxs-lookup"><span data-stu-id="1c135-241">(See [Shor's original paper](https://doi.org/10.1109/SFCS.1994.365700) for details, or one of the *Basic quantum computing* texts in [For more information](xref:microsoft.quantum.more-information)).</span></span>
<span data-ttu-id="1c135-242">Если простой фактор не возвращается, мы просто повторим алгоритм из шага (1).</span><span class="sxs-lookup"><span data-stu-id="1c135-242">If a prime factor is not returned, then we simply repeat the algorithm from step (1).</span></span>  <span data-ttu-id="1c135-243">После $n $ попыток, вероятность того, что каждая попытка не удалась, не превышает $2 ^ {-n} $.</span><span class="sxs-lookup"><span data-stu-id="1c135-243">After $n$ tries, the probability that every attempt has failed is at most $2^{-n}$.</span></span>
<span data-ttu-id="1c135-244">Таким же результатом, после повторения алгоритма небольшое количество случаев успешного выполнения практически гарантированно.</span><span class="sxs-lookup"><span data-stu-id="1c135-244">Thus after repeating the algorithm a small number of times success is virtually assured.</span></span>
