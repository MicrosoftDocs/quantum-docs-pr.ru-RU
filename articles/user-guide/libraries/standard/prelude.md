---
title: Встроенные операции и функции в КДК
description: Сведения о внутренних операциях и функциях в КДК, включая классические функции и единые операции поворота и измерения.
author: QuantumWriter
ms.author: martinro
ms.date: 12/11/2017
ms.topic: article
uid: microsoft.quantum.libraries.standard.prelude
no-loc:
- Q#
- $$v
ms.openlocfilehash: dd507d0c644ae711a5e5a1dff9156f571cb0fa92
ms.sourcegitcommit: 9b0d1ffc8752334bd6145457a826505cc31fa27a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/21/2020
ms.locfileid: "90833553"
---
# <a name="the-prelude"></a>Версионного #

Q#Компилятор и целевые компьютеры, входящие в состав пакета средств разработки тактовой передачи, предоставляют набор встроенных функций и операций, которые можно использовать при написании тактовых программ в Q# .

## <a name="intrinsic-operations-and-functions"></a>Встроенные операции и функции ##

Внутренние операции, определенные в стандартной библиотеке, относятся к одной из нескольких категорий:

- Неотъемлемые классические функции, собранные в <xref:microsoft.quantum.core> пространстве имен.
- Операции, представляющие унитариес, состоящие из [Клиффорд и $T $ Gates](xref:microsoft.quantum.concepts.qubit).
- Операции, представляющие повороты различных операторов.
- Операции, реализующие измерения.

Так как набор шлюзов Клиффорд + $T $ является [универсальным](xref:microsoft.quantum.concepts.multiple-qubits) для тактовых вычислений, эти операции достаточно для реализации любого тактового алгоритма в неглигибли небольшой ошибке.
Предоставляя также повороты, Q# позволяя программисту работать в рамках единой кубит единой и кнот ворота библиотеки. Эту библиотеку гораздо проще подумать, так как она не требует от программиста непосредственного выражения Клиффорд + $T $, и так как существуют высокоэффективные методы для компиляции одного кубит унитариес в Клиффорд и $T $ Gates (Дополнительные сведения см. [здесь](xref:microsoft.quantum.more-information) ).

Там, где это возможно, операции, определенные в версионного, которые работают с Кубитс, позволяют применить `Controlled` вариант, чтобы целевой компьютер выполнит соответствующую декомпозицию.

Многие функции и операции, определенные в этой части версионного, находятся в @"microsoft.quantum.intrinsic" пространстве имен, так что большинство Q# исходных файлов будет иметь `open Microsoft.Quantum.Intrinsic;` директиву сразу после объявления первоначального пространства имен.
<xref:microsoft.quantum.core>Пространство имен автоматически открывается, поэтому такие функции, как, <xref:microsoft.quantum.core.length> можно использовать без `open` инструкции.

### <a name="common-single-qubit-unitary-operations"></a>Распространенные операции с одиночным кубит единым ###

Версионного также определяет многие распространенные [операции с одной кубит](xref:microsoft.quantum.concepts.qubit#single-qubit-operations).
Все эти операции допускают `Controlled` и `Adjoint` операторов.

#### <a name="pauli-operators"></a>Операторы Паули ####

<xref:microsoft.quantum.intrinsic.x>Операция реализует оператор паули $X $.
Это иногда также называется `NOT` шлюзом.
Он имеет подпись `(Qubit => Unit is Adj + Ctl)` .
Он соответствует единому кубит едину:

\бегин{екуатион} \бегин{бматрикс} 0 & 1 \\ \\ % FIXME: это в настоящее время использует куадвхакк.
1 & 0 \енд{бматрикс} \енд{екуатион}

<xref:microsoft.quantum.intrinsic.y>Операция реализует оператор паули $Y $.
Он имеет подпись `(Qubit => Unit is Adj + Ctl)` .
Он соответствует единому кубит едину:

\бегин{екуатион} \бегин{бматрикс} 0 &-i \\ \\ % FIXME: в настоящее время используется куадвхакк хакер.
я & 0 \енд{бматрикс} \енд{екуатион}

<xref:microsoft.quantum.intrinsic.z>Операция реализует оператор паули $Z $.
Он имеет подпись `(Qubit => Unit is Adj + Ctl)` .
Он соответствует единому кубит едину:

\бегин{екуатион} \бегин{бматрикс} 1 & 0 \\ \\ % FIXME: это в настоящее время использует куадвхакк.
0 &-1 \енд{бматрикс} \енд{екуатион}

Ниже показаны преобразования, сопоставленные с [блочной сферой](xref:microsoft.quantum.concepts.qubit#visualizing-qubits-and-transformations-using-the-bloch-sphere) (ось вращения в каждом случае выделяется красным цветом):

![Операции Паули, сопоставленные с сферой БЛОЧ](~/media/prelude_pauliBloch.png)

Важно отметить, что применение одного и того же шлюза Паули дважды к тому же кубит отменяет операцию (так как теперь вы выполнили полный поворот 2π (360 °) над поверхностью БЛОЧ Sphere, что приводит к последующей отправной точке). Это приводит нас к следующему удостоверению:

$ $ X ^ 2 = Y ^ 2 = Z ^ 2 = \болдоне $ $

Это можно визуально использовать в сфере БЛОЧ:

![XX = I](~/media/prelude_blochIdentity.png)

#### <a name="other-single-qubit-cliffords"></a>Другие одиночные кубит Клиффордс ####

<xref:microsoft.quantum.intrinsic.h>Операция реализует шлюз хадамард.
Это повлияет на оси Паули $X $ и $Z $ целевого кубит, например $H \кет {0} = \кет{+} \масрел{: =} (\кет {0} + \кет {1} )/\скрт {2} $ and $H \кет{+} = \кет {0} $.
Он имеет сигнатуру `(Qubit => Unit is Adj + Ctl)` и соответствует кубит единому:

\бегин{екуатион} \фрак {1} {\скрт {2} } \бегин{бматрикс} 1 & 1 \\ \\ % FIXME: в настоящее время используется куадвхакк Hack.
1 &-1 \енд{бматрикс} \енд{екуатион}

Шлюз Хадамард особенно важен, так как он может использоваться для создания части Штатов $ \кет {0} $ и $ \кет {1} $. В представлении БЛОЧ Sphere проще всего подумать об этом как повороте $ \кет{\пси} $ вокруг оси x на $ \пи $ радианы ($ 180 ^ \Цирк $), за которым следует вращение (по часовой стрелке) вокруг оси y на $ \ PI/2 $ радианы ($ 90 ^ \Цирк $):

![Операция хадамард, сопоставленная с сферой БЛОЧ](~/media/prelude_hadamardBloch.png)

<xref:microsoft.quantum.intrinsic.s>Операция реализует шлюз фазы $S $.
Это квадратный корень матрицы операции Паули $Z $.
То есть $S ^ 2 = Z $.
Он имеет сигнатуру `(Qubit => Unit is Adj + Ctl)` и соответствует кубит единому:

\бегин{екуатион} \бегин{бматрикс} 1 & 0 \\ \\ % FIXME: это в настоящее время использует куадвхакк.
0 & я \енд{бматрикс} \енд{екуатион}

#### <a name="rotations"></a>Ротации ####

В дополнение к операциям Паули и Клиффорд выше, Q# версионного предоставляет разнообразные способы выражения поворотов.
Как описано в разделе [операции с одним кубит](xref:microsoft.quantum.concepts.qubit#single-qubit-operations), возможность смены критически важна для алгоритмов такта.

Мы начнем с отзыва, что мы можем выразить любую операцию с одним кубит, используя $H $ и $T $ Gates, где $H $ является операцией Хадамард и где \бегин{екуатион} T \масрел{: =} \бегин{бматрикс} 1 & 0 \\ \\ % FIXME: в настоящее время используется четырехъядерный отправляю.
0 & e ^ {i \пи/4} \енд{бматрикс} \енд{екуатион} это квадратный корень <xref:microsoft.quantum.intrinsic.s> операции, то есть $T ^ 2 = S $.
$T $ Gate в свою очередь реализуется <xref:microsoft.quantum.intrinsic.t> операцией и имеет сигнатуру `(Qubit => Unit is Adj + Ctl)` , указывающую, что она является единой операцией с одним кубит.

Несмотря на то, что этот принцип достаточно для описания любой произвольной операции с одним кубит, различные целевые компьютеры могут иметь более эффективные представления для ротации операторов Паули, таким образом, версионного включает различные способы конвиенентли Express.
Самый простой из них — это <xref:microsoft.quantum.intrinsic.r> операция, которая реализует поворот вокруг заданной оси Паули, \Бегин{екуатион} R (\сигма, \фи) \масрел{: =} \експ (-i \фи \сигма/2), \енд{екуатион}, где $ \сигма $ является оператором Паули, $ \Phi $ является углом и где $ \exp $ представляет экспоненциальную экспоненту.
Он имеет сигнатуру `((Pauli, Double, Qubit) => Unit is Adj + Ctl)` , где первые две части входных данных представляют классические аргументы $ \сигма $ и $ \фи $, необходимые для указания одного оператора $R (\сигма, \фи) $.
Можно частично применить $ \сигма $ и $ \фи $, чтобы получить операцию, тип которой является производным от одного кубит.
Например, `R(PauliZ, PI() / 4, _)` имеет тип `(Qubit => Unit is Adj + Ctl)` .

> [!NOTE]
> <xref:microsoft.quantum.intrinsic.r>Операция делит входной угол на 2 и умножает его на-1.
> Для ротаций $Z $ это означает, что параметр $ \кет {0} $ еиженстате поворачивается на $-\фи/$2, а $ \кет {1} $ еиженстате поворачивается на $ \фи/$2, поэтому параметр $ \кет {1} $ еиженстате поворачивается на $ \фи $ по отношению к $ \кет $ {0} еиженстате.
>
> В частности, это означает, что `T` и отличается только неактуальным `R(PauliZ, PI() / 8, _)` [глобальным этапом](xref:microsoft.quantum.glossary#global-phase).
> По этой причине $T $ иногда называют $ \фрак{\пи} {8} $-Gate.
>
> Обратите внимание также на то, что поворот вокруг `PauliI` просто применяет глобальную фазу $ \фи/$2. Хотя такие этапы несущественны, как в [концептуальных документах](xref:microsoft.quantum.concepts.qubit), они важны для контролируемых `PauliI` поворотов.

В алгоритмах такта часто бывает полезно выражать повороты как ДЯДИК дроби, например $ \фи = \пи k/2 ^ n $ для некоторых $k \ин \Масбб{з} $ и $n \ин \Масбб{н} $.
<xref:microsoft.quantum.intrinsic.rfrac>Операция реализует поворот вокруг указанной оси Паули, используя это соглашение.
Он отличается от <xref:microsoft.quantum.intrinsic.r> в том, что угол вращения задается как два входных значения типа `Int` , интерпретируемые как ДЯДИК дробь.
Таким словами, `RFrac` имеет сигнатуру `((Pauli, Int, Int, Qubit) => Unit is Adj + Ctl)` .
Он реализует однокубитную единую $ \експ (i \пи k \сигма/2 ^ n) $, где $ \сигма $ — это матрица Паули, соответствующая первому аргументу, $k $ является вторым аргументом, а $n $ — третьим аргументом.
`RFrac(_,k,n,_)` то же самое, что `R(_,-πk/2^n,_)` ; Обратите внимание, что угол — это *отрицательная* часть дроби.

<xref:microsoft.quantum.intrinsic.rx>Операция реализует поворот вокруг оси паули $X $.
Он имеет подпись `((Double, Qubit) => Unit is Adj + Ctl)` .
Параметр `Rx(_, _)` совпадает с параметром `R(PauliX, _, _)`.

<xref:microsoft.quantum.intrinsic.ry>Операция реализует поворот вокруг оси паули $Y $.
Он имеет подпись `((Double, Qubit) => Unit is Adj + Ctl)` .
Параметр `Ry(_, _)` совпадает с параметром `R(PauliY,_ , _)`.

<xref:microsoft.quantum.intrinsic.rz>Операция реализует поворот вокруг оси паули $Z $.
Он имеет подпись `((Double, Qubit) => Unit is Adj + Ctl)` .
Параметр `Rz(_, _)` совпадает с параметром `R(PauliZ, _, _)`.

<xref:microsoft.quantum.intrinsic.r1>Операция реализует поворот на заданную величину около $ \кет {1} $, еиженстате $-$1 из $Z $.
Он имеет подпись `((Double, Qubit) => Unit is Adj + Ctl)` .
`R1(phi,_)` то же, что и, `R(PauliZ,phi,_)` за которым следует `R(PauliI,-phi,_)` .

<xref:microsoft.quantum.intrinsic.r1frac>Операция реализует поворот на части по заданному объему вокруг Z = 1 еиженстате.
Он имеет подпись `((Int,Int, Qubit) => Unit is Adj + Ctl)` .
`R1Frac(k,n,_)` то же, что и, `RFrac(PauliZ,-k.n+1,_)` за которым следует `RFrac(PauliI,k,n+1,_)` .

Пример операции вращения (вокруг оси Паули $Z $ в этом экземпляре), сопоставленной с блочной сферой, показан ниже:

![Операция вращения, сопоставленная с блочной сферой](~/media/prelude_rotationBloch.png)

#### <a name="multi-qubit-operations"></a>Операции с несколькими кубит ####

В дополнение к кубит операциям выше, версионного также определяет несколько операций с несколькими кубит.

Во-первых, <xref:microsoft.quantum.intrinsic.cnot> операция выполняет Стандартный контролируемый `NOT` шлюз, \бегин{екуатион} \операторнаме{кнот} \масрел{: =} \бегин{бматрикс} 1 & 0 & 0 & 0 \\ \\ 0 & 1 & 0 & 0 \\ \\ 0 & 0 & 0 & 1 \\ \\ 0 & 0 & 1 & 0 \енд{бматрикс}.
\енд{екуатион} имеет сигнатуру `((Qubit, Qubit) => Unit is Adj + Ctl)` , представляющую, что $ \операторнаме{кнот} $ действует унитарили на двух отдельных Кубитс.
Параметр `CNOT(q1, q2)` совпадает с параметром `(Controlled X)([q1], q2)`.
Так как `Controlled` функтор позволяет управлять регистром, мы используем литерал массива, `[q1]` чтобы указать, что нам нужен только один элемент управления.

Эта <xref:microsoft.quantum.intrinsic.ccnot> Операция ВЫПОЛНЯЕТ не шлюз с удвоенной назначением, иногда также известный как шлюз Тоффоли.
Он имеет подпись `((Qubit, Qubit, Qubit) => Unit is Adj + Ctl)` .
Параметр `CCNOT(q1, q2, q3)` совпадает с параметром `(Controlled X)([q1, q2], q3)`.

<xref:microsoft.quantum.intrinsic.swap>Операция меняет местами такты двух Кубитс.
То есть реализуется единая матрица \бегин{екуатион} \Операторнаме{СВАП} \масрел{: =} \бегин{бматрикс} 1 & 0 & 0 & 0 \\ \\ 0 & 0 & 1 & 0 \\ \\ 0 & 1 & 0 & 0 \\ \\ 0 & 0 & 0 & 1 \енд{бматрикс}.
\енд{екуатион} имеет подпись `((Qubit, Qubit) => Unit is Adj + Ctl)` .
`SWAP(q1,q2)` эквивалентно следующему, `CNOT(q1, q2)` `CNOT(q2, q1)` а затем `CNOT(q1, q2)` .

> [!NOTE]
> Шлюз подкачки *не* совпадает с изменением расположения элементов переменной с типом `Qubit[]` .
> Применение `SWAP(q1, q2)` приводит к изменению состояния Кубитс, на которое ссылается `q1` и, а `q2` `let swappedRegister = [q2, q1];` также влияет только на эти Кубитс.
> Кроме того, `(Controlled SWAP)([q0], (q1, q2))` позволяет `SWAP` применять к состоянию третьего кубит, который не может быть представлен путем изменения расположения элементов.
> Шлюз с управляемым ПЕРЕКЛЮЧЕНИЕм, также известный как шлюз Фредкин, достаточно мощный для включения всех классических вычислений.

Наконец, версионного предоставляет две операции для представления экспоненциальных функций операторов множественного кубит Паули.
<xref:microsoft.quantum.intrinsic.exp>Операция выполняет поворот на основе тензорные произведения матриц Паули, как представлено в нескольких кубит единых \Бегин{екуатион} \операторнаме{ЕКСП} (\век{\сигма}, \фи) \масрел{: =} \експ\лефт (i \Phi \ sigma_0 \otimes \ sigma_1 \otimes \cdots \otimes \ sigma_n \right), \end{Equation}, где $ \vec{\sigma} = (\ sigma_0, \ sigma_1, \dots, \ sigma_n) $ — это последовательность одноqubitных операторов Pauli, где $ \Phi $ является углом.
`Exp`Поворот представляет $ \век{\сигма} $ как массив `Pauli` элементов, так что он имеет сигнатуру `((Pauli[], Double, Qubit[]) => Unit is Adj + Ctl)` .

<xref:microsoft.quantum.intrinsic.expfrac>Операция выполняет тот же поворот, используя нотацию дробной части ДЯДИК, о которой говорилось выше.
Он имеет подпись `((Pauli[], Int, Int, Qubit[]) => Unit is Adj + Ctl)` .

> [!WARNING]
> Экспоненциальные произведения тензорные операторов Паули не аналогичны тензорныеным продуктам экспоненциальных операторов Паули.
> То есть $e ^ {i (Z \отимес Z) \фи} \не e ^ {i Z \фи} \отимес e ^ {i Z \фи} $.

### <a name="measurements"></a>Измерения ###

При измерении значение + 1 еиженвалуе оператора соответствует `Zero` результату, а значение-1 еиженвалуе — `One` результату.

> [!NOTE]
> Хотя это соглашение может показаться странным, оно имеет два очень замечательных преимущества.
> Во-первых, наблюдение за результатом $ \кет {0} $ представлено `Result` значением `Zero` , при котором наблюдение $ \кет {1} $ соответствует `One` .
> Во-вторых, мы можем написать, что еиженвалуе $ \ламбда $ соответствует результату, $r $ — $ \ламбда = (-1) ^ r $.

Операции измерения поддерживают ни `Adjoint` функтор, ни параметр `Controlled` .

<xref:microsoft.quantum.intrinsic.measure>Операция выполняет совместное измерение одного или нескольких Кубитс в указанном продукте операторов Паули.
Если массив Паули и массив кубит имеют разную длину, операция завершается ошибкой.
`Measure` имеет сигнатуру `((Pauli[], Qubit[]) => Result)` .

Обратите внимание, что совместное измерение не совпадает с измерением каждого кубит по отдельности.
Например, рассмотрим состояние $ \кет {11} = \кет {1} \отимес \Кет {1} = кс\отимес X \кет {00} $.
По отдельности измеряйте $Z _0 $ и $Z _1 $, чтобы получить результаты $r _0 = $1 и $r _1 = $1.
Однако при измерении $Z _0 Z_1 $ мы получаем один результат $r _ {\текстрм{жоинт}} = $0, представляющий, что пара $ \кет {11} $ является положительной.
Разместите иначе $ (-1) ^ {r_0 + r_1} = (-1) ^ r_ {\текстрм{жоинт}}) $.
Важно, так как мы изучен *только* четность из этого измерения, все сведения о такте, представленные в подстановке 2 2 между кубит состояниями положительной четности, $ \кет {00} $ и $ \кет {11} $, сохраняются.
Это свойство будет необходимо для дальнейшего использования, так как мы обсудим исправление ошибок.

Для удобства версионного также предоставляет две другие операции для измерения Кубитс.
Во-первых, поскольку выполнение однокубитных измерений довольно распространено, версионного определяет сокращение для этого случая.
<xref:microsoft.quantum.intrinsic.m>Операция измеряет оператор паули $Z $ в одном кубит и имеет сигнатуру `(Qubit => Result)` .
`M(q)` равно `Measure([PauliZ], [q])`.

<xref:microsoft.quantum.measurement.multim>Оператор паули $Z $ измеряется *отдельно* для каждого массива Кубитс, возвращая *массив* `Result` значений, полученных для каждого кубит.
В некоторых случаях это можно оптимизировать. Он имеет подпись ( `Qubit[] => Result[])` .
`MultiM(qs)` эквивалентно следующему:

```qsharp
mutable rs = new Result[Length(qs)];
for (index in 0..Length(qs)-1)
{
    set rs[index] = M(qs[index]);
}
return rs;
```

## <a name="extension-functions-and-operations"></a>Функции и операции расширения ##

Кроме того, версионного определяет широкий набор математических функций и функции преобразования типов на уровне .NET для использования в Q# коде.
Например, <xref:microsoft.quantum.math> пространство имен определяет полезные операции, такие как <xref:microsoft.quantum.math.sin> и <xref:microsoft.quantum.math.log> .
Реализация, предоставляемая пакетом разработки тактовой передачи, использует классическую библиотеку базовых классов .NET и, таким же, может затрагивать дополнительный обмен информацией между тактовыми программами и их классическими драйверами.
Хотя это и не является проблемой для локального симулятора, это может быть проблемой с производительностью при использовании удаленного симулятора или реального оборудования в качестве целевого компьютера.
С другой стороны, отдельный целевой компьютер может уменьшить это воздействие на производительность, переопределив эти операции с использованием версий, которые более эффективны для конкретной системы.

### <a name="math"></a>Математический ###

<xref:microsoft.quantum.math>Пространство имен предоставляет множество полезных функций из [ `System.Math` класса](https://docs.microsoft.com/dotnet/api/system.math?view=netframework-4.7.1&preserve-view=true)библиотеки базовых классов .NET.
Эти функции можно использовать так же, как и любые другие Q# функции:

```qsharp
open Microsoft.Quantum.Math;
// ...
let y = Sin(theta);
```

Если статический метод .NET перегружен в зависимости от типа его аргументов, соответствующая Q# функция помечается суффиксом, указывающим тип входных данных:

```qsharp
let x = AbsI(-3); // x : Int = 3
let y = AbsD(-PI()); // y : Double = 3.1415...
```


### <a name="bitwise-operations"></a>Битовые операции ###

Наконец, <xref:microsoft.quantum.bitwise> пространство имен предоставляет несколько полезных функций для управления целыми числами с помощью побитовых операторов.
Например, <xref:microsoft.quantum.bitwise.parity> возвращает побитовую четность целого числа в виде другого целого числа.
