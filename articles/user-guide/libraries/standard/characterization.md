---
title: Посимвольная и статистика тактовой задержки
description: Узнайте, как статистика измерений из оценок этапов используется для оценки результирующих значений при программировании такта.
author: bradben
uid: microsoft.quantum.libraries.characterization
ms.author: martinro
ms.date: 12/11/2017
ms.topic: article
no-loc:
- 'Q#'
- '$$v'
ms.openlocfilehash: 51e7b3bcf4402a4d0ba5647643f284e9f10c3bb3
ms.sourcegitcommit: 29e0d88a30e4166fa580132124b0eb57e1f0e986
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/27/2020
ms.locfileid: "92692148"
---
# <a name="quantum-characterization-and-statistics"></a><span data-ttu-id="fbfb9-103">Посимвольная и статистика тактовой задержки</span><span class="sxs-lookup"><span data-stu-id="fbfb9-103">Quantum Characterization and Statistics</span></span> #

<span data-ttu-id="fbfb9-104">Очень важно иметь возможность объяснить влияние операций для разработки полезных алгоритмов тактовой задержки.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-104">It is critical to be able to characterize the effects of operations in order to develop useful quantum algorithms.</span></span>
<span data-ttu-id="fbfb9-105">Это сложно, так как каждое измерение тактовой системы возвращает не более одного бита информации.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-105">This is challenging because every measurement of a quantum system yields at most one bit of information.</span></span>
<span data-ttu-id="fbfb9-106">Чтобы изучить еиженвалуе, проверим состояние такта, результаты многих измерений должны быть соединены вместе, чтобы пользователь мог получить множество сведений, необходимых для представления этих концепций.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-106">In order to learn an eigenvalue, let alone a quantum state, the results of many measurements must be stitched together so that the user can glean the many bits of information needed to represent these concepts.</span></span>
<span data-ttu-id="fbfb9-107">Состояния тактов особенно досадной, так как [отсутствие клонирования Теорема](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) указывает, что нет способа изучать произвольное состояние такта из одной копии состояния, так как это позволяет создавать копии состояния.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-107">Quantum states are especially vexing because the [no-cloning theorem](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) states that there is no way to learn an arbitrary quantum state from a single copy of the state, because doing so would let you make copies of the state.</span></span>
<span data-ttu-id="fbfb9-108">Такая маскировка состояния такта от пользователя отражается на том, что не Q# предоставляет или даже не определяет состояние, которое *относится* к тактовым программам.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-108">This obfuscation of the quantum state from the user is reflected in the fact that Q# does not expose or even define what a state *is* to quantum programs.</span></span>
<span data-ttu-id="fbfb9-109">Поэтому мы подходим к тактовой обработке, рассматривая операции и состояния в виде черного ящика; Этот подход широко распространен с экспериментальной практикой, проверкой и проверкой тактовой задержки (ККВВ).</span><span class="sxs-lookup"><span data-stu-id="fbfb9-109">We thus approach quantum characterization by treating operations and states as black-box; this approach shares much in common with the experimental practice of quantum characterization, verification and validation (QCVV).</span></span>

<span data-ttu-id="fbfb9-110">Символьная кодировка отличается от многих других библиотек, обсуждаемых ранее.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-110">Characterization is distinct from many of the other libraries discussed previously.</span></span>
<span data-ttu-id="fbfb9-111">Целью этого является меньшее изучению классической информации о системе, а не выполнению единого преобразования в векторе состояния.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-111">The aim here is less to learn classical information about the system, rather than to perform a unitary transformation on a state vector.</span></span>
<span data-ttu-id="fbfb9-112">Таким образом, эти библиотеки должны смешивать как классические, так и тактовую обработку данных.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-112">These libraries must therefore blend both classical and quantum information processing.</span></span>


## <a name="iterative-phase-estimation"></a><span data-ttu-id="fbfb9-113">Оценка этапа итерации</span><span class="sxs-lookup"><span data-stu-id="fbfb9-113">Iterative Phase Estimation</span></span> ##

<span data-ttu-id="fbfb9-114">Просмотр тактовой задержки с точки зрения тактовой задержки предлагает полезную альтернативу оценки тактовой фазы.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-114">Viewing quantum programming in terms of quantum characterization suggests a useful alternative to quantum phase estimation.</span></span>
<span data-ttu-id="fbfb9-115">Это значит, что вместо подготовки $n $-кубит Register для хранения двоичного представления этапа, как в ходе оценки тактовой фазы, можно просмотреть оценку этапа как процесса, по которому *классический* агент узнает о свойствах тактовой системы через измерения.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-115">That is, instead of preparing an $n$-qubit register to contain a binary representation of the phase as in quantum phase estimation, we can view phase estimation as the process by which a *classical* agent learns properties of a quantum system through measurements.</span></span>
<span data-ttu-id="fbfb9-116">Мы работаем в качестве тактового случая с помощью этапа киккбакк, чтобы превратить приложения в операцию черного ящика в вращение неизвестного угла, но будет измерять анЦилла кубит, который мы повернут на каждом шаге сразу после поворота.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-116">We proceed as in the quantum case by using phase kickback to turn applications of a black-box operation into rotations by an unknown angle, but will measure the ancilla qubit that we rotate at each step immediately following the rotation.</span></span>
<span data-ttu-id="fbfb9-117">Это преимущество заключается в том, что для выполнения этапа киккбакк, описанного в тактовой ситуации, требуется только один дополнительный кубит, так как мы затем изучен этап от результатов измерения на каждом шаге итеративным образом.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-117">This has the advantage that we only require a single additional qubit to perform the phase kickback described in the quantum case, as we then learn the phase from the measurement results at each step in an iterative fashion.</span></span>  
<span data-ttu-id="fbfb9-118">Каждый из методов, предложенных ниже, использует другую стратегию для проектирования экспериментов и различных методов обработки данных для изучения этапа.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-118">Each of the methods proposed below uses a different strategy for designing experiments and different data processing methods to learn the phase.</span></span>  <span data-ttu-id="fbfb9-119">У каждого из них есть уникальные преимущества от строгой привязки к ошибкам, возможности включать в них более раннюю информацию, допускать ошибки или запускать на лимиттед классические компьютеры.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-119">They each have unique advantage ranging from having rigorous error bounds, to the abilities to incorporate prior information, tolerate errors or run on memory limitted classical computers.</span></span>

<span data-ttu-id="fbfb9-120">В обсуждении оценки итеративной фазы мы будем рассматривать единое $U $, заданное как черно-блочная операция.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-120">In discussing iterative phase estimation, we will consider a unitary $U$ given as a black-box operation.</span></span>
<span data-ttu-id="fbfb9-121">Как описано в разделе по Oracle в [структурах данных](xref:microsoft.quantum.libraries.data-structures), Q# Canon моделирует такие операции с помощью <xref:Microsoft.Quantum.Oracles.DiscreteOracle> определяемого пользователем типа, определенного типом кортежа `((Int, Qubit[]) => Unit : Adjoint, Controlled)` .</span><span class="sxs-lookup"><span data-stu-id="fbfb9-121">As described in the section on oracles in [data structures](xref:microsoft.quantum.libraries.data-structures), the Q# canon models such operations by the <xref:Microsoft.Quantum.Oracles.DiscreteOracle> user-defined type, defined by the tuple type `((Int, Qubit[]) => Unit : Adjoint, Controlled)`.</span></span>
<span data-ttu-id="fbfb9-122">Конкретнее, если `U : DiscreteOracle` , то `U(m)` реализует $U ^ m $ для `m : Int` .</span><span class="sxs-lookup"><span data-stu-id="fbfb9-122">Concretely, if `U : DiscreteOracle`, then `U(m)` implements $U^m$ for `m : Int`.</span></span>

<span data-ttu-id="fbfb9-123">После этого определения каждый этап итерационной оценки этапов продолжается путем подготовки вспомогательной кубит в состоянии $ \кет{+} $ вместе с начальным состоянием $ \кет{\фи} $, которое мы предполагаем, это [еиженвектор](xref:microsoft.quantum.concepts.matrix-advanced) $U (m) $, т. е. $U (m) \кет{\фи} = e ^ {им\фи} \ Сисакет {\ фи} $.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-123">With this definition in place, each step of iterative phase estimation proceeds by preparing an auxiliary qubit in the $\ket{+}$ state along with the initial state $\ket{\phi}$ that we assume is an [eigenvector](xref:microsoft.quantum.concepts.matrix-advanced) of $U(m)$, i.e. $U(m)\ket{\phi}= e^{im\phi}\ket{\phi}$.</span></span>  
<span data-ttu-id="fbfb9-124">Затем используется управляемое приложение класса, `U(m)` которое подготавливает состояние $ \лефт ( \_ m \фи) \кет{+} \ригхт) \кет{\фи} $.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-124">A controlled application of `U(m)` is then used which prepares the state $\left(R\_1(m \phi) \ket{+}\right)\ket{\phi}$.</span></span>
<span data-ttu-id="fbfb9-125">Как и в случае тактового случая, результат управляемого приложения Oracle точно такой `U(m)` же, как и результат применения $R _1 $ для неизвестного этапа в $ \кет{+} $, так что мы можем описать эффект $U $ в этом упрощенном виде.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-125">As in the quantum case, the effect of a controlled application of the oracle `U(m)` is precisely the same as the effect of applying $R_1$ for the unknown phase on $\ket{+}$, such that we can describe the effects of $U$ in this simpler fashion.</span></span>
<span data-ttu-id="fbfb9-126">При необходимости алгоритм поворачивает элемент управления кубит, применяя $R _1 (-м\сета) $ для получения состояния $ \кет{\пси} = \лефт (R \_ 1 (m [\фи-\сета]) \кет{+} \ригхт) \кет{\фи} $ $.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-126">Optionally, the algorithm then rotates the control qubit by applying $R_1(-m\theta)$ to obtain a state $\ket{\psi}=\left(R\_1(m [\phi-\theta]) \ket{+}\right)\ket{\phi}$$.</span></span>
<span data-ttu-id="fbfb9-127">Дополнительный кубит, используемый в качестве элемента управления для `U(m)` , затем измеряется в $X $ для получения единого классического `Result` .</span><span class="sxs-lookup"><span data-stu-id="fbfb9-127">The auxiliary qubit used as a control for `U(m)` is then measured in the $X$ basis to obtain a single classical `Result`.</span></span>

<span data-ttu-id="fbfb9-128">На этом этапе воссоздание этапа на основе `Result` значений, полученных с помощью итеративной оценки этапа, является классической проблемой статистического вывода.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-128">At this point, reconstructing the phase from the `Result` values obtained through iterative phase estimation is a classical statistical inference problem.</span></span>
<span data-ttu-id="fbfb9-129">Поиск значения $m $, который позволяет максимально увеличить объем полученной информации, по фиксированному методу вывода — это просто проблема в статистике.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-129">Finding the value of $m$ that maximizes the information gained, given a fixed inference method, is simply a problem in statistics.</span></span>
<span data-ttu-id="fbfb9-130">Мы Подчеркните это, кратко описывая оценку итеративного этапа на теоретическом уровне в формальном механизме оценки параметров Байеса, прежде чем продолжать описывать статистические алгоритмы, предоставляемые в Q# Canon для решения этой классической проблемы вывода.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-130">We emphasize this by briefly describing iterative phase estimation at a theoretical level in the Bayesian parameter estimation formalism before proceeding to describe the statistical algorithms provided in the Q# canon for solving this classical inference problem.</span></span>

### <a name="iterative-phase-estimation-without-eigenstates"></a><span data-ttu-id="fbfb9-131">Оценка этапа итерации без Еиженстатес</span><span class="sxs-lookup"><span data-stu-id="fbfb9-131">Iterative Phase Estimation Without Eigenstates</span></span> ###

<span data-ttu-id="fbfb9-132">Если указано состояние ввода, которое не является еиженстате, то есть, что если $U (m) \кет{\фи \_ j} = e ^ {им\фи \_ j} $, то процесс оценки этапа недетерминированно направляет состояние такта к одному еиженстате энергии.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-132">If an input state is provided that is not an eigenstate, which is to say that if $U(m)\ket{\phi\_j} = e^{im\phi\_j}$ then the process of phase estimation non-deterministically guides the quantum state towards a single energy eigenstate.</span></span>  <span data-ttu-id="fbfb9-133">Еиженстате, который в конечном итоге сходится с, — это еиженстате, который, скорее всего, будет изготовить `Result` .</span><span class="sxs-lookup"><span data-stu-id="fbfb9-133">The eigenstate it ultimately converges to is the eigenstate that is most likely to produce the observed `Result`.</span></span>

<span data-ttu-id="fbfb9-134">В частности, один шаг PE выполняет следующее неединое преобразование состояния \бегин{алигн} \ sum_j \Скрт{\пр (\фи \_ j)} \кет{\фи \_ j} \мапсто \сум \_ ж\фрак {\ sqrt {\ PR (\фи \_ j)} \скрт{\пр (\текст{ресулт} | \Phi \_ j)} \Ket{\Phi \_ j}} {\sqrt{\Pr (\Phi \_ j) \sum \_ j \Pr (\Text{Result} | \Phi \_ j)}}.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-134">Specifically, a single step of PE performs the following non-unitary transformation on a state \begin{align} \sum_j \sqrt{\Pr(\phi\_j)} \ket{\phi\_j} \mapsto \sum\_j\frac{\sqrt{\Pr(\phi\_j)}\sqrt{\Pr(\text{Result}|\phi\_j)}\ket{\phi\_j}}{\sqrt{\Pr(\phi\_j)\sum\_j \Pr(\text{Result}|\phi\_j)}}.</span></span>
<span data-ttu-id="fbfb9-135">\енд{алигн} в процессе итерации по нескольким `Result` значениям, еиженстатес, у которых нет максимального значения $ \ prod_k \пр (\текст{ресулт} \_ k | \фи \_ j) $, будет экспоненциально подавлен.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-135">\end{align} As this process is iterated over multiple `Result` values, eigenstates that do not have maximal values of $\prod_k\Pr(\text{Result}\_k|\phi\_j)$ will be exponentially suppressed.</span></span>
<span data-ttu-id="fbfb9-136">В результате процесс вывода, как правило, сходится к состояниям с одним еиженвалуе, если эксперименты выбраны правильно.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-136">As a result, the inference process will tend to converge to states with a single eigenvalue if the experiments are chosen properly.</span></span>

<span data-ttu-id="fbfb9-137">Алгоритм Байеса "Теорема дополнительно предлагает, что состояние, полученное в результате оценки фазы, должно быть написано в форме \бегин{алигн} \Фрак{\скрт{\пр (\фи \_ j)} \скрт{\пр (\текст{ресулт} | \фи \_ j)} \кет{\фи \_ j}} {\скрт{\пр (\Phi \_ j) \Sum \_ j \Pr (\Text{Result} | \Phi \_ j)}} = \ sum_j \sqrt{\Pr (\Phi \_ j | \Text{result})} \ket{\Phi \_ j}.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-137">Bayes' theorem further suggests that the state that results from phase estimation be written in the form \begin{align} \frac{\sqrt{\Pr(\phi\_j)}\sqrt{\Pr(\text{Result}|\phi\_j)}\ket{\phi\_j}}{\sqrt{\Pr(\phi\_j)\sum\_j \Pr(\text{Result}|\phi\_j)}}=\sum_j \sqrt{\Pr(\phi\_j|\text{Result})} \ket{\phi\_j}.</span></span>
<span data-ttu-id="fbfb9-138">\енд{алигн} здесь $ \Пр (\фи \_ j | \текст{ресулт}) $ может быть интерпреттед, как вероятность того, что один из них будет ascribe к каждой гипотезе о еиженстатес.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-138">\end{align} Here $\Pr(\phi\_j|\text{Result})$ can be interpretted as the probability that one would ascribe to each hypothesis about the eigenstates given:</span></span>

1. <span data-ttu-id="fbfb9-139">знание состояния такта перед измерением,</span><span class="sxs-lookup"><span data-stu-id="fbfb9-139">knowledge of the quantum state prior to measurement,</span></span>
2. <span data-ttu-id="fbfb9-140">знания о еиженстатесх $U $ и,</span><span class="sxs-lookup"><span data-stu-id="fbfb9-140">knowledge of the eigenstates of $U$ and,</span></span>
3. <span data-ttu-id="fbfb9-141">знание еиженвалуеса $U $.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-141">knowledge of the eigenvalues of $U$.</span></span>

<span data-ttu-id="fbfb9-142">Изучение этих трех моментов зачастую является экспоненциальным сложностью на самом простом компьютере.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-142">Learning these three things is often exponentially hard on a classical computer.</span></span>
<span data-ttu-id="fbfb9-143">Программа оценки этапа возникает без небольших экстентов, от того факта, что она может выполнять такую задачу по обучению тактов, не зная ни одного.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-143">The utility of phase estimation arises, to no small extent, from the fact that it can perform such a quantum learning task without knowing any of them.</span></span>
<span data-ttu-id="fbfb9-144">Оценка этапа по этой причине появляется в нескольких тактовых алгоритмах, которые обеспечивают экспоненциальное ускорение.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-144">Phase estimation for this reason appears within a number of quantum algorithms that provide exponential speedups.</span></span>

### <a name="bayesian-phase-estimation"></a><span data-ttu-id="fbfb9-145">Оценка этапа Байеса</span><span class="sxs-lookup"><span data-stu-id="fbfb9-145">Bayesian Phase Estimation</span></span> ###

> [!TIP]
> <span data-ttu-id="fbfb9-146">Дополнительные сведения об оценке этапа Байеса на практике см. в примере [**фасистиматион**](https://github.com/microsoft/Quantum/tree/main/samples/characterization/phase-estimation) .</span><span class="sxs-lookup"><span data-stu-id="fbfb9-146">For more details on Bayesian phase estimation in practice, please see the [**PhaseEstimation**](https://github.com/microsoft/Quantum/tree/main/samples/characterization/phase-estimation) sample.</span></span>

<span data-ttu-id="fbfb9-147">Идея оценки этапа Байеса проста.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-147">The idea of Bayesian phase estimation is simple.</span></span>
<span data-ttu-id="fbfb9-148">Вы соберете статистику измерений из протокола оценки этапа, а затем обрабатываете результаты с помощью вывода Байеса и выдаете оценку параметра.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-148">You collect measurement statistics from the phase estimation protocol and then you process the results using Bayesian inference and provide an estimate of the parameter.</span></span>
<span data-ttu-id="fbfb9-149">Эта обработка дает оценку еиженвалуе, а также неопределенности в этой оценке.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-149">This processing gives you an estimate of the eigenvalue as well as the uncertainty in that estimate.</span></span>
<span data-ttu-id="fbfb9-150">Он также позволяет выполнять адаптивные эксперименты и использовать более раннюю информацию.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-150">It also allows you to perform adaptive experiments and utilize prior information.</span></span>
<span data-ttu-id="fbfb9-151">Недостаток принципов метода заключается в том, что он требует вычислений.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-151">The methods' principle drawback is that it is computationally demanding.</span></span>

<span data-ttu-id="fbfb9-152">Чтобы понять, как работает этот процесс вывода Байеса, рассмотрите возможность обработки одного `Zero` результата.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-152">To understand how this Bayesian inference process works, consider the case of processing a single `Zero` result.</span></span>
<span data-ttu-id="fbfb9-153">Обратите внимание, что $X = \кет{+} \бра{+}-\кет {-} \бра {-} $, например, $ \кет{+} $ является единственным положительным еиженстатеом $X $, соответствующим `Zero` .</span><span class="sxs-lookup"><span data-stu-id="fbfb9-153">Note that $X = \ket{+}\bra{+} - \ket{-}\bra{-}$, such that $\ket{+}$ is the only positive eigenstate of $X$ corresponding to `Zero`.</span></span>
<span data-ttu-id="fbfb9-154">`Zero`Кубит \пр (\тексттт{зеро} | \пси) = \лефт | \бракет{+ | \пси} \right | ^ 2. это вероятность наблюдения для [ `PauliX` измерения](xref:microsoft.quantum.concepts.pauli) в первой области, заданной входным состоянием $ \кет{\пси}\кет{\фи} $.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-154">The probability of observing `Zero` for a [`PauliX` measurement](xref:microsoft.quantum.concepts.pauli) on the first qubit given an input state $\ket{\psi}\ket{\phi}$ is thus \begin{equation} \Pr(\texttt{Zero} | \psi) = \left| \braket{+ | \psi} \right|^2.</span></span>
<span data-ttu-id="fbfb9-155">\енд{екуатион} в случае с итеративной оценкой этапа, у нас есть $ \кет{\пси} = R_1 (m [\фи-\сета]) \кет{+} $, например \бегин{алигн} \Пр (\Тексттт{зеро} | \фи; m, \сета) & = \left | \бракет{+ | R_1 (m [\фи-\сета]) | +} \ригхт | ^ 2 \\ \\ & = \лефт | \frac12 \лефт (\бра {0} + \бра {1} \ригхт) \лефт (\кет {0} + e ^ {i m [\фи-\сета]} \кет {1} \ригхт) \ригхт | ^ 2 \\ \\ & = \лефт | \frac{1 + e ^ {i m [\фи-\сета]}} {2} \right | ^ 2 \\ \\ & = \cos ^ 2 (m [\Phi-\theta]/2) \tag{★} \label{EQ: этап — средство EST-правдоподобие}.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-155">\end{equation} In the case of iterative phase estimation, we have that $\ket{\psi} = R_1(m [\phi-\theta]) \ket{+}$, such that \begin{align} \Pr(\texttt{Zero} | \phi; m,\theta) & = \left| \braket{+ | R_1(m [\phi-\theta]) | +} \right|^2 \\\\ & = \left| \frac12 \left( \bra{0} + \bra{1} \right) \left( \ket{0} + e^{i m [\phi-\theta]} \ket{1} \right) \right|^2 \\\\ & = \left| \frac{1 + e^{i m [\phi-\theta]}}{2} \right|^2 \\\\ & = \cos^2(m [\phi-\theta] / 2) \tag{★} \label{eq:phase-est-likelihood}.</span></span>
<span data-ttu-id="fbfb9-156">\енд{алигн}, то есть оценка поэтапной итерации состоит из изучения частоты колебаний функции синусоидальной, учитывая возможность перелистывания монет с сдвигом, заданным этим синусоид.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-156">\end{align} That is, iterative phase estimation consists of learning the oscillation frequency of a sinusoidal function, given the ability to flip a coin with a bias given by that sinusoid.</span></span>
<span data-ttu-id="fbfb9-157">В следующей традиционной классической терминологии мы вызываем $ \екреф{ЕК: Phase-EST-правдоподобие} $ *функции правдоподобия* для оценки итеративной фазы.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-157">Following traditional classical terminology, we call $\eqref{eq:phase-est-likelihood}$ the *likelihood function* for iterative phase estimation.</span></span>

<span data-ttu-id="fbfb9-158">Наблюдая за `Result` функцией правдоподобия итеративной оценки, мы можем использовать правило алгоритма Байеса, чтобы предписывает, что следует предполагать, что этап должен следовать за этим наблюдением.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-158">Having observed a `Result` from the iterative phase estimation likelihood function, we can then use Bayes' rule to prescribe what we should believe the phase to be following that observation.</span></span>
<span data-ttu-id="fbfb9-159">В частности, \бегин{екуатион} \Пр (\фи | d) = \Фрак{\пр (d | \фи) \Пр (\фи)} {\инт \Пр (d | \фи) \Пр (\фи) {\масрм d} \фи} \Пр (\Phi), \end{Equation}, где $d \in \\ {\texttt{Zero}, \texttt{One} \\ } $ — а `Result` , где $ \Pr (\Phi) $ описывает наши предыдущие воззрений о $ \Phi $.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-159">Concretely, \begin{equation} \Pr(\phi | d) = \frac{\Pr(d | \phi) \Pr(\phi)}{\int \Pr(d | \phi) \Pr(\phi){\mathrm d}\phi} \Pr(\phi), \end{equation} where $d \in \\{\texttt{Zero}, \texttt{One}\\}$ is a `Result`, and where $\Pr(\phi)$ describes our prior beliefs about $\phi$.</span></span>
<span data-ttu-id="fbfb9-160">Это делает итеративную природу оценки итеративной фазы явной, так как апостериорные Distribution $ \Пр (\фи | d) $ описывает наш воззрений непосредственно перед нашим наблюдением за следующим `Result` .</span><span class="sxs-lookup"><span data-stu-id="fbfb9-160">This then makes the iterative nature of iterative phase estimation explicit, as the posterior distribution $\Pr(\phi | d)$ describes our beliefs immediately preceding our observation of the next `Result`.</span></span>

<span data-ttu-id="fbfb9-161">В любой момент выполнения этой процедуры мы можем сообщить этап $ \хат{\фи} $, выводимый классическим контроллером как \бегин{екуатион} \хат{\фи} \масрел{: =} \експект [\фи | \текст{Дата}] = \инт \фи \Pr (\Phi | \Text{Data}) {\mathrm d} \Phi, \end{Equation}, где $ \Text{Data} $ означает всю запись всех `Result` полученных значений.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-161">At any point during this procedure, we can report the phase $\hat{\phi}$ inferred by the classical controller as \begin{equation} \hat{\phi} \mathrel{:=} \expect[\phi | \text{data}] = \int \phi \Pr(\phi | \text{data}) {\mathrm d}\phi, \end{equation} where $\text{data}$ stands for the entire record of all `Result` values obtained.</span></span>

<span data-ttu-id="fbfb9-162">Точный вывод Байеса является нерекомендуемым.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-162">Exact Bayesian inference is in practice intractable.</span></span>
<span data-ttu-id="fbfb9-163">Чтобы увидеть это, мы хотели бы изучить $n $-разрядную переменную $x $.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-163">To see this imagine we wish to learn an $n$-bit variable $x$.</span></span>
<span data-ttu-id="fbfb9-164">В предыдущем дистрибутиве $ \Пр (x) $ предусмотрена поддержка более чем $2 ^ n $ гипотетических значений $x $.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-164">The prior distribution $\Pr(x)$ has support over $2^n$ hypothetical values of $x$.</span></span>
<span data-ttu-id="fbfb9-165">Это означает, что если нам требуется очень точная оценка $x $, оценка фазы Байеса может потребовать недостаточного объема памяти и времени обработки.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-165">This means that if we need a highly accurate estimate of $x$ then Bayesian phase estimation may need prohibitive memory and processing time.</span></span>
<span data-ttu-id="fbfb9-166">Хотя для некоторых приложений, таких как моделирование такта, требуемая точность лимиттед не исключает такие методы, как алгоритмы Шор, не может использовать точное определение Байеса на этапе оценки этапа.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-166">While for some applications, such as quantum simulation, the limitted accuracy required does not preclude such methods other applications, such as Shor's algorithm, cannot use exact Bayesian inference within its phase estimation step.</span></span>  <span data-ttu-id="fbfb9-167">По этой причине мы также предоставляем реализации для приблизительных методов Байеса, таких как [Оценка этапа случайного анализа (рвпе)](xref:Microsoft.Quantum.Research.Characterization.RandomWalkPhaseEstimation) , а также небайеса подходов, таких как [устойчивая Оценка этапа](xref:Microsoft.Quantum.Characterization.RobustPhaseEstimation).</span><span class="sxs-lookup"><span data-stu-id="fbfb9-167">For this reason, we also provide implementations for approximate Bayesian methods such as [random walk phase estimation (RWPE)](xref:Microsoft.Quantum.Research.Characterization.RandomWalkPhaseEstimation) and also non-Bayesian approaches such as [robust phase estimation](xref:Microsoft.Quantum.Characterization.RobustPhaseEstimation).</span></span>

### <a name="robust-phase-estimation"></a><span data-ttu-id="fbfb9-168">Надежная оценка этапа</span><span class="sxs-lookup"><span data-stu-id="fbfb9-168">Robust Phase Estimation</span></span> ###

<span data-ttu-id="fbfb9-169">*Постериори* байесаная Оценка этапа оценки фазы от результатов измерения является экспоненциально сложной в худшем случае.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-169">A maximum *a posteriori* Bayesian reconstruction of a phase estimate from measurement results is exponentially hard in the worst-case.</span></span> <span data-ttu-id="fbfb9-170">Поэтому большинство алгоритмов практической оценки практических этапов приводят к возникновению некоторого качества в процессе реконструкции, в Exchange — на уровне классической последующей обработки, которая вместо этого масштабируется с учетом количества произведенных измерений.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-170">Thus most practical phase estimation algorithms sacrifice some quality in the reconstruction, in exchange for an amount of classical post-processing that instead scales polynomially with the number of measurements made.</span></span>

<span data-ttu-id="fbfb9-171">Одним из таких примеров с эффективным этапом пост-обработки является [надежный алгоритм оценки этапа](https://arxiv.org/abs/1502.02677)с сигнатурой и входными данными, упомянутыми выше.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-171">One such example with an efficient classical post-processing step is the [robust phase estimation algorithm](https://arxiv.org/abs/1502.02677), with its signature and inputs mentioned above.</span></span> <span data-ttu-id="fbfb9-172">Предполагается, что входные целые квадратные ящики $U $ упаковываются как `DiscreteOracle` тип, и поэтому только запрашивает целочисленные значения управляемых-$U $.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-172">It assumes that input unitary black-boxes $U$ are packaged as `DiscreteOracle` type, and therefore only queries integer powers of controlled-$U$.</span></span> <span data-ttu-id="fbfb9-173">Если входное состояние в `Qubit[]` регистре — еиженстате $U \кет{\пси} = e ^ {и\фи} \ Сисакет {\ PSI} $, то надежный алгоритм оценки этапа Возвращает оценку $ \хат{\фи}\ин [-\пи, \пи) $ из $ \фи $ в качестве `Double` .</span><span class="sxs-lookup"><span data-stu-id="fbfb9-173">If the input state in the `Qubit[]` register is an eigenstate $U\ket{\psi}=e^{i\phi}\ket{\psi}$, the robust phase estimation algorithm returns an estimate $\hat{\phi}\in[-\pi,\pi)$ of $\phi$ as a `Double`.</span></span>

<span data-ttu-id="fbfb9-174">Самая важная возможность надежной оценки этапа, которая является общей для большинства полезных вариантов, заключается в том, что качество реконструкции $ \хат{\фи} $ имеет определенный смысл Гейзенбега.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-174">The most important feature of robust phase estimation, which is shared with most other useful variants, is that the reconstruction quality of $\hat{\phi}$ is in some sense Heisenberg-limited.</span></span> <span data-ttu-id="fbfb9-175">Это означает, что если отклонение $ \хат{\фи} $ от истинного значения равно $ \сигма $, то $ \сигма $ масштабируется обратно, пропорционально общему количеству запросов $Q $, выполненных в контролируемой $U $, т. е. $ \сигма = \Маскал{о} (1/Q) $.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-175">This means that if the deviation of $\hat{\phi}$ from the true value is $\sigma$, then $\sigma$ scales inversely-proportional to the total number of queries $Q$ made to controlled-$U$, i.e. $\sigma=\mathcal{O}(1/Q)$.</span></span> <span data-ttu-id="fbfb9-176">Теперь определение отклонения зависит от различных алгоритмов оценки.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-176">Now, the definition of deviation varies between different estimation algorithms.</span></span> <span data-ttu-id="fbfb9-177">В некоторых случаях это может означать, что по крайней мере $ \Маскал{о} (1) $ вероятность, ошибка оценки $ | \хат{\фи}-\фи | \_ \Цирк\ле \сигма $ для некоторой циклической меры $ \Цирк $.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-177">In some cases, it may mean that with at least $\mathcal{O}(1)$ probability, the estimation error $|\hat{\phi}-\phi|\_\circ\le \sigma$ on some circular measure $\circ$.</span></span> <span data-ttu-id="fbfb9-178">Для надежной оценки фазы отклонение является точной дисперсией $ \сигма ^ 2 = \Масбб{е} \_ \хат{\фи} [(\мод \_ {2 \ PI} (\хат{\фи}-\фи + \пи)-\пи) ^ 2] $, если мы раз периодические этапы на один конечный интервал $ (-\пи, \пи] $).</span><span class="sxs-lookup"><span data-stu-id="fbfb9-178">For robust phase estimation, deviation is precisely the variance $\sigma^2 = \mathbb{E}\_\hat{\phi}[(\mod\_{2\pi}(\hat{\phi}-\phi +\pi)-\pi)^2]$ if we unwrap periodic phases onto a single finite interval $(-\pi,\pi]$.</span></span> <span data-ttu-id="fbfb9-179">Точнее, стандартное отклонение в надежной оценке фазы соответствует неравенствам $ $ \бегин{алигн} 2,0 \пи/Q \ле \сигма \ле 2 \ PI/2 ^ {n} \ле 10.7 \ PI/Q, \енд{алигн} $ $, где нижняя граница достигает предела асимптотикалли Large $Q $, а верхняя граница гарантирована даже для мелких размеров выборки.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-179">More precisely, the standard deviation in robust phase estimation satisfies the inequalities $$ \begin{align} 2.0 \pi / Q \le \sigma \le 2\pi / 2^{n} \le 10.7\pi / Q, \end{align} $$ where the lower bound is reached in the limit of asymptotically large $Q$, and the upper bound is guaranteed even for small sample sizes.</span></span>  <span data-ttu-id="fbfb9-180">Обратите внимание, что $n $ выбрано `bitsPrecision` входными данными, которые неявно определяют $Q $.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-180">Note that $n$ selected by the `bitsPrecision` input, which implicitly defines $Q$.</span></span>

<span data-ttu-id="fbfb9-181">К другим важным сведениям относится, скажем, небольшие издержки, связанные только с $1 $ анЦилла кубит, или что процедура не является адаптивной, то есть необходимая последовательность тактов тактовой эксперимента не зависит от промежуточных результатов измерения.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-181">Other relevant details include, say, the small space overhead of just $1$ ancilla qubit, or that the procedure is non-adaptive, meaning the required sequence of quantum experiments is independent of the intermediate measurement outcomes.</span></span> <span data-ttu-id="fbfb9-182">В этом и будущих примерах, где важно выбрать алгоритм оценки этапа, один из них должен ссылаться на документацию, например, @"microsoft.quantum.characterization.robustphaseestimation" и на упоминаемые публикации для получения дополнительных сведений и для их реализации.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-182">In this and forthcoming examples where the choice of phase estimation algorithm is important, one should one should refer to the documentation such as @"microsoft.quantum.characterization.robustphaseestimation" and the referenced publications therein for more information and for their the implementation.</span></span>

> [!TIP]
> <span data-ttu-id="fbfb9-183">Существует много примеров, где используется устойчивая Оценка этапа.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-183">There are many samples where robust phase estimation is used.</span></span> <span data-ttu-id="fbfb9-184">Для оценки этапа при извлечении энергии в энергопотреблении различных физических систем см. пример [ **моделирования "H2**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line)", пример [ **симплеисинг**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/simple)и [ **модель Хуббард**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/hubbard).</span><span class="sxs-lookup"><span data-stu-id="fbfb9-184">For phase estimation in extracting the ground state energy of various physical system, please see the [**H2 simulation** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line), the [**SimpleIsing** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/simple), and the [**Hubbard model** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/hubbard).</span></span>


### <a name="continuous-oracles"></a><span data-ttu-id="fbfb9-185">Непрерывные Oracle</span><span class="sxs-lookup"><span data-stu-id="fbfb9-185">Continuous Oracles</span></span> ###

<span data-ttu-id="fbfb9-186">Кроме того, можно обобщить модель Oracle, использованную выше, чтобы обеспечить непрерывную репликацию Oracle, смоделированную по типу Canon <xref:Microsoft.Quantum.Oracles.ContinuousOracle> .</span><span class="sxs-lookup"><span data-stu-id="fbfb9-186">We can also generalize from the oracle model used above to allow for continuous-time oracles, modeled by the canon type <xref:Microsoft.Quantum.Oracles.ContinuousOracle>.</span></span>
<span data-ttu-id="fbfb9-187">Учтите, что вместо одного отдельного оператора $U $ у нас есть семейство единых операторов $U (t) $ для $t \ин \Масбб{р} $, что $U (t) U (s) $ = $U (t + s) $.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-187">Consider that instead of a single unitary operator $U$, we have a family of unitary operators $U(t)$ for $t \in \mathbb{R}$ such that $U(t) U(s)$ = $U(t + s)$.</span></span>
<span data-ttu-id="fbfb9-188">Это более слабая инструкция, чем в отдельном случае, так как мы можем создать <xref:Microsoft.Quantum.Oracles.DiscreteOracle> с помощью ограничения $t = m \, \делта t $ для некоторых фиксированных $ \делта t $.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-188">This is a weaker statement than in the discrete case, since we can construct a <xref:Microsoft.Quantum.Oracles.DiscreteOracle> by restricting $t = m\,\delta t$ for some fixed $\delta t$.</span></span>
<span data-ttu-id="fbfb9-189">По [теоремау камень](https://en.wikipedia.org/wiki/Stone%27s_theorem_on_one-parameter_unitary_groups)$U (t) = \експ (i H t) $ для какого-либо оператора $H $, где $ \експ $ — это матрица, экспоненциальная, как описано в [расширенных матрицах](xref:microsoft.quantum.concepts.matrix-advanced).</span><span class="sxs-lookup"><span data-stu-id="fbfb9-189">By [Stone's theorem](https://en.wikipedia.org/wiki/Stone%27s_theorem_on_one-parameter_unitary_groups), $U(t) = \exp(i H t)$ for some operator $H$, where $\exp$ is the matrix exponential as described in [advanced matrices](xref:microsoft.quantum.concepts.matrix-advanced).</span></span>
<span data-ttu-id="fbfb9-190">Еиженстате $ \кет{\фи} $ of $H $, который $H \кет{\фи} = \фи \кет{\фи} $, также является еиженстате $U (t) $ для всех $t $, \бегин{екуатион} U (t) \кет{\фи} = e ^ {i \Phi t} \ket{\Phi}.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-190">An eigenstate $\ket{\phi}$ of $H$ such that $H \ket{\phi} = \phi \ket{\phi}$ is then also an eigenstate of $U(t)$ for all $t$, \begin{equation} U(t) \ket{\phi} = e^{i \phi t} \ket{\phi}.</span></span>
<span data-ttu-id="fbfb9-191">\енд{екуатион}</span><span class="sxs-lookup"><span data-stu-id="fbfb9-191">\end{equation}</span></span>

<span data-ttu-id="fbfb9-192">Можно применить точный анализ, обсуждаемый для [оценки этапа Байеса](#bayesian-phase-estimation) , и функция правдоподобия точно такая же, как для этой более общей модели Oracle: $ $ \Пр (\тексттт{зеро} | \фи; t, \сета) = \кос ^ 2 \ Left (\фрак{т [\фи-\сета]} {2} \ригхт).</span><span class="sxs-lookup"><span data-stu-id="fbfb9-192">The exact same analysis discussed for [Bayesian phase estimation](#bayesian-phase-estimation) can be applied, and the likelihood function is the precisely the same for this more general oracle model: $$ \Pr(\texttt{Zero} | \phi; t,\theta)=\cos^2\left(\frac{t[\phi -\theta]}{2}\right).</span></span>
<span data-ttu-id="fbfb9-193">$ $ Более того, если $U $ является имитацией динамического генератора, как в случае с [имитацией хамилтониан](xref:microsoft.quantum.libraries.applications#hamiltonian-simulation), мы интерпретируем $ \фи $ как энергия.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-193">$$ Moreover, if $U$ is a simulation of a dynamical generator, as is the case for [Hamiltonian simulation](xref:microsoft.quantum.libraries.applications#hamiltonian-simulation), we interpret $\phi$ as an energy.</span></span>
<span data-ttu-id="fbfb9-194">Таким образом, использование оценки этапа с непрерывными запросами позволяет нам изучать смоделированный [спектр молекул](https://arxiv.org/abs/quant-ph/0604193), [материалов](https://arxiv.org/abs/1510.03859) или [полей теории](https://arxiv.org/abs/1111.3633v2) , не нарушая выбор экспериментов, требуя, чтобы $t $ быть целым числом.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-194">Thus, using phase estimation with continuous queries allows us to learn the simulated [energy spectrum of molecules](https://arxiv.org/abs/quant-ph/0604193), [materials](https://arxiv.org/abs/1510.03859) or [field theories](https://arxiv.org/abs/1111.3633v2) without having to compromise our choice of experiments by requiring $t$ to be an integer.</span></span>

### <a name="random-walk-phase-estimation"></a><span data-ttu-id="fbfb9-195">Оценка этапа случайного анализа</span><span class="sxs-lookup"><span data-stu-id="fbfb9-195">Random Walk Phase Estimation</span></span> ###

<span data-ttu-id="fbfb9-196">Q# предоставляет полезную аппроксимацию оценки этапа Байеса, предназначенной для использования близкого к такту устройства, работающего с условием случайного анализа записи данных, полученной из оценки итеративной фазы.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-196">Q# provides a useful approximation of Bayesian phase estimation designed for use close to quantum devices that operates by conditioning a random walk on the data record obtained from iterative phase estimation.</span></span>
<span data-ttu-id="fbfb9-197">Этот метод является как адаптивным, так и полностью детерминированным, что позволяет использовать почти оптимальное масштабирование ошибок в оценочной фазе $ \хат{\фи} $ с очень низкими заголовками памяти.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-197">This method is both adaptive and entirely deterministic, allowing for near-optimal scaling of errors in the estimated phase $\hat{\phi}$ with very low memory overheads.</span></span>

<span data-ttu-id="fbfb9-198">Протокол использует приблизительный метод вывода Байеса, который предполагает, что прежнее распределение имеет значение "Гауссу".</span><span class="sxs-lookup"><span data-stu-id="fbfb9-198">The protocol uses an approximate Bayesian inference method that assumes the prior distribution is Gaussian.</span></span>
<span data-ttu-id="fbfb9-199">Это допущение по Гауссу позволяет нам использовать аналитическую формулу для эксперимента, которая уменьшает апостериорные дисперсию.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-199">This Gaussian assumption allows us to use an analytical formula for the experiment that minimizes the posterior variance.</span></span>
<span data-ttu-id="fbfb9-200">Затем алгоритм, основанный на результатах этого эксперимента, сдвигает оценку $ \фи $ Left или right на предварительно определенный объем и сжимает дисперсию по заранее определенному объему.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-200">The algorithm then, based on the outcome of that experiment, shifts the estimate of $\phi$ left or right by a pre-determined amount and shrinks the variance by a pre-determined amount.</span></span>
<span data-ttu-id="fbfb9-201">Это означает, что при следующем эксперименте все сведения, необходимые для указания геометрического значения в $ \фи $, задаются в соответствии с заданными по Гауссу.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-201">This mean and variance give all the information that is needed to specify a Gaussian prior on $\phi$ for the next experiment.</span></span>
<span data-ttu-id="fbfb9-202">Непредвиденные сбои измерения или истинный результат в заключительном фрагменте исходного ранее, может привести к сбою этого метода.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-202">Unexpected measurement failures, or the true result being on the tails of the initial prior, can cause this method to fail.</span></span>
<span data-ttu-id="fbfb9-203">Она восстанавливается после сбоя, выполняя эксперименты, чтобы проверить, подходит ли текущее среднее и стандартное отклонение для системы.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-203">It recovers from failure by performing experiments to test whether the current mean and standard deviation are appropriate for the system.</span></span>
<span data-ttu-id="fbfb9-204">Если это не так, то алгоритм выполняет обратный шаг прохода и процесс продолжится.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-204">If they are not, then the algorithm does an inverse step of the walk and the process continues.</span></span>
<span data-ttu-id="fbfb9-205">Возможность выполнять шаг назад также позволяет алгоритму изучать даже в том случае, если первое предыдущее стандартное отклонение инапроприатели мало.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-205">The ability to step backwards also allows the algorithm to learn even if the initial prior standard deviation is inapropriately small.</span></span>

## <a name="calling-phase-estimation-algorithms"></a><span data-ttu-id="fbfb9-206">Алгоритмы оценки этапа вызова</span><span class="sxs-lookup"><span data-stu-id="fbfb9-206">Calling Phase Estimation Algorithms</span></span> ##

<span data-ttu-id="fbfb9-207">Каждая операция оценки этапа, обеспечиваемая Q# Canon, принимает другой набор входных данных, обменяя качество, которое мы хотим используть для окончательной оценки $ \хат{\фи} $.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-207">Each phase estimation operation provided with the Q# canon takes a different set of inputs parameterizing the quality that we demand out of the final estimate $\hat{\phi}$.</span></span>
<span data-ttu-id="fbfb9-208">Однако эти различные входные данные совместно используют несколько общих входных данных, так что частичное применение параметров качества приводит к распространенной сигнатуре.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-208">These various inputs, however, all share several inputs in common, such that partial application over the quality parameters results in a common signature.</span></span>
<span data-ttu-id="fbfb9-209">Например, операция, <xref:Microsoft.Quantum.Characterization.RobustPhaseEstimation> описанная в следующем разделе, имеет следующую сигнатуру:</span><span class="sxs-lookup"><span data-stu-id="fbfb9-209">For example, the <xref:Microsoft.Quantum.Characterization.RobustPhaseEstimation> operation discussed in the next section has the following signature:</span></span>

```qsharp
operation RobustPhaseEstimation(bitsPrecision : Int, oracle : DiscreteOracle, eigenstate : Qubit[])  : Double
```

<span data-ttu-id="fbfb9-210">`bitsPrecision`Входные данные уникальны для `RobustPhaseEstimation` , хотя `oracle` и `eigenstate` являются общими.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-210">The `bitsPrecision` input is unique to `RobustPhaseEstimation`, while `oracle` and `eigenstate` are in common.</span></span>
<span data-ttu-id="fbfb9-211">Таким образом, как видно в **H2Sample** , операция может принять алгоритм оценки итеративной фазы с входными данными формы `(DiscreteOracle, Qubit[]) => Unit` , чтобы позволить пользователю указать алгоритмы произвольной оценки этапа:</span><span class="sxs-lookup"><span data-stu-id="fbfb9-211">Thus, as seen in **H2Sample** , an operation can accept an iterative phase estimation algorithm with an input of the form `(DiscreteOracle, Qubit[]) => Unit` to allow a user to specify arbitrary phase estimation algorithms:</span></span>

```qsharp
operation H2EstimateEnergy(
    idxBondLength : Int,
    trotterStepSize : Double,
    phaseEstAlgorithm : ((DiscreteOracle, Qubit[]) => Double))
: Double
```

<span data-ttu-id="fbfb9-212">Эти алгоритмы многоэтапной оценки оптимизированы для различных свойств и входных параметров, которые должны быть понятны, чтобы сделать лучший выбор для целевого приложения.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-212">These myriad phase estimation algorithms are optimized for different properties and input parameters, which must be understood to make the best choice for the target application.</span></span> <span data-ttu-id="fbfb9-213">Например, некоторые алгоритмы оценки этапа являются адаптивными. Это означает, что будущие шаги будут управляться в классическом виде по результатам измерения предыдущих шагов.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-213">For instance, some phase estimation algorithms are adaptive, meaning that future steps are classically controlled by the measurement results of previous steps.</span></span> <span data-ttu-id="fbfb9-214">Для некоторых требуется возможность експонентиате единую форму Oracle с помощью произвольных реальных степеней, а для других требуются только целые значения, но они могут только разрешать этап оценки остатка от деления $2 \ PI $.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-214">Some require the ability to exponentiate its black-box unitary oracle by arbitrary real powers, and others only require integer powers but are only able to resolve a phase estimate modulo $2\pi$.</span></span> <span data-ttu-id="fbfb9-215">Для некоторых требуется много вспомогательных Кубитс, а для других требуется только одна.</span><span class="sxs-lookup"><span data-stu-id="fbfb9-215">Some require many auxiliary qubits, and others require only one.</span></span>

<span data-ttu-id="fbfb9-216">Аналогично, использование оценки этапа случайного анализа выполняется практически так же, как и для других алгоритмов, предоставляемых с помощью Canon:</span><span class="sxs-lookup"><span data-stu-id="fbfb9-216">Similarly, using random walk phase estimation proceeds in much the same way as for other algorithms provided with the canon:</span></span>

```qsharp
operation ApplyExampleOracle(
    eigenphase : Double,
    time : Double,
    register : Qubit[])
: Unit is Adj + Ctl {
    Rz(2.0 * eigenphase * time, register[0]);
}

operation EstimateBayesianPhase(eigenphase : Double) : Double {
    let oracle = ContinuousOracle(ApplyExampleOracle(eigenphase, _, _));
    using (eigenstate = Qubit()) {
        X(eigenstate);
        // The additional inputs here specify the mean and variance of the prior, the number of
        // iterations to perform, how many iterations to perform as a maximum, and how many
        // steps to roll back on an approximation failure.
        let est = RandomWalkPhaseEstimation(0.0, 1.0, 61, 100000, 1, oracle, [eigenstate]);
        Reset(eigenstate);
        return est;
    }
}
```
