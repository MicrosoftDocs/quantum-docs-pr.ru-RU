---
title: Посимвольная и статистика тактовой задержки
description: Узнайте, как статистика измерений из оценок этапов используется для оценки результирующих значений при программировании такта.
author: QuantumWriter
uid: microsoft.quantum.libraries.characterization
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: 7ed92c29020ccf389faa099f5bd80516af525578
ms.sourcegitcommit: 0181e7c9e98f9af30ea32d3cd8e7e5e30257a4dc
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/23/2020
ms.locfileid: "85275763"
---
# <a name="quantum-characterization-and-statistics"></a>Посимвольная и статистика тактовой задержки #

Очень важно иметь возможность объяснить влияние операций для разработки полезных алгоритмов тактовой задержки.
Это сложно, так как каждое измерение тактовой системы возвращает не более одного бита информации.
Чтобы изучить еиженвалуе, проверим состояние такта, результаты многих измерений должны быть соединены вместе, чтобы пользователь мог получить множество сведений, необходимых для представления этих концепций.
Состояния тактов особенно досадной, так как [отсутствие клонирования Теорема](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) указывает, что нет способа изучать произвольное состояние такта из одной копии состояния, так как это позволяет создавать копии состояния.
Такая маскировка состояния такта от пользователя отражается на том, что Q # не предоставляет или даже не определяет состояние, которое *относится* к тактовым программам.
Поэтому мы подходим к тактовой обработке, рассматривая операции и состояния в виде черного ящика; Этот подход широко распространен с экспериментальной практикой, проверкой и проверкой тактовой задержки (ККВВ).

Символьная кодировка отличается от многих других библиотек, обсуждаемых ранее.
Целью этого является меньшее изучению классической информации о системе, а не выполнению единого преобразования в векторе состояния.
Таким образом, эти библиотеки должны смешивать как классические, так и тактовую обработку данных.


## <a name="iterative-phase-estimation"></a>Оценка этапа итерации ##

Просмотр тактовой задержки с точки зрения тактовой задержки предлагает полезную альтернативу оценки тактовой фазы.
Это значит, что вместо подготовки $n $-кубит Register для хранения двоичного представления этапа, как в ходе оценки тактовой фазы, можно просмотреть оценку этапа как процесса, по которому *классический* агент узнает о свойствах тактовой системы через измерения.
Мы работаем в качестве тактового случая с помощью этапа киккбакк, чтобы превратить приложения в операцию черного ящика в вращение неизвестного угла, но будет измерять анЦилла кубит, который мы повернут на каждом шаге сразу после поворота.
Это преимущество заключается в том, что для выполнения этапа киккбакк, описанного в тактовой ситуации, требуется только один дополнительный кубит, так как мы затем изучен этап от результатов измерения на каждом шаге итеративным образом.  
Каждый из методов, предложенных ниже, использует другую стратегию для проектирования экспериментов и различных методов обработки данных для изучения этапа.  У каждого из них есть уникальные преимущества от строгой привязки к ошибкам, возможности включать в них более раннюю информацию, допускать ошибки или запускать на лимиттед классические компьютеры.

В обсуждении оценки итеративной фазы мы будем рассматривать единое $U $, заданное как черно-блочная операция.
Как описано в разделе по Oracle в [структурах данных](xref:microsoft.quantum.libraries.data-structures), Q # Canon моделирует такие операции по <xref:microsoft.quantum.oracles.discreteoracle> определяемому пользователем типу, определяемому типом кортежа `((Int, Qubit[]) => Unit : Adjoint, Controlled)` .
Конкретнее, если `U : DiscreteOracle` , то `U(m)` реализует $U ^ m $ для `m : Int` .

После этого определения каждый этап итерационной оценки этапов продолжается путем подготовки вспомогательной кубит в состоянии $ \кет{+} $ вместе с начальным состоянием $ \кет{\фи} $, которое мы предполагаем, это [еиженвектор](xref:microsoft.quantum.concepts.matrix-advanced) $U (m) $, т. е. $U (m) \кет{\фи} = e ^ {им\фи} \ Сисакет {\ фи} $.  
Затем используется управляемое приложение класса, `U(m)` которое подготавливает состояние $ \лефт ( \_ m \фи) \кет{+} \ригхт) \кет{\фи} $.
Как и в случае тактового случая, результат управляемого приложения Oracle точно такой `U(m)` же, как и результат применения $R _1 $ для неизвестного этапа в $ \кет{+} $, так что мы можем описать эффект $U $ в этом упрощенном виде.
При необходимости алгоритм поворачивает элемент управления кубит, применяя $R _1 (-м\сета) $ для получения состояния $ \кет{\пси} = \лефт (R \_ 1 (m [\фи-\сета]) \кет{+} \ригхт) \кет{\фи} $ $.
Дополнительный кубит, используемый в качестве элемента управления для `U(m)` , затем измеряется в $X $ для получения единого классического `Result` .

На этом этапе воссоздание этапа на основе `Result` значений, полученных с помощью итеративной оценки этапа, является классической проблемой статистического вывода.
Поиск значения $m $, который позволяет максимально увеличить объем полученной информации, по фиксированному методу вывода — это просто проблема в статистике.
Мы Подчеркните это, кратко описывая оценку итеративного этапа на теоретическом уровне в формальном механизме оценки параметров Байеса, прежде чем приступать к описанию статистических алгоритмов, предоставляемых в Q # Canon для решения этой классической проблемы вывода.

### <a name="iterative-phase-estimation-without-eigenstates"></a>Оценка этапа итерации без Еиженстатес ###

Если указано состояние ввода, которое не является еиженстате, то есть, что если $U (m) \кет{\фи \_ j} = e ^ {им\фи \_ j} $, то процесс оценки этапа недетерминированно направляет состояние такта к одному еиженстате энергии.  Еиженстате, который в конечном итоге сходится с, — это еиженстате, который, скорее всего, будет изготовить `Result` .

В частности, один шаг PE выполняет следующее неединое преобразование состояния \бегин{алигн} \ sum_j \Скрт{\пр (\фи \_ j)} \кет{\фи \_ j} \мапсто \сум \_ ж\фрак {\ sqrt {\ PR (\фи \_ j)} \скрт{\пр (\текст{ресулт} | \Phi \_ j)} \Ket{\Phi \_ j}} {\sqrt{\Pr (\Phi \_ j) \sum \_ j \Pr (\Text{Result} | \Phi \_ j)}}.
\енд{алигн} в процессе итерации по нескольким `Result` значениям, еиженстатес, у которых нет максимального значения $ \ prod_k \пр (\текст{ресулт} \_ k | \фи \_ j) $, будет экспоненциально подавлен.
В результате процесс вывода, как правило, сходится к состояниям с одним еиженвалуе, если эксперименты выбраны правильно.

Алгоритм Байеса "Теорема дополнительно предлагает, что состояние, полученное в результате оценки фазы, должно быть написано в форме \бегин{алигн} \Фрак{\скрт{\пр (\фи \_ j)} \скрт{\пр (\текст{ресулт} | \фи \_ j)} \кет{\фи \_ j}} {\скрт{\пр (\Phi \_ j) \Sum \_ j \Pr (\Text{Result} | \Phi \_ j)}} = \ sum_j \sqrt{\Pr (\Phi \_ j | \Text{result})} \ket{\Phi \_ j}.
\енд{алигн} здесь $ \Пр (\фи \_ j | \текст{ресулт}) $ может быть интерпреттед, как вероятность того, что один из них будет ascribe к каждой гипотезе о еиженстатес.

1. знание состояния такта перед измерением,
2. знания о еиженстатесх $U $ и,
3. знание еиженвалуеса $U $.

Изучение этих трех моментов зачастую является экспоненциальным сложностью на самом простом компьютере.
Программа оценки этапа возникает без небольших экстентов, от того факта, что она может выполнять такую задачу по обучению тактов, не зная ни одного.
Оценка этапа по этой причине появляется в нескольких тактовых алгоритмах, которые обеспечивают экспоненциальное ускорение.

### <a name="bayesian-phase-estimation"></a>Оценка этапа Байеса ###

> [!TIP]
> Дополнительные сведения об оценке этапа Байеса на практике см. в примере [**фасистиматион**](https://github.com/microsoft/Quantum/tree/master/samples/characterization/phase-estimation) .

Идея оценки этапа Байеса проста.
Вы соберете статистику измерений из протокола оценки этапа, а затем обрабатываете результаты с помощью вывода Байеса и выдаете оценку параметра.
Эта обработка дает оценку еиженвалуе, а также неопределенности в этой оценке.
Он также позволяет выполнять адаптивные эксперименты и использовать более раннюю информацию.
Недостаток принципов метода заключается в том, что он требует вычислений.

Чтобы понять, как работает этот процесс вывода Байеса, рассмотрите возможность обработки одного `Zero` результата.
Обратите внимание, что $X = \кет{+} \бра{+}-\кет {-} \бра {-} $, например, $ \кет{+} $ является единственным положительным еиженстатеом $X $, соответствующим `Zero` .
`Zero`Кубит \пр (\тексттт{зеро} | \пси) = \лефт | \бракет{+ | \пси} \right | ^ 2. это вероятность наблюдения для [ `PauliX` измерения](xref:microsoft.quantum.concepts.pauli) в первой области, заданной входным состоянием $ \кет{\пси}\кет{\фи} $.
\енд{екуатион} в случае с итеративной оценкой этапа, у нас есть $ \кет{\пси} = R_1 (m [\фи-\сета]) \кет{+} $, например \бегин{алигн} \Пр (\Тексттт{зеро} | \фи; m, \сета) & = \left | \бракет{+ | R_1 (m [\фи-\сета]) | +} \ригхт | ^ 2 \\ \\ & = \лефт | \frac12 \лефт (\бра {0} + \бра {1} \ригхт) \лефт (\кет {0} + e ^ {i m [\фи-\сета]} \кет {1} \ригхт) \ригхт | ^ 2 \\ \\ & = \лефт | \frac{1 + e ^ {i m [\фи-\сета]}} {2} \right | ^ 2 \\ \\ & = \cos ^ 2 (m [\Phi-\theta]/2) \tag{★} \label{EQ: этап — средство EST-правдоподобие}.
\енд{алигн}, то есть оценка поэтапной итерации состоит из изучения частоты колебаний функции синусоидальной, учитывая возможность перелистывания монет с сдвигом, заданным этим синусоид.
В следующей традиционной классической терминологии мы вызываем $ \екреф{ЕК: Phase-EST-правдоподобие} $ *функции правдоподобия* для оценки итеративной фазы.

Наблюдая за `Result` функцией правдоподобия итеративной оценки, мы можем использовать правило алгоритма Байеса, чтобы предписывает, что следует предполагать, что этап должен следовать за этим наблюдением.
В частности, \бегин{екуатион} \Пр (\фи | d) = \Фрак{\пр (d | \фи) \Пр (\фи)} {\инт \Пр (d | \фи) \Пр (\фи) {\масрм d} \фи} \Пр (\Phi), \end{Equation}, где $d \in \\ {\texttt{Zero}, \texttt{One} \\ } $ — а `Result` , где $ \Pr (\Phi) $ описывает наши предыдущие воззрений о $ \Phi $.
Это делает итеративную природу оценки итеративной фазы явной, так как апостериорные Distribution $ \Пр (\фи | d) $ описывает наш воззрений непосредственно перед нашим наблюдением за следующим `Result` .

В любой момент выполнения этой процедуры мы можем сообщить этап $ \хат{\фи} $, выводимый классическим контроллером как \бегин{екуатион} \хат{\фи} \масрел{: =} \експект [\фи | \текст{Дата}] = \инт \фи \Pr (\Phi | \Text{Data}) {\mathrm d} \Phi, \end{Equation}, где $ \Text{Data} $ означает всю запись всех `Result` полученных значений.

Точный вывод Байеса является нерекомендуемым.
Чтобы увидеть это, мы хотели бы изучить $n $-разрядную переменную $x $.
В предыдущем дистрибутиве $ \Пр (x) $ предусмотрена поддержка более чем $2 ^ n $ гипотетических значений $x $.
Это означает, что если нам требуется очень точная оценка $x $, оценка фазы Байеса может потребовать недостаточного объема памяти и времени обработки.
Хотя для некоторых приложений, таких как моделирование такта, требуемая точность лимиттед не исключает такие методы, как алгоритмы Шор, не может использовать точное определение Байеса на этапе оценки этапа.  По этой причине мы также предоставляем реализации для приблизительных методов Байеса, таких как [Оценка этапа случайного анализа (рвпе)](xref:microsoft.quantum.research.randomwalkphaseestimation.randomwalkphaseestimation) , а также небайеса подходов, таких как [устойчивая Оценка этапа](xref:microsoft.quantum.characterization.robustphaseestimation).

### <a name="robust-phase-estimation"></a>Надежная оценка этапа ###

*Постериори* байесаная Оценка этапа оценки фазы от результатов измерения является экспоненциально сложной в худшем случае. Поэтому большинство алгоритмов практической оценки практических этапов приводят к возникновению некоторого качества в процессе реконструкции, в Exchange — на уровне классической последующей обработки, которая вместо этого масштабируется с учетом количества произведенных измерений.

Одним из таких примеров с эффективным этапом пост-обработки является [надежный алгоритм оценки этапа](https://arxiv.org/abs/1502.02677)с сигнатурой и входными данными, упомянутыми выше. Предполагается, что входные целые квадратные ящики $U $ упаковываются как `DiscreteOracle` тип, и поэтому только запрашивает целочисленные значения управляемых-$U $. Если входное состояние в `Qubit[]` регистре — еиженстате $U \кет{\пси} = e ^ {и\фи} \ Сисакет {\ PSI} $, то надежный алгоритм оценки этапа Возвращает оценку $ \хат{\фи}\ин [-\пи, \пи) $ из $ \фи $ в качестве `Double` .

Самая важная возможность надежной оценки этапа, которая является общей для большинства полезных вариантов, заключается в том, что качество реконструкции $ \хат{\фи} $ имеет определенный смысл Гейзенбега. Это означает, что если отклонение $ \хат{\фи} $ от истинного значения равно $ \сигма $, то $ \сигма $ масштабируется обратно, пропорционально общему количеству запросов $Q $, выполненных в контролируемой $U $, т. е. $ \сигма = \Маскал{о} (1/Q) $. Теперь определение отклонения зависит от различных алгоритмов оценки. В некоторых случаях это может означать, что по крайней мере $ \Маскал{о} (1) $ вероятность, ошибка оценки $ | \хат{\фи}-\фи | \_ \Цирк\ле \сигма $ для некоторой циклической меры $ \Цирк $. Для надежной оценки фазы отклонение является точной дисперсией $ \сигма ^ 2 = \Масбб{е} \_ \хат{\фи} [(\мод \_ {2 \ PI} (\хат{\фи}-\фи + \пи)-\пи) ^ 2] $, если мы раз периодические этапы на один конечный интервал $ (-\пи, \пи] $). Точнее, стандартное отклонение в надежной оценке фазы соответствует неравенствам $ $ \бегин{алигн} 2,0 \пи/Q \ле \сигма \ле 2 \ PI/2 ^ {n} \ле 10.7 \ PI/Q, \енд{алигн} $ $, где нижняя граница достигает предела асимптотикалли Large $Q $, а верхняя граница гарантирована даже для мелких размеров выборки.  Обратите внимание, что $n $ выбрано `bitsPrecision` входными данными, которые неявно определяют $Q $.

К другим важным сведениям относится, скажем, небольшие издержки, связанные только с $1 $ анЦилла кубит, или что процедура не является адаптивной, то есть необходимая последовательность тактов тактовой эксперимента не зависит от промежуточных результатов измерения. В этом и будущих примерах, где важно выбрать алгоритм оценки этапа, один из них должен ссылаться на документацию, например, @"microsoft.quantum.characterization.robustphaseestimation" и на упоминаемые публикации для получения дополнительных сведений и для их реализации.

> [!TIP]
> Существует много примеров, где используется устойчивая Оценка этапа. Для оценки этапа при извлечении энергии в энергопотреблении различных физических систем см. пример [ **моделирования "H2** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line)", пример [ **симплеисинг** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/simple)и [ **модель Хуббард** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/hubbard).


### <a name="continuous-oracles"></a>Непрерывные Oracle ###

Кроме того, можно обобщить модель Oracle, использованную выше, чтобы обеспечить непрерывную репликацию Oracle, смоделированную по типу Canon <xref:microsoft.quantum.oracles.continuousoracle> .
Учтите, что вместо одного отдельного оператора $U $ у нас есть семейство единых операторов $U (t) $ для $t \ин \Масбб{р} $, что $U (t) U (s) $ = $U (t + s) $.
Это более слабая инструкция, чем в отдельном случае, так как мы можем создать <xref:microsoft.quantum.oracles.discreteoracle> с помощью ограничения $t = m \, \делта t $ для некоторых фиксированных $ \делта t $.
По [теоремау камень](https://en.wikipedia.org/wiki/Stone%27s_theorem_on_one-parameter_unitary_groups)$U (t) = \експ (i H t) $ для какого-либо оператора $H $, где $ \експ $ — это матрица, экспоненциальная, как описано в [расширенных матрицах](xref:microsoft.quantum.concepts.matrix-advanced).
Еиженстате $ \кет{\фи} $ of $H $, который $H \кет{\фи} = \фи \кет{\фи} $, также является еиженстате $U (t) $ для всех $t $, \бегин{екуатион} U (t) \кет{\фи} = e ^ {i \Phi t} \ket{\Phi}.
\енд{екуатион}

Можно применить точный анализ, обсуждаемый для [оценки этапа Байеса](#bayesian-phase-estimation) , и функция правдоподобия точно такая же, как для этой более общей модели Oracle: $ $ \Пр (\тексттт{зеро} | \фи; t, \сета) = \кос ^ 2 \ Left (\фрак{т [\фи-\сета]} {2} \ригхт).
$ $ Более того, если $U $ является имитацией динамического генератора, как в случае с [имитацией хамилтониан](xref:microsoft.quantum.libraries.applications#hamiltonian-simulation), мы интерпретируем $ \фи $ как энергия.
Таким образом, использование оценки этапа с непрерывными запросами позволяет нам изучать смоделированный [спектр молекул](https://arxiv.org/abs/quant-ph/0604193), [материалов](https://arxiv.org/abs/1510.03859) или [полей теории](https://arxiv.org/abs/1111.3633v2) , не нарушая выбор экспериментов, требуя, чтобы $t $ быть целым числом.

### <a name="random-walk-phase-estimation"></a>Оценка этапа случайного анализа ###

Q # предоставляет полезную аппроксимацию оценки этапа Байеса, предназначенной для использования близкого к такту устройства, работающего с условием случайного анализа записи данных, полученной из оценки итеративной фазы.
Этот метод является как адаптивным, так и полностью детерминированным, что позволяет использовать почти оптимальное масштабирование ошибок в оценочной фазе $ \хат{\фи} $ с очень низкими заголовками памяти.

Протокол использует приблизительный метод вывода Байеса, который предполагает, что прежнее распределение имеет значение "Гауссу".
Это допущение по Гауссу позволяет нам использовать аналитическую формулу для эксперимента, которая уменьшает апостериорные дисперсию.
Затем алгоритм, основанный на результатах этого эксперимента, сдвигает оценку $ \фи $ Left или right на предварительно определенный объем и сжимает дисперсию по заранее определенному объему.
Это означает, что при следующем эксперименте все сведения, необходимые для указания геометрического значения в $ \фи $, задаются в соответствии с заданными по Гауссу.
Непредвиденные сбои измерения или истинный результат в заключительном фрагменте исходного ранее, может привести к сбою этого метода.
Она восстанавливается после сбоя, выполняя эксперименты, чтобы проверить, подходит ли текущее среднее и стандартное отклонение для системы.
Если это не так, то алгоритм выполняет обратный шаг прохода и процесс продолжится.
Возможность выполнять шаг назад также позволяет алгоритму изучать даже в том случае, если первое предыдущее стандартное отклонение инапроприатели мало.

## <a name="calling-phase-estimation-algorithms"></a>Алгоритмы оценки этапа вызова ##

Каждая операция оценки этапа, обеспечиваемая Q # Canon, принимает другой набор входных данных, обменяя качество, которое мы хотим за пределами окончательной оценки $ \хат{\фи} $.
Однако эти различные входные данные совместно используют несколько общих входных данных, так что частичное применение параметров качества приводит к распространенной сигнатуре.
Например, операция, <xref:microsoft.quantum.characterization.robustphaseestimation> описанная в следующем разделе, имеет следующую сигнатуру:

```qsharp
operation RobustPhaseEstimation(bitsPrecision : Int, oracle : DiscreteOracle, eigenstate : Qubit[])  : Double
```

`bitsPrecision`Входные данные уникальны для `RobustPhaseEstimation` , хотя `oracle` и `eigenstate` являются общими.
Таким образом, как видно в **H2Sample**, операция может принять алгоритм оценки итеративной фазы с входными данными формы `(DiscreteOracle, Qubit[]) => Unit` , чтобы позволить пользователю указать алгоритмы произвольной оценки этапа:

```qsharp
operation H2EstimateEnergy(
    idxBondLength : Int,
    trotterStepSize : Double,
    phaseEstAlgorithm : ((DiscreteOracle, Qubit[]) => Double))
: Double
```

Эти алгоритмы многоэтапной оценки оптимизированы для различных свойств и входных параметров, которые должны быть понятны, чтобы сделать лучший выбор для целевого приложения. Например, некоторые алгоритмы оценки этапа являются адаптивными. Это означает, что будущие шаги будут управляться в классическом виде по результатам измерения предыдущих шагов. Для некоторых требуется возможность експонентиате единую форму Oracle с помощью произвольных реальных степеней, а для других требуются только целые значения, но они могут только разрешать этап оценки остатка от деления $2 \ PI $. Для некоторых требуется много вспомогательных Кубитс, а для других требуется только одна.

Аналогично, использование оценки этапа случайного анализа выполняется практически так же, как и для других алгоритмов, предоставляемых с помощью Canon:

```qsharp
operation ApplyExampleOracle(
    eigenphase : Double,
    time : Double,
    register : Qubit[])
: Unit is Adj + Ctl {
    Rz(2.0 * eigenphase * time, register[0]);
}

operation EstimateBayesianPhase(eigenphase : Double) : Double {
    let oracle = ContinuousOracle(ApplyExampleOracle(eigenphase, _, _));
    using (eigenstate = Qubit()) {
        X(eigenstate);
        // The additional inputs here specify the mean and variance of the prior, the number of
        // iterations to perform, how many iterations to perform as a maximum, and how many
        // steps to roll back on an approximation failure.
        let est = RandomWalkPhaseEstimation(0.0, 1.0, 61, 100000, 1, oracle, [eigenstate]);
        Reset(eigenstate);
        return est;
    }
}
```
