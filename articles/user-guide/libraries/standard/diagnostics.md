---
title: Диагностика в Q# стандартных библиотеках
description: Сведения о диагностических функциях и операциях в Q# стандартных библиотеках, используемых для перехвата ошибок или ошибок в тактовых программах.
author: cgranade
uid: microsoft.quantum.libraries.diagnostics
ms.author: chgranad
ms.topic: article
no-loc:
- Q#
- $$v
ms.openlocfilehash: 11ce1bc86db0c5aa0f81ba7d0f2d6ec3463b178c
ms.sourcegitcommit: 9b0d1ffc8752334bd6145457a826505cc31fa27a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/21/2020
ms.locfileid: "90835576"
---
# <a name="diagnostics"></a>Диагностика #

Как и в классической среде разработки, важно иметь возможность диагностировать ошибки и ошибки в тактовых программах.
Q#Стандартные библиотеки предоставляют различные способы обеспечения правильности тактовых программ, как описано в <xref:microsoft.quantum.guide.testingdebugging> .
В основном эта поддержка происходит в виде функций и операций, которые указывают целевому компьютеру предоставить дополнительные диагностические сведения для основной программы или разработчика или обеспечивают правильность условий и инвариантов, выраженных вызовом функции или операции.

## <a name="machine-diagnostics"></a>Диагностика компьютеров ##

Диагностическую информацию о классических значениях можно получить с помощью <xref:microsoft.quantum.intrinsic.message> функции, которая зарегистрирует сообщение в зависимости от компьютера.
По умолчанию строка записывается в консоль.
Используется вместе с интерполяцией строк, <xref:microsoft.quantum.intrinsic.message> что позволяет легко передавать диагностические сведения о классических значениях:

```Q#
let angle = Microsoft.Quantum.Math.PI() * 2.0 / 3.0;
Message($"About to rotate by an angle of {angle}...");
```

> [!NOTE]
> `Message` имеет сигнатуру `(String -> Unit)` , которая снова представляет, что сообщение журнала отладки не может рассматриваться в Q# .

Вызываемые командлеты <xref:microsoft.quantum.diagnostics.dumpmachine> <xref:microsoft.quantum.diagnostics.dumpregister> указывают целевым компьютерам на предоставление диагностических сведений обо всех текущих выделенных Кубитс или о конкретной регистрации Кубитс, соответственно.
Каждый целевой компьютер зависит от того, какие диагностические сведения предоставляются в ответ на инструкцию дампа.
Например, целевой компьютер [имитатора полного состояния](xref:microsoft.quantum.machines.full-state-simulator) предоставляет основной программе вектор состояния, который используется внутренне для представления регистра Кубитс.
По сравнению, целевой компьютер [имитатора Тоффоли](xref:microsoft.quantum.machines.toffoli-simulator) предоставляет единый Классический бит для каждого кубит.

 Чтобы узнать больше о выходных данных [имитатора полного состояния](xref:microsoft.quantum.machines.full-state-simulator) `DumpMachine` , ознакомьтесь с разделом функции дампа [статьи тестирование и отладка](xref:microsoft.quantum.guide.testingdebugging#dump-functions).


## <a name="facts-and-assertions"></a>Факты и утверждения ##

Как обсуждалось в разделе [тестирование и отладка](xref:microsoft.quantum.guide.testingdebugging), функция или операция с сигнатурой `Unit -> Unit` или `Unit => Unit` , соответственно, могут быть помечены как *модульный тест*.
Каждый модульный тест обычно состоит из небольшой тактовой программы, а также одного или нескольких условий, которые проверяют правильность этой программы.
Эти условия могут поступать в виде любых _фактов_, которые проверяют значения их входных данных или _утверждения_, которые проверяют состояния одного или нескольких Кубитс, переданных в качестве входных данных.

Например, `EqualityFactI(1 + 1, 2, "1 + 1 != 2")` представляет математический факт, что $1 + 1 = $2, а `AssertQubit(One, qubit)` представляет условие, которое измерение `qubit` будет возвращать `One` с сохранением.
В первом случае мы можем проверить правильность условия, учитывая только его значения. в последнем случае нам необходимо узнать о состоянии кубит, чтобы оценить утверждение.

Q#Стандартные библиотеки предоставляют несколько различных функций для представления фактов, включая:

- <xref:microsoft.quantum.diagnostics.fact>
- <xref:microsoft.quantum.diagnostics.equalitywithintolerancefact>
- <xref:microsoft.quantum.diagnostics.nearequalityfactc>
- <xref:microsoft.quantum.diagnostics.equalityfacti>


### <a name="testing-qubit-states"></a>Тестирование состояний кубит ###

На практике утверждения полагаются на тот факт, что классический симулятор механики не должен подчиняться [Теорема без клонирования](https://arxiv.org/abs/quant-ph/9607018), так что мы можем делать нефизические измерения и утверждения при использовании симулятора на нашем целевом компьютере.
Таким же путем можно протестировать отдельные операции в классический симулятор перед развертыванием на оборудовании.
На целевых компьютерах, которые не допускают оценку утверждений, вызовы в <xref:microsoft.quantum.diagnostics.assertmeasurement> можно спокойно игнорировать.

Как правило, <xref:microsoft.quantum.diagnostics.assertmeasurement> Операция утверждает, что измерение данного Кубитс в заданной паулиной базе всегда будет иметь заданный результат.
Если утверждение не выполняется, выполнение завершается вызовом `fail` с заданным сообщением.
По умолчанию эта операция не реализована. Симуляторы, которые могут поддерживать ИТ, должны обеспечивать реализацию, которая выполняет проверку среды выполнения.
`AssertMeasurement` имеет сигнатуру `((Pauli[], Qubit[], Result, String) -> ())` .
Поскольку `AssertMeasurement` является функцией с пустым кортежем в качестве типа выходных данных, никакие эффекты от вызова не `AssertMeasurement` могут быть наблюдаемыми в Q# программе.

<xref:microsoft.quantum.diagnostics.assertmeasurementprobability>Функция Operation утверждает, что измерение заданного Кубитс в заданной паулиной базе будет иметь заданный результат с заданной вероятностью в пределах некоторой допустимости.
Допуском является аддитивный (например, `abs(expected-actual) < tol` ).
Если утверждение не выполняется, выполнение завершается вызовом `fail` с заданным сообщением.
По умолчанию эта операция не реализована. Симуляторы, которые могут поддерживать ИТ, должны обеспечивать реализацию, которая выполняет проверку среды выполнения.
`AssertMeasurementProbability` имеет сигнатуру `((Pauli[], Qubit[], Result, Double, String, Double) -> Unit)` . Первый из `Double` параметров дает желаемую вероятность результата, а второй — допуск.

Мы можем сделать больше, чем утверждение одного измерения, используя классическую информацию, используемую симулятором для представления внутреннего состояния кубита, податливася к копированию, чтобы не нужно было фактически выполнять измерение для тестирования нашего утверждения.
В частности, это позволяет нам полагаться на *несовместимые* измерения, которые могут быть невозможно на фактическом оборудовании.

Предположим, что `P : Qubit => Unit` это операция, предназначенная для подготовки состояния $ \кет{\пси} $, когда входные данные находятся в состоянии $ \кет {0} $.
Let $ \кет{\пси '} $ станет действительным состоянием, подготовленным `P` .
Затем $ \кет{\пси} = \кет{\пси '} $ If и только в том случае, если измерение $ \кет{\пси '} $ на оси, описываемом $ \кет{\пси} $, всегда возвращает значение `Zero` .
То есть \бегин{алигн} \кет{\пси} = \кет{\пси '} \текст{, только если} \бракет{\пси | \пси '} = 1.
\енд{алигн} с помощью примитивных операций, определенных в версионного, мы можем напрямую выполнить измерение, возвращающее, `Zero` Если $ \кет{\пси} $ является еиженстате одного из операторов Паули.


Операция <xref:microsoft.quantum.diagnostics.assertqubit> является особенно полезной для этого в том случае, если мы хотим протестировать утверждение $ \кет{\пси} = \кет {0} $.
Это часто, например, когда мы невычисленными, чтобы вернуть анЦилла Кубитс в $ \кет {0} $ перед их освобождением.
Утверждение для $ \кет {0} $ также полезно, когда мы хотим подтвердить, что две подготовительные `P` операции и `Q` действия подготавливают одно и то же состояние и когда `Q` поддерживают `Adjoint` .
В частности,

```qsharp
using (register = Qubit()) {
    P(register);
    Adjoint Q(register);

    AssertQubit(Zero, register);
}
```

Однако в общем случае у нас может не быть доступа к утверждениям о состояниях, которые не совпадают с еиженстатес операторами Паули.
Например, $ \кет{\пси} = (\кет {0} + e ^ {i \пи/8} \кет {1} )/\скрт {2} $ не является Еиженстате любого оператора Паули, так что мы не можем использовать <xref:microsoft.quantum.diagnostics.assertmeasurementprobability> для однозначного определения того, что состояние $ \кет{\пси '} $ равно $ \кет{\пси} $.
Вместо этого необходимо разложить утверждение $ \кет{\пси '} = \кет{\пси} $ на предположения, которые можно напрямую протестировать с использованием примитивов, поддерживаемых нашим симулятором.
Для этого позвольте $ \кет{\пси} = \алфа \кет {0} + \бета \кет {1} $ для комплексных чисел $ \алфа = a \_ r + a \_ i $ and $ \бета $.
Обратите внимание, что для этого выражения требуется четыре вещественных числа $ \{ a \_ r, a \_ i, b \_ r, b \_ i \} $ для указания, так как каждое комплексное число можно выразить как сумму действительной и мнимой части.
Однако из-за глобального этапа мы можем выбрать $a \_ i = $0, чтобы для уникальной идентификации одного кубитного состояния нам потребуются только три реальных числа.

Таким образом, необходимо указать три утверждения, которые не зависят друг от друга, чтобы подтвердить предполагаемое состояние.
Для этого нужно найти вероятность наблюдения `Zero` за каждым Паули измерением, заданным $ \алфа $ и $ \бета $, и утвердить их независимо друг от друга.
Let $x $, $y $ и $z $ должны быть `Result` значениями для паули $X $, $Y $ и $Z $ измерений соответственно.
Затем, используя функцию правдоподобия для измерений тактов, \бегин{алигн} \Пр (x = \Тексттт{зеро} | \алфа, \бета) & = \frac12 + a \_ r b \_ r + a \_ i b \_ i \\ \\ \пр (y = \тексттт{зеро} | \алфа, \бета) & = \frac12 + a \_ r b \_ i – a \_ b \_ r \\ \\ \пр (z = \тексттт{зеро} | \alpha, \beta) & = \frac12\left (1 + a \_ r ^ 2 + b i ^ 2 \_ \_ \_ \right).
\енд{алигн}

<xref:microsoft.quantum.diagnostics.assertqubitisinstatewithintolerance>Операция реализует эти утверждения, заданные в представлениях $ \алфа $ и $ \бета $ в качестве значений типа <xref:microsoft.quantum.math.complex> .
Это полезно, когда ожидаемое состояние может быть вычислено математическим.

### <a name="asserting-equality-of-quantum-operations"></a>Утверждение равенства операций такта ###

До сих пор мы работаем над тестированием операций, предназначенных для подготовки определенных состояний.
Однако часто мы заинтересованы в том, как операция работает с произвольными входными данными, а не с одним фиксированным входом.
Например, предположим, что мы реализовали операцию, `U : ((Double, Qubit[]) => () : Adjoint)` соответствующую семейству единых операторов $U (t) $, и предоставили явный `adjoint` блок вместо использования `adjoint auto` .
Мы можем заинтересовать, что $U ^ \дагжер (t) = U (-t) $, как и ожидалось, если $t $ представляет время развития.

В общем, существует две различные стратегии, которые мы можем отслеживать, чтобы сделать утверждение, которое две операции `U` и `V` действуют одинаково.
Во-первых, мы можем проверить, `U(target); (Adjoint V)(target);` сохраняет ли каждое состояние на заданном уровне.
Во вторых, мы можем проверить, что, `U(target); (Adjoint V)(target);` действуя с половиной состояния запутанными, сохраняет замкнутые.
Эти стратегии реализуются с помощью операций Canon <xref:microsoft.quantum.diagnostics.assertoperationsequalinplace> и <xref:microsoft.quantum.diagnostics.assertoperationsequalreferenced> соответственно.

> [!NOTE]
> Упомянутое выше утверждение работает на основе [Чои – жамиłковски исоморфисм](https://en.wikipedia.org/wiki/Channel-state_duality), математической платформы, которая связывает операции с $n $ Кубитс с запутанными состояниями в $2N $ Кубитс.
> В частности, операция идентификации в $n $ Кубитс представляется $n $ копиями состояния запутанными $ \кет{\ beta_ {00} } \масрел{: =} (\кет {00} + \кет {11} )/\скрт {2} $.
> Операция <xref:microsoft.quantum.preparation.preparechoistate> реализует этот исоморфисм, подготавливая состояние, представляющее заданную операцию.

Примерно эти стратегии различаются по времени.
Для прохода по каждому входному состоянию требуется дополнительное время, а для использования замкнутые в качестве ссылки требуется хранить дополнительные Кубитс.
В случаях, когда операция реализует обратимую классическую операцию, в которой мы заинтересованы только в своем поведении на вычислительные состояния, <xref:microsoft.quantum.diagnostics.assertoperationsequalinplacecompbasis> проверяет равенство на этом ограниченном наборе входных данных.

> [!TIP]
> Итерация по состояниям ввода обрабатывается операциями перечисления <xref:microsoft.quantum.canon.iteratethroughcartesianproduct> и <xref:microsoft.quantum.canon.iteratethroughcartesianpower> .
> Эти операции более часто используются для применения операции к каждому элементу декартово произведения между двумя или более наборами.

Однако, что более важно, два подхода проверяют различные свойства выполняемых операций.
Поскольку утверждение на месте вызывает каждую операцию несколько раз, один раз для каждого входного состояния, любые случайные выборки и результаты измерения могут измениться между вызовами.
Напротив, проверочное утверждение, на которое указывает ссылка, вызывает каждую операцию только один раз, так что она проверяет, что операции равны *одному снимку*.
Оба эти теста полезны для обеспечения правильности тактовых программ.


## <a name="further-reading"></a>Дополнительные материалы ##

- <xref:microsoft.quantum.guide.testingdebugging>
- <xref:microsoft.quantum.diagnostics>
