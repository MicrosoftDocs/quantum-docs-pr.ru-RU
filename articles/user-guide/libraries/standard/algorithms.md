---
title: Алгоритмы такта вQ#
description: Сведения об основных алгоритмах тактовой обработки, включая усиление амплитуды, преобразование Фурье, Драпер и Беаурегард методах, а также оценку фазы.
author: QuantumWriter
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
uid: microsoft.quantum.libraries.standard.algorithms
no-loc:
- Q#
- $$v
ms.openlocfilehash: 0b5972480061c460345057285bbfe53305acc122
ms.sourcegitcommit: 6bf99d93590d6aa80490e88f2fd74dbbee8e0371
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/06/2020
ms.locfileid: "87868820"
---
# <a name="quantum-algorithms"></a><span data-ttu-id="a0da9-103">Алгоритмы такта</span><span class="sxs-lookup"><span data-stu-id="a0da9-103">Quantum Algorithms</span></span> #

## <a name="amplitude-amplification"></a><span data-ttu-id="a0da9-104">Усиление амплитуды</span><span class="sxs-lookup"><span data-stu-id="a0da9-104">Amplitude Amplification</span></span> ##

<span data-ttu-id="a0da9-105">*Усиление амплитуды* — одно из фундаментальных средств тактовых вычислений.</span><span class="sxs-lookup"><span data-stu-id="a0da9-105">*Amplitude Amplification* is one of the fundamental tools of Quantum Computing.</span></span> <span data-ttu-id="a0da9-106">Это фундаментальная идея, которая лежит в основе поиска Гровер, оценки амплитуды и многих алгоритмов машинного обучения для тактов.</span><span class="sxs-lookup"><span data-stu-id="a0da9-106">It is the fundamental idea that underlies Grover's search, amplitude estimation and many quantum machine learning algorithms.</span></span>  <span data-ttu-id="a0da9-107">Существует множество вариантов, и в Q# мы предоставляем общую версию на основе усиления амплитуды очевидным с частичными отражениями, чтобы обеспечить широкую область приложения.</span><span class="sxs-lookup"><span data-stu-id="a0da9-107">There are many variants, and in Q# we provide a general version based on Oblivious Amplitude Amplification with Partial Reflections to allow for the widest area of application.</span></span>

<span data-ttu-id="a0da9-108">Центральной идеей для усиления амплитуды является повысить эффективность вероятность желаемого результата, выполняя последовательность отражений.</span><span class="sxs-lookup"><span data-stu-id="a0da9-108">The central idea behind amplitude amplification is to amplify the probability of a desired outcome occurring by performing a sequence of reflections.</span></span>  <span data-ttu-id="a0da9-109">Эти отражения поворачивают начальное состояние ближе к желаемому целевому состоянию, которое часто называется помеченным состоянием.</span><span class="sxs-lookup"><span data-stu-id="a0da9-109">These reflections rotate the initial state closer towards a desired target state, often called a marked state.</span></span>  <span data-ttu-id="a0da9-110">В частности, если вероятность измерения начального состояния до помеченного состояния — $ \син ^ 2 (\сета) $, после применения усиления амплитуды $m $ раз вероятность успеха становится равна $ \син ^ 2 ((2 MБ + 1) \сета) $.</span><span class="sxs-lookup"><span data-stu-id="a0da9-110">Specifically, if the probability of measuring the initial state to be in a marked state is $\sin^2(\theta)$ then after applying amplitude amplification $m$ times the probability of success becomes $\sin^2((2m+1)\theta)$.</span></span>  <span data-ttu-id="a0da9-111">Это означает, что если $ \сета = \ PI/[2 (2n + 1)] $ для некоторого значения $n $, то при повышении амплитуды может повыситься вероятность успеха $100 \\ % $ после $n $ итераций усиления амплитуды.</span><span class="sxs-lookup"><span data-stu-id="a0da9-111">This means that if $\theta = \pi/[2(2n+1)]$ for some value of $n$ then amplitude amplification is capable of boosting the probability of success to $100\\%$ after $n$ iterations of amplitude amplification.</span></span>  <span data-ttu-id="a0da9-112">Начиная с $ \сета = \син ^ {-1} (\скрт{\пр (успешно)}) $ это означает, что число итераций, необходимых для успешного получения результата, в корне меньше ожидаемого числа, необходимого для поиска помеченного состояния, недетерминированного с помощью случайной выборки.</span><span class="sxs-lookup"><span data-stu-id="a0da9-112">Since $\theta = \sin^{-1}(\sqrt{\Pr(success)})$ this means that the number of iterations needed to obtain a success deterministically is quadratically lower than the expected number needed to find a marked state non-deterministically using random sampling.</span></span>

<span data-ttu-id="a0da9-113">Для каждой итерации усиления амплитуды необходимо указать два оператора отражения.</span><span class="sxs-lookup"><span data-stu-id="a0da9-113">Each iteration of Amplitude amplification requires that two reflection operators be specified.</span></span> <span data-ttu-id="a0da9-114">В частности, если $Q $ является итерацией для усиления амплитуды и $P _0 $ является оператором-проектором на начальном подпространстве, а $P _1 $ является проектором на помеченный пробел, то $Q =-(\болдоне-2P_0) (\болдоне-2P_1) $.</span><span class="sxs-lookup"><span data-stu-id="a0da9-114">Specifically, if $Q$ is the amplitude amplification iterate and $P_0$ is a projector operator onto the initial subspace and $P_1$ is the projector onto the marked subspace then $Q=-(\boldone-2P_0)(\boldone -2P_1)$.</span></span>  <span data-ttu-id="a0da9-115">Вспомним, что проектор — это Хермитиан оператор, который имеет еиженвалуес $ + $1 и $0 $, и в результате $ (\болдоне-2P_0) $ является единым, так как он имеет еиженвалуес, являющиеся корнями Unity (в данном случае $ \пм $1).</span><span class="sxs-lookup"><span data-stu-id="a0da9-115">Recall that a projector is a Hermitian operator that has eigenvalues $+1$ and $0$ and as a result $(\boldone -2P_0)$ is unitary because it has eigenvalues that are roots of unity (in this case $\pm 1$).</span></span> <span data-ttu-id="a0da9-116">В качестве примера рассмотрим вариант поиска Гровер с начальным состоянием $H ^ {\отимес n} \кет {0} $ и помеченным State $ \кет{м} $, $P _0 = H ^ {\отимес n} \кет {0} \бра {0} H ^ {\отимес n} $ and $P _1 = \кет{м}\бра{м} $.</span><span class="sxs-lookup"><span data-stu-id="a0da9-116">As an example, consider the case of Grover's search with initial state $H^{\otimes n} \ket{0}$ and marked state $\ket{m}$, $P_0 = H^{\otimes n}\ket{0}\bra{0}H^{\otimes n}$ and $P_1= \ket{m}\bra{m}$.</span></span>  <span data-ttu-id="a0da9-117">В большинстве приложений для усиления амплитуды $P _0 $ будет являться проектором на начальное состояние, означающее, что $P _0 = \болдоне-2 \ Сисакет {\ PSI} \ неверное {\ PSI} $ для некоторых векторов $ \кет{\пси} $; Однако для очевидным амплитуда ампликатион $P _0 $ обычно проецируется на множество состояний тактов (т. е. Кратность $1 еиженвалуе $P _0 $ больше $1 $).</span><span class="sxs-lookup"><span data-stu-id="a0da9-117">In most applications of amplitude amplification $P_0$ will be a projector onto an initial state meaning that $P_0 = \boldone -2\ket{\psi}\bra{\psi}$ for some vector $\ket{\psi}$; however, for oblivious amplitude amplication $P_0$ will typically project onto many quantum states (i.e. the multiplicity of the $+1$ eigenvalue of $P_0$ is greater than $1$).</span></span>

<span data-ttu-id="a0da9-118">Логика, основанная на усилении амплитуды, следует непосредственно за еижен-декомпозицией $Q $.</span><span class="sxs-lookup"><span data-stu-id="a0da9-118">The logic behind amplitude amplification follows directly from the eigen-decomposition of $Q$.</span></span>  <span data-ttu-id="a0da9-119">В частности, основе собственных векторов $Q $ о том, что начальное состояние имеет ненулевую поддержку, может отображаться как линейное $1 сочетание $P основе собственных векторов _0 $ и $P _1 $.</span><span class="sxs-lookup"><span data-stu-id="a0da9-119">Specifically, the eigenvectors of $Q$ that the initial state has non-zero support over can be shown to be linear combinations of the $+1$ eigenvectors of $P_0$ and $P_1$.</span></span>  <span data-ttu-id="a0da9-120">В частности, исходное состояние для усиления амплитуды (при условии, что это $ + $1 еиженвектор $P _0 $) может быть записано как $ $ \кет{\пси} = \фрак{-и}{\скрт {2} } \лефт (e ^ {и\сета} \ Сисакет {\ psi_ +} + e ^ {-и\сета} \ Сисакет {\ psi_-} \ригхт). $ $ где $ \кет{\ psi_ \пм} $ основе собственных векторов из $Q $ с еиженвалуес $e ^ {\pm 2i \ тета} $ и поддерживает только основе собственных векторов $ + $1 _0 из $P $ и $P _1 $.</span><span class="sxs-lookup"><span data-stu-id="a0da9-120">Specifically, the initial state for amplitude amplification (assuming it is a $+1$ eigenvector of $P_0$) can be written as $$ \ket{\psi}=\frac{-i}{\sqrt{2}}\left(e^{i\theta}\ket{\psi_+} + e^{-i\theta}\ket{\psi_-}\right), $$ where $\ket{\psi_\pm}$ are eigenvectors of $Q$ with eigenvalues $e^{\pm  2i\theta}$ and only have support on the $+1$ eigenvectors of $P_0$ and $P_1$.</span></span>  <span data-ttu-id="a0da9-121">Тот факт, что еиженвалуес $e ^ {\пм i \сета} $ означает, что оператор $Q $ выполняет поворот в двухмерном пространстве, заданном двумя проекторами, и начальное состояние, где угол поворота равен $2 \ тета $.</span><span class="sxs-lookup"><span data-stu-id="a0da9-121">The fact that the eigenvalues are $e^{\pm i \theta}$ implies that the operator $Q$ performs a rotation in a two-dimensional subspace specified by the two projectors and the initial state where the rotation angle is $2\theta$.</span></span>  <span data-ttu-id="a0da9-122">Именно поэтому после $m $ итераций $Q $ вероятность успеха равна $ \син ^ 2 ([2 MБ + 1] \сета) $.</span><span class="sxs-lookup"><span data-stu-id="a0da9-122">This is why after $m$ iterations of $Q$ the success probability is $\sin^2([2m+1]\theta)$.</span></span>

<span data-ttu-id="a0da9-123">Еще одно полезное свойство, которое выходит за пределы этого, заключается в том, что еиженвалуе $ \сета $ напрямую связан с вероятностью того, что первоначальное состояние было бы отмечено (в случае, когда $P _0 $ является проектором только в первоначальном состоянии).</span><span class="sxs-lookup"><span data-stu-id="a0da9-123">Another useful property that comes out of this is that the eigenvalue $\theta$ is directly related to probability that the initial state would be marked (in the case where $P_0$ is a projector onto only the initial state).</span></span>  <span data-ttu-id="a0da9-124">Так как $Q еиженфасес $ имеет значение $2 \ тета = 2 \ Sin ^ {-1} (\скрт{\пр (Success)}) $, то после применения оценки этапа к $Q $ мы можем узнать вероятность успеха для единой тактовой процедуры.</span><span class="sxs-lookup"><span data-stu-id="a0da9-124">Since the eigenphases of $Q$ are $2\theta = 2\sin^{-1}(\sqrt{\Pr(success)})$ it then follows that if we apply phase estimation to $Q$ then we can learn the probability of success for a unitary quantum procedure.</span></span>  <span data-ttu-id="a0da9-125">Это полезно, так как для изучения вероятности успеха, которая в противном случае потребовалась бы в случае успешного выполнения, требуется не менее чем больше приложений тактовой процедуры.</span><span class="sxs-lookup"><span data-stu-id="a0da9-125">This is useful because it requires quadratically fewer applications of the quantum procedure to learn the success probability than would otherwise be needed.</span></span>

<span data-ttu-id="a0da9-126">Q#Введение в усиление амплитуды в качестве специализации усиления амплитуды очевидным.</span><span class="sxs-lookup"><span data-stu-id="a0da9-126">Q# introduces amplitude amplification as a specialization of oblivious amplitude amplification.</span></span>  <span data-ttu-id="a0da9-127">Усиление амплитуды очевидным зарабатывает этот моникер, так как проектор на первоначальной еиженспаце не должен быть проектором в первоначальном состоянии.</span><span class="sxs-lookup"><span data-stu-id="a0da9-127">Oblivious amplitude amplification earns this moniker because the projector onto the initial eigenspace need not be a projector onto the initial state.</span></span>  <span data-ttu-id="a0da9-128">В этом смысле протокол очевидным в исходное состояние.</span><span class="sxs-lookup"><span data-stu-id="a0da9-128">In this sense, the protocol is oblivious to the initial state.</span></span>  <span data-ttu-id="a0da9-129">Ключевое приложение усиления амплитуды очевидным — это определенные *линейные комбинации единых* методов моделирования хамилтониан, где начальное состояние неизвестно, но становится запутанными с регистрацией анЦилла в протоколе моделирования.</span><span class="sxs-lookup"><span data-stu-id="a0da9-129">The key application of oblivious amplitude amplification is in certain *linear combinations of unitary* Hamiltonian simulation methods, wherein the initial state is unknown but becomes entangled with an ancilla register in the simulation protocol.</span></span>  <span data-ttu-id="a0da9-130">Если регистр анЦилла должен быть фиксированным значением, скажем $0 $, то такие методы моделирования применяют необходимое единое преобразование к оставшимся Кубитс (называемым системным регистром).</span><span class="sxs-lookup"><span data-stu-id="a0da9-130">If this ancilla register were to be measured to be a fixed value, say $0$, then such simulation methods apply the desired unitary transformation to the remaining qubits (called the system register).</span></span>  <span data-ttu-id="a0da9-131">Однако все остальные результаты измерений ведут к сбою.</span><span class="sxs-lookup"><span data-stu-id="a0da9-131">All other measurement outcomes lead to failure however.</span></span>  <span data-ttu-id="a0da9-132">Усиление амплитуды очевидным позволяет повысить вероятность успеха этого измерения до $100 \\ % $ с помощью описанной выше причины.</span><span class="sxs-lookup"><span data-stu-id="a0da9-132">Oblivious amplitude amplification allows the probability of success of this measurement to be boosted to $100\\%$ using the above reasoning.</span></span>  <span data-ttu-id="a0da9-133">Кроме того, обычное усиление амплитуды соответствует случаю, когда регистр системы пуст.</span><span class="sxs-lookup"><span data-stu-id="a0da9-133">Further, ordinary amplitude amplification corresponds to the case where the system register is empty.</span></span>  <span data-ttu-id="a0da9-134">Именно поэтому Q# в качестве основной подпрограммы для усиления амплитуд используется усиление амплитуды очевидным.</span><span class="sxs-lookup"><span data-stu-id="a0da9-134">This is why Q# uses oblivious amplitude amplification as its fundamental amplitude amplification subroutine.</span></span>

<span data-ttu-id="a0da9-135">Общая подпрограммы ( `AmpAmpObliviousByReflectionPhases` ) имеет два регистра, которые мы вызываем `ancillaRegister` и `systemRegister` .</span><span class="sxs-lookup"><span data-stu-id="a0da9-135">The general routine (`AmpAmpObliviousByReflectionPhases`) has two registers that we call `ancillaRegister` and `systemRegister`.</span></span> <span data-ttu-id="a0da9-136">Он также принимает два Oracle для необходимых отражений.</span><span class="sxs-lookup"><span data-stu-id="a0da9-136">It also accepts two oracles for the necessary reflections.</span></span> <span data-ttu-id="a0da9-137">Объект `ReflectionOracle` действует только в, `ancillaRegister` а `ObliviousOracle` действует совместно с обеими регистрами.</span><span class="sxs-lookup"><span data-stu-id="a0da9-137">The `ReflectionOracle` acts only on the `ancillaRegister` while the `ObliviousOracle` acts jointly on both registers.</span></span> <span data-ttu-id="a0da9-138">Входные данные `ancillaRegister` должны быть инициализированы значением-1 еиженстате первого оператора отражения $ \болдоне-2P_1 $.</span><span class="sxs-lookup"><span data-stu-id="a0da9-138">The input to `ancillaRegister` must be initialized to a -1 eigenstate of the first reflection operator $\boldone -2P_1$.</span></span>

<span data-ttu-id="a0da9-139">Как правило, Oracle готовит состояние в вычислительной базе $ \ket{0...0} $.</span><span class="sxs-lookup"><span data-stu-id="a0da9-139">Typically, the oracle prepares the state in the computational basis $\ket{0...0}$.</span></span> <span data-ttu-id="a0da9-140">В нашей реализации объект `ancillaRegister` состоит из одного кубит ( `flagQubit` ), который управляет `stateOracle` и остальной части требуемого анЦиллас.</span><span class="sxs-lookup"><span data-stu-id="a0da9-140">In our implementation, the `ancillaRegister` consistes of one qubit (`flagQubit`) that controls the `stateOracle` and the rest of the desired ancillas.</span></span> <span data-ttu-id="a0da9-141">`stateOracle`Применяется, когда параметр `flagQubit` имеет значение $ \кет {1} $.</span><span class="sxs-lookup"><span data-stu-id="a0da9-141">The `stateOracle` is applied when the `flagQubit` is $\ket{1}$.</span></span>

<span data-ttu-id="a0da9-142">Один может также предоставлять Oracle `StateOracle` и `ObliviousOracle` вместо отражения с помощью вызова `AmpAmpObliviousByOraclePhases` .</span><span class="sxs-lookup"><span data-stu-id="a0da9-142">One may also provide oracles `StateOracle` and `ObliviousOracle` instead of reflections via a call to `AmpAmpObliviousByOraclePhases`.</span></span>

<span data-ttu-id="a0da9-143">Как уже упоминалось, традиционная усиление амплитуд — это лишь особый случай использования этих подпрограмм, где `ObliviousOracle` является оператором идентификации и отсутствует системный Кубитс (т. е. `systemRegister` пустой).</span><span class="sxs-lookup"><span data-stu-id="a0da9-143">As mentioned, traditional Amplitude Amplification is just a special case of these routines where `ObliviousOracle` is the identity operator and there are no system qubits (i.e., `systemRegister` is empty).</span></span> <span data-ttu-id="a0da9-144">Если вы хотите получить этапы для частичных отражений (например, для поиска Гровер), функция `AmpAmpPhasesStandard` будет доступна.</span><span class="sxs-lookup"><span data-stu-id="a0da9-144">If you wish to obtain phases for partial reflections (e.g., for Grover search), the function `AmpAmpPhasesStandard` is available.</span></span> <span data-ttu-id="a0da9-145">`DatabaseSearch.qs`Пример реализации алгоритма Гровер см. в разделе.</span><span class="sxs-lookup"><span data-stu-id="a0da9-145">Please refer to `DatabaseSearch.qs` for a sample implementation of Grover's algorithm.</span></span>

<span data-ttu-id="a0da9-146">Мы будем связывать фазы ротации кубит с этапами оператора отражения, как описано в документе [Г.х. Low, I. L. Чжуанский](https://arxiv.org/abs/1707.05391).</span><span class="sxs-lookup"><span data-stu-id="a0da9-146">We relate the single-qubit rotation phases to the reflection operator phases as described in the paper by [G.H. Low, I. L. Chuang](https://arxiv.org/abs/1707.05391).</span></span> <span data-ttu-id="a0da9-147">Используемые фазы фиксированной точки подробно описаны в [Йодер, Low и Чжуанский](https://arxiv.org/abs/1409.3305) вместе с этапами [Low, Йодер и Чжуанский](https://arxiv.org/abs/1603.03996).</span><span class="sxs-lookup"><span data-stu-id="a0da9-147">The fixed point phases that are used are detailed in [Yoder, Low and Chuang](https://arxiv.org/abs/1409.3305) along with the phases in [Low, Yoder and Chuang](https://arxiv.org/abs/1603.03996).</span></span>

<span data-ttu-id="a0da9-148">В качестве фона можно начать с уровня " [стандартный](https://arxiv.org/abs/quant-ph/0005055) ", а затем перейти к вводу в [очевидным с усилением амплитуды](https://arxiv.org/abs/1312.1414) и, наконец, в [Чжуанский](https://arxiv.org/abs/1610.06546).</span><span class="sxs-lookup"><span data-stu-id="a0da9-148">For background, you could start from [Standard Amplitude Amplification](https://arxiv.org/abs/quant-ph/0005055) then move to an introduction to [Oblivious Amplitude Amplification](https://arxiv.org/abs/1312.1414) and finally generalizations presented in [Low and Chuang](https://arxiv.org/abs/1610.06546).</span></span> <span data-ttu-id="a0da9-149">Хорошим обзором всей области (как она относится к моделированию Хамилтониан) было [Dominic Берри](http://www.dominicberry.org/presentations/Durban.pdf).</span><span class="sxs-lookup"><span data-stu-id="a0da9-149">A nice overview presentation of this entire area (as it relates to Hamiltonian Simulation) was given by [Dominic Berry](http://www.dominicberry.org/presentations/Durban.pdf).</span></span>

## <a name="quantum-fourier-transform"></a><span data-ttu-id="a0da9-150">Преобразование Фурье для тактов</span><span class="sxs-lookup"><span data-stu-id="a0da9-150">Quantum Fourier Transform</span></span> ##

<span data-ttu-id="a0da9-151">Преобразование Фурье является фундаментальным инструментом классического анализа и так же важно для вычислений тактов.</span><span class="sxs-lookup"><span data-stu-id="a0da9-151">The Fourier transform is a fundamental tool of classical analysis and is just as important for quantum computations.</span></span>
<span data-ttu-id="a0da9-152">Кроме того, эффективность *преобразования Фурье* (Кфт) значительно превосходит то, что возможно на классической машине, делая ее одним из первых средств, которые можно выбрать при проектировании алгоритма такта.</span><span class="sxs-lookup"><span data-stu-id="a0da9-152">In addition, the efficiency of the *quantum Fourier transform* (QFT) far surpasses what is possible on a classical machine making it one of the first tools of choice when designing a quantum algorithm.</span></span>

<span data-ttu-id="a0da9-153">Как приблизительная обобщение Кфт, мы предоставляем <xref:microsoft.quantum.canon.approximateqft> операцию, которая позволяет выполнять дальнейшую оптимизацию путем очистки поворотов, которые не являются строго необходимыми для требуемой точности алгоритма.</span><span class="sxs-lookup"><span data-stu-id="a0da9-153">As an approximate generalization of the QFT, we provide the <xref:microsoft.quantum.canon.approximateqft> operation that allows for further optimizations by pruning rotations that aren't strictly necessary for the desired algorithmic accuracy.</span></span>
<span data-ttu-id="a0da9-154">Приблизительный Кфт требует операции ДЯДИК $Z $-ротации, а <xref:microsoft.quantum.intrinsic.rfrac> также <xref:microsoft.quantum.intrinsic.h> операции.</span><span class="sxs-lookup"><span data-stu-id="a0da9-154">The approximate QFT requires the dyadic $Z$-rotation operation <xref:microsoft.quantum.intrinsic.rfrac> as well as the <xref:microsoft.quantum.intrinsic.h> operation.</span></span>
<span data-ttu-id="a0da9-155">Предполагается, что входные и выходные данные кодируются в кодировке с обратным порядком байтов---т. е. кубит с индексом `0` кодируется в крайнем левом (верхнем) бит двоичного целочисленного представления.</span><span class="sxs-lookup"><span data-stu-id="a0da9-155">The input and output are assumed to be encoded in big endian encoding---that is, the qubit with index `0` is encoded in the left-most (highest) bit of the binary integer representation.</span></span>
<span data-ttu-id="a0da9-156">Это согласуется с [нотацией Сисакет](xref:microsoft.quantum.concepts.dirac), как регистр трех Кубитс в состоянии $ \кет {100} $ соответствует $q _0 $ в состоянии $ \кет {1} $, а $q _1 $ и $q _2 $ находятся в состоянии $ \кет {0} $.</span><span class="sxs-lookup"><span data-stu-id="a0da9-156">This aligns with [ket notation](xref:microsoft.quantum.concepts.dirac), as a register of three qubits in the state $\ket{100}$ corresponds to $q_0$ being in the state $\ket{1}$ while $q_1$ and $q_2$ are both in state $\ket{0}$.</span></span>
<span data-ttu-id="a0da9-157">Параметр аппроксимации $a $ определяет уровень очистки $Z $-поворотов, т. е. $a \ин [0.. n] $.</span><span class="sxs-lookup"><span data-stu-id="a0da9-157">The approximation parameter $a$ determines the pruning level of the $Z$-rotations, i.e., $a \in [0..n]$.</span></span>
<span data-ttu-id="a0da9-158">В этом случае все $Z $-ротации $2 \ PI/2 ^ k $, где $k > $, удаляются из цепи Кфт.</span><span class="sxs-lookup"><span data-stu-id="a0da9-158">In this case all $Z$-rotations $2\pi/2^k$ where $k > a$ are removed from the QFT circuit.</span></span>
<span data-ttu-id="a0da9-159">Известно, что для $k \же \ log_2 (n) + \ log_2 (1/\епсилон) + $3.</span><span class="sxs-lookup"><span data-stu-id="a0da9-159">It is known that for $k \ge \log_2(n) + \log_2(1 / \epsilon) + 3$.</span></span> <span data-ttu-id="a0da9-160">можно привязать $ \\ | \операторнаме{Кфт}-\операторнаме{акфт} \\ | < \епсилон $.</span><span class="sxs-lookup"><span data-stu-id="a0da9-160">one can bound $\\| \operatorname{QFT} - \operatorname{AQFT} \\| < \epsilon$.</span></span>
<span data-ttu-id="a0da9-161">Здесь $ \\ | \кдот \\ | $ является нормой оператора, который в данном случае является квадратным корнем самого крупного [еиженвалуеа](xref:microsoft.quantum.concepts.matrix-advanced) $ (\операторнаме{Кфт}-\операторнаме{акфт}) (\операторнаме{Кфт}-\операторнаме{акфт}) ^ \dagger $.</span><span class="sxs-lookup"><span data-stu-id="a0da9-161">Here $\\|\cdot\\|$ is the operator norm which in this case is the square root of the largest [eigenvalue](xref:microsoft.quantum.concepts.matrix-advanced) of $(\operatorname{QFT} - \operatorname{AQFT})(\operatorname{QFT} - \operatorname{AQFT})^\dagger$.</span></span>

## <a name="arithmetic"></a><span data-ttu-id="a0da9-162">Арифметические</span><span class="sxs-lookup"><span data-stu-id="a0da9-162">Arithmetic</span></span> ##

<span data-ttu-id="a0da9-163">Как и в случае с арифметическими вычислениями, роль играет в сфере компьютерных вычислений.</span><span class="sxs-lookup"><span data-stu-id="a0da9-163">Just as arithmetic plays a central role in classical computing, it is also indispensable in quantum computing.</span></span>  <span data-ttu-id="a0da9-164">Такие алгоритмы, как алгоритм факторинга Шор, методы моделирования тактов, а также многие алгоритмы оракулар полагаются на согласованные арифметические операции.</span><span class="sxs-lookup"><span data-stu-id="a0da9-164">Algorithms such as Shor's factoring algorithm, quantum simulation methods as well as many oracular algorithms rely upon coherent arithmetic operations.</span></span>  <span data-ttu-id="a0da9-165">Большинство подходов к арифметической построению на основе цепей тактовой Adder.</span><span class="sxs-lookup"><span data-stu-id="a0da9-165">Most approaches to arithmetic build upon quantum adder circuits.</span></span>  <span data-ttu-id="a0da9-166">Простейший Adder принимает классическое входное $b $ и добавляет значение в состояние такта, содержащее целое число $ \кет{а} $.</span><span class="sxs-lookup"><span data-stu-id="a0da9-166">The simplest adder takes a classical input $b$ and adds the value to a quantum state holding an integer $\ket{a}$.</span></span>  <span data-ttu-id="a0da9-167">С помощью математического выражения Adder (который, по-вашему, стоит $ \Операторнаме{адд} (b) $ для классического ввода $b $) имеет свойство, которое</span><span class="sxs-lookup"><span data-stu-id="a0da9-167">Mathematically, the adder (which we denote $\operatorname{Add}(b)$ for classical input $b$) has the property that</span></span>

<span data-ttu-id="a0da9-168">$ $ \Операторнаме{адд} (b) \кет{а} = \кет{а + b}.</span><span class="sxs-lookup"><span data-stu-id="a0da9-168">$$ \operatorname{Add}(b)\ket{a}=\ket{a + b}.</span></span>
<span data-ttu-id="a0da9-169">$ $ Этот базовый канал Adder является более инкрементным, чем Adder.</span><span class="sxs-lookup"><span data-stu-id="a0da9-169">$$ This basic adder circuit is more of an incrementer than an adder.</span></span>
<span data-ttu-id="a0da9-170">Его можно преобразовать в Adder с двумя входными тактами через $ $ \Операторнаме{адд}\кет{а}\кет{б} = \кет{а}\кет{а + b}, $ $ с помощью $n $ controlled Applications методах формы \бегин{алигн} \Операторнаме{адд} \ket{a} \ket{b} & = \Lambda \_ {a \_ 0} \Left (\operatorname{Add} (1) \Right) \Lambda {a \_ \_ 1} \left (\operatorname{Add} (2) \right) \Lambda \_ {a \_ 2} \left (\operatorname{Add} (4) \right) \cdots \Lambda \_ {a \_ {n-1}} \left (\operatorname{Add} ({{n-1}}) \right) \ket{a}\ket{b} \\ \\ & = \ket{a} \ket{b + a}, \end{align} для $n $-разрядных целых чисел $a $ и $b $ и сложения по модулю $2 ^ n $.</span><span class="sxs-lookup"><span data-stu-id="a0da9-170">It can be converted into an adder that has two quantum inputs via $$ \operatorname{Add}\ket{a}\ket{b}=\ket{a}\ket{a+b}, $$ using $n$ controlled applications of adders of the form \begin{align} \operatorname{Add} \ket{a} \ket{b} & = \Lambda\_{a\_0} \left(\operatorname{Add}(1) \right) \Lambda\_{a\_1} \left(\operatorname{Add}(2) \right) \Lambda\_{a\_2} \left(\operatorname{Add}(4) \right) \cdots \Lambda\_{a\_{n-1}} \left(\operatorname{Add}({{n-1}}) \right) \ket{a}\ket{b} \\\\ & = \ket{a} \ket{b + a}, \end{align} for $n$-bit integers $a$ and $b$ and addition modulo $2^n$.</span></span>  <span data-ttu-id="a0da9-171">Помните, что нотация $ \Ламбда \_ x (A) $ относится к любой операции, $A $, к управляемой версии этой операции с помощью элемента управления кубит $x $ AS.</span><span class="sxs-lookup"><span data-stu-id="a0da9-171">Recall that the notation $\Lambda\_x(A)$ refers, for any operation $A$, to the controlled version of that operation with the qubit $x$ as control.</span></span>

<span data-ttu-id="a0da9-172">Аналогичным образом, классический контролируемый способ умножения (Модульная форма, которая необходима для алгоритма факторинга Шор) может быть выполнена с помощью аналогичной серии контролируемых дополнений: \бегин{алигн} \Операторнаме{мулт} (a) \кет{КС}\кет{б} & = \Ламбда \_ {x \_ 0} \Лефт (\операторнаме{адд} (2 ^ 0 а) \Right) \Lambda \_ {a \_ 1} \left (\operatorname{Add} (2 ^ 1a) \right) \Lambda \_ {a \_ 2} \left (\operatorname{Add} (2 ^ 2 а) \right) \cdots \Lambda \_ {x \_ {n-1}} \left (\operatorname{Add} ({2 ^ {n-1}} a) \right) \ket{x}\ket{b} \\ \\ & = \ket{x}\ket{b + AX}.</span><span class="sxs-lookup"><span data-stu-id="a0da9-172">Similarly, classically controlled multiplication (a modular form of which is essential for Shor's factoring algorithm) can be performed by using a similar series of controlled  additions: \begin{align} \operatorname{Mult}(a)\ket{x}\ket{b} & = \Lambda\_{x\_0}\left(\operatorname{Add}(2^0 a)\right) \Lambda\_{a\_1}\left(\operatorname{Add}(2^1a)\right) \Lambda\_{a\_2}\left(\operatorname{Add}(2^2 a)\right) \cdots \Lambda\_{x\_{n-1}} \left(\operatorname{Add}({2^{n-1}}a) \right)\ket{x}\ket{b} \\\\ & = \ket{x}\ket{b+ax}.</span></span>
<span data-ttu-id="a0da9-173">\енд{алигн} на тактовых компьютерах есть тонкость, которую вы можете заметить в определении $ \Операторнаме{мулт} $ выше.</span><span class="sxs-lookup"><span data-stu-id="a0da9-173">\end{align} There is a subtlety with multiplication on quantum computers that you may notice from the definition of $\operatorname{Mult}$ above.</span></span>  <span data-ttu-id="a0da9-174">В отличие от добавления, тактовая версия этой цепи сохраняет продукт входных данных во вспомогательном регистре, а не во входном регистре.</span><span class="sxs-lookup"><span data-stu-id="a0da9-174">Unlike addition, the quantum version of this circuit stores the product of the inputs in an ancillary register rather than in the input register.</span></span>  <span data-ttu-id="a0da9-175">В этом примере регистр инициализируется значением $b $, но обычно он начинает удерживать нулевое значение.</span><span class="sxs-lookup"><span data-stu-id="a0da9-175">In this example, the register is initialized with the value $b$, but typically it will start holding the value zero.</span></span>  <span data-ttu-id="a0da9-176">Это необходимо в том случае, если в общем нет мультипликативные для общих $a $ и $x $.</span><span class="sxs-lookup"><span data-stu-id="a0da9-176">This is needed in because in general there is not a multiplicative inverse for general $a$ and $x$.</span></span>  <span data-ttu-id="a0da9-177">Так как все операции над тактами, сохранение измерения, являются обратимыми, нам нужно сохранить достаточно информации, чтобы инвертировать умножение.</span><span class="sxs-lookup"><span data-stu-id="a0da9-177">Since all quantum operations, save measurement, are reversible we need to keep enough information around to invert the multiplication.</span></span>  <span data-ttu-id="a0da9-178">По этой причине результат сохраняется в отдельном массиве.</span><span class="sxs-lookup"><span data-stu-id="a0da9-178">For this reason the result is stored in a separate array.</span></span>  <span data-ttu-id="a0da9-179">Этот прием необратимой операции, например умножения, в отдельном регистре называется «Беннет хитростью» после Чарли Беннет и является фундаментальным средством как в обратимых, так и в тактовых вычислениях.</span><span class="sxs-lookup"><span data-stu-id="a0da9-179">This trick of saving the output of an irreversible operation, like multiplication, in a separate register is known as the "Bennett trick" after Charlie Bennett and is a fundamental tool in both reversible and quantum computing.</span></span>

<span data-ttu-id="a0da9-180">Многие тактовые цепи были предложены для сложения, и каждый из них изучает различные компромиссы с точки зрения количества Кубитс (пробел) и количества требуемых операций (времени) шлюза.</span><span class="sxs-lookup"><span data-stu-id="a0da9-180">Many quantum circuits have been proposed for addition and each explores a different tradeoff in terms of the number of qubits (space) and the number of gate operations (time) required.</span></span>  <span data-ttu-id="a0da9-181">Мы рассмотрим два эффективных методах, которые в значительной степени пространства называются Драпер Adder и Беаурегард Adder.</span><span class="sxs-lookup"><span data-stu-id="a0da9-181">We review two highly space efficient adders below known as the Draper adder and the Beauregard adder.</span></span>

### <a name="draper-adder"></a><span data-ttu-id="a0da9-182">Драпер Adder</span><span class="sxs-lookup"><span data-stu-id="a0da9-182">Draper Adder</span></span> ###

<span data-ttu-id="a0da9-183">Драпер Adder, вероятно, является одним из самых элегантных методах тактов, так как он напрямую вызывает свойства такта для выполнения сложения.</span><span class="sxs-lookup"><span data-stu-id="a0da9-183">The Draper adder is arguably one of the most elegant quantum adders, as it directly invokes quantum properties to perform addition.</span></span>  <span data-ttu-id="a0da9-184">Понимание Драпер Adder заключается в том, что преобразование Фурье можно использовать для перевода сдвига этапа в Поразрядный сдвиг.</span><span class="sxs-lookup"><span data-stu-id="a0da9-184">The insight behind the Draper adder is that the Fourier transform can be used to translate phase shifts into a bit shift.</span></span>  <span data-ttu-id="a0da9-185">Затем следует применить преобразование Фурье, применить соответствующие сдвиги этапа, а затем отменить преобразование Фурье, чтобы реализовать Adder.</span><span class="sxs-lookup"><span data-stu-id="a0da9-185">It then follows that by applying a Fourier transform, applying appropriate phase shifts, and then undoing the Fourier transform you can implement an adder.</span></span>  <span data-ttu-id="a0da9-186">В отличие от многих других методах, Драпер Adder явно использует тактовые эффекты, появившиеся в процессе преобразования Фурье в тактовой форме.</span><span class="sxs-lookup"><span data-stu-id="a0da9-186">Unlike many other adders that have been proposed, the Draper adder explicitly uses quantum effects introduced through the quantum Fourier transform.</span></span>  <span data-ttu-id="a0da9-187">У него нет естественного классического аналога.</span><span class="sxs-lookup"><span data-stu-id="a0da9-187">It does not have a natural classical counterpart.</span></span>  <span data-ttu-id="a0da9-188">Ниже приведены конкретные шаги Драпер Adder.</span><span class="sxs-lookup"><span data-stu-id="a0da9-188">The specific steps of the Draper adder are given below.</span></span>

<span data-ttu-id="a0da9-189">Предположим, что у вас есть два $n $-битных регистров кубит, в которых хранятся целые числа $a $ и $b $ then для всех $a $ $ $ \Операторнаме{Кфт}\кет{а} = \фрак {1} {\sqrt{2 ^ n}} \сум \_ {j = 0} ^ {2 ^ n-1} e ^ {i2\pi (AJ)/2 ^ n} \кет{ж}.</span><span class="sxs-lookup"><span data-stu-id="a0da9-189">Assume that you have two $n$-bit qubit registers storing the integers $a$ and $b$ then for all $a$ $$ \operatorname{QFT}\ket{a}= \frac{1}{\sqrt{2^n}}\sum\_{j=0}^{2^n-1} e^{i2\pi(aj)/2^n} \ket{j}.</span></span>
<span data-ttu-id="a0da9-190">$ $ Если мы определяем $ $ \кет{\фи \_ k (a)} = \фрак {1} {\скрт {2} } \лефт (\кет {0} + e ^ {i2\pi a/2 ^ k} \кет {1} \ригхт), $ $ после некоторого момента можно увидеть, что $ $ \операторнаме{Кфт}\кет{а} = \кет{\фи \_ 1 (a)} \отимес \cdots \otimes \ket{\Phi \_ n (a)}.</span><span class="sxs-lookup"><span data-stu-id="a0da9-190">$$ If we define $$ \ket{\phi\_k(a)} = \frac{1}{\sqrt{2}}\left(\ket{0} + e^{i2\pi a /2^k}\ket{1} \right), $$ then after some algebra you can see that $$ \operatorname{QFT}\ket{a}=\ket{\phi\_1(a)}\otimes \cdots \otimes \ket{\phi\_n(a)}.</span></span>
<span data-ttu-id="a0da9-191">$ $ Путь к выполнению Adder, после чего будет ясно, что сумма входных данных может быть записана как $ $ \кет{а + b} = \Операторнаме{Кфт} ^ {-1} \кет{\фи \_ 1 (a + b)} \отимес \кдотс \отимес \кет{\фи \_ n (a + b)}.</span><span class="sxs-lookup"><span data-stu-id="a0da9-191">$$ The path towards performing an adder then becomes clear after observing that the sum of the inputs can be written as $$ \ket{a+b}=\operatorname{QFT}^{-1}\ket{\phi\_1(a+b)}\otimes \cdots \otimes \ket{\phi\_n(a+b)}.</span></span>
<span data-ttu-id="a0da9-192">$ $ После этого можно добавить целые числа $b $ и $a $, выполнив управляемый поворот на каждом из Кубитс в декомпозиции с использованием битов $b $ в качестве элементов управления.</span><span class="sxs-lookup"><span data-stu-id="a0da9-192">$$ The integers $b$ and $a$ can then be added by performing controlled-phase rotation on each of the qubits in the decomposition using the bits of $b$ as controls.</span></span>

<span data-ttu-id="a0da9-193">Это расширение можно упростить, отметив, что для любого целого числа $j $ и вещественное число $x $ $e ^ {i2\pi (x + j)} = e ^ {i2\pi x} $.</span><span class="sxs-lookup"><span data-stu-id="a0da9-193">This expansion can be further simplified by noting that for any integer $j$ and real number $x$, $e^{i2\pi(x+j)}=e^{i2\pi x}$.</span></span>  <span data-ttu-id="a0da9-194">Это связано с тем, что если вы поворачиваете $360 ^ {\Цирк} $ градусы ($ 2 \ PI $ радианы) в круге, то сможете точно приступить к работе.</span><span class="sxs-lookup"><span data-stu-id="a0da9-194">This is because if you rotate $360^{\circ}$ degrees ($2\pi$ radians) in a circle then you end up precisely where you started.</span></span>  <span data-ttu-id="a0da9-195">Единственная важная часть $x $ for $e ^ {i2\pi x} $, таким образом, является дробной частью $x $.</span><span class="sxs-lookup"><span data-stu-id="a0da9-195">The only important part of $x$ for $e^{i2\pi x}$ is therefore the fractional part of $x$.</span></span>  <span data-ttu-id="a0da9-196">В частности, если у нас есть двоичное расширение формы $x = y +0. x \_ 0x \_ 2 \ лдотс x \_ n $ then $e ^ {i2\pi x} = e ^ {i2\pi (0. x \_ 0x \_ 2 \ лдотс x \_ {n-1})} $ и, следовательно, $ $ \кет{\фи \_ k (a + b)} = \фрак {1} {\скрт {2} } \лефт (\кет {0} + e ^ {i2\pi [a/2 ^ k +0. b \_ К\лдотс b \_ 1]} \кет {1} \ригхт). $ $ Это означает, что если мы выполняем сложение путем увеличения каждого из тензорные факторов в расширении преобразования Фурье для $ \кет{а} $, число поворотов сокращается как $k $ уменьшаются.</span><span class="sxs-lookup"><span data-stu-id="a0da9-196">Specifically, if we have a binary expansion of the form $x=y+0.x\_0x\_2\ldots x\_n$ then $e^{i2\pi x}=e^{i2\pi (0.x\_0x\_2\ldots x\_{n-1})}$ and hence $$\ket{\phi\_k(a+b)}=\frac{1}{\sqrt{2}}\left(\ket{0} + e^{i2\pi [a/2^k+0.b\_k\ldots b\_1]}\ket{1} \right).$$ This means that if we perform addition by incrementing each of the tensor factors in the expansion of the Fourier transform of $\ket{a}$ then the number of rotations shrinks as $k$ decreases.</span></span>  <span data-ttu-id="a0da9-197">Это значительно сокращает число шлюзов тактов, необходимых в Adder.</span><span class="sxs-lookup"><span data-stu-id="a0da9-197">This substantially reduces the number of quantum gates needed in the adder.</span></span>  <span data-ttu-id="a0da9-198">Мы будем заметку о преобразовании Фурье, добавлении этапов и обратных шагах преобразования Фурье, которые составляют Драпер Adder как $ \Операторнаме{Кфт} ^ {-1} \лефт (\Фи \\ \! \операторнаме{адд}\ригхт) \операторнаме{Кфт} $.</span><span class="sxs-lookup"><span data-stu-id="a0da9-198">We denote the Fourier transform, phase addition and the inverse Fourier transform steps that comprise the Draper adder as $\operatorname{QFT}^{-1} \left(\phi\\\!\operatorname{ADD}\right) \operatorname{QFT}$.</span></span> <span data-ttu-id="a0da9-199">Ниже показана тактовая цепь, использующая эту упрощение для реализации всего процесса.</span><span class="sxs-lookup"><span data-stu-id="a0da9-199">A quantum circuit that uses this simplification to implement the entire process can be seen below.</span></span>

![Драпер Adder показан в виде схемы цепи](~/media/draper.svg)

<span data-ttu-id="a0da9-201">Каждый контролируемый $e ^ {I2 \ PI/k} $ в цепи относится к управляемому шлюзу.</span><span class="sxs-lookup"><span data-stu-id="a0da9-201">Each controlled $e^{i2\pi/k}$ gate in the circuit refers to a controlled-phase gate.</span></span>  <span data-ttu-id="a0da9-202">Такие шлюзы имеют свойство, связанное с парой Кубитс, в которой они действуют, $ \кет {00} \мапсто \кет {00} $, но $ \кет {11} \мапсто e ^ {I2 \ PI/k} \ Сисакет {11} $.</span><span class="sxs-lookup"><span data-stu-id="a0da9-202">Such gates have the property that on the pair of qubits on which they act, $\ket{00}\mapsto \ket{00}$ but $\ket{11}\mapsto e^{i2\pi/k}\ket{11}$.</span></span>  <span data-ttu-id="a0da9-203">Эта цепь позволяет нам выполнять сложение без дополнительных Кубитс, кроме тех, которые необходимы для хранения входных и выходных данных.</span><span class="sxs-lookup"><span data-stu-id="a0da9-203">This circuit allows us to perform addition using no additional qubits apart from those needed to store the inputs and the outputs.</span></span>

### <a name="beauregard-adder"></a><span data-ttu-id="a0da9-204">Беаурегард Adder</span><span class="sxs-lookup"><span data-stu-id="a0da9-204">Beauregard Adder</span></span> ###

<span data-ttu-id="a0da9-205">Беаурегард Adder — это тактовая Модульная Adder, использующая Драпер Adder для выполнения сложения по модулю $N $ для произвольного положительного целого числа $N $.</span><span class="sxs-lookup"><span data-stu-id="a0da9-205">The Beauregard adder is a quantum modular adder that uses the Draper adder in order to perform addition modulo $N$ for an arbitrary value positive integer $N$.</span></span>  <span data-ttu-id="a0da9-206">Значение тактовой модульной методахи, например Беаурегард Adder, разработано в больших экстентах, от их использования в действии модульного энерговедения в рамках алгоритма Шор для факторинга.</span><span class="sxs-lookup"><span data-stu-id="a0da9-206">The significance of quantum modular adders, such as the Beauregard adder, stems to a large extent from their use in the modular exponentiation step within Shor's algorithm for factoring.</span></span>  <span data-ttu-id="a0da9-207">Тактовая Модульная Modular Adder имеет следующее действие для входных данных такта $ \кет{б} $ и классического входного $a $, где $a $ и $b $ представляют собой целые числа mod $N $. Это означает, что они находятся в интервале $ [0, \лдотс, N-1] $.</span><span class="sxs-lookup"><span data-stu-id="a0da9-207">A quantum modular adder has the following action for quantum input $\ket{b}$ and classical input $a$ where $a$ and $b$ are promised to be integers mod $N$, meaning that they are in the interval $[0,\ldots, N-1]$.</span></span>

<span data-ttu-id="a0da9-208">$ $ \кет{б}\ригхтарров \кет{б + a \текст{mod} N} = \бегин{Касес} \кет{б + a}, & б + a < N \\ \\ \кет{б + a-N}, & (b + a) \же N \енд{Касес}.</span><span class="sxs-lookup"><span data-stu-id="a0da9-208">$$ \ket{b}\rightarrow \ket{b+a \text{ mod }N}=\begin{cases} \ket{b+a},& b+a < N\\\\ \ket{b+a-N},& (b+a)\ge N \end{cases}.</span></span>
$$

<span data-ttu-id="a0da9-209">Беаурегард Adder использует Драпер Adder или точнее $ \фи \\ \! \операторнаме{адд} $, чтобы добавить $a $ и $b $ in.</span><span class="sxs-lookup"><span data-stu-id="a0da9-209">The Beauregard adder uses the Draper adder, or more specifically $\phi\\\!\operatorname{ADD}$, to add $a$ and $b$ in phase.</span></span>  <span data-ttu-id="a0da9-210">Затем она использует ту же операцию для того, чтобы определить, $a + b <N $ путем вычитания $N $ и проверки, если $a + b-N<$0.</span><span class="sxs-lookup"><span data-stu-id="a0da9-210">It then uses the same operation to identify whether $a+b <N$ by subtracting $N$ and testing if $a+b-N<0$.</span></span>  <span data-ttu-id="a0da9-211">Эта информация хранится в вспомогательной кубит, а затем добавляется $N $ обратно в регистр, если $a + b<N $.</span><span class="sxs-lookup"><span data-stu-id="a0da9-211">The circuit stores this information in an ancillary qubit and then adds $N$ back the register if $a+b<N$.</span></span>  <span data-ttu-id="a0da9-212">Затем он завершается невычислением этого вспомогательного бита (этот шаг необходим для того, чтобы анЦилла можно было отменить выделение после вызова Adder).</span><span class="sxs-lookup"><span data-stu-id="a0da9-212">It then concludes by uncomputing this ancillary bit (this step is needed to ensure that the ancilla can be de-allocated after calling the adder).</span></span>  <span data-ttu-id="a0da9-213">Цепь для Беаурегард Adder указана ниже.</span><span class="sxs-lookup"><span data-stu-id="a0da9-213">The circuit for the Beauregard adder is given below.</span></span>

![Беаурегард Adder показан в виде схемы цепи](~/media/beau.svg)

<span data-ttu-id="a0da9-215">Здесь шлюз $ \Фи \\ \! \операторнаме{адд} $ принимает ту же форму, что и $ \фи \\ \! \операторнаме{адд} $, за исключением того, что в этом контексте входные данные являются классическим, а не тактом.</span><span class="sxs-lookup"><span data-stu-id="a0da9-215">Here the gate $\Phi\\\!\operatorname{ADD}$ takes the same form as $\phi\\\!\operatorname{ADD}$ except that in this context the input is classical rather than quantum.</span></span>  <span data-ttu-id="a0da9-216">Это позволяет заменять контролируемые этапы в $ \Фи \\ \! \операторнаме{адд} $ многофазными шлюзами, которые затем можно скомпилировать вместе в меньшее количество операций, чтобы сократить число Кубитс и число шлюзов, необходимое для Adder.</span><span class="sxs-lookup"><span data-stu-id="a0da9-216">This allows the controlled phases in $\Phi\\\!\operatorname{ADD}$ to be replaced with phase gates that can then be compiled together into fewer operations to reduce both the number of qubits and number of gates needed for the adder.</span></span>

<span data-ttu-id="a0da9-217">Дополнительные сведения см. в разделе [M. роеттелер, TH. Бет](http://doi.org/10.1007/s00200-008-0072-2 ) и [D. копперсмис](https://arxiv.org/abs/quant-ph/0201067).</span><span class="sxs-lookup"><span data-stu-id="a0da9-217">For more details, please refer to [M. Roetteler, Th. Beth](http://doi.org/10.1007/s00200-008-0072-2 ) and [D. Coppersmith](https://arxiv.org/abs/quant-ph/0201067).</span></span>

### <a name="quantum-phase-estimation"></a><span data-ttu-id="a0da9-218">Оценка квантовых фаз</span><span class="sxs-lookup"><span data-stu-id="a0da9-218">Quantum Phase Estimation</span></span> ###

<span data-ttu-id="a0da9-219">Одним из важнейших приложений преобразования Фурье в тактовой ситуации является изучение еиженвалуес операторов, которые называются *оценкой этапа*.</span><span class="sxs-lookup"><span data-stu-id="a0da9-219">One particularly important application of the quantum Fourier transform is to learn the eigenvalues of unitary operators, a problem known as *phase estimation*.</span></span>
<span data-ttu-id="a0da9-220">Рассмотрим единое $U $ и состояние $ \кет{\фи} $ таким, что $ \кет{\фи} $ является еиженстате $U $ с неизвестным еиженвалуе $ \фи $, \бегин{екуатион} У\кет {\ фи} = \фи\кет{\фи}.</span><span class="sxs-lookup"><span data-stu-id="a0da9-220">Consider a unitary $U$ and a state $\ket{\phi}$ such that $\ket{\phi}$ is an eigenstate of $U$ with unknown eigenvalue $\phi$, \begin{equation} U\ket{\phi} = \phi\ket{\phi}.</span></span>
<span data-ttu-id="a0da9-221">\енд{екуатион} если у нас есть только доступ к $U $ в качестве Oracle, то мы можем изучить этап $ \фи $, используя, что $Z $ повороты, примененные к цели управляемой операции, передаются обратно в элемент управления.</span><span class="sxs-lookup"><span data-stu-id="a0da9-221">\end{equation} If we only have access to $U$ as an oracle, then we can learn the phase $\phi$ by utilizing that $Z$ rotations applied to the target of a controlled operation propagate back onto the control.</span></span>

<span data-ttu-id="a0da9-222">Предположим, что $V $ является управляемым приложением $U $, таким как \бегин{алигн} V (\кет {0} \отимес \кет{\фи}) & = \кет {0} \отимес \кет{\фи} \текстрм{ \\ \\ и} V (\кет {1} \отимес \кет{\фи}) & = e ^ {i \Phi} {1} \ket \otimes \ket{\Phi}.</span><span class="sxs-lookup"><span data-stu-id="a0da9-222">Suppose that $V$ is a controlled application of $U$, such that \begin{align} V (\ket{0} \otimes \ket{\phi}) & =            \ket{0} \otimes \ket{\phi} \\\\ \textrm{ and } V (\ket{1} \otimes \ket{\phi}) & = e^{i \phi} \ket{1} \otimes \ket{\phi}.</span></span>
<span data-ttu-id="a0da9-223">\енд{алигн}, по линейной шкале, \бегин{алигн} V (\кет{+} \отимес \кет{\фи}) & = \фрак{(\кет {0} \отимес \кет{\фи}) + e ^ {i \фи} (\ket {1} \otimes \ket{\Phi})} {\sqrt {2} }.</span><span class="sxs-lookup"><span data-stu-id="a0da9-223">\end{align} Then, by linearity, \begin{align} V(\ket{+} \otimes \ket{\phi}) & = \frac{ (\ket{0} \otimes \ket{\phi}) + e^{i \phi} (\ket{1} \otimes \ket{\phi}) }{\sqrt{2}}.</span></span>
<span data-ttu-id="a0da9-224">\енд{алигн} мы можем собираются термины, чтобы найти \бегин{алигн} V (\кет{+} \отимес \кет{\фи}) & = \фрак{\кет {0} + e ^ {i \фи} \кет {1} } {\скрт {2} } \отимес \ket{\Phi} \\ \\ & = (R_1 (\Phi) \ket{+}) \otimes \ket{\phi}, \end{align}, где $R _1 $ — это единое действие, применяемое <xref:microsoft.quantum.intrinsic.r1> операцией.</span><span class="sxs-lookup"><span data-stu-id="a0da9-224">\end{align} We can collect terms to find that \begin{align} V(\ket{+} \otimes \ket{\phi}) & = \frac{\ket{0} + e^{i \phi} \ket{1}}{\sqrt{2}} \otimes \ket{\phi} \\\\ & = (R_1(\phi) \ket{+}) \otimes \ket{\phi}, \end{align} where $R_1$ is the unitary applied by the <xref:microsoft.quantum.intrinsic.r1> operation.</span></span>
<span data-ttu-id="a0da9-225">Иначе говоря, результат применения $V $ точно такой же, как применение $R _1 $ с неизвестным углом, несмотря на то, что у нас есть доступ только к $V $ в качестве Oracle.</span><span class="sxs-lookup"><span data-stu-id="a0da9-225">Put differently, the effect of applying $V$ is precisely the same as applying $R_1$ with an unknown angle, even though we only have access to $V$ as an oracle.</span></span>
<span data-ttu-id="a0da9-226">Таким образом, в оставшейся части этого обсуждения мы рассмотрим оценку этапа в терминах $R _1 (\фи) $, которые мы реализуем с помощью так называемого *этапа киккбакк*.</span><span class="sxs-lookup"><span data-stu-id="a0da9-226">Thus, for the rest of this discussion we will discuss phase estimation in terms of $R_1(\phi)$, which we implement by using so-called *phase kickback*.</span></span>

<span data-ttu-id="a0da9-227">Так как элемент управления и целевой регистр остаются унтанглед после этого процесса, мы можем повторно использовать $ \кет{\фи} $ в качестве целевого объекта управляемого приложения $U ^ $2 для подготовки второго элемента управления кубит в состоянии $R _1 (2 \фи) \кет{+} $.</span><span class="sxs-lookup"><span data-stu-id="a0da9-227">Since the control and target register remain untangled after this process, we can reuse $\ket{\phi}$ as the target of a controlled application of $U^2$ to prepare a second control qubit in the state $R_1(2 \phi) \ket{+}$.</span></span>
<span data-ttu-id="a0da9-228">Продолжая таким образом, можно получить регистр в формате \бегин{алигн} \кет{\пси} & = \ sum_ {j = 0} ^ n R_1 (2 ^ j \фи) \кет{+} \\ \\ & \пропто \ bigotimes_ {j = 0} ^ {n} \лефт (\кет {0} + \експ (i 2 ^ {j} \фи) \кет {1} \ригхт) \\ \\ & \пропто \ sum_ {k = 0} ^ {2 ^ n – 1} \експ (i \Phi k) \ket{k} \end{align}, где $n $ — число требуемых разрядов точности, и где мы использовали $ {} \propto {} $, чтобы указать, что мы отменяли коэффициент нормализации $1/\sqrt{2 ^ n} $.</span><span class="sxs-lookup"><span data-stu-id="a0da9-228">Continuing in this way, we can obtain a register of the form \begin{align} \ket{\psi} & = \sum_{j = 0}^n R_1(2^j \phi) \ket{+} \\\\ & \propto \bigotimes_{j=0}^{n} \left(\ket{0} + \exp(i 2^{j} \phi) \ket{1}\right) \\\\ & \propto \sum_{k = 0}^{2^n - 1} \exp(i \phi k) \ket{k} \end{align} where $n$ is the number of bits of precision that we require, and where we have used ${} \propto {}$ to indicate that we have suppressed the normalization factor of $1 / \sqrt{2^n}$.</span></span>

<span data-ttu-id="a0da9-229">Если предполагается, что $ \фи = 2 \пи p/2 ^ k $ для целого числа $p $, то мы понимаем это как $ \кет{\пси} = \Операторнаме{Кфт} \кет{p_0 p_1 \дотс p_n} $, где $p _j $ — $j ^ {\текстрм{с}} $ $2 \пи \фи $.</span><span class="sxs-lookup"><span data-stu-id="a0da9-229">If we assume that $\phi = 2 \pi p / 2^k$ for an integer $p$, then we recognize this as $\ket{\psi} = \operatorname{QFT} \ket{p_0 p_1 \dots p_n}$, where $p_j$ is the $j^{\textrm{th}}$ bit of $2 \pi \phi$.</span></span>
<span data-ttu-id="a0da9-230">Применяя смежную часть преобразования Фурье в тактовой области, мы получаем двоичное представление этапа, закодированного как состояние такта.</span><span class="sxs-lookup"><span data-stu-id="a0da9-230">Applying the adjoint of the quantum Fourier transform, we therefore obtain the binary representation of the phase encoded as a quantum state.</span></span>

<span data-ttu-id="a0da9-231">В Q# это реализуется <xref:microsoft.quantum.characterization.quantumphaseestimation> операцией, которая принимает <xref:microsoft.quantum.oracles.discreteoracle> реализацию приложения $U ^ m $ в качестве функции положительных целых чисел $m $.</span><span class="sxs-lookup"><span data-stu-id="a0da9-231">In Q#, this is implemented by the <xref:microsoft.quantum.characterization.quantumphaseestimation> operation, which takes a <xref:microsoft.quantum.oracles.discreteoracle> implementing application of $U^m$ as a function of positive integers $m$.</span></span>
