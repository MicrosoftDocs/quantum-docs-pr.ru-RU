---
title: 'Алгоритмы такта в Q #'
description: Сведения об основных алгоритмах тактовой обработки, включая усиление амплитуды, преобразование Фурье, Драпер и Беаурегард методах, а также оценку фазы.
author: QuantumWriter
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
uid: microsoft.quantum.libraries.standard.algorithms
ms.openlocfilehash: 7f4916353c53d6459356243098281ccb16b17278
ms.sourcegitcommit: cdf67362d7b157254e6fe5c63a1c5551183fc589
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/21/2020
ms.locfileid: "86871320"
---
# <a name="quantum-algorithms"></a>Алгоритмы такта #

## <a name="amplitude-amplification"></a>Усиление амплитуды ##

*Усиление амплитуды* — одно из фундаментальных средств тактовых вычислений. Это фундаментальная идея, которая лежит в основе поиска Гровер, оценки амплитуды и многих алгоритмов машинного обучения для тактов.  Существует много вариантов, и в Q # Мы предоставляем общую версию на основе усиления амплитуды очевидным с частичными отражениями, чтобы обеспечить широкую область применения.

Центральной идеей для усиления амплитуды является повысить эффективность вероятность желаемого результата, выполняя последовательность отражений.  Эти отражения поворачивают начальное состояние ближе к желаемому целевому состоянию, которое часто называется помеченным состоянием.  В частности, если вероятность измерения начального состояния до помеченного состояния — $ \син ^ 2 (\сета) $, после применения усиления амплитуды $m $ раз вероятность успеха становится равна $ \син ^ 2 ((2 MБ + 1) \сета) $.  Это означает, что если $ \сета = \ PI/[2 (2n + 1)] $ для некоторого значения $n $, то при повышении амплитуды может повыситься вероятность успеха $100 \\ % $ после $n $ итераций усиления амплитуды.  Начиная с $ \сета = \син ^ {-1} (\скрт{\пр (успешно)}) $ это означает, что число итераций, необходимых для успешного получения результата, в корне меньше ожидаемого числа, необходимого для поиска помеченного состояния, недетерминированного с помощью случайной выборки.

Для каждой итерации усиления амплитуды необходимо указать два оператора отражения. В частности, если $Q $ является итерацией для усиления амплитуды и $P _0 $ является оператором-проектором на начальном подпространстве, а $P _1 $ является проектором на помеченный пробел, то $Q =-(\болдоне-2P_0) (\болдоне-2P_1) $.  Вспомним, что проектор — это Хермитиан оператор, который имеет еиженвалуес $ + $1 и $0 $, и в результате $ (\болдоне-2P_0) $ является единым, так как он имеет еиженвалуес, являющиеся корнями Unity (в данном случае $ \пм $1). В качестве примера рассмотрим вариант поиска Гровер с начальным состоянием $H ^ {\отимес n} \кет {0} $ и помеченным State $ \кет{м} $, $P _0 = H ^ {\отимес n} \кет {0} \бра {0} H ^ {\отимес n} $ and $P _1 = \кет{м}\бра{м} $.  В большинстве приложений для усиления амплитуды $P _0 $ будет являться проектором на начальное состояние, означающее, что $P _0 = \болдоне-2 \ Сисакет {\ PSI} \ неверное {\ PSI} $ для некоторых векторов $ \кет{\пси} $; Однако для очевидным амплитуда ампликатион $P _0 $ обычно проецируется на множество состояний тактов (т. е. Кратность $1 еиженвалуе $P _0 $ больше $1 $).

Логика, основанная на усилении амплитуды, следует непосредственно за еижен-декомпозицией $Q $.  В частности, основе собственных векторов $Q $ о том, что начальное состояние имеет ненулевую поддержку, может отображаться как линейное $1 сочетание $P основе собственных векторов _0 $ и $P _1 $.  В частности, исходное состояние для усиления амплитуды (при условии, что это $ + $1 еиженвектор $P _0 $) может быть записано как $ $ \кет{\пси} = \фрак{-и}{\скрт {2} } \лефт (e ^ {и\сета} \ Сисакет {\ psi_ +} + e ^ {-и\сета} \ Сисакет {\ psi_-} \ригхт). $ $ где $ \кет{\ psi_ \пм} $ основе собственных векторов из $Q $ с еиженвалуес $e ^ {\pm 2i \ тета} $ и поддерживает только основе собственных векторов $ + $1 _0 из $P $ и $P _1 $.  Тот факт, что еиженвалуес $e ^ {\пм i \сета} $ означает, что оператор $Q $ выполняет поворот в двухмерном пространстве, заданном двумя проекторами, и начальное состояние, где угол поворота равен $2 \ тета $.  Именно поэтому после $m $ итераций $Q $ вероятность успеха равна $ \син ^ 2 ([2 MБ + 1] \сета) $.

Еще одно полезное свойство, которое выходит за пределы этого, заключается в том, что еиженвалуе $ \сета $ напрямую связан с вероятностью того, что первоначальное состояние было бы отмечено (в случае, когда $P _0 $ является проектором только в первоначальном состоянии).  Так как $Q еиженфасес $ имеет значение $2 \ тета = 2 \ Sin ^ {-1} (\скрт{\пр (Success)}) $, то после применения оценки этапа к $Q $ мы можем узнать вероятность успеха для единой тактовой процедуры.  Это полезно, так как для изучения вероятности успеха, которая в противном случае потребовалась бы в случае успешного выполнения, требуется не менее чем больше приложений тактовой процедуры.

Q # вводит усиление амплитуды в качестве специализации усиления амплитуды очевидным.  Усиление амплитуды очевидным зарабатывает этот моникер, так как проектор на первоначальной еиженспаце не должен быть проектором в первоначальном состоянии.  В этом смысле протокол очевидным в исходное состояние.  Ключевое приложение усиления амплитуды очевидным — это определенные *линейные комбинации единых* методов моделирования хамилтониан, где начальное состояние неизвестно, но становится запутанными с регистрацией анЦилла в протоколе моделирования.  Если регистр анЦилла должен быть фиксированным значением, скажем $0 $, то такие методы моделирования применяют необходимое единое преобразование к оставшимся Кубитс (называемым системным регистром).  Однако все остальные результаты измерений ведут к сбою.  Усиление амплитуды очевидным позволяет повысить вероятность успеха этого измерения до $100 \\ % $ с помощью описанной выше причины.  Кроме того, обычное усиление амплитуды соответствует случаю, когда регистр системы пуст.  Именно поэтому Q # использует усиление амплитуды очевидным в качестве основной подпрограммы для усиления амплитуды.

Общая подпрограммы ( `AmpAmpObliviousByReflectionPhases` ) имеет два регистра, которые мы вызываем `ancillaRegister` и `systemRegister` . Он также принимает два Oracle для необходимых отражений. Объект `ReflectionOracle` действует только в, `ancillaRegister` а `ObliviousOracle` действует совместно с обеими регистрами. Входные данные `ancillaRegister` должны быть инициализированы значением-1 еиженстате первого оператора отражения $ \болдоне-2P_1 $.

Как правило, Oracle готовит состояние в вычислительной базе $ \ket{0...0} $. В нашей реализации объект `ancillaRegister` состоит из одного кубит ( `flagQubit` ), который управляет `stateOracle` и остальной части требуемого анЦиллас. `stateOracle`Применяется, когда параметр `flagQubit` имеет значение $ \кет {1} $.

Один может также предоставлять Oracle `StateOracle` и `ObliviousOracle` вместо отражения с помощью вызова `AmpAmpObliviousByOraclePhases` .

Как уже упоминалось, традиционная усиление амплитуд — это лишь особый случай использования этих подпрограмм, где `ObliviousOracle` является оператором идентификации и отсутствует системный Кубитс (т. е. `systemRegister` пустой). Если вы хотите получить этапы для частичных отражений (например, для поиска Гровер), функция `AmpAmpPhasesStandard` будет доступна. `DatabaseSearch.qs`Пример реализации алгоритма Гровер см. в разделе.

Мы будем связывать фазы ротации кубит с этапами оператора отражения, как описано в документе [Г.х. Low, I. L. Чжуанский](https://arxiv.org/abs/1707.05391). Используемые фазы фиксированной точки подробно описаны в [Йодер, Low и Чжуанский](https://arxiv.org/abs/1409.3305) вместе с этапами [Low, Йодер и Чжуанский](https://arxiv.org/abs/1603.03996).

В качестве фона можно начать с уровня " [стандартный](https://arxiv.org/abs/quant-ph/0005055) ", а затем перейти к вводу в [очевидным с усилением амплитуды](https://arxiv.org/abs/1312.1414) и, наконец, в [Чжуанский](https://arxiv.org/abs/1610.06546). Хорошим обзором всей области (как она относится к моделированию Хамилтониан) было [Dominic Берри](http://www.dominicberry.org/presentations/Durban.pdf).

## <a name="quantum-fourier-transform"></a>Преобразование Фурье для тактов ##

Преобразование Фурье является фундаментальным инструментом классического анализа и так же важно для вычислений тактов.
Кроме того, эффективность *преобразования Фурье* (Кфт) значительно превосходит то, что возможно на классической машине, делая ее одним из первых средств, которые можно выбрать при проектировании алгоритма такта.

Как приблизительная обобщение Кфт, мы предоставляем <xref:microsoft.quantum.canon.approximateqft> операцию, которая позволяет выполнять дальнейшую оптимизацию путем очистки поворотов, которые не являются строго необходимыми для требуемой точности алгоритма.
Приблизительный Кфт требует операции ДЯДИК $Z $-ротации, а <xref:microsoft.quantum.intrinsic.rfrac> также <xref:microsoft.quantum.intrinsic.h> операции.
Предполагается, что входные и выходные данные кодируются в кодировке с обратным порядком байтов---т. е. кубит с индексом `0` кодируется в крайнем левом (верхнем) бит двоичного целочисленного представления.
Это согласуется с [нотацией Сисакет](xref:microsoft.quantum.concepts.dirac), как регистр трех Кубитс в состоянии $ \кет {100} $ соответствует $q _0 $ в состоянии $ \кет {1} $, а $q _1 $ и $q _2 $ находятся в состоянии $ \кет {0} $.
Параметр аппроксимации $a $ определяет уровень очистки $Z $-поворотов, т. е. $a \ин [0.. n] $.
В этом случае все $Z $-ротации $2 \ PI/2 ^ k $, где $k > $, удаляются из цепи Кфт.
Известно, что для $k \же \ log_2 (n) + \ log_2 (1/\епсилон) + $3. можно привязать $ \\ | \операторнаме{Кфт}-\операторнаме{акфт} \\ | < \епсилон $.
Здесь $ \\ | \кдот \\ | $ является нормой оператора, который в данном случае является квадратным корнем самого крупного [еиженвалуеа](xref:microsoft.quantum.concepts.matrix-advanced) $ (\операторнаме{Кфт}-\операторнаме{акфт}) (\операторнаме{Кфт}-\операторнаме{акфт}) ^ \dagger $.

## <a name="arithmetic"></a>Арифметические ##

Как и в случае с арифметическими вычислениями, роль играет в сфере компьютерных вычислений.  Такие алгоритмы, как алгоритм факторинга Шор, методы моделирования тактов, а также многие алгоритмы оракулар полагаются на согласованные арифметические операции.  Большинство подходов к арифметической построению на основе цепей тактовой Adder.  Простейший Adder принимает классическое входное $b $ и добавляет значение в состояние такта, содержащее целое число $ \кет{а} $.  С помощью математического выражения Adder (который, по-вашему, стоит $ \Операторнаме{адд} (b) $ для классического ввода $b $) имеет свойство, которое

$ $ \Операторнаме{адд} (b) \кет{а} = \кет{а + b}.
$ $ Этот базовый канал Adder является более инкрементным, чем Adder.
Его можно преобразовать в Adder с двумя входными тактами через $ $ \Операторнаме{адд}\кет{а}\кет{б} = \кет{а}\кет{а + b}, $ $ с помощью $n $ controlled Applications методах формы \бегин{алигн} \Операторнаме{адд} \ket{a} \ket{b} & = \Lambda \_ {a \_ 0} \Left (\operatorname{Add} (1) \Right) \Lambda {a \_ \_ 1} \left (\operatorname{Add} (2) \right) \Lambda \_ {a \_ 2} \left (\operatorname{Add} (4) \right) \cdots \Lambda \_ {a \_ {n-1}} \left (\operatorname{Add} ({{n-1}}) \right) \ket{a}\ket{b} \\ \\ & = \ket{a} \ket{b + a}, \end{align} для $n $-разрядных целых чисел $a $ и $b $ и сложения по модулю $2 ^ n $.  Помните, что нотация $ \Ламбда \_ x (A) $ относится к любой операции, $A $, к управляемой версии этой операции с помощью элемента управления кубит $x $ AS.

Аналогичным образом, классический контролируемый способ умножения (Модульная форма, которая необходима для алгоритма факторинга Шор) может быть выполнена с помощью аналогичной серии контролируемых дополнений: \бегин{алигн} \Операторнаме{мулт} (a) \кет{КС}\кет{б} & = \Ламбда \_ {x \_ 0} \Лефт (\операторнаме{адд} (2 ^ 0 а) \Right) \Lambda \_ {a \_ 1} \left (\operatorname{Add} (2 ^ 1a) \right) \Lambda \_ {a \_ 2} \left (\operatorname{Add} (2 ^ 2 а) \right) \cdots \Lambda \_ {x \_ {n-1}} \left (\operatorname{Add} ({2 ^ {n-1}} a) \right) \ket{x}\ket{b} \\ \\ & = \ket{x}\ket{b + AX}.
\енд{алигн} на тактовых компьютерах есть тонкость, которую вы можете заметить в определении $ \Операторнаме{мулт} $ выше.  В отличие от добавления, тактовая версия этой цепи сохраняет продукт входных данных во вспомогательном регистре, а не во входном регистре.  В этом примере регистр инициализируется значением $b $, но обычно он начинает удерживать нулевое значение.  Это необходимо в том случае, если в общем нет мультипликативные для общих $a $ и $x $.  Так как все операции над тактами, сохранение измерения, являются обратимыми, нам нужно сохранить достаточно информации, чтобы инвертировать умножение.  По этой причине результат сохраняется в отдельном массиве.  Этот прием необратимой операции, например умножения, в отдельном регистре называется «Беннет хитростью» после Чарли Беннет и является фундаментальным средством как в обратимых, так и в тактовых вычислениях.

Многие тактовые цепи были предложены для сложения, и каждый из них изучает различные компромиссы с точки зрения количества Кубитс (пробел) и количества требуемых операций (времени) шлюза.  Мы рассмотрим два эффективных методах, которые в значительной степени пространства называются Драпер Adder и Беаурегард Adder.

### <a name="draper-adder"></a>Драпер Adder ###

Драпер Adder, вероятно, является одним из самых элегантных методах тактов, так как он напрямую вызывает свойства такта для выполнения сложения.  Понимание Драпер Adder заключается в том, что преобразование Фурье можно использовать для перевода сдвига этапа в Поразрядный сдвиг.  Затем следует применить преобразование Фурье, применить соответствующие сдвиги этапа, а затем отменить преобразование Фурье, чтобы реализовать Adder.  В отличие от многих других методах, Драпер Adder явно использует тактовые эффекты, появившиеся в процессе преобразования Фурье в тактовой форме.  У него нет естественного классического аналога.  Ниже приведены конкретные шаги Драпер Adder.

Предположим, что у вас есть два $n $-битных регистров кубит, в которых хранятся целые числа $a $ и $b $ then для всех $a $ $ $ \Операторнаме{Кфт}\кет{а} = \фрак {1} {\sqrt{2 ^ n}} \сум \_ {j = 0} ^ {2 ^ n-1} e ^ {i2\pi (AJ)/2 ^ n} \кет{ж}.
$ $ Если мы определяем $ $ \кет{\фи \_ k (a)} = \фрак {1} {\скрт {2} } \лефт (\кет {0} + e ^ {i2\pi a/2 ^ k} \кет {1} \ригхт), $ $ после некоторого момента можно увидеть, что $ $ \операторнаме{Кфт}\кет{а} = \кет{\фи \_ 1 (a)} \отимес \cdots \otimes \ket{\Phi \_ n (a)}.
$ $ Путь к выполнению Adder, после чего будет ясно, что сумма входных данных может быть записана как $ $ \кет{а + b} = \Операторнаме{Кфт} ^ {-1} \кет{\фи \_ 1 (a + b)} \отимес \кдотс \отимес \кет{\фи \_ n (a + b)}.
$ $ После этого можно добавить целые числа $b $ и $a $, выполнив управляемый поворот на каждом из Кубитс в декомпозиции с использованием битов $b $ в качестве элементов управления.

Это расширение можно упростить, отметив, что для любого целого числа $j $ и вещественное число $x $ $e ^ {i2\pi (x + j)} = e ^ {i2\pi x} $.  Это связано с тем, что если вы поворачиваете $360 ^ {\Цирк} $ градусы ($ 2 \ PI $ радианы) в круге, то сможете точно приступить к работе.  Единственная важная часть $x $ for $e ^ {i2\pi x} $, таким образом, является дробной частью $x $.  В частности, если у нас есть двоичное расширение формы $x = y +0. x \_ 0x \_ 2 \ лдотс x \_ n $ then $e ^ {i2\pi x} = e ^ {i2\pi (0. x \_ 0x \_ 2 \ лдотс x \_ {n-1})} $ и, следовательно, $ $ \кет{\фи \_ k (a + b)} = \фрак {1} {\скрт {2} } \лефт (\кет {0} + e ^ {i2\pi [a/2 ^ k +0. b \_ К\лдотс b \_ 1]} \кет {1} \ригхт). $ $ Это означает, что если мы выполняем сложение путем увеличения каждого из тензорные факторов в расширении преобразования Фурье для $ \кет{а} $, число поворотов сокращается как $k $ уменьшаются.  Это значительно сокращает число шлюзов тактов, необходимых в Adder.  Мы будем заметку о преобразовании Фурье, добавлении этапов и обратных шагах преобразования Фурье, которые составляют Драпер Adder как $ \Операторнаме{Кфт} ^ {-1} \лефт (\Фи \\ \! \операторнаме{адд}\ригхт) \операторнаме{Кфт} $. Ниже показана тактовая цепь, использующая эту упрощение для реализации всего процесса.

![Драпер Adder показан в виде схемы цепи](~/media/draper.svg)

Каждый контролируемый $e ^ {I2 \ PI/k} $ в цепи относится к управляемому шлюзу.  Такие шлюзы имеют свойство, связанное с парой Кубитс, в которой они действуют, $ \кет {00} \мапсто \кет {00} $, но $ \кет {11} \мапсто e ^ {I2 \ PI/k} \ Сисакет {11} $.  Эта цепь позволяет нам выполнять сложение без дополнительных Кубитс, кроме тех, которые необходимы для хранения входных и выходных данных.

### <a name="beauregard-adder"></a>Беаурегард Adder ###

Беаурегард Adder — это тактовая Модульная Adder, использующая Драпер Adder для выполнения сложения по модулю $N $ для произвольного положительного целого числа $N $.  Значение тактовой модульной методахи, например Беаурегард Adder, разработано в больших экстентах, от их использования в действии модульного энерговедения в рамках алгоритма Шор для факторинга.  Тактовая Модульная Modular Adder имеет следующее действие для входных данных такта $ \кет{б} $ и классического входного $a $, где $a $ и $b $ представляют собой целые числа mod $N $. Это означает, что они находятся в интервале $ [0, \лдотс, N-1] $.

$ $ \кет{б}\ригхтарров \кет{б + a \текст{mod} N} = \бегин{Касес} \кет{б + a}, & б + a < N \\ \\ \кет{б + a-N}, & (b + a) \же N \енд{Касес}.
$$

Беаурегард Adder использует Драпер Adder или точнее $ \фи \\ \! \операторнаме{адд} $, чтобы добавить $a $ и $b $ in.  Затем она использует ту же операцию для того, чтобы определить, $a + b <N $ путем вычитания $N $ и проверки, если $a + b-N<$0.  Эта информация хранится в вспомогательной кубит, а затем добавляется $N $ обратно в регистр, если $a + b<N $.  Затем он завершается невычислением этого вспомогательного бита (этот шаг необходим для того, чтобы анЦилла можно было отменить выделение после вызова Adder).  Цепь для Беаурегард Adder указана ниже.

![Беаурегард Adder показан в виде схемы цепи](~/media/beau.svg)

Здесь шлюз $ \Фи \\ \! \операторнаме{адд} $ принимает ту же форму, что и $ \фи \\ \! \операторнаме{адд} $, за исключением того, что в этом контексте входные данные являются классическим, а не тактом.  Это позволяет заменять контролируемые этапы в $ \Фи \\ \! \операторнаме{адд} $ многофазными шлюзами, которые затем можно скомпилировать вместе в меньшее количество операций, чтобы сократить число Кубитс и число шлюзов, необходимое для Adder.

Дополнительные сведения см. в разделе [M. роеттелер, TH. Бет](http://doi.org/10.1007/s00200-008-0072-2 ) и [D. копперсмис](https://arxiv.org/abs/quant-ph/0201067).

### <a name="quantum-phase-estimation"></a>Оценка квантовых фаз ###

Одним из важнейших приложений преобразования Фурье в тактовой ситуации является изучение еиженвалуес операторов, которые называются *оценкой этапа*.
Рассмотрим единое $U $ и состояние $ \кет{\фи} $ таким, что $ \кет{\фи} $ является еиженстате $U $ с неизвестным еиженвалуе $ \фи $, \бегин{екуатион} У\кет {\ фи} = \фи\кет{\фи}.
\енд{екуатион} если у нас есть только доступ к $U $ в качестве Oracle, то мы можем изучить этап $ \фи $, используя, что $Z $ повороты, примененные к цели управляемой операции, передаются обратно в элемент управления.

Предположим, что $V $ является управляемым приложением $U $, таким как \бегин{алигн} V (\кет {0} \отимес \кет{\фи}) & = \кет {0} \отимес \кет{\фи} \текстрм{ \\ \\ и} V (\кет {1} \отимес \кет{\фи}) & = e ^ {i \Phi} {1} \ket \otimes \ket{\Phi}.
\енд{алигн}, по линейной шкале, \бегин{алигн} V (\кет{+} \отимес \кет{\фи}) & = \фрак{(\кет {0} \отимес \кет{\фи}) + e ^ {i \фи} (\ket {1} \otimes \ket{\Phi})} {\sqrt {2} }.
\енд{алигн} мы можем собираются термины, чтобы найти \бегин{алигн} V (\кет{+} \отимес \кет{\фи}) & = \фрак{\кет {0} + e ^ {i \фи} \кет {1} } {\скрт {2} } \отимес \ket{\Phi} \\ \\ & = (R_1 (\Phi) \ket{+}) \otimes \ket{\phi}, \end{align}, где $R _1 $ — это единое действие, применяемое <xref:microsoft.quantum.intrinsic.r1> операцией.
Иначе говоря, результат применения $V $ точно такой же, как применение $R _1 $ с неизвестным углом, несмотря на то, что у нас есть доступ только к $V $ в качестве Oracle.
Таким образом, в оставшейся части этого обсуждения мы рассмотрим оценку этапа в терминах $R _1 (\фи) $, которые мы реализуем с помощью так называемого *этапа киккбакк*.

Так как элемент управления и целевой регистр остаются унтанглед после этого процесса, мы можем повторно использовать $ \кет{\фи} $ в качестве целевого объекта управляемого приложения $U ^ $2 для подготовки второго элемента управления кубит в состоянии $R _1 (2 \фи) \кет{+} $.
Продолжая таким образом, можно получить регистр в формате \бегин{алигн} \кет{\пси} & = \ sum_ {j = 0} ^ n R_1 (2 ^ j \фи) \кет{+} \\ \\ & \пропто \ bigotimes_ {j = 0} ^ {n} \лефт (\кет {0} + \експ (i 2 ^ {j} \фи) \кет {1} \ригхт) \\ \\ & \пропто \ sum_ {k = 0} ^ {2 ^ n – 1} \експ (i \Phi k) \ket{k} \end{align}, где $n $ — число требуемых разрядов точности, и где мы использовали $ {} \propto {} $, чтобы указать, что мы отменяли коэффициент нормализации $1/\sqrt{2 ^ n} $.

Если предполагается, что $ \фи = 2 \пи p/2 ^ k $ для целого числа $p $, то мы понимаем это как $ \кет{\пси} = \Операторнаме{Кфт} \кет{p_0 p_1 \дотс p_n} $, где $p _j $ — $j ^ {\текстрм{с}} $ $2 \пи \фи $.
Применяя смежную часть преобразования Фурье в тактовой области, мы получаем двоичное представление этапа, закодированного как состояние такта.

В Q # это реализуется <xref:microsoft.quantum.characterization.quantumphaseestimation> операцией, которая принимает <xref:microsoft.quantum.oracles.discreteoracle> реализацию приложения $U ^ m $ в качестве функции положительных целых чисел $m $.
