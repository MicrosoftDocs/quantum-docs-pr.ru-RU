---
title: Структуры данных в Q# стандартных библиотеках
description: Сведения о структурах данных, Oracle и динамических генераторах в Q# стандартных библиотеках Майкрософт.
author: QuantumWriter
uid: microsoft.quantum.libraries.data-structures
ms.author: martinro
ms.date: 12/11/2017
ms.topic: article
no-loc:
- Q#
- $$v
ms.openlocfilehash: c3ce5d531618c269d15be3e4eb58ecbb597a022c
ms.sourcegitcommit: 29e0d88a30e4166fa580132124b0eb57e1f0e986
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/27/2020
ms.locfileid: "92692242"
---
# <a name="data-structures-and-modeling"></a>Структуры и моделирование данных #

## <a name="classical-data-structures"></a>Классические структуры данных ##

Вместе с определяемыми пользователем типами для представления тактовых концепций Canon также предоставляет операции, функции и типы для работы с классическими данными, используемыми в управлении тактовыми системами.
Например, <xref:Microsoft.Quantum.Arrays.Reversed> функция принимает массив в качестве входных данных и возвращает один и тот же массив в обратный порядок.
Затем его можно использовать в массиве типа `Qubit[]` , чтобы избежать применения ненужных \операторнаме{СВАП} $ Gates при преобразовании между тактовыми представлениями целых чисел.
Аналогичным образом мы видели в предыдущем разделе, что типы формы `(Int, Int -> T)` могут быть полезны для представления коллекций произвольного доступа, поэтому <xref:Microsoft.Quantum.Arrays.LookupFunction> функция предоставляет удобный способ создания таких типов из типов массивов.

### <a name="pairs"></a>Пар ###

Canon поддерживает нотацию функционального стиля для пар, дополняющих доступ к кортежам по деконструкции:

```qsharp
let pair = (PauliZ, register); // type (Pauli, Qubit[])
ApplyToEach(H, Snd(pair)); // No need to deconstruct to access the register.
```

### <a name="arrays"></a>Массивы ###

Canon предоставляет несколько функций для управления массивами.
Эти функции являются параметризованными и поэтому могут использоваться с массивами любого Q# типа.
Например, <xref:Microsoft.Quantum.Arrays.Reversed> функция возвращает новый массив, элементы которого находятся в обратном порядке от его входных данных.
Это можно использовать для изменения способа представления регистра такта при вызове операций:

```qsharp
let leRegister = LittleEndian(register);
// QFT expects a BigEndian, so we can reverse before calling.
QFT(BigEndian(Reversed(leRegister!)));
// This is how the LittleEndianAsBigEndian function is implemented:
QFT(LittleEndianAsBigEndian(leRegister));
```

Аналогичным образом <xref:Microsoft.Quantum.Arrays.Subarray> функция может использоваться для переупорядочивания или получения подмножеств элементов массива:

```qsharp
// Applies H to qubits 2 and 5.
ApplyToEach(H, Subarray([2, 5], register));
```

В сочетании с управлением потоком функции работы с массивами, такие как, <xref:Microsoft.Quantum.Arrays.Zipped> могут предоставить мощный способ для выражения тактовых программ:

```qsharp
// Applies X₃ Y₁ Z₇ to a register of any size.
ApplyToEach(
    ApplyPauli(_, register),
    Map(
        EmbedPauli(_, _, Length(register)),
        Zipped([PauliX, PauliY, PauliZ], [3, 1, 7])
    )
);
```

## <a name="oracles"></a>Oracle ##

При [оценке этапов](https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm) и повышении [амплитуды](https://en.wikipedia.org/wiki/Amplitude_amplification) понятие Oracle часто встречается.
Здесь термин Oracle означает подпрограммы такта блаккбокс, которая работает с набором Кубитс и возвращает ответ в качестве фазы.
Эту подпрограммы часто можно рассматривать как входные данные для алгоритма такта, который принимает Oracle, в дополнение к некоторым другим параметрам и применяет ряд операций в такте и обрабатывая вызов этой подпрограммы-такта, как если бы это был фундаментальный шлюз.
Очевидно, что для реализации более крупного алгоритма необходимо предоставить конкретную декомпозицию Oracle в фундаментальных шлюзах, но такая декомпозиция не требуется для понимания алгоритма, который вызывает Oracle.
В Q# Эта абстракция представляется с помощью таких операций, которые являются первыми значениями класса, поэтому операции могут передаваться в реализации алгоритмов тактовой передачи в виде черного ящика.
Более того, определяемые пользователем типы используются для обозначения различных представлений Oracle в строго типизированном виде, что усложняет случайное упрощение различных видов операций с черными ящиками.

Такие Oracle отображаются в разных контекстах, в том числе на таких известных примерах, как алгоритмы [поиска Гровер](https://en.wikipedia.org/wiki/Grover%27s_algorithm) и моделирования тактов.
Здесь основное внимание уделяется Oracle, необходимым только для двух приложений: усиление амплитуды и оценка фазы.
Прежде чем переходить к оценке этапа, мы сначала обсудим функции Oracle для усиления амплитуды.

### <a name="amplitude-amplification-oracles"></a>Oracle усиление амплитуды ###

Алгоритм усиления амплитуды предназначен для выполнения вращения между начальным и конечным состояниями путем применения последовательности отражений состояния.
Чтобы алгоритм мог функционировать, ему требуется спецификация обоих состояний.
Эти спецификации предоставляются двумя Oracle.
Эти Oracle работают путем разбиения входных данных на два пробела, "целевое" и "исходное" подпространство.
Oracle определяет такие подпространства, подобно тому, как Паули операторы определяют два пробела, применяя фазу $ \пм $1 к этим пробелам.
Основное отличие состоит в том, что в этом приложении эти пробелы не должны быть половинными пробелами.
Также обратите внимание, что эти два подпространства не являются взаимоисключающими, так как в обоих пробелах присутствуют только векторы.
Если это не так, это не повлияет на усиление амплитуды, поэтому нам необходимо, чтобы исходное подпространство имело ненулевое перекрытие с целевым подпространством.

Мы обносимся первой базой данных Oracle, которую требуется для усиления амплитуды $P \_ $0, чтобы иметь следующее действие.  Для всех состояний $ \кет{КС} $ в "начальном" подпространстве $P \_ 0 \кет{КС} =-\кет{КС} $ и для всех штатов $ \кет{и} $, которые не находятся в этом подпространстве, $P \_ 0 \кет{и} = \кет{и} $.
Oracle, помечающий целевое подпространство, $P _1 $, принимает в точности ту же форму.
Для всех состояний $ \кет{КС} $ в целевом подпространстве (т. е. для всех состояний, которые нужно использовать для вывода алгоритма), $P _1 \ Сисакет {x} =-\кет{КС} $.
Аналогичным образом для всех состояний $ \кет{и} $, которые не находятся в целевом подпространстве $P _1 \ Сисакет {y} = \кет{и} $.
Эти две отражения затем объединяются, образуя оператор, который вводит один шаг к повышению амплитуды, $Q =-P_0 P_1 $, где общий знак минуса важен только для управления приложениями.
Затем функция усиления амплитуды переходит в исходное состояние, $ \кет{\пси} $, расположенное в начальном подпространстве, а затем выполняет $ \кет{\пси} \мапсто Q ^ m \кет{\пси} $.
Выполнение такой итерации гарантирует, что если одна из них начинается с начального состояния, которое пересекает $ \син ^ 2 (\сета) $ с отмеченным пространством, то после $m $ итерации перекрываются до $ \син ^ 2 ([2 MБ + 1] \сета) $.
Поэтому обычно требуется выбрать $m $, чтобы быть свободным параметром, таким образом, $ [2 МБ + 1] \сета = \ PI/2 $; Однако такие жесткие выборы не так важны для некоторых форм усиления амплитуды, например для усиления амплитуды с фиксированной точкой.
Этот процесс позволяет нам подготовить состояние в отмеченном подпространстве с помощью минимально меньшего числа запросов к функции пометки и функции подготовки состояния, чем было бы возможно на строго классической устройстве.
Именно поэтому усиление амплитуды является значительным стандартным блоком для многих приложений тактовых вычислений.

Чтобы понять, как использовать алгоритм, полезно предоставить пример, который предоставляет построение Oracle.  Рассмотрите возможность выполнения алгоритма Гровер для поиска базы данных в этом параметре.
В поиске Гровер необходимо преобразовать State $ \кет{+} ^ {\отимес n} = H ^ {\отимес n} \кет {0} $ в одно из (потенциально) много помеченных состояний.
Для дальнейшего упрощения рассмотрим случай, когда только отмеченное состояние — $ \кет {0} $.
Затем мы создали две базы данных Oracle: одну, которая помечает только начальное состояние $ \кет{+} ^ {\отимес n} $ символом минуса, а другой символ, помечающий помеченное состояние $ \кет $ символом {0} "минус".
Последний шлюз можно реализовать с помощью следующей операции обработки, используя операции потока управления в Canon:

```qsharp
operation ReflectAboutAllZeros(register : Qubit[]) : Unit 
is Adj + Ctl {

    // Apply $X$ gates to every qubit.
    ApplyToEach(X, register);

    // Apply an $n-1$ controlled $Z$-gate to the $n^{\text{th}}$ qubit.
    // This gate will lead to a sign flip if and only if every qubit is
    // $1$, which happens only if each of the qubits were $0$ before step 1.
    Controlled Z(Most(register), Tail(register));

    // Apply $X$ gates to every qubit.
    ApplyToEach(X, register);
}
```

Эта база данных Oracle является особым случаем <xref:Microsoft.Quantum.Canon.RAll1> операции, которая позволяет выполнять поворот на произвольном этапе вместо случая отражения $ \фи = \пи $.
В этом случае, `RAll1` похоже на <xref:Microsoft.Quantum.Intrinsic.R1> операцию версионного, в том, что она поворачивает около $ \ket{11\cdots1} $ вместо кубит State $ \кет {1} $.

Oracle, который помечает начальное подпространство, может быть создан аналогичным образом.
В псевдокоде:

1. Примените $H $ Гейтс к каждому кубит.
2. Примените $X $ Гейтс к каждому кубит.
3. Примените управляемый $n-$1 $Z $-Gate к $n ^ {\текст{с}} $ кубит.
4. Примените $X $ Гейтс к каждому кубит.
5. Примените $H $ Гейтс к каждому кубит.

На этот раз мы также демонстрируем использование <xref:Microsoft.Quantum.Canon.ApplyWith> вместе с <xref:Microsoft.Quantum.Canon.RAll1> операцией, описанной выше:

```qsharp
operation ReflectAboutInitial(register : Qubit[]) : Unit
is Adj + Ctl {
    ApplyWithCA(ApplyToEach(H, _), ApplyWith(ApplyToEach(X, _), RAll1(_, PI()), _), register);
}
```

Затем можно объединить эти две Oracle вместе, чтобы переходить между двумя состояниями и детерминированно преобразовать $ \кет{+} ^ {\отимес n} $ в $ \кет {0} $, используя несколько уровней шлюза хадамард, который пропорциональен $ \sqrt{2 ^ n} $ (ie $m \пропто \sqrt{2 ^ n} $) и примерно 2 $ ^ n $ слои, которые требуются для недетерминированной подготовки состояния $ \кет {0} $ путем подготовки и измерения начального состояния до тех пор, пока не будет обнаружен результат $0 $.

### <a name="phase-estimation-oracles"></a>Оценочная Оценка этапов Oracle ###

Для оценки этапов Oracle является несколько более естественным.
Целью оценки фазы является проектирование подпрограммы, которая может выдавать выборку из еиженвалуес единой матрицы.
Этот метод является незаменимым в процессе моделирования такта, так как для многих физических проблем в химия и материальных науки эти еиженвалуес приводят к силыию тактовых систем, которые предоставляют ценную информацию о схемах материалов и радиосвязи для молекул.
Каждой разновидности оценки фазы требуется ввод в единое целое.
Это единое из них описано одним из двух типов Oracle.

> [!TIP]
> В примерах рассматриваются оба типа Oracle, описанные ниже.
> Дополнительные сведения о Oracle с непрерывным запросом см. в [примере **фасистиматион**](https://github.com/microsoft/Quantum/tree/main/samples/characterization/phase-estimation).
> Дополнительные сведения о дискретных запросах Oracle см. в примере [ **исингфасистиматион**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/phase-estimation).

Первый тип Oracle, который вызывает дискретный запрос Oracle и представлен с определяемым пользователем типом <xref:Microsoft.Quantum.Oracles.DiscreteOracle> , просто включает в себя единую матрицу.
Если $U $ является единым, для которой мы хотим оценить, то Oracle для $U $ является просто подподпрограммой, реализующей $U $.
Например, можно взять $U $ в качестве $Q Oracle $, определенного выше для оценки амплитуды.
Еиженвалуес этой матрицей можно использовать для оценки перекрытия между начальным и целевым состояниями, $ \син ^ 2 (\сета) $, с использованием квадратичного числа выборок, чем в противном случае.
Это порабатывает применение оценки этапа с помощью Гровер Oracle $Q $ в качестве входного моникера оценки амплитуды.
Другое общее приложение, широко используемое в тактовой метрологии, включает оценку небольшого угла вращения.
Иными словами, мы хотим оценить $ \сета $ для неизвестного шлюза ротации формы $R _z (\сета) $.
В таких случаях подпрограммы, с которыми мы будем взаимодействовать, чтобы изучить фиксированное значение $ \сета $ для шлюза, — $ $ \бегин{алигн} U & = R_z (\сета) \\ \\ & = \бегин{бматрикс} e ^ {-i \сета/2} & 0 \\ \\ 0 & e ^ {i \ тета/2} \енд{бматрикс}.
\енд{алигн} $ $

Второй тип Oracle, используемый в оценке фазы, — это непрерывный запрос Oracle, представленный <xref:Microsoft.Quantum.Oracles.ContinuousOracle> типом.
В Oracle для оценки этапа непрерывный запрос принимает форму $U (t) $, где $t $ является классическим, известным вещественным числом.
Если мы попробуем $U $ быть фиксированной, то в Oracle непрерывный запрос принимает форму $U (t) = U ^ t $.
Это позволяет нам запрашивать такие матрицы, как $ \Скрт{у} $, которые не могут быть реализованы непосредственно в дискретной модели запроса.

Такой тип Oracle полезен, если вы не проверяюте конкретное единое, а хотите изучить свойства генератора единой.
Например, в динамическом моделировании такта цель состоит в том, чтобы разрабатывать тактовые каналы, которые приблизительно точнее $U (t) = e ^ {-i H t} $ для матрицы Хермитиан $H $ и эволюционное время $t $.
Еиженвалуес $U (t) $ напрямую связаны с еиженвалуесом $H $.
Чтобы увидеть это, рассмотрите еиженвектор $H $: $H \Кет{е} = Е\кет {E} $, после чего можно легко увидеть в определении ряда питания матрицы, что $U (t) \Кет{е} = e ^ {и\фи} \ Сисакет {E} = e ^ {-ИЕТ} \Кет{е} $.
Таким образом, оценка еиженфасе $U (t) $ дает еиженвалуе $E $, предполагая, что еиженвектор $ \Кет{е} $ является входным алгоритмом оценки этапа.
Однако в этом случае значение $t $ может быть выбрано по усмотрению пользователя, так как для любого достаточного небольшого значения $t $ еиженвалуе $E $ может быть однозначно инвертирован через $E =-\ фи/t $.
Так как методы моделирования такта обеспечивают возможность выполнения изменений в дробной части, это дает алгоритмам оценки этапа дополнительную свободу при выполнении запроса, особенно в том случае, когда дискретная модель запроса позволяет использовать только унитариес формы $U ^ j $ к целому $j $. в этом случае в Oracle можно приблизительно унитариес форму $U ^ t $ для любого $t $.
Это важно для того, чтобы задержать все последние унции эффективности в алгоритмах оценки этапа, так как это позволяет выбрать именно эксперимент, который предоставит наибольшую информацию о $E $; в то время как методы, основанные на дискретных запросах, должны делать это с ослаблением, выбрав лучшее целое число запросов в алгоритме.

В качестве конкретного примера рассмотрим проблему оценки не угла вращения шлюза, но процессион частоты поворота тактовой системы.
Единая, описывающая такой тактовую частоту, — $U (t) = R_z (2 \ Омега t) $ для эволюции времени $t $ и неизвестная частота $ \омега $.
В этом контексте можно имитировать $U (t) $ для любого $t $ с помощью одного $R _z $ Gate и, таким образом, не нужно ограничивать себя только дискретными запросами к единому.
Такая непрерывная модель также имеет свойство, частота которого больше $2 – PI $ может быть получено из процессов оценки этапа, использующих непрерывные запросы, так как сведения о фазе, которые в противном случае были скрыты с помощью разветвлений функции логарифма, можно получить из результатов экспериментов, выполненных для соответствии значений $t $.
Таким образом, для таких проблем, как непрерывные модели запросов для оценки фазы Oracle, не только подходит, но и предпочтительны для дискретной модели запросов.
По этой причине Q# функция предназначена для обеих форм запросов и оставляет пользователю возможность выбрать алгоритм оценки этапа в соответствии с их потребностями и доступным типом Oracle.

## <a name="dynamical-generator-modeling"></a>Динамическое моделирование генератора ##

Генераторы времени развития описывают, как состояния развиваются по времени. Например, значение Dynamics состояния такта $ \кет{\пси} $ регулируется уравнением Шредингер $ $ \бегин{алигн} и\фрак {d \кет{\пси (t)}} {d t} & = H \кет{\пси (t)}, \енд{алигн} $ $ с Хермитиан матрицей $H $, известной как Хамилтониан, как генератор движения. Заданное начальное состояние $ \кет{\пси (0)} $ в момент $t = $0, формальное решение для этого уравнения во время $t $ может быть, в принципе, написано $ $ \бегин{алигн} \кет{\пси (t)} = U (t) \кет{\пси (0)}, \енд{алигн} $ $, где экспоненциальная $U (t) = e ^ {-i H t} $ называется единым оператором развития времени. Несмотря на то, что основное внимание уделяется генераторам этой формы, мы Подчеркните, что концепция применяется более широко, например, для имитации открытых тактовых систем или более абстрактных разностных уравнений.

Основной целью динамического моделирования является реализация оператора времени развития в некоторых состояниях такта, закодированных в Кубитс компьютера-такта.  Во многих случаях Хамилтониан может быть разбит на сумму некоторых $d $ более простых терминов.

$ $ \бегин{алигн} H & = \сум ^ {d-1} _ {j = 0} H_j, \енд{алигн} $ $

где время — развитие каждого термина легко реализовать на тактовой системе. Например, если $H _j $ является оператором $X _1X_2 $, действующим на первый и второй элемент регистра кубит `qubits` , то его развитие времени в течение любого времени $t $ может быть реализовано просто путем вызова операции `Exp([PauliX,PauliX], t, qubits[1..2])` , которая имеет сигнатуру `((Pauli[], Double, Qubit[]) => Unit is Adj + Ctl)` . Как обсуждалось далее в моделировании Хамилтониан, одно решение — это приблизительное время развития $H $ с последовательностью более простых операций.

$ $ \бегин{алигн} U (t) & = \лефт (e ^ {-iH \_ 0 t/r} e ^ {-IH \_ 1 t/r} \кдотс e ^ {-IH \_ {d-1} t/r} \ригхт) ^ {r} + \маскал{о} (d ^ 2 \ max_j \\ | H \_ j \\ | ^ 2 t ^ 2/r), \енд{алигн} $ $

где целое число $r > $0 управляет ошибкой приближения.

Библиотека динамического моделирования генератора предоставляет платформу для систематической кодирования сложных генераторов с точки зрения более простых генераторов. Такое описание может затем передаваться, скажем, в библиотеку моделирования, чтобы реализовать развитие времени с помощью выбранного алгоритма моделирования с множеством деталей, которые автоматически позаботится.

> [!TIP]
> Библиотека динамического генератора, описанная ниже, рассматривается в примерах. Пример, основанный на модели Исинг, см. в примере [ **исингженераторс**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/generators).
> Пример, основанный на молекулярное водорода, см. в примерах [**H2SimulationCmdLine**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line) и [**H2SimulationGUI**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/gui) .

### <a name="complete-description-of-a-generator"></a>Полное описание генератора ###

На верхнем уровне полное описание Хамилтониан содержится в `EvolutionGenerator` определяемом пользователем типе, который состоит из двух компонентов:

```qsharp
newtype EvolutionGenerator = (EvolutionSet, GeneratorSystem);
```

`GeneratorSystem`Определяемый пользователем тип является классическим описанием хамилтониан.

```qsharp
newtype GeneratorSystem = (Int, (Int -> GeneratorIndex));
```

Первый элемент `Int` кортежа хранит количество терминов $d $ в хамилтониан, а второй элемент `(Int -> GeneratorIndex)` — это функция, которая сопоставляет целочисленный индекс в диапазоне от $ \{ 0, 1,..., d-1 \} $ с `GeneratorIndex` определяемым пользователем типом, который однозначно определяет каждый примитивный термин в хамилтониан. Обратите внимание, что при выпуске коллекции терминов в Хамилтониан в качестве функции, а не массива `GeneratorIndex[]` , это позволяет выполнять оперативное вычисление, `GeneratorIndex` которое особенно полезно при описании хамилтонианс с большим количеством терминов.

По крайней мере, мы не используем соглашение о том, какие примитивные термины, идентифицируемые с помощью, `GeneratorIndex` просты в имитации. Например, примитивные термины могут быть Паули операторами, как описано выше, но они также могут быть Фермионик аннихилатион и операторы создания, обычно используемые в моделировании тактовой химия. Само по себе, не `GeneratorIndex` имеет смысла, так как не описывает, как время развития термина, на который она указывает, может быть реализовано в виде тактовой цепи.

Это разрешается путем указания `EvolutionSet` определяемого пользователем типа, который сопоставляет любой `GeneratorIndex` из канонических наборов с единым оператором, `EvolutionUnitary` выраженным в виде тактовой цепи. `EvolutionSet`Определяет правила `GeneratorIndex` структурирования, а также определяет набор возможных `GeneratorIndex` .

```qsharp
newtype EvolutionSet = (GeneratorIndex -> EvolutionUnitary);
```

### <a name="pauli-operator-generators"></a>Генераторы операторов Паули ###

Конкретный и полезный пример генераторов — Хамилтонианс, которые являются суммой операторов Паули, каждый из которых может иметь другой коэффициент.
$ $ \бегин{алигн} H & = \сум ^ {d-1} _ {j = 0} a_j H_j, \енд{алигн} $ $, где каждый $ \хат H_j $ теперь взят из группы Паули. Для таких систем мы предоставляем `PauliEvolutionSet()` тип `EvolutionSet` , определяющий соглашение о том, как элемент группы Паули и коэффициент могут быть идентифицированы с помощью `GeneratorIndex` , который имеет следующую сигнатуру.

```qsharp
newtype GeneratorIndex = ((Int[], Double[]), Int[]);
```

В нашей кодировке первый параметр `Int[]` указывает строку Паули, где $ \Хат и\ригхтарров $0, $ \Хат кс\ригхтарров $1, $ \Хат и\ригхтарров $2 и $ \Хат з\ригхтарров $3. Второй параметр `Double[]` сохраняет коэффициент строки Паули в хамилтониан. Обратите внимание, что используется только первый элемент массива. Третий параметр `Int[]` индексирует Кубитс, на котором действует эта строка Паули, и не должна иметь повторяющихся элементов. Таким образом, термин Хамилтониан $0,4 \хат X_0 \хат Y_8 \хат I_2 \хат Z_1 $ может быть представлен как

```qsharp
let generatorIndexExample = GeneratorIndex(([1,2,0,3], [0.4]]), [0,8,2,1]);
```

`PauliEvolutionSet()`— Это функция, которая сопоставляет любую `GeneratorIndex` из этих форм `EvolutionUnitary` со следующей сигнатурой.

```qsharp
newtype EvolutionUnitary = ((Double, Qubit[]) => Unit is Adj + Ctl);
```

Первый параметр представляет временную длительность, который умножается на коэффициент в, который действует в `GeneratorIndex` едином развитии. Вторым параметром является кубит, который регистрируется для единой функции. 

### <a name="time-dependent-generators"></a>Генераторы Time-Dependent ###

Во многих случаях мы также заинтересованы в моделировании зависимых от времени генераторов, как это может произойти в уравнении Шредингер $ $ \бегин{алигн} и\фрак {d \кет{\пси (t)}} {d t} & = \хат H (t) \кет{\пси (t)}, \енд{алигн} $ $, где генератор $ \хат H (t) $ теперь зависит от времени. Расширение из независимых от времени генераторов выше этого случая очень просто. Вместо фиксированного `GeneratorSystem` описания хамилтониан для всех раз $t $, мы используем `GeneratorSystemTimeDependent` тип, определяемый пользователем.

```qsharp
newtype GeneratorSystemTimeDependent = (Double -> GeneratorSystem);
```

Первый параметр — это непрерывный параметр расписания $s \ин [0, 1] $, а функции этого типа возвращают `GeneratorSystem` для этого расписания. Обратите внимание, что параметр Schedule может быть линейно связан с параметром физического времени, например $s = t/T $, для некоторого общего времени моделирования $T $. Однако в общем случае это не так.

Аналогично, полное описание этого генератора требует `EvolutionSet` , и поэтому мы определим `EvolutionSchedule` определяемый пользователем тип.

```qsharp
newtype EvolutionSchedule = (EvolutionSet, GeneratorSystemTimeDependent);
```
