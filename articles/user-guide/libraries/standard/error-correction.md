---
title: Исправление ошибок в Q# стандартных библиотеках
description: Узнайте, как использовать коды исправления ошибок в программах, Q# защищая состояние Кубитс.
author: QuantumWriter
uid: microsoft.quantum.libraries.error-correction
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
no-loc:
- Q#
- $$v
ms.openlocfilehash: 8b1f008793281121bc547d1a6ac3b960feb082ab
ms.sourcegitcommit: 6bf99d93590d6aa80490e88f2fd74dbbee8e0371
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/06/2020
ms.locfileid: "87868497"
---
# <a name="error-correction"></a>Исправление ошибок #

## <a name="introduction"></a>Введение ##

В классический вычислительной среде, если бы один из них хочет защититься от ошибок, он часто может представлять этот бит на *логический бит* , повторив бит данных.
Например, пусть $ \оверлине {0} = $0 быть кодировкой бита данных 0, где мы используем строку над меткой 0, чтобы указать, что она является кодировкой бита в состоянии 0.
Если же мы добавим $ \оверлине {1} = $111, то у нас есть простой код повтора, который защищается от ошибки отражения одного бита.
То есть при отражении любого из трех битов можно восстановить состояние логического бита, принимая во внимание большинство голосов.
Несмотря на то, что классический вариант исправления ошибок является более широким, что в данном примере (мы рекомендуем [lint в теории кодирования](https://www.springer.com/us/book/9783540641339)), приведенный выше код повторения уже указывает на возможную проблему, связанную с защитой данных о такте.
А именно, [Теорема](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) означает, что при измерении каждого отдельного кубита и последующем голосовании в классический пример кода мы потеряли точную информацию, которую мы пытаемся защитить.

В параметре такта мы видим, что измерение является проблематичным. Мы по-прежнему можем реализовать приведенную выше кодировку.
Это полезно для того, чтобы увидеть, как можно обобщить исправление ошибок в тактовый случай.
Таким путем, Let $ \кет{\оверлине {0} } = \кет {000} = \кет {0} \отимес \кет {0} \отимес \кет {0} $ и Let $ \кет{\оверлине {1} } = \кет {111} $.
Затем по линейной шкале мы определили код повтора для всех входных данных. Например, $ \кет{\оверлине{+}} = (\кет{\оверлине {0} } + \кет{\оверлине {1} })/\скрт {2} = (\кет {000} + \кет {111} )/\скрт {2} $.
В частности, при появлении ошибки побитового отражения $X _1 $ действовал на среднем кубит, мы видим, что исправление, необходимое в обеих ветвях, точно $X _1 $: $ $ \бегин{алигн} X_1 \кет{\оверлине{+}} & = \фрак {1} {\скрт {2} } \лефт (X_1 \кет {000} + X_1 \кет {111} \ригхт) \\ \\ & = \фрак {1} {\скрт {2} } \лефт (\ket {010} + \ket {101} \right).
\енд{алигн} $ $

Чтобы понять, как это делается, не измеряя очень важность, которую мы пытаемся защитить, полезно написать о том, что происходит при каждом последующем возникновении ошибки отражения в логические состояния:

| Ошибка $E $ | $E \кет{\оверлине {0} } $ | $E \кет{\оверлине {1} } $ |
| --- | --- | --- |
| $ \болдоне $ | $ \кет {000} $ | $ \кет {111} $ |
| $X _0 $ | $ \кет {100} $ | $ \кет {011} $ |
| $X _1 $ | $ \кет {010} $ | $ \кет {101} $ |
| $X _2 $ | $ \кет {001} $ | $ \кет {110} $ |

Для защиты состояния кодирования мы должны уметь отличать три ошибки друг от друга и от идентификатора $ \болдоне $ без различия между $ \кет{\оверлине {0} } $ и $ \кет{\оверлине {1} } $.
Например, если измеряется $Z _0 $, мы получаем другой результат для $ \кет{\оверлине {0} } $ и $ \кет{\оверлине {1} } $ в случае отсутствия ошибок, чтобы свернуть закодированное состояние.
С другой стороны, рассмотрите возможность измерения $Z _0 Z_1 $, а также четность первых двух битов в каждом вычислительном уровне.
Вспомним, что каждое измерение оператора Паули проверяет, что еиженвалуе состояние соответствует, поэтому для каждого состояния $ \кет{\пси} $ в таблице выше мы можем вычислить $Z _0 Z_1 \кет{\пси} $, чтобы узнать, получает ли мы $ \пм\кет{\пси} $.
Обратите внимание, что $Z _0 Z_1 \кет {000} = \кет {000} $ и что $Z _0 Z_1 \кет {111} = \кет {111} $, чтобы мы заносимся в заключение того, что это измерение выполняет то же самое в обоих закодированных состояниях.
С другой стороны, $Z _0 Z_1 \кет {100} =-\кет {100} $ and $Z _0 Z_1 \кет {011} =-\кет {011} $, поэтому результат измерения $Z _0 Z_1 $ раскрывает полезную информацию о том, какая ошибка произошла.

Чтобы подчеркнуть это, мы повторяем приведенную выше таблицу, но добавим результаты измерения $Z _0 Z_1 $ and $Z _1 Z_2 $ в каждой строке.
Мы обносим результаты каждого измерения по знаку еиженвалуе, который наблюдается: $ + $ или $-$, соответствующее Q# `Result` значениям `Zero` и `One` соответственно.

| Ошибка $E $ | $E \кет{\оверлине {0} } $ | $E \кет{\оверлине {1} } $ | Результат $Z _0 Z_1 $ | Результат $Z _1 Z_2 $ |
| --- | --- | --- | --- | --- |
| $ \болдоне $ | $ \кет {000} $ | $ \кет {111} $ | $+$ | $+$ |
| $X _0 $ | $ \кет {100} $ | $ \кет {011} $ | $-$ | $+$ |
| $X _1 $ | $ \кет {010} $ | $ \кет {101} $ | $-$ | $-$ |
| $X _2 $ | $ \кет {001} $ | $ \кет {110} $ | $+$ | $-$ |

Таким образом, результаты двух измерений однозначно определяют, какая именно ошибка отражения бита возникла, но без отображения сведений о состоянии, закодированном нами.
Мы вызываем эти результаты как *синдром*и ссылающиеся на процесс сопоставления синдром с ошибкой, вызвавшей ее как *Восстановление*.
В частности, мы Подчеркните, что восстановление является *классической* процедурой вывода, которая принимает в качестве входных данных синдром и возвращает инструкции по устранению ошибок, которые могли произойти.

> [!NOTE]
> Приведенный выше код зеркального отражения может исправлять только для ошибок отражения одного бита. то есть операция, `X` действующая на один кубит.
> Применение `X` к более чем одному кубит будет сопоставлять $ \кет{\оверлине {0} } $ с $ \кет{\оверлине {1} } $ после восстановления.
> Аналогично, при применении операции отражения на этапе `Z` будет сопоставлено значение $ \кет{\оверлине {1} } $ с $-\кет{\оверлине {1} } $, и поэтому будет сопоставлять $ \кет{\оверлине{+}} $ с $ \кет{\оверлине {-} } $.
> Более того, коды можно создавать для поддержки большего количества ошибок, а также для решения $Z $ Errors и $X $ Errors.

Понимание того, что мы можем описать измерения в исправлении ошибок такта, которые работают одинаково во всех состояниях кода, является сутью *формального стабилизер*.
Q#Платформа Canon предоставляет платформу для описания кодировки и декодирования из кодов стабилизер, а также для описания того, как один из них восстанавливается из ошибок.
В этом разделе мы описываем эту платформу и ее приложение на несколько простых кодов коррекции ошибок в такте.

> [!TIP]
> Полное введение в стабилизер formal выходит за рамки этого раздела.
> Мы будем называть читателей, заинтересованных в изучении более [готтесман 2009](https://arxiv.org/abs/0904.2557).

## <a name="representing-error-correcting-codes-in-no-locq"></a>Представление кодов коррекции ошибок вQ# ##

Чтобы помочь указать коды исправления ошибок, в Q# Canon предусмотрено несколько различных определяемых пользователем типов:

- <xref:microsoft.quantum.errorcorrection.logicalregister>`= Qubit[]`: Указывает, что регистр Кубитс должен интерпретироваться как блок кода исправления ошибок.
- <xref:microsoft.quantum.errorcorrection.syndrome>`= Result[]`: Указывает, что массив результатов измерения должен интерпретироваться как синдром, измеряемый в блоке кода.
- <xref:microsoft.quantum.errorcorrection.recoveryfn>`= (Syndrome -> Pauli[])`: Указывает, что *Классическая* функция должна использоваться для интерпретации синдром и возвращать исправление, которое следует применить.
- <xref:microsoft.quantum.errorcorrection.encodeop>`= ((Qubit[], Qubit[]) => LogicalRegister)`: Указывает, что операция принимает Кубитс представления данных вместе с новой анЦилла Кубитс, чтобы получить блок кода исправления ошибок.
- <xref:microsoft.quantum.errorcorrection.decodeop>`= (LogicalRegister => (Qubit[], Qubit[]))`: Обозначает, что операция разбивает блок кода ошибки исправления кода в Кубитс данных и анЦилла Кубитс, используемый для представления информации синдром.
- <xref:microsoft.quantum.errorcorrection.syndromemeasop>`= (LogicalRegister => Syndrome)`: Обозначает операцию, которая должна использоваться для извлечения сведений о синдром из блока кода без нарушения состояния, защищенного кодом.

Наконец, Canon предоставляет <xref:microsoft.quantum.errorcorrection.qecc> тип для получения сведений о других типах, необходимых для определения кода исправления ошибок в такте. Связанный с каждым стабилизер тактовым кодом является длина кода $n $, число $k $ из логических Кубитс и минимальное расстояние $d $, часто сгруппированные в нотации ⟦ $n $, $k $, $d $ ⟧. Например, <xref:microsoft.quantum.errorcorrection.bitflipcode> функция определяет код отражения ⟦ 3, 1, 1 ⟧ бит:

```qsharp
let encodeOp = EncodeOp(BitFlipEncoder);
let decodeOp = DecodeOp(BitFlipDecoder);
let syndMeasOp = SyndromeMeasOp(MeasureStabilizerGenerators([
    [PauliZ, PauliZ, PauliI],
    [PauliI, PauliZ, PauliZ]
], _, MeasureWithScratch));
let code = QECC(encodeOp, decodeOp, syndMeasOp);
```

Обратите внимание, что `QECC` тип *не* включает функцию восстановления.
Это позволяет нам изменить функцию восстановления, используемую при исправлении ошибок, не изменяя определение самого кода. Эта возможность особенно полезна при внедрении обратной связи между измерениями для встраивания в модель, предполагаемая восстановлением.

После того как код определен таким образом, можно использовать <xref:microsoft.quantum.errorcorrection.recover> операцию для восстановления после ошибок:

```qsharp
let code = BitFlipCode();
let fn = BitFlipRecoveryFn();
let X0 = ApplyPauli([PauliX, PauliI, PauliI], _);
using (scratch = Qubit[nScratch]) {
    let logicalRegister = encode(data, scratch);
    // Cause an error.
    X0(logicalRegister);
    Recover(code, fn, logicalRegister);
    let (decodedData, decodedScratch) = decode(logicalRegister);
    ApplyToEach(Reset, decodedScratch);
}
```

Мы подробно рассмотрим это в [примере кода побитового отражения](https://github.com/microsoft/Quantum/tree/master/samples/error-correction/bit-flip-code).

Помимо кода для побитового отражения, Q# Canon предоставляется с реализациями [кубит идеального кода](https://arxiv.org/abs/quant-ph/9602019)и [семи кубит кодом](https://arxiv.org/abs/quant-ph/9705052), оба из которых могут исправить произвольную ошибку с одним кодом кубит.
