---
title: Исправление ошибок в Q# стандартных библиотеках
description: Узнайте, как использовать коды исправления ошибок в программах, Q# защищая состояние Кубитс.
author: QuantumWriter
uid: microsoft.quantum.libraries.error-correction
ms.author: martinro
ms.date: 12/11/2017
ms.topic: conceptual
no-loc:
- Q#
- $$v
ms.openlocfilehash: fc8e46aa22cb2575de42cfc3d4f57c43e5d3f7b0
ms.sourcegitcommit: 71605ea9cc630e84e7ef29027e1f0ea06299747e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/26/2021
ms.locfileid: "98857214"
---
# <a name="error-correction"></a><span data-ttu-id="8caa9-103">Исправление ошибок</span><span class="sxs-lookup"><span data-stu-id="8caa9-103">Error Correction</span></span> #

## <a name="introduction"></a><span data-ttu-id="8caa9-104">Введение</span><span class="sxs-lookup"><span data-stu-id="8caa9-104">Introduction</span></span> ##

<span data-ttu-id="8caa9-105">В классический вычислительной среде, если бы один из них хочет защититься от ошибок, он часто может представлять этот бит на *логический бит* , повторив бит данных.</span><span class="sxs-lookup"><span data-stu-id="8caa9-105">In classical computing, if one wants to protect a bit against errors, it can often suffice to represent that bit by a *logical bit* by repeating the data bit.</span></span>
<span data-ttu-id="8caa9-106">Например, пусть $ \оверлине {0} = $0 быть кодировкой бита данных 0, где мы используем строку над меткой 0, чтобы указать, что она является кодировкой бита в состоянии 0.</span><span class="sxs-lookup"><span data-stu-id="8caa9-106">For instance, let $\overline{0} = 000$ be the encoding of the data bit 0, where we use the a line above the label 0 to indicate that it is an encoding of a bit in the 0 state.</span></span>
<span data-ttu-id="8caa9-107">Если же мы добавим $ \оверлине {1} = $111, то у нас есть простой код повтора, который защищается от ошибки отражения одного бита.</span><span class="sxs-lookup"><span data-stu-id="8caa9-107">If we similarly let $\overline{1} = 111$, then we have a simple repetition code that protects against any one bit flip error.</span></span>
<span data-ttu-id="8caa9-108">То есть при отражении любого из трех битов можно восстановить состояние логического бита, принимая во внимание большинство голосов.</span><span class="sxs-lookup"><span data-stu-id="8caa9-108">That is, if any of the three bits are flipped, then we can recover the state of the logical bit by taking a majority vote.</span></span>
<span data-ttu-id="8caa9-109">Несмотря на то, что классический вариант исправления ошибок является более широким, что в данном примере (мы рекомендуем [lint в теории кодирования](https://www.springer.com/us/book/9783540641339)), приведенный выше код повторения уже указывает на возможную проблему, связанную с защитой данных о такте.</span><span class="sxs-lookup"><span data-stu-id="8caa9-109">Though classical error correction is a much richer subject that this particular example (we recommend [Lint's introduction to coding theory](https://www.springer.com/us/book/9783540641339)), the repetition code above already points to a possible problem in protecting quantum information.</span></span>
<span data-ttu-id="8caa9-110">А именно, [Теорема](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) означает, что при измерении каждого отдельного кубита и последующем голосовании в классический пример кода мы потеряли точную информацию, которую мы пытаемся защитить.</span><span class="sxs-lookup"><span data-stu-id="8caa9-110">Namely, the [no-cloning theorem](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) implies that if we measure each individual qubit and take a majority vote by analogy to classical code above, then we have lost the precise information that we are trying to protect.</span></span>

<span data-ttu-id="8caa9-111">В параметре такта мы видим, что измерение является проблематичным.</span><span class="sxs-lookup"><span data-stu-id="8caa9-111">In the quantum setting, we will see that the measurement is problematic.</span></span> <span data-ttu-id="8caa9-112">Мы по-прежнему можем реализовать приведенную выше кодировку.</span><span class="sxs-lookup"><span data-stu-id="8caa9-112">We can still implement the encoding above.</span></span>
<span data-ttu-id="8caa9-113">Это полезно для того, чтобы увидеть, как можно обобщить исправление ошибок в тактовый случай.</span><span class="sxs-lookup"><span data-stu-id="8caa9-113">It is helpful to do so to see how we can generalize error correction to the quantum case.</span></span>
<span data-ttu-id="8caa9-114">Таким путем, Let $ \кет{\оверлине {0} } = \кет {000} = \кет {0} \отимес \кет {0} \отимес \кет {0} $ и Let $ \кет{\оверлине {1} } = \кет {111} $.</span><span class="sxs-lookup"><span data-stu-id="8caa9-114">Thus, let $\ket{\overline{0}} = \ket{000} = \ket{0} \otimes \ket{0} \otimes \ket{0}$, and let $\ket{\overline{1}} = \ket{111}$.</span></span>
<span data-ttu-id="8caa9-115">Затем по линейной шкале мы определили код повтора для всех входных данных. Например, $ \кет{\оверлине{+}} = (\кет{\оверлине {0} } + \кет{\оверлине {1} })/\скрт {2} = (\кет {000} + \кет {111} )/\скрт {2} $.</span><span class="sxs-lookup"><span data-stu-id="8caa9-115">Then, by linearity, we have defined our repetition code for all inputs; for instance, $\ket{\overline{+}} = (\ket{\overline{0}} + \ket{\overline{1}}) / \sqrt{2} = (\ket{000} + \ket{111}) / \sqrt{2}$.</span></span>
<span data-ttu-id="8caa9-116">В частности, при появлении ошибки побитового отражения $X _1 $ действовал на среднем кубит, мы видим, что исправление, необходимое в обеих ветвях, точно $X _1 $: $ $ \бегин{алигн} X_1 \кет{\оверлине{+}} & = \фрак {1} {\скрт {2} } \лефт (X_1 \кет {000} + X_1 \кет {111} \ригхт) \\ \\ & = \фрак {1} {\скрт {2} } \лефт (\ket {010} + \ket {101} \right).</span><span class="sxs-lookup"><span data-stu-id="8caa9-116">In particular, letting a bit-flip error $X_1$ act on the middle qubit, we see that the correction needed in both branches is precisely $X_1$: $$ \begin{align} X_1 \ket{\overline{+}} & = \frac{1}{\sqrt{2}} \left( X_1 \ket{000} + X_1 \ket{111} \right) \\\\ & = \frac{1}{\sqrt{2}} \left( \ket{010} + \ket{101} \right).</span></span>
<span data-ttu-id="8caa9-117">\енд{алигн} $ $</span><span class="sxs-lookup"><span data-stu-id="8caa9-117">\end{align} $$</span></span>

<span data-ttu-id="8caa9-118">Чтобы понять, как это делается, не измеряя очень важность, которую мы пытаемся защитить, полезно написать о том, что происходит при каждом последующем возникновении ошибки отражения в логические состояния:</span><span class="sxs-lookup"><span data-stu-id="8caa9-118">To see how we can identify that this is the case without measuring the very state we are trying to protect, it is helpful to write down what each different bit flip error does to our logical states:</span></span>

| <span data-ttu-id="8caa9-119">Ошибка $E $</span><span class="sxs-lookup"><span data-stu-id="8caa9-119">Error $E$</span></span> | <span data-ttu-id="8caa9-120">$E \кет{\оверлине {0} } $</span><span class="sxs-lookup"><span data-stu-id="8caa9-120">$E\ket{\overline{0}}$</span></span> | <span data-ttu-id="8caa9-121">$E \кет{\оверлине {1} } $</span><span class="sxs-lookup"><span data-stu-id="8caa9-121">$E\ket{\overline{1}}$</span></span> |
| --- | --- | --- |
| <span data-ttu-id="8caa9-122">$ \болдоне $</span><span class="sxs-lookup"><span data-stu-id="8caa9-122">$\boldone$</span></span> | <span data-ttu-id="8caa9-123">$ \кет {000} $</span><span class="sxs-lookup"><span data-stu-id="8caa9-123">$\ket{000}$</span></span> | <span data-ttu-id="8caa9-124">$ \кет {111} $</span><span class="sxs-lookup"><span data-stu-id="8caa9-124">$\ket{111}$</span></span> |
| <span data-ttu-id="8caa9-125">$X _0 $</span><span class="sxs-lookup"><span data-stu-id="8caa9-125">$X_0$</span></span> | <span data-ttu-id="8caa9-126">$ \кет {100} $</span><span class="sxs-lookup"><span data-stu-id="8caa9-126">$\ket{100}$</span></span> | <span data-ttu-id="8caa9-127">$ \кет {011} $</span><span class="sxs-lookup"><span data-stu-id="8caa9-127">$\ket{011}$</span></span> |
| <span data-ttu-id="8caa9-128">$X _1 $</span><span class="sxs-lookup"><span data-stu-id="8caa9-128">$X_1$</span></span> | <span data-ttu-id="8caa9-129">$ \кет {010} $</span><span class="sxs-lookup"><span data-stu-id="8caa9-129">$\ket{010}$</span></span> | <span data-ttu-id="8caa9-130">$ \кет {101} $</span><span class="sxs-lookup"><span data-stu-id="8caa9-130">$\ket{101}$</span></span> |
| <span data-ttu-id="8caa9-131">$X _2 $</span><span class="sxs-lookup"><span data-stu-id="8caa9-131">$X_2$</span></span> | <span data-ttu-id="8caa9-132">$ \кет {001} $</span><span class="sxs-lookup"><span data-stu-id="8caa9-132">$\ket{001}$</span></span> | <span data-ttu-id="8caa9-133">$ \кет {110} $</span><span class="sxs-lookup"><span data-stu-id="8caa9-133">$\ket{110}$</span></span> |

<span data-ttu-id="8caa9-134">Для защиты состояния кодирования мы должны уметь отличать три ошибки друг от друга и от идентификатора $ \болдоне $ без различия между $ \кет{\оверлине {0} } $ и $ \кет{\оверлине {1} } $.</span><span class="sxs-lookup"><span data-stu-id="8caa9-134">In order to protect the state that we're encoding, we need to be able to distinguish the three errors from each other and from the identity $\boldone$ without distinguishing between $\ket{\overline{0}}$ and $\ket{\overline{1}}$.</span></span>
<span data-ttu-id="8caa9-135">Например, если измеряется $Z _0 $, мы получаем другой результат для $ \кет{\оверлине {0} } $ и $ \кет{\оверлине {1} } $ в случае отсутствия ошибок, чтобы свернуть закодированное состояние.</span><span class="sxs-lookup"><span data-stu-id="8caa9-135">For example, if we measure $Z_0$, we get a different result for $\ket{\overline{0}}$ and $\ket{\overline{1}}$ in the no-error case, so that collapses the encoded state.</span></span>
<span data-ttu-id="8caa9-136">С другой стороны, рассмотрите возможность измерения $Z _0 Z_1 $, а также четность первых двух битов в каждом вычислительном уровне.</span><span class="sxs-lookup"><span data-stu-id="8caa9-136">On the other hand, consider measuring $Z_0 Z_1$, the parity of the first two bits in each computational basis state.</span></span>
<span data-ttu-id="8caa9-137">Вспомним, что каждое измерение оператора Паули проверяет, что еиженвалуе состояние соответствует, поэтому для каждого состояния $ \кет{\пси} $ в таблице выше мы можем вычислить $Z _0 Z_1 \кет{\пси} $, чтобы узнать, получает ли мы $ \пм\кет{\пси} $.</span><span class="sxs-lookup"><span data-stu-id="8caa9-137">Recall that each measurement of a Pauli operator checks which eigenvalue  the state being measured corresponds to, so for each state $\ket{\psi}$ in the table above, we can compute $Z_0 Z_1 \ket{\psi}$ to see if we get $\pm\ket{\psi}$.</span></span>
<span data-ttu-id="8caa9-138">Обратите внимание, что $Z _0 Z_1 \кет {000} = \кет {000} $ и что $Z _0 Z_1 \кет {111} = \кет {111} $, чтобы мы заносимся в заключение того, что это измерение выполняет то же самое в обоих закодированных состояниях.</span><span class="sxs-lookup"><span data-stu-id="8caa9-138">Note that $Z_0 Z_1 \ket{000} = \ket{000}$ and that $Z_0 Z_1 \ket{111} = \ket{111}$, so that we conclude that this measurement does the same thing to both encoded states.</span></span>
<span data-ttu-id="8caa9-139">С другой стороны, $Z _0 Z_1 \кет {100} =-\кет {100} $ and $Z _0 Z_1 \кет {011} =-\кет {011} $, поэтому результат измерения $Z _0 Z_1 $ раскрывает полезную информацию о том, какая ошибка произошла.</span><span class="sxs-lookup"><span data-stu-id="8caa9-139">On the other hand, $Z_0 Z_1 \ket{100} = - \ket{100}$ and $Z_0 Z_1 \ket{011} = -\ket{011}$, so the result of measuring $Z_0 Z_1$ reveals useful information about which error occurred.</span></span>

<span data-ttu-id="8caa9-140">Чтобы подчеркнуть это, мы повторяем приведенную выше таблицу, но добавим результаты измерения $Z _0 Z_1 $ and $Z _1 Z_2 $ в каждой строке.</span><span class="sxs-lookup"><span data-stu-id="8caa9-140">To emphasize this, we repeat the table above, but add the results of measuring $Z_0 Z_1$ and $Z_1 Z_2$ on each row.</span></span>
<span data-ttu-id="8caa9-141">Мы обносим результаты каждого измерения по знаку еиженвалуе, который наблюдается: $ + $ или $-$, соответствующее Q# `Result` значениям `Zero` и `One` соответственно.</span><span class="sxs-lookup"><span data-stu-id="8caa9-141">We denote the results of each measurement by the sign of the eigenvalue that is observed, either $+$ or $-$, corresponding to the Q# `Result` values of `Zero` and `One`, respectively.</span></span>

| <span data-ttu-id="8caa9-142">Ошибка $E $</span><span class="sxs-lookup"><span data-stu-id="8caa9-142">Error $E$</span></span> | <span data-ttu-id="8caa9-143">$E \кет{\оверлине {0} } $</span><span class="sxs-lookup"><span data-stu-id="8caa9-143">$E\ket{\overline{0}}$</span></span> | <span data-ttu-id="8caa9-144">$E \кет{\оверлине {1} } $</span><span class="sxs-lookup"><span data-stu-id="8caa9-144">$E\ket{\overline{1}}$</span></span> | <span data-ttu-id="8caa9-145">Результат $Z _0 Z_1 $</span><span class="sxs-lookup"><span data-stu-id="8caa9-145">Result of $Z_0 Z_1$</span></span> | <span data-ttu-id="8caa9-146">Результат $Z _1 Z_2 $</span><span class="sxs-lookup"><span data-stu-id="8caa9-146">Result of $Z_1 Z_2$</span></span> |
| --- | --- | --- | --- | --- |
| <span data-ttu-id="8caa9-147">$ \болдоне $</span><span class="sxs-lookup"><span data-stu-id="8caa9-147">$\boldone$</span></span> | <span data-ttu-id="8caa9-148">$ \кет {000} $</span><span class="sxs-lookup"><span data-stu-id="8caa9-148">$\ket{000}$</span></span> | <span data-ttu-id="8caa9-149">$ \кет {111} $</span><span class="sxs-lookup"><span data-stu-id="8caa9-149">$\ket{111}$</span></span> | $+$ | $+$ |
| <span data-ttu-id="8caa9-150">$X _0 $</span><span class="sxs-lookup"><span data-stu-id="8caa9-150">$X_0$</span></span> | <span data-ttu-id="8caa9-151">$ \кет {100} $</span><span class="sxs-lookup"><span data-stu-id="8caa9-151">$\ket{100}$</span></span> | <span data-ttu-id="8caa9-152">$ \кет {011} $</span><span class="sxs-lookup"><span data-stu-id="8caa9-152">$\ket{011}$</span></span> | $-$ | $+$ |
| <span data-ttu-id="8caa9-153">$X _1 $</span><span class="sxs-lookup"><span data-stu-id="8caa9-153">$X_1$</span></span> | <span data-ttu-id="8caa9-154">$ \кет {010} $</span><span class="sxs-lookup"><span data-stu-id="8caa9-154">$\ket{010}$</span></span> | <span data-ttu-id="8caa9-155">$ \кет {101} $</span><span class="sxs-lookup"><span data-stu-id="8caa9-155">$\ket{101}$</span></span> | $-$ | $-$ |
| <span data-ttu-id="8caa9-156">$X _2 $</span><span class="sxs-lookup"><span data-stu-id="8caa9-156">$X_2$</span></span> | <span data-ttu-id="8caa9-157">$ \кет {001} $</span><span class="sxs-lookup"><span data-stu-id="8caa9-157">$\ket{001}$</span></span> | <span data-ttu-id="8caa9-158">$ \кет {110} $</span><span class="sxs-lookup"><span data-stu-id="8caa9-158">$\ket{110}$</span></span> | $+$ | $-$ |

<span data-ttu-id="8caa9-159">Таким образом, результаты двух измерений однозначно определяют, какая именно ошибка отражения бита возникла, но без отображения сведений о состоянии, закодированном нами.</span><span class="sxs-lookup"><span data-stu-id="8caa9-159">Thus, the results of the two measurements uniquely determines which bit-flip error occurred, but without revealing any information about which state we encoded.</span></span>
<span data-ttu-id="8caa9-160">Мы вызываем эти результаты как *синдром* и ссылающиеся на процесс сопоставления синдром с ошибкой, вызвавшей ее как *Восстановление*.</span><span class="sxs-lookup"><span data-stu-id="8caa9-160">We call these results a *syndrome*, and refer to the process of mapping a syndrome back to the error that caused it as *recovery*.</span></span>
<span data-ttu-id="8caa9-161">В частности, мы Подчеркните, что восстановление является *классической* процедурой вывода, которая принимает в качестве входных данных синдром и возвращает инструкции по устранению ошибок, которые могли произойти.</span><span class="sxs-lookup"><span data-stu-id="8caa9-161">In particular, we emphasize that recovery is a *classical* inference procedure which takes as its input the syndrome which occurred, and returns a prescription for how to fix any errors that may have occurred.</span></span>

> [!NOTE]
> <span data-ttu-id="8caa9-162">Приведенный выше код зеркального отражения может исправлять только для ошибок отражения одного бита. то есть операция, `X` действующая на один кубит.</span><span class="sxs-lookup"><span data-stu-id="8caa9-162">The bit-flip code above can only correct against single bit-flip errors; that is, an `X` operation acting on a single qubit.</span></span>
> <span data-ttu-id="8caa9-163">Применение `X` к более чем одному кубит будет сопоставлять $ \кет{\оверлине {0} } $ с $ \кет{\оверлине {1} } $ после восстановления.</span><span class="sxs-lookup"><span data-stu-id="8caa9-163">Applying `X` to more than one qubit will map $\ket{\overline{0}}$ to $\ket{\overline{1}}$ following recovery.</span></span>
> <span data-ttu-id="8caa9-164">Аналогично, при применении операции отражения на этапе `Z` будет сопоставлено значение $ \кет{\оверлине {1} } $ с $-\кет{\оверлине {1} } $, и поэтому будет сопоставлять $ \кет{\оверлине{+}} $ с $ \кет{\оверлине {-} } $.</span><span class="sxs-lookup"><span data-stu-id="8caa9-164">Similarly, applying a phase flip operation `Z` will map $\ket{\overline{1}}$ to $-\ket{\overline{1}}$, and hence will map $\ket{\overline{+}}$ to $\ket{\overline{-}}$.</span></span>
> <span data-ttu-id="8caa9-165">Более того, коды можно создавать для поддержки большего количества ошибок, а также для решения $Z $ Errors и $X $ Errors.</span><span class="sxs-lookup"><span data-stu-id="8caa9-165">More generally, codes can be created to handle larger number of errors, and to handle $Z$ errors as well as $X$ errors.</span></span>

<span data-ttu-id="8caa9-166">Понимание того, что мы можем описать измерения в исправлении ошибок такта, которые работают одинаково во всех состояниях кода, является сутью *формального стабилизер*.</span><span class="sxs-lookup"><span data-stu-id="8caa9-166">The insight that we can describe measurements in quantum error correction that act the same way on all code states, is the essence of the *stabilizer formalism*.</span></span>
<span data-ttu-id="8caa9-167">Q#Платформа Canon предоставляет платформу для описания кодировки и декодирования из кодов стабилизер, а также для описания того, как один из них восстанавливается из ошибок.</span><span class="sxs-lookup"><span data-stu-id="8caa9-167">The Q# canon provides a framework for describing encoding into and decoding from stabilizer codes, and for describing how one recovers from errors.</span></span>
<span data-ttu-id="8caa9-168">В этом разделе мы описываем эту платформу и ее приложение на несколько простых кодов коррекции ошибок в такте.</span><span class="sxs-lookup"><span data-stu-id="8caa9-168">In this section, we describe this framework and its application to a few simple quantum error-correcting codes.</span></span>

> [!TIP]
> <span data-ttu-id="8caa9-169">Полное введение в стабилизер formal выходит за рамки этого раздела.</span><span class="sxs-lookup"><span data-stu-id="8caa9-169">A full introduction to the stabilizer formalism is beyond the scope of this section.</span></span>
> <span data-ttu-id="8caa9-170">Мы будем называть читателей, заинтересованных в изучении более [готтесман 2009](https://arxiv.org/abs/0904.2557).</span><span class="sxs-lookup"><span data-stu-id="8caa9-170">We refer readers interested in learning more to [Gottesman 2009](https://arxiv.org/abs/0904.2557).</span></span>

## <a name="representing-error-correcting-codes-in-no-locq"></a><span data-ttu-id="8caa9-171">Представление кодов коррекции ошибок в Q#</span><span class="sxs-lookup"><span data-stu-id="8caa9-171">Representing Error Correcting Codes in Q#</span></span> ##

<span data-ttu-id="8caa9-172">Чтобы помочь указать коды исправления ошибок, в Q# Canon предусмотрено несколько различных определяемых пользователем типов:</span><span class="sxs-lookup"><span data-stu-id="8caa9-172">To help specify error correcting codes, the Q# canon provides several distinct user-defined types:</span></span>

- <span data-ttu-id="8caa9-173"><xref:Microsoft.Quantum.ErrorCorrection.LogicalRegister>`= Qubit[]`: Указывает, что регистр Кубитс должен интерпретироваться как блок кода исправления ошибок.</span><span class="sxs-lookup"><span data-stu-id="8caa9-173"><xref:Microsoft.Quantum.ErrorCorrection.LogicalRegister> `= Qubit[]`: Denotes that a register of qubits should be interpreted as the code block of an error-correcting code.</span></span>
- <span data-ttu-id="8caa9-174"><xref:Microsoft.Quantum.ErrorCorrection.Syndrome>`= Result[]`: Указывает, что массив результатов измерения должен интерпретироваться как синдром, измеряемый в блоке кода.</span><span class="sxs-lookup"><span data-stu-id="8caa9-174"><xref:Microsoft.Quantum.ErrorCorrection.Syndrome> `= Result[]`: Denotes that an array of measurement results should be interpreted as the syndrome measured on a code block.</span></span>
- <span data-ttu-id="8caa9-175"><xref:Microsoft.Quantum.ErrorCorrection.RecoveryFn>`= (Syndrome -> Pauli[])`: Указывает, что *Классическая* функция должна использоваться для интерпретации синдром и возвращать исправление, которое следует применить.</span><span class="sxs-lookup"><span data-stu-id="8caa9-175"><xref:Microsoft.Quantum.ErrorCorrection.RecoveryFn> `= (Syndrome -> Pauli[])`: Denotes that a *classical* function should be used to interpret a syndrome and return a correction that should be applied.</span></span>
- <span data-ttu-id="8caa9-176"><xref:Microsoft.Quantum.ErrorCorrection.EncodeOp>`= ((Qubit[], Qubit[]) => LogicalRegister)`: Указывает, что операция принимает Кубитс представления данных вместе с новой анЦилла Кубитс, чтобы получить блок кода исправления ошибок.</span><span class="sxs-lookup"><span data-stu-id="8caa9-176"><xref:Microsoft.Quantum.ErrorCorrection.EncodeOp> `= ((Qubit[], Qubit[]) => LogicalRegister)`: Denotes that an operation takes qubits representing data along with fresh ancilla qubits in order to produce a code block of an error-correcting code.</span></span>
- <span data-ttu-id="8caa9-177"><xref:Microsoft.Quantum.ErrorCorrection.DecodeOp>`= (LogicalRegister => (Qubit[], Qubit[]))`: Обозначает, что операция разбивает блок кода ошибки исправления кода в Кубитс данных и анЦилла Кубитс, используемый для представления информации синдром.</span><span class="sxs-lookup"><span data-stu-id="8caa9-177"><xref:Microsoft.Quantum.ErrorCorrection.DecodeOp> `= (LogicalRegister => (Qubit[], Qubit[]))`: Denotes than an operation decomposes a code block of an error correcting code into the data qubits and the ancilla qubits used to represent syndrome information.</span></span>
- <span data-ttu-id="8caa9-178"><xref:Microsoft.Quantum.ErrorCorrection.SyndromeMeasOp>`= (LogicalRegister => Syndrome)`: Обозначает операцию, которая должна использоваться для извлечения сведений о синдром из блока кода без нарушения состояния, защищенного кодом.</span><span class="sxs-lookup"><span data-stu-id="8caa9-178"><xref:Microsoft.Quantum.ErrorCorrection.SyndromeMeasOp> `= (LogicalRegister => Syndrome)`: Denotes an operation that should be used to extract syndrome information from a code block, without disturbing the state protected by the code.</span></span>

<span data-ttu-id="8caa9-179">Наконец, Canon предоставляет <xref:Microsoft.Quantum.ErrorCorrection.QECC> тип для получения сведений о других типах, необходимых для определения кода исправления ошибок в такте.</span><span class="sxs-lookup"><span data-stu-id="8caa9-179">Finally, the canon provides the <xref:Microsoft.Quantum.ErrorCorrection.QECC> type to collect the other types required to define a quantum error-correcting code.</span></span> <span data-ttu-id="8caa9-180">Связанный с каждым стабилизер тактовым кодом является длина кода $n $, число $k $ из логических Кубитс и минимальное расстояние $d $, часто сгруппированные в нотации ⟦ $n $, $k $, $d $ ⟧.</span><span class="sxs-lookup"><span data-stu-id="8caa9-180">Associated with each stabilizer quantum code is the code length $n$, the number $k$ of logical qubits, and the minimum distance $d$, often conveniently grouped together in the notation ⟦$n$, $k$, $d$⟧.</span></span> <span data-ttu-id="8caa9-181">Например, <xref:Microsoft.Quantum.ErrorCorrection.BitFlipCode> функция определяет код отражения ⟦ 3, 1, 1 ⟧ бит:</span><span class="sxs-lookup"><span data-stu-id="8caa9-181">For example, the <xref:Microsoft.Quantum.ErrorCorrection.BitFlipCode> function defines the ⟦3, 1, 1⟧ bit flip code:</span></span>

```qsharp
let encodeOp = EncodeOp(BitFlipEncoder);
let decodeOp = DecodeOp(BitFlipDecoder);
let syndMeasOp = SyndromeMeasOp(MeasureStabilizerGenerators([
    [PauliZ, PauliZ, PauliI],
    [PauliI, PauliZ, PauliZ]
], _, MeasureWithScratch));
let code = QECC(encodeOp, decodeOp, syndMeasOp);
```

<span data-ttu-id="8caa9-182">Обратите внимание, что `QECC` тип *не* включает функцию восстановления.</span><span class="sxs-lookup"><span data-stu-id="8caa9-182">Notice that the `QECC` type does *not* include a recovery function.</span></span>
<span data-ttu-id="8caa9-183">Это позволяет нам изменить функцию восстановления, используемую при исправлении ошибок, не изменяя определение самого кода. Эта возможность особенно полезна при внедрении обратной связи между измерениями для встраивания в модель, предполагаемая восстановлением.</span><span class="sxs-lookup"><span data-stu-id="8caa9-183">This allows us to change the recovery function that is used in correcting errors without changing the definition of the code itself; this ability is in particular useful when incorporating feedback from characterization measurements into the model assumed by recovery.</span></span>

<span data-ttu-id="8caa9-184">После того как код определен таким образом, можно использовать <xref:Microsoft.Quantum.ErrorCorrection.Recover> операцию для восстановления после ошибок:</span><span class="sxs-lookup"><span data-stu-id="8caa9-184">Once a code is defined in this way, we can use the <xref:Microsoft.Quantum.ErrorCorrection.Recover> operation to recover from errors:</span></span>

```qsharp
let code = BitFlipCode();
let fn = BitFlipRecoveryFn();
let X0 = ApplyPauli([PauliX, PauliI, PauliI], _);
using (scratch = Qubit[nScratch]) {
    let logicalRegister = encode(data, scratch);
    // Cause an error.
    X0(logicalRegister);
    Recover(code, fn, logicalRegister);
    let (decodedData, decodedScratch) = decode(logicalRegister);
    ApplyToEach(Reset, decodedScratch);
}
```

<span data-ttu-id="8caa9-185">Мы подробно рассмотрим это в [примере кода побитового отражения](https://github.com/microsoft/Quantum/tree/main/samples/error-correction/bit-flip-code).</span><span class="sxs-lookup"><span data-stu-id="8caa9-185">We explore this in more detail in the [bit flip code sample](https://github.com/microsoft/Quantum/tree/main/samples/error-correction/bit-flip-code).</span></span>

<span data-ttu-id="8caa9-186">Помимо кода для побитового отражения, Q# Canon предоставляется с реализациями [кубит идеального кода](https://arxiv.org/abs/quant-ph/9602019)и [семи кубит кодом](https://arxiv.org/abs/quant-ph/9705052), оба из которых могут исправить произвольную ошибку с одним кодом кубит.</span><span class="sxs-lookup"><span data-stu-id="8caa9-186">Aside from the bit-flip code, the Q# canon is provided with implementations of the [five-qubit perfect code](https://arxiv.org/abs/quant-ph/9602019), and the [seven-qubit code](https://arxiv.org/abs/quant-ph/9705052), both of which can correct an arbitrary single-qubit error.</span></span>
