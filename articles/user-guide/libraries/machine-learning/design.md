---
title: Разработка собственного классификатора с помощью КДК
description: Изучите основные понятия конструирования моделей цепи для классификатора, ориентированного на такт.
author: geduardo
ms.author: v-edsanc
ms.date: 02/17/2020
ms.topic: conceptual
uid: microsoft.quantum.libraries.machine-learning.design
no-loc:
- Q#
- $$v
ms.openlocfilehash: 2100fe120ba3b5fce5d06e77d7f3f5174bc04adb
ms.sourcegitcommit: 71605ea9cc630e84e7ef29027e1f0ea06299747e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/26/2021
ms.locfileid: "98858800"
---
# <a name="design-your-own-classifier"></a>Проектирование собственного классификатора

В этом разделе вы узнаете основные понятия, лежащие в основе проектирования моделей каналов для классификатора, ориентированного на такт.

Как и в случае с классическим глубоким обучением, не существует общего правила выбора конкретной архитектуры. В зависимости от проблемы некоторые архитектуры будут работать лучше, чем другие. Но есть некоторые концепции, которые могут быть полезны при проектировании канала:

- Большое количество параметров подразумевает более гибкую модель, которая может быть удобна для нарисовать сложные границы классификации, но это также может быть более уязвимым для перегонки.

- Шлюзы ентанглинг между Кубитс являются обязательными для записи корреляции между функциями такта.

## <a name="how-to-build-a-classifier-with-q"></a>Создание классификатора с помощью Q\#

Чтобы создать классификатор, мы будем объединять управляемые параметризованнымные вращения в нашей модели канала. Для этого можно использовать тип, [`ControlledRotation`](xref:Microsoft.Quantum.MachineLearning.ControlledRotation) определенный в библиотеке тактов машинное обучение. Этот тип принимает четыре аргумента, которые определяют: индекс целевого кубит, массив индексов элемента управления Кубитс, ось вращения и индекс связанного параметра в массиве параметров, определяющих модель.

Рассмотрим пример классификатора. В [примере половинной Луны](https://github.com/microsoft/Quantum/tree/main/samples/machine-learning/half-moons)мы можем найти следующий классификатор, определенный в файле `Training.qs` .

```qsharp
    function ClassifierStructure() : ControlledRotation[] {
        return [
            ControlledRotation((0, new Int[0]), PauliX, 4),
            ControlledRotation((0, new Int[0]), PauliZ, 5),
            ControlledRotation((1, new Int[0]), PauliX, 6),
            ControlledRotation((1, new Int[0]), PauliZ, 7),
            ControlledRotation((0, [1]), PauliX, 0),
            ControlledRotation((1, [0]), PauliX, 1),
            ControlledRotation((1, new Int[0]), PauliZ, 2),
            ControlledRotation((1, new Int[0]), PauliX, 3)
        ];
    }
 ```

Здесь мы определяем функцию, которая возвращает массив `ControlledRotation` элементов, которые вместе с массивом параметров и сдвигом определяют наш [`SequentialModel`](xref:Microsoft.Quantum.MachineLearning.SequentialModel) . Этот тип является фундаментальным в библиотеке тактов Машинное обучение и определяет классификатор. Цепь, определенная в приведенной выше функции, является частью классификатора, в котором каждый пример набора данных содержит две функции. Поэтому нам нужны только два Кубитс. Графическое представление канала:

 ![Пример модели канала](~/media/circuit_model_1.PNG)

Обратите внимание, что по умолчанию для оценки вероятностей классификации можно выполнить операции с кубитом Машинное обучение тактовой меры. При проектировании канала следует иметь в виду этот факт.

## <a name="use-the-library-functions-to-write-layers-of-gates"></a>Использование библиотечных функций для записи уровней шлюзов

Предположим, что у нас есть набор данных с 784 компонентами на экземпляр, например изображения с 28 × 28 пикселями, такими как набор данных MNIST. В этом случае ширина канала станет достаточно большой, чтобы писать вручную каждый отдельный шлюз станет возможной, но непрактичной задачей. Именно поэтому библиотека тактов Машинное обучение предоставляет набор средств для автоматического создания слоев поворотов параметризованным. Например, функция [`LocalRotationsLayer`](xref:Microsoft.Quantum.MachineLearning.LocalRotationsLayer) возвращает массив неуправляемых поворотов с одним кубитом вдоль заданной оси с одним поворотом для каждого кубит в регистре, каждый параметризованным с помощью другого параметра модели. Например, `LocalRotationsLayer(4, X)` возвращает следующий набор шлюзов:

 ![Слой локальных поворотов](~/media/local_rotations_layer.PNG)

Мы рекомендуем изучить Справочник по [API-интерфейсу машинное обучение библиотеки тактов](xref:Microsoft.Quantum.MachineLearning) , чтобы найти все средства, доступные для упрощения проектирования цепи.

## <a name="next-steps"></a>Дальнейшие действия

 Попробуйте использовать различные структуры в примерах, представленных в примерах. Отображаются ли изменения в производительности модели? В следующем руководстве [`Load your own datasets`](xref:microsoft.quantum.libraries.machine-learning.load) вы узнаете, как загружать наборы данных для попыток и исследовать новые архитектуры классификаторов.
