---
title: Типы в Q#
description: 'Сведения о различных типах, используемых в языке программирования Q #.'
author: gillenhaalb
ms.author: a-gibec@microsoft.com
ms.date: 03/05/2020
ms.topic: article
uid: microsoft.quantum.guide.types
ms.openlocfilehash: 4a551ee90a0abb6e42953cf04c7f5a8ca3573f26
ms.sourcegitcommit: 682a4a5f5dd23ca58a4addf62aea4086bb308552
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/19/2020
ms.locfileid: "83609147"
---
# <a name="types-in-q"></a>Типы в Q#

На этой странице размещается модель Q # Type и описывается синтаксис для указания типов и работы с ними.
На следующей странице [введите Expressions](xref:microsoft.quantum.guide.expressions), а затем — сведения о создании выражений этих типов и работе с ними.

Обратите внимание, что Q # является *строго типизированным* языком, поэтому Аккуратное использование этих типов может помочь компилятору обеспечить строгую гарантию для программ Q # во время компиляции.
Чтобы обеспечить максимально возможную гарантию, преобразования между типами в Q # должны быть явными с помощью вызовов функций, которые выражают это преобразование. Ряд таких функций предоставляется как часть <xref:microsoft.quantum.convert> пространства имен.
С другой стороны, операции приведения к совместимым типам происходят неявно. 

Q # предоставляет оба типа-примитива, которые можно использовать напрямую, и различные способы создания новых типов из других типов.
В оставшейся части этого раздела мы рассмотрим каждую из них.

## <a name="primitive-types"></a>Примитивные типы

Язык Q # предоставляет несколько *простых типов*, из которых можно создавать другие типы:

- `Int`Тип представляет 64-разрядное целое число со знаком, например: `2` , `107` , `-5` .
- `BigInt`Тип представляет целое число со знаком произвольного размера, например `2L` , `107L` , `-5L` .
   Этот тип основан на .NET<xref:System.Numerics.BigInteger>
   Тип.
- `Double`Тип представляет число с плавающей запятой двойной точности, например: `0.0` , `-1.3` , `4e-7` .
- `Bool`Тип представляет логическое значение, которое может быть либо `true` `false` .
- `Range`Тип представляет последовательность целых чисел, обозначенную параметром `start..step..stop` , где указание шага является необязательным. 
   Это `start .. stop` соответствует `start..1..stop` , и, например, `1..2..7` представляет последовательность $ \{ 1, 3, 5, 7 \} $.
- `String`Тип — это последовательность символов Юникода, которая непрозрачна для пользователя после создания.
  Этот тип используется для передачи сообщений в классический узел в случае ошибки или диагностического события.
- `Unit`Тип — это тип, который допускает только одно значение `()` . 
  Этот тип используется, чтобы указать, что функция Q # или операция не возвращает никаких сведений. 
- `Qubit`Тип представляет тактовый бит или кубит.
   `Qubit`непрозрачны для пользователя; единственной операцией с ними, кроме передачи их в другую операцию, является проверка удостоверения (равенство).
   В конечном итоге, действия с `Qubit` s реализуются путем вызова внутренних инструкций в процессоре тактовой задержки (или при моделировании).
- `Pauli`Тип представляет один из четырех однокубитых операторов Паули.
   Этот тип используется для обозначения базовой операции для поворотов и для указания измеряемого наблюдаемого типа.
   Это перечислимый тип, имеющий четыре возможных значения: `PauliI` , `PauliX` , `PauliY` и, которые `PauliZ` являются константами типа `Pauli` .
- `Result`Тип представляет результат измерения.
   Это перечислимый тип с двумя возможными значениями: `One` и `Zero` , которые являются константами типа `Result` .
   `Zero`Указывает, что был измерен + 1 еиженвалуе; `One`указывает значение-1 еиженвалуе.

Константы,,,,,, `true` `false` `PauliI` `PauliX` `PauliY` `PauliZ` `One` и `Zero` являются зарезервированными символами в Q #.

## <a name="array-types"></a>Типы массивов

При наличии любого допустимого типа Q # `'T` существует тип, представляющий массив значений типа `'T` .
Этот тип массива представлен как `'T[]` , например, `Qubit[]` или `Int[][]` .
Например, коллекция целых чисел обозначается `Int[]` , а массив массивов `(Bool, Pauli)` значений обозначается `(Bool, Pauli)[][]` .

Во втором примере обратите внимание, что это может быть массив массивов массива, а не прямоугольный двумерный массив.
Q # не обеспечивает поддержку для прямоугольных многомерных массивов.

Значение массива может быть написано в исходном коде Q # с помощью квадратных скобок вокруг элементов массива, как в `[PauliI, PauliX, PauliY, PauliZ]` .
Тип литерала массива определяется общим базовым типом всех элементов массива. 

> [!WARNING]
> Элементы массива нельзя изменить после создания массива.
> Для создания измененного массива можно использовать [Операторы обновления и повторного назначения](xref:microsoft.quantum.guide.variables#update-and-reassign-statements) , а также [выражения копирования и обновления](xref:microsoft.quantum.guide.expressions#copy-and-update-expressions) .

Кроме того, массив можно создать из его размера с помощью `new` ключевого слова:

```qsharp
let zeros = new Int[13];
// new also allows for creating empty arrays:
let emptyRegister = new Qubit[0];
```

В любом случае, после создания массива `Length` можно использовать функцию Core для получения числа элементов в виде `Int` .
Массивы могут быть вложенными в скрипты с помощью квадратных скобок, с подстрочными индексами либо с типом, либо с `Int` типом `Range` , чтобы получить либо отдельные элементы, либо новые массивы, содержащие подмножество элементов массива.
Индексы массивов отсчитываются от нуля:

```qsharp
let arr = [10, 11, 36, 49];
let ten = arr[0]; // 10
let odds = arr[1..2..4]; // [11, 49]
```

## <a name="tuple-types"></a>Типы кортежей

При указании одного или нескольких типов, `T0` `T1` ,..., `Tn` можно обозначить новый *тип кортежа* как `(T0, T1, ..., Tn)` .
Типы, используемые для создания нового типа кортежа, могут быть кортежами, как в `(Int, (Qubit, Qubit))` .
Однако такое вложение всегда имеет конечное ограничение, так как типы кортежей не могут быть в каких-либо обстоятельствах.

Значения нового типа кортежа являются кортежами, сформированными последовательностями значений из каждого типа в кортеже.
Например, `(3, false)` — это кортеж, тип которого является типом кортежа `(Int, Bool)` .
Можно создавать массивы кортежей, кортежи массивов, кортежи подкортежей и т. д.

Начиная с Q # 0,3 `Unit` — это имя *типа* пустого кортежа; `()` используется для пустого *значения*кортежа.

Экземпляры кортежей являются неизменяемыми.
Q # не предоставляет механизм для изменения содержимого кортежа после его создания.

Кортежи — это мощная концепция, используемая в Q # для объединения значений в одно значение, что упрощает их передачу.
В частности, с помощью нотации кортежа можно выразить, что каждая операция и вызываемый метод принимают ровно один вход и возвращает ровно один результат.

### <a name="singleton-tuple-equivalence"></a>Эквивалентность одноэлементного кортежа

Можно создать одноэлементный кортеж (с одним элементом), `('T1)` например `(5)` или `([1,2,3])` .
Однако Q # обрабатывает одноэлементный кортеж как полностью эквивалентный значению заключенного в него типа.
Это значит, что различия между and и OR между and и `5` `(5)` `5` `(((5)))` `(5, (6))` `(5, 6)` .
Его можно написать так же `(5)+3` , как и для записи `5+3` , и оба выражения будут иметь значение `8` .

Это эквивалентное действие применяется для всех целей, включая присваивание и выражения.
При наличии любого выражения такое же выражение, заключенное в круглые скобки, является выражением того же типа.
Например, `(7)` является `Int` выражением, `([1,2,3])` является выражением типа массива `Int` s и `((1,2))` является выражением с типом `(Int, Int)` .

В частности, это означает, что операция или функция, для которых Входной кортеж или тип выходного кортежа имеет одно поле, можно рассматривать как принимающий один аргумент или возвращая одно значение.

Мы будем называть это свойство _эквивалентностью одноэлементного кортежа_.


## <a name="user-defined-types"></a>Определяемые пользователем типы

Объявление определяемого пользователем типа состоит из ключевого слова `newtype` , за которым следует имя определяемого пользователем типа, тип `=` , допустимая спецификация типа и завершающая точка с запятой.

Пример:

```qsharp
newtype PairOfInts = (Int, Int);
```

Каждый исходный файл Q # может объявлять любое количество определяемых пользователем типов.
Имена типов должны быть уникальными в пределах пространства имен и могут не конфликтовать с именами операций и функций.

Определяемые пользователем типы различаются, даже если базовые типы идентичны.
В частности, нет автоматического преобразования между значениями двух определяемых пользователем типов, даже если базовые типы идентичны.

### <a name="named-vs-anonymous-items"></a>Сравнение именованных и анонимных элементов

Файл Q # может определять новый именованный тип, содержащий одно значение любого допустимого типа.
Для любого типа кортежа `T` можно объявить новый определяемый пользователем тип, который является подтипом `T` с `newtype` инструкцией.
@"microsoft.quantum.math"Например, в пространстве имен сложные числа определяются как определяемые пользователем типы:

```qsharp
newtype Complex = (Double, Double);
```
Эта инструкция создает новый тип с двумя анонимными элементами типа `Double` .   

Помимо анонимных элементов, определяемые пользователем типы также поддерживают *именованные элементы* в Q # версии 0,7 или более поздней. Например, мы могли бы назвать элементы для `Re` типа Double, представляющего реальную часть комплексного числа и `Im` для мнимой части: 

```qsharp
newtype Complex = (Re : Double, Im : Double);
```
Именование одного элемента в определяемом пользователем типе не подразумевает, что все элементы должны иметь имя — любое сочетание именованных и неименованных элементов поддерживается. Кроме того, внутренние элементы также могут называться.
Тип `Nested` , определенный ниже в качестве примера, имеет базовый тип `(Double, (Int, String))` , в котором только элемент типа называется, `Int` а все остальные элементы являются анонимными. 

```qsharp
newtype Nested = (Double, (ItemName : Int, String)); 
```

Именованные элементы имеют преимущество, доступ к которому можно получить напрямую с помощью *оператора доступа* `::` . 

```qsharp
function ComplexAddition(c1 : Complex, c2 : Complex) : Complex {
    return Complex(c1::Re + c2::Re, c1::Im + c2::Im);
}
```

Помимо простых псевдонимов для потенциально сложных типов кортежей, одно существенное преимущество определения таких типов заключается в том, что они могут документировать намерение определенного значения.
При возврате к примеру `Complex` , один из них мог бы также определить двумерные полярные координаты в виде определяемого пользователем типа:

```qsharp
newtype Polar = (Radius : Double, Phase : Double);
```

Хотя оба типа `Complex` и `Polar` имеют базовый тип `(Double, Double)` , эти два типа полностью несовместимы в Q #, что сводит к минимуму риск случайного вызова сложной математической функции с полярными координатами и наоборот.
Таким образом, определяемые пользователем типы имеют аналогичную роль в качестве записей в F #, например. 


#### <a name="access-anonymous-items-with-the-unwrap-operator"></a>Доступ к анонимным элементам с помощью оператора Unwrap

Для доступа к анонимным элементам с другой стороны, сначала необходимо извлечь заключенное в оболочку значение с помощью постфиксного оператора `!` .
Оператор "Unwrap" `!` позволяет извлечь значение, содержащееся в определяемом пользователем типе.
Тип такого выражения "Unwrap" является базовым типом определяемого пользователем типа. 

```qsharp
function PrintedMessage(value : Nested) : Unit {
    let (d, (_, str)) = value!;
    Message ($"{str}, value: {d}");
}
```

Оператор Unwrap разворачивает ровно один слой упаковки.
Для доступа к значению с множественной обтеканием можно использовать несколько операторов распаковки.

например

```qsharp
newtype WrappedInt = Int;
newtype DoublyWrappedInt = WrappedInt;

...
    let x = DoublyWrappedInt(WrappedInt(6));
    let y = x!;       // y is WrappedInt(6)
    let z = x!!;      // z is 6
    let a = x + 5;    // This is an error, a DoublyWrappedInt isn't an Int
    let b = x! + 5;   // Also an error
    let c = x!! + 5;  // This is valid, c will be 11
...
```

Дополнительные сведения о операторе Unwrap можно найти в [выражениях типа в Q #](xref:microsoft.quantum.guide.expressions).

### <a name="creating-values-of-user-defined-types"></a>Создание значений определяемых пользователем типов

Значения определяемого пользователем типа можно создать, вызвав соответствующий конструктор типа:

```
let realUnit = Complex(1.0, 0.0);
let imaginaryUnit = Complex(0.0, 1.0);
```

Кроме того, новые значения можно создавать из существующих с помощью [выражений копирования и обновления](xref:microsoft.quantum.guide.expressions#copy-and-update-expressions). Как и для массивов, такие выражения копируют все значения элементов исходного выражения, за исключением указанных именованных элементов. Для этих значений задаются значения, определенные в правой части выражения. Любые другие языковые конструкции, например [Операторы обновления и повторного назначения](xref:microsoft.quantum.guide.variables#update-and-reassign-statements), доступные для элементов массива, существуют и для именованных элементов в определяемых пользователем типах.

```qsharp
newtype ComplexArray = (Count : Int, Data : Complex[]);

function AsComplexArray (data : Double[]) : ComplexArray {

    mutable res = ComplexArray(0, new Complex[0]);
    for (item in data) {
        set res w/= Data <- res::Data + [Complex(item, 0.)]; // update-and-reassign statement
    }
    return res w/ Count <- Length(res::Data); // returning a copy-and-update expression
}
```

Определяемые пользователем типы могут использоваться в любом месте, где можно использовать любой другой тип.
В частности, можно определить массив определяемого пользователем типа и включить определяемый пользователем тип как элемент типа кортежа.

Примечание. невозможно создать рекурсивные структуры типов.
То есть тип, определяющий определяемый пользователем тип, не может быть типом кортежа, включающим элемент определяемого пользователем типа.
Как правило, определяемые пользователем типы могут не иметь циклических зависимостей друг от друга, поэтому следующий набор определений типов будет недопустимым:

```qsharp
newtype TypeA = (Int, TypeB);
newtype TypeB = (Double, TypeC);
newtype TypeC = (TypeA, Range);
```


## <a name="operation-and-function-types"></a>Типы операций и функций

Базовый тип для любого вызываемого типа записывается как `('Tinput => 'Tresult)` или `('Tinput -> 'Tresult)` , где `'Tinput` `'Tresult` типы и являются типами.
Они называются *сигнатурой* вызываемого метода.

Все вызываемые команды Q # принимают одно значение в качестве входных данных и возвращают одно значение в качестве выходных данных.
Входные и выходные значения могут быть кортежами.
Вызываемые, не возвращающие результатов `Unit` .
Вызываемые, не имеющие входных данных, принимают пустой кортеж в качестве входных данных.

> [!NOTE]
> Первая форма с параметром `=>` используется для операций, а вторая форма — с `->` , для функций.
> Например, `((Qubit, Pauli) => Result)` представляет сигнатуру для возможной операции однозначного измерения кубит.
Типы *функций* полностью определяются их сигнатурой.
Например, функция, вычисляющая синус угла, будет иметь тип `(Double -> Double)` .

*Операции*---, но не функции---имеют определенные дополнительные характеристики, которые выражаются как часть типа операции. Такие характеристики включают сведения о том, что *операторов* поддерживает операция.
Например, если выполнение операции может быть соблюдено в состоянии других Кубитс, оно должно поддерживать `Controlled` функтор; если операция имеет обратную, она должна поддерживать `Adjoint` функтор. Операторов и операции подробно обсуждаются в разделе [операции и функции в Q #](xref:microsoft.quantum.guide.operationsfunctions), но здесь мы просто обсудим, как это изменяет сигнатуру операции.

Чтобы требовать поддержку для `Controlled` и/или `Adjoint` функтор в типе операции, необходимо добавить аннотацию, указывающую соответствующие характеристики.
Аннотация `is Ctl` (например, `(Qubit => Unit is Ctl)` ) указывает, что операция является управляемой---то есть, она выполняется в состоянии другого кубит или Кубитс. Аналогично, `is Adj` указывает, что операция имеет смежный объект; или просто может быть "инверсной", чтобы успешно применить операцию, а затем ее примыкающую к состоянию оставляет состояние без изменений. 

Если требуется, чтобы операция этого типа поддерживала `Adjoint` и `Controlled` функтор, мы можем выразить это как `(Qubit => Unit is Adj + Ctl)` . Например, встроенная <xref:microsoft.quantum.intrinsic.x> Операция Паули имеет тип `(Qubit => Unit is Adj + Ctl)` . 

Тип операции, который не поддерживает ни один операторов, задается только типом входного и выходного типа без дополнительной заметки.

### <a name="type-parameterized-functions-and-operations"></a>Функции и операции с параметрами типа

Вызываемые типы могут содержать параметры типа.
Параметры типа обозначаются символом, который предваряется одинарной кавычкой; Например, является допустимым `'A` параметром типа.
Сведения об определении вызываемых параметрами типа приведены в статье [операции и функции на странице Q #](xref:microsoft.quantum.guide.operationsfunctions#generic-type-parameterized-callables) .

Параметр типа может присутствовать в одной сигнатуре более одного раза.
Например, функция, которая применяет другую функцию к каждому элементу массива и возвращает собранные результаты, будет иметь сигнатуру `(('A[], 'A->'A) -> 'A[])` .
Аналогично, функция, возвращающая композицию двух операций, может иметь сигнатуру `((('A=>'B), ('B=>'C)) -> ('A=>'C))` .

При вызове вызываемого параметризованного типа все аргументы, имеющие один и тот же параметр типа, должны иметь один и тот же тип.

Q # не предоставляет механизм ограничения возможных типов, которые могут быть заменены для параметра типа.

## <a name="whats-next"></a>Дальнейшая работа
Теперь, когда вы видели все типы, составляющие язык Q #, вы можете заголовкировать [выражения в q #](xref:microsoft.quantum.guide.expressions) , чтобы узнать, как создавать и манипулировать выражениями этих различных типов.


