---
title: Типы в Q#
description: 'Сведения о различных типах, используемых в языке программирования Q #.'
author: gillenhaalb
ms.author: a-gibec@microsoft.com
ms.date: 03/05/2020
ms.topic: article
uid: microsoft.quantum.guide.types
ms.openlocfilehash: e37ce6e3a2dfad5395cdecf06178d64ec51b79f1
ms.sourcegitcommit: af10179284967bd7a72a52ae7e1c4da65c7d128d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/26/2020
ms.locfileid: "85415292"
---
# <a name="types-in-q"></a>Типы в Q#

В этой статье описывается модель типа Q # и синтаксис для указания типов и работы с ними. Дополнительные сведения о создании выражений этих типов и работе с ними см. в разделе [выражения типов](xref:microsoft.quantum.guide.expressions).

Обратите внимание, что Q # является *строго типизированным* языком, поэтому Аккуратное использование этих типов может помочь компилятору обеспечить строгую гарантию для программ Q # во время компиляции.
Чтобы обеспечить максимально возможную гарантию, преобразования между типами в Q # должны быть явными с помощью вызовов функций, которые выражают это преобразование. Q # предоставляет множество таких функций, как часть <xref:microsoft.quantum.convert> пространства имен.
С другой стороны, операции приведения к совместимым типам происходят неявно. 

Q # предоставляет оба типа-примитива, которые используются напрямую, и различные способы создания новых типов из других типов.
В оставшейся части этой статьи мы рассмотрим каждую из них.

## <a name="primitive-types"></a>Примитивные типы

Язык Q # предоставляет следующие типы- *примитивы*, которые можно использовать непосредственно в программе Q #. Эти примитивные типы также можно использовать для создания новых типов.

- `Int`Тип представляет 64-разрядное целое число со знаком, например,, `2` `107` `-5` .
- `BigInt`Тип представляет целое число со знаком произвольного размера, например, `2L` , `107L` , `-5L` .
   Этот тип основан на .NET<xref:System.Numerics.BigInteger>
   Тип.

- `Double`Тип представляет число с плавающей запятой двойной точности, например,, `0.0` `-1.3` `4e-7` .
- `Bool`Тип представляет логическое значение либо `true` `false` .
- `Range`Тип представляет последовательность целых чисел, обозначенную параметром `start..step..stop` , где указание шага является необязательным. 
   Например, `start .. stop` соответствует `start..1..stop` , и `1..2..7` представляет последовательность $ \{ 1, 3, 5, 7 \} $.
- `String`Тип — это последовательность символов Юникода, которая непрозрачна для пользователя после создания.
  Используйте `string` тип для передачи сообщений на классический узел в случае ошибки или диагностического события.
- `Unit`Тип может иметь только одно значение, `()` . 
  Используйте этот тип, чтобы указать, что функция Q # или операция не возвращает никаких сведений. 
- `Qubit`Тип представляет тактовый бит или кубит.
   `Qubit`непрозрачны для пользователя. Единственной операцией с ними, кроме передачи их в другую операцию, является проверка удостоверения (равенство).
   В конечном итоге, вы реализуете действия в с `Qubit` помощью вызова внутренних инструкций для процессора тактовой задержки (или имитатора такта).
- `Pauli`Тип представляет один из четырех однокубитых операторов Паули.
   Используйте этот тип, чтобы обозначить базовую операцию для поворотов и указать измеряемый наблюдаемый объект.
   Это перечислимый тип, имеющий четыре возможных значения: `PauliI` , `PauliX` , `PauliY` и, которые `PauliZ` являются константами типа `Pauli` .
- `Result`Тип представляет результат измерения.
   Это перечислимый тип с двумя возможными значениями: `One` и `Zero` , которые являются константами типа `Result` .
   `Zero`Указывает, что был измерен + 1 еиженвалуе; `One`указывает, что еиженвалуе-1 был измерен.

Константы,,,,,, `true` `false` `PauliI` `PauliX` `PauliY` `PauliZ` `One` и `Zero` являются зарезервированными символами в Q #.

## <a name="array-types"></a>Типы массивов

* Для любого допустимого типа Q # существует тип, представляющий массив значений этого типа.
    Например, `Qubit[]` и `(Bool, Pauli)[]` представляют массивы `Qubit` значений и `(Bool, Pauli)` значений кортежей.

* Массив массивов также является допустимым. Развернув предыдущий пример, вы `(Bool, Pauli)` обозначаете массив массивов `(Bool, Pauli)[][]` .

> [!NOTE] 
> Этот пример, `(Bool, Pauli)[][]` представляет потенциально неровный массив массивов, а не прямоугольный двумерный массив. Q # не поддерживает прямоугольные многомерные массивы.

* Значение массива может быть написано в исходном коде Q # с помощью квадратных скобок вокруг элементов массива, как в `[PauliI, PauliX, PauliY, PauliZ]` .
Общий базовый тип всех элементов массива определяет тип литерала массива. Таким образом, создание массива с элементами, не имеющими общего базового типа, вызывает ошибку.  
Пример см. в разделе [массивы вызываемых элементов](xref:microsoft.quantum.guide.expressions#arrays-of-callables).

    > [!WARNING]
    > После создания элементы массива не могут быть изменены.
    > Для создания измененного массива используйте [инструкции UPDATE-и-reassignя](xref:microsoft.quantum.guide.variables#update-and-reassign-statements) или [выражения копирования и обновления](xref:microsoft.quantum.guide.expressions#copy-and-update-expressions).

* Кроме того, массив можно создать из его размера с помощью `new` ключевого слова:

    ```qsharp
    let zeros = new Int[13];
    // you can also use new for creating empty arrays:
    let emptyRegister = new Qubit[0];
    ```

* Используйте функцию Core, `Length` чтобы получить количество элементов массива в виде `Int` .
* Массивы могут быть вложенными в скрипт, чтобы получить либо отдельные элементы, либо новые массивы, содержащие подмножество элементов массива.
Индексы массивов отсчитываются от нуля и должны иметь тип `Int` или тип `Range` :

    ```qsharp
    let arr = [10, 11, 36, 49];
    let ten = arr[0]; // 10
    let odds = arr[1..2..4]; // [11, 49]
    ```

## <a name="tuple-types"></a>Типы кортежей

Кортежи — это мощная концепция, используемая в Q # для объединения значений в одно значение, что упрощает их передачу.
В частности, с помощью нотации кортежа можно выразить, что каждая операция и вызываемый метод принимают ровно один вход и возвращает ровно один результат.

* Если указано ноль или более различных типов, `T0` `T1` ,..., `Tn` можно обозначить новый *тип кортежа* как `(T0, T1, ..., Tn)` .
Типы, используемые для создания нового типа кортежа, могут быть кортежами, как в `(Int, (Qubit, Qubit))` .
Однако такое вложение всегда имеет конечное ограничение, так как типы кортежей не могут быть в каких-либо обстоятельствах.

* Значения нового типа кортежа являются кортежами, сформированными последовательностями значений из каждого типа в кортеже.
Например, `(3, false)` — это кортеж, тип которого является типом кортежа `(Int, Bool)` .
Можно создавать массивы кортежей, кортежи массивов, кортежи подкортежей и т. д.

* Начиная с Q # 0,3 `Unit` — это имя *типа* пустого кортежа; `()` используется для *значения* пустого кортежа.

* Экземпляры кортежей являются неизменяемыми.
Q # не предоставляет механизм для изменения содержимого кортежа после его создания.



### <a name="singleton-tuple-equivalence"></a>Эквивалентность одноэлементного кортежа

Можно создать одноэлементный кортеж (с одним элементом) `('T1)` , например `(5)` или `([1,2,3])` .
Однако Q # обрабатывает одноэлементный кортеж как эквивалентный значению заключенного в него типа.
Это значит, что различия между and и OR между and и `5` `(5)` `5` `(((5)))` `(5, (6))` `(5, 6)` .
Его можно написать так же, `(5)+3` как и для записи `5+3` ; оба выражения имеют значение `8` .

Это эквивалентное действие применяется для всех целей, включая присваивание и выражения.
При наличии любого выражения такое же выражение, заключенное в круглые скобки, является выражением того же типа.
Например, `(7)` выражение типа `Int` , `([1,2,3])` является выражением типа `Int[]` , а `((1,2))` является выражением типа `(Int, Int)` .

В частности, это означает, что вы можете просмотреть операцию или функцию, у которых Входной кортеж или тип выходного кортежа имеет одно поле, которое принимает один аргумент или возвращает одно значение.

Мы будем называть это свойство _эквивалентностью одноэлементного кортежа_.


## <a name="user-defined-types"></a>Определяемые пользователем типы

Объявление определяемого пользователем типа состоит из ключевого слова `newtype` , за которым следует имя определяемого пользователем типа, тип `=` , допустимая спецификация типа и завершающая точка с запятой.

Пример:

```qsharp
newtype PairOfInts = (Int, Int);
```
    
* Каждый исходный файл Q # может объявлять любое количество определяемых пользователем типов.
* Имена типов должны быть уникальными в пределах пространства имен и могут не конфликтовать с именами операций и функций.
* Определяемые пользователем типы различаются, даже если базовые типы идентичны.
В частности, не существует автоматического преобразования между значениями двух определяемых пользователем типов, даже если базовые типы идентичны.

### <a name="named-vs-anonymous-items"></a>Сравнение именованных и анонимных элементов

Файл Q # может определять новый именованный тип, содержащий одно значение любого допустимого типа.
Для любого типа кортежа `T` можно объявить новый определяемый пользователем тип, который является подтипом `T` с `newtype` инструкцией.
@"microsoft.quantum.math"Например, в пространстве имен в качестве определяемого пользователем типа определены комплексные числа:

```qsharp
newtype Complex = (Double, Double);
```
Эта инструкция создает новый тип с двумя анонимными элементами типа `Double` .   

Помимо анонимных элементов, определяемые пользователем типы также поддерживают *именованные элементы* в Q # версии 0,7 или более поздней. Например, можно присвоить элементам имя `Re` Double, представляющей реальную часть комплексного числа и `Im` для мнимой части: 

```qsharp
newtype Complex = (Re : Double, Im : Double);
```
Именование одного элемента в определяемом пользователем типе не подразумевает, что все элементы должны иметь имя — любое сочетание именованных и неименованных элементов поддерживается. Кроме того, внутренние элементы также могут называться.
Тип `Nested` , как определено ниже, имеет базовый тип `(Double, (Int, String))` , для которого только элемент типа `Int` имеет имя, а все остальные элементы являются анонимными. 

```qsharp
newtype Nested = (Double, (ItemName : Int, String)); 
```

Именованные элементы имеют преимущество, доступ к которому можно получить напрямую с помощью *оператора доступа* `::` . 

```qsharp
function ComplexAddition(c1 : Complex, c2 : Complex) : Complex {
    return Complex(c1::Re + c2::Re, c1::Im + c2::Im);
}
```

Помимо простых псевдонимов для потенциально сложных типов кортежей, значительное преимущество определения таких типов заключается в том, что они могут документировать намерение определенного значения.
При возврате к примеру `Complex` , один из них мог бы также определить двумерные полярные координаты в виде определяемого пользователем типа:

```qsharp
newtype Polar = (Radius : Double, Phase : Double);
```

Хотя оба `Complex` типа и `Polar` имеют базовый тип `(Double, Double)` , эти два типа полностью несовместимы в Q #, что сводит к минимуму риск случайного вызова сложной математической функции с полярными координатами и наоборот.

#### <a name="access-anonymous-items-with-the-unwrap-operator"></a>Доступ к анонимным элементам с помощью оператора Unwrap

Чтобы получить доступ к анонимным элементам, сначала извлеките упакованное значение с помощью постфиксного оператора `!` .
С помощью оператора "Unwrap" `!` можно извлечь значение, содержащееся в определяемом пользователем типе.
Тип такого выражения "Unwrap" является базовым типом определяемого пользователем типа. 

```qsharp
function PrintedMessage(value : Nested) : Unit {
    let (d, (_, str)) = value!;
    Message ($"{str}, value: {d}");
}
```

Один неупакованный Оператор разворачивает один слой упаковки. Для доступа к значению с множественной обтеканием используйте несколько операторов Unwrap.

Пример:

```qsharp
newtype WrappedInt = Int;
newtype DoublyWrappedInt = WrappedInt;

...
    let x = DoublyWrappedInt(WrappedInt(6));
    let y = x!;       // y is WrappedInt(6)
    let z = x!!;      // z is 6
    let a = x + 5;    // This is an error, a DoublyWrappedInt isn't an Int
    let b = x! + 5;   // Also an error
    let c = x!! + 5;  // This is valid, c will be 11
...
```

Дополнительные сведения о операторе Unwrap см. [в разделе выражения типа в Q #](xref:microsoft.quantum.guide.expressions).

### <a name="creating-values-of-user-defined-types"></a>Создание значений определяемых пользователем типов

Создайте значения определяемого пользователем типа, вызвав соответствующий конструктор типа:

```qsharp
let realUnit = Complex(1.0, 0.0);
let imaginaryUnit = Complex(0.0, 1.0);
```

Кроме того, можно создавать новые значения из существующих с помощью [выражений копирования и обновления](xref:microsoft.quantum.guide.expressions#copy-and-update-expressions). Точно так же, как и с массивами, выражения копирования и обновления копируют все значения элементов исходного выражения, за исключением указанных именованных элементов. Для этих исключений значения этих элементов являются значениями, определенными в правой части выражения. Любые другие языковые конструкции, доступные для элементов массива, например [Операторы обновления и повторного назначения](xref:microsoft.quantum.guide.variables#update-and-reassign-statements), существуют и для именованных элементов в определяемых пользователем типах.

```qsharp
newtype ComplexArray = (Count : Int, Data : Complex[]);

function AsComplexArray (data : Double[]) : ComplexArray {

    mutable res = ComplexArray(0, new Complex[0]);
    for (item in data) {
        set res w/= Data <- res::Data + [Complex(item, 0.)]; // update-and-reassign statement
    }
    return res w/ Count <- Length(res::Data); // returning a copy-and-update expression
}
```

* Определяемые пользователем типы можно использовать в любом месте, где используются любые другие типы.
В частности, можно определить массив определяемого пользователем типа и включить определяемый пользователем тип как элемент типа кортежа.

* Невозможно создать рекурсивные структуры типа.
То есть тип, определяющий определяемый пользователем тип, не может быть кортежным типом, включающим элемент определяемого пользователем типа.
В общем, определяемые пользователем типы могут не иметь циклических зависимостей друг от друга, поэтому следующий набор определений типов является недопустимым:

    ```qsharp
    newtype TypeA = (Int, TypeB);
    newtype TypeB = (Double, TypeC);
    newtype TypeC = (TypeA, Range);
    ```


## <a name="operation-and-function-types"></a>Типы операций и функций

С учетом типов `'Tinput` и `'Tresult` :

* `('Tinput => 'Tresult)`— Это базовый тип для любой *операции*, например `((Qubit, Pauli) => Result)` .
* `('Tinput -> 'Tresult)`— Это базовый тип для любой *функции*, например `(Int -> Int)` . 

Они называются *сигнатурой* вызываемого метода.

* Все вызываемые команды Q # принимают одно значение в качестве входных данных и возвращают одно значение в качестве выходных данных.
* Кортежи можно использовать как для входных, так и для выходных значений.
* Вызываемые, которые не имеют результата, возвращают `Unit` .
* Вызываемые, не имеющие входных данных, принимают пустой кортеж в качестве входных данных.

### <a name="functors"></a>Операторов

Типы *функций* полностью определяются их сигнатурой. Например, функция, вычисляющая синус угла, будет иметь тип `(Double -> Double)` . 

*Операции* имеют определенные дополнительные характеристики, которые выражаются как часть типа операции. Такие характеристики включают сведения о том, какие *операторов* поддерживаются операцией.
Например, если выполнение операции зависит от состояния других Кубитс, то оно должно поддерживать `Controlled` функтор; если операция имеет обратный, она должна поддерживать `Adjoint` функтор.

> [!NOTE]
> В этой статье обсуждается только, как операторов изменяет подпись операции. Дополнительные сведения о операторов и операциях см. [в статье об операциях и функциях в Q #](xref:microsoft.quantum.guide.operationsfunctions). 

Чтобы требовать поддержку для `Controlled` и/или `Adjoint` функтор в типе операции, необходимо добавить заметку, указывающую соответствующие характеристики.
Аннотация `is Ctl` (например, `(Qubit => Unit is Ctl)` ) указывает, что операция является управляемой. Это значит, что его выполнение зависит от состояния другого кубит или Кубитс. Аналогичным образом, заметка `is Adj` указывает, что операция имеет смежное значение, то есть может быть "инвертированным", чтобы успешно применить операцию, а затем ее примыкающую к состоянию оставляет состояние без изменений. 

Если требуется, чтобы операция этого типа поддерживала `Adjoint` и `Controlled` функтор, можно выразить это как `(Qubit => Unit is Adj + Ctl)` . Например, встроенная <xref:microsoft.quantum.intrinsic.x> Операция Паули имеет тип `(Qubit => Unit is Adj + Ctl)` . 

Тип операции, который не поддерживает ни один операторов, задается только типом входного и выходного типа без дополнительной заметки.

### <a name="type-parameterized-functions-and-operations"></a>Функции и операции с параметрами типа

Вызываемые типы могут содержать *Параметры типа*.
Используйте символ, обозначенный префиксом одинарной кавычки, для обозначения параметра типа; Например, является допустимым `'A` параметром типа.
Дополнительные сведения и сведения о том, как определять вызываемые параметрами типа, см. [в разделе операции и функции в Q #](xref:microsoft.quantum.guide.operationsfunctions#generic-type-parameterized-callables).

Параметр типа может присутствовать в одной сигнатуре более одного раза.
Например, функция, которая применяет другую функцию к каждому элементу массива и возвращает собранные результаты, имеет сигнатуру `(('A[], 'A->'A) -> 'A[])` .
Аналогично, функция, возвращающая композицию двух операций, имеет сигнатуру `((('A=>'B), ('B=>'C)) -> ('A=>'C))` .

При вызове вызываемого параметризованного типа все аргументы, имеющие один и тот же параметр типа, должны иметь один и тот же тип.

Q # не предоставляет механизм ограничения возможных типов, которые пользователь может заменить параметром типа.

## <a name="next-steps"></a>Следующие шаги

Теперь, когда вы видели все типы, составляющие язык Q #, см. раздел [выражения типа в Q #](xref:microsoft.quantum.guide.expressions) , чтобы научиться создавать и манипулировать выражениями этих различных типов.
