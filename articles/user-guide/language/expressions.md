---
title: 'Выражения типа в Q #'
description: 'Узнайте, как указывать, ссылаться и объединять константы, переменные, операторы, операции и функции в качестве выражений в Q #.'
author: gillenhaalb
ms.author: a-gibec@microsoft.com
ms.date: 03/05/2020
ms.topic: article
uid: microsoft.quantum.guide.expressions
ms.openlocfilehash: 93432cef9711b6780192cd59e92b09647a264b5c
ms.sourcegitcommit: 2317473fdf2b80de58db0f43b9fcfb57f56aefff
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/15/2020
ms.locfileid: "83431212"
---
# <a name="type-expressions-in-q"></a>Выражения типа в Q #

## <a name="numeric-expressions"></a>Числовые выражения

Числовые выражения — это выражения типа `Int` , `BigInt` или `Double` .
То есть это либо целочисленное, либо числовое число с плавающей запятой.

`Int`литералы в Q # записываются просто как последовательность цифр.
Шестнадцатеричные и двоичные целые числа поддерживаются `0x` с `0b` префиксом и соответственно.

`BigInt`литералы в Q # записываются с помощью замыкающего `l` `L` суффикса или.
Шестнадцатеричные большие целые числа поддерживаются с префиксом "0x".
Таким образом, все следующие допустимые варианты использования `BigInt` литералов:

```qsharp
let bigZero = 0L;
let bigHex = 0x123456789abcdef123456789abcdefL;
let bigOne = bigZero + 1L;
```

`Double`литералы в Q # — это числа с плавающей запятой, записанные с использованием десятичных цифр.
Они могут быть записаны с десятичной запятой, `.` и (или) экспоненциальной частью, обозначенной как "e" или "e" (после чего допустимы только возможные отрицательные знаки и знаки после запятой).
Ниже приведены допустимые `Double` литералы: `0.0` , `1.2e5` , `1e-5` .

При наличии выражения массива любого типа элементов `Int` выражение может быть сформировано с помощью [`Length`](xref:microsoft.quantum.core.length) встроенной функции с выражением массива, заключенным в круглые скобки, `(` и `)` .
Например, если `a` привязан к массиву, то `Length(a)` является целочисленным выражением.
Если `b` является массивом массивов целых чисел, то `Int[][]` `Length(b)` — число подмассивов в `b` , а `Length(b[1])` — число целых чисел во втором подмассиве в `b` .

При наличии двух числовых выражений одного типа бинарные операторы,, `+` `-` `*` и `/` могут использоваться для формирования нового числового выражения.
Тип нового выражения будет таким же, как и типы составных выражений.

При наличии двух целочисленных выражений бинарный оператор `^` (Power) может использоваться для формирования нового целочисленного выражения.
Аналогичным образом `^` для формирования нового двойного выражения можно использовать два выражения типа Double.
Наконец, `^` можно использовать с большим целым числом слева и целым числом справа для формирования нового выражения больших целочисленных значений.
В этом случае второй параметр должен соответствовать 32 бит; Если нет, возникнет ошибка времени выполнения.

При наличии двух целочисленных или больших целочисленных выражений можно формировать новое целочисленное или большое целочисленное выражение с помощью `%` операторов (модуль), `&&&` (побитовое и), `|||` (побитовое или) или `^^^` (побитовое исключающее).

При наличии целочисленного или длинного целочисленного выражения слева, а также целочисленного выражения справа можно `<<<` использовать операторы (арифметические сдвиги влево) или `>>>` (арифметические сдвиги вправо) для создания нового выражения с тем же типом, что и у левого выражения.

Второй параметр (сумма сдвига) для операции сдвига должен быть больше или равен нулю; поведение для отрицательных сумм сдвига не определено.
Сумма сдвига для операции сдвига также должна соответствовать 32 бит; Если нет, возникнет ошибка времени выполнения.
Если число для сдвига является целым числом, то величина сдвига интерпретируется, `mod 64` то есть сдвиг 1 и сдвиг 65 имеют одинаковый результат.

Для целочисленных и больших целочисленных значений сдвиги являются арифметическими.
Сдвиг отрицательного значения влево или вправо приведет к отрицательному числу.
Это значит, что сдвиг на один шаг влево или вправо точно так же, как умножение или деление на 2 соответственно.

Целочисленный разделитель и модуль целых чисел соответствуют тому же поведению для отрицательных чисел, что и в C#.
То есть `a % b` всегда будет иметь тот же знак, что `a` и, и `b * (a / b) + a % b` всегда будет равно `a` .
Пример:

 `A` | `B` | `A / B` | `A % B`
---------|----------|---------|---------
 5 | 2 | 2 | 1
 5 | -2 | -2 | 1
 -5 | 2 | -2 | -1
 -5 | -2 | 2 | -1

Подразделение больших целых чисел и модуль работают одинаково.

При наличии любого числового выражения новое выражение может быть сформировано с помощью `-` унарного оператора.
Новое выражение будет иметь тот же тип, что и составное выражение.

При наличии целочисленного или длинного целочисленного выражения новое выражение того же типа может быть сформировано с помощью `~~~` унарного оператора (побитовое дополнение).

## <a name="boolean-expressions"></a>Логические выражения

Двумя `Bool` литеральными значениями являются `true` и `false` .

При наличии двух выражений одного и того же примитивного типа `==` `!=` для создания выражения можно использовать бинарные операторы и `Bool` .
Выражение будет иметь значение true, если два выражения равны, и false в противном случае.

Значения определяемых пользователем типов могут не сравниваться, можно сравнивать только их неупакованные значения. Например, с помощью оператора "Unwrap" `!` (подробно описывается в [типах в Q #](xref:microsoft.quantum.guide.types#access-anonymous-items-with-the-unwrap-operator)).

```qsharp
newtype WrappedInt = Int;     // Yes, this is a contrived example
let x = WrappedInt(1);
let y = WrappedInt(2);
let z = x! == y!;             // This will compile and yield z = false.
let t = x == y;               // This will cause a compiler error.
```

Сравнение на равенство для `Qubit` значений — равенство по идентификатору, то есть, определяет, совпадают ли два выражения с одинаковым кубит.
Состояние двух Кубитс не сравнивается, обращается, измеряется или изменяется с помощью этого сравнения.

Сравнение значений на равенство `Double` может привести к неверному результату из-за эффектов округления.
Например, `49.0 * (1.0/49.0) != 1.0` .

При наличии двух числовых выражений бинарные операторы, `>` , `<` `>=` и `<=` могут использоваться для создания нового логического выражения, которое имеет значение true, если первое выражение соответственно больше, меньше, больше или равно или меньше или равно второму выражению.

При наличии двух логических выражений `and` `or` бинарные операторы и можно использовать для создания нового логического выражения, которое имеет значение true, если оба выражения (отв. оба или оба) имеют значение true.

При наличии любого логического выражения `not` унарный оператор может использоваться для создания нового логического выражения, которое имеет значение true, если составное выражение имеет значение false.

## <a name="string-expressions"></a>Строковые выражения

Q # позволяет использовать строки в `fail` инструкции (объясняются в [потоке управления](xref:microsoft.quantum.guide.controlflow#fail-statement)) и в [`Message`](xref:microsoft.quantum.intrinsic.message) стандартной функции.
Конкретное поведение второго зависит от используемого симулятора, но обычно записывает сообщение в консоль узла при вызове во время программы Q #.

Строки в Q # — это литералы или интерполяции строк.

Строковые литералы похожи на простые строковые литералы в большинстве языков: последовательность символов Юникода, заключенная в двойные кавычки `"` .
Внутри строки символ обратной косой черты `\` может использоваться для экранирования символа двойной кавычки, а также для вставки новой строки как `\n` , возврата каретки в виде `\r` и табуляции как `\t` .
например

```qsharp
"\"Hello world!\", she said.\n"
```
### <a name="interpolated-strings"></a>Интерполированные строки

Синтаксис Q # для интерполяции строк является подмножеством синтаксиса C#, но мы обведем основные моменты, так как они относятся к Q #.
Ниже описаны основные различия.

Для определения строкового литерала в качестве интерполированной строки добавьте к началу символ `$`.
Пробелы между `$` и должны `"` начинать строковые литералы.

Ниже приведен простой пример использования [`Message`](xref:microsoft.quantum.intrinsic.message) функции для записи результата измерения в консоль вместе с другими выражениями Q #.

```qsharp
    let num = 8;       // some Q# expression
    let res = M(q);
    Message($"Number: {num}, Result: {res}");
```
Любое допустимое выражение Q # может присутствовать в интерполяции строки.

Дополнительные сведения о синтаксисе C# можно найти в [*интерполяции строк*](https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/interpolated-strings).
Самое важное отличие заключается в том, что Q # не поддерживает буквальные строки с интерполяцией (многострочные).
Выражения внутри строки с интерполяцией следуют синтаксису Q #, а не синтаксису C#.

## <a name="range-expressions"></a>Выражения диапазона

Учитывая все три `Int` выражения `start` , `step` , и `stop` , `start .. step .. stop` — это выражение диапазона, первый элемент которого имеет значение, второй элемент —, `start` `start+step` третий элемент — и `start+step+step` т. д., пока `stop` не будет передан.
Диапазон может быть пустым, если, например, `step` положительным и `stop < start` .
Последний элемент в диапазоне будет иметь значение `stop` , если разница между `start` и `stop` является целочисленным кратным, `step` то есть диапазон является инклюзивным на обоих концах.

При наличии двух `Int` выражений `start` и `stop` `start .. stop` является выражением диапазона, равным `start .. 1 .. stop` .
Обратите внимание, что подразумеваемым `step` является + 1, даже если `stop` значение меньше `start` ; в этом случае диапазон пуст.

Ниже приведены некоторые примеры диапазонов.

- `1..3`диапазон значений 1, 2, 3.
- `2..2..5`диапазон 2, 4.
- `2..2..6`— диапазон 2, 4, 6.
- `6..-2..2`— диапазон 6, 4, 2.
- `2..1`является пустым диапазоном.
- `2..6..7`— диапазон 2.
- `2..2..1`является пустым диапазоном.
- `1..-1..2`является пустым диапазоном.

## <a name="qubit-expressions"></a>Выражения кубит

Единственными `Qubit` выражениями являются символы, привязанные к `Qubit` значениям или элементам массива `Qubit` массивов.
`Qubit`Литералы отсутствуют.

## <a name="pauli-expressions"></a>Выражения Паули

Все четыре `Pauli` значения,,, `PauliI` `PauliX` `PauliY` и `PauliZ` , являются допустимыми `Pauli` выражениями.

Кроме того, единственными `Pauli` выражениями являются символы, привязанные к `Pauli` значениям или элементам массива `Pauli` массивов.

## <a name="result-expressions"></a>Выражения результатов

Два `Result` значения, `One` и `Zero` , являются допустимыми `Result` выражениями.

Кроме того, единственными `Result` выражениями являются символы, привязанные к `Result` значениям или элементам массива `Result` массивов.
В частности, обратите внимание, что `One` не совпадает с целым числом `1` и прямое преобразование между ними отсутствует.
Это справедливо `Zero` и для и `0` .

## <a name="tuple-expressions"></a>Кортежные выражения

Литерал кортежа — это последовательность выражений элементов соответствующего типа, разделенных запятыми, заключенная в `(` и `)` .
Например, `(1, One)` является `(Int, Result)` выражением.

Кроме литералов, единственными кортежными выражениями являются символы, привязанные к значениям кортежа, элементы массива кортежей и вызываемые вызовы, возвращающие кортежи.

## <a name="user-defined-type-expressions"></a>Выражения определяемого пользователем типа

Литерал определяемого пользователем типа состоит из имени типа, за которым следует литерал кортежа базового типа кортежа типа.
Например, если `IntPair` является определяемым пользователем типом, основанным на `(Int, Int)` , то будет `IntPair(2, 3)` допустимым литералом этого типа.

Кроме литералов, единственными выражениями определяемого пользователем типа являются символы, привязанные к значениям этого типа, элементы массива массивов этого типа и вызываемые вызовы, возвращающие этот тип.

## <a name="unwrap-expressions"></a>Разносить выражения

В Q # оператор Unwrap является восклицательным знаком в конце `!` .
Например, если `IntPair` является определяемым пользователем типом с базовым типом `(Int, Int)` и является `s` переменной со значением `IntPair(2, 3)` , то `s!` `(2, 3)` это будет.

Для определяемых пользователем типов, определенных с точки зрения других определяемых пользователем типов. Оператор Unwrap может повторяться; Например, `s!!` указывает значение удвоенного неупакованного значения `s` .
Таким образом, если `WrappedPair` является определяемым пользователем типом с базовым типом `IntPair` , а `t` является переменной со значением `WrappedPair(IntPair(1,2))` , то будет `t!!` `(1,2)` .

`!`Оператор имеет более высокий приоритет, чем все остальные операторы `[]` , кроме для индексирования и среза массива.
`!`и `[]` необходимо выполнить привязку с позиционированием, то есть `a[i]![3]` должны быть считаны следующим образом `((a[i])!)[3]` : взять `i` элемент "th" `a` , распаковать его, а затем получить третий элемент неупакованного значения (который должен быть массивом).

Приоритет `!` оператора имеет одно влияние, которое может быть неочевидным.
Если функция или операция возвращает значение, которое затем извлекается, функция или вызов операции должны быть заключены в круглые скобки, чтобы кортеж аргументов привязывается к вызову, а не к развернутому.
Пример:

```qsharp
let f = (Foo(arg))!;    // Calls Foo(arg), then unwraps the result
let g = Foo(arg)!;      // Syntax error
```

## <a name="array-expressions"></a>Выражения массива

Литерал массива — это последовательность из одного или нескольких выражений элементов, разделенных запятыми, заключенная в `[` и `]` .
Все элементы должны быть совместимы с одним и тем же типом.


При наличии двух массивов одного типа бинарный `+` оператор может использоваться для формирования нового массива, который объединяет два массива.
Например, `[1,2,3] + [4,5,6]` имеет `[1,2,3,4,5,6]` .

### <a name="array-creation"></a>Создание массива

При наличии типа и `Int` выражения `new` оператор может использоваться для выделения нового массива заданного размера.
Например, `new Int[i + 1]` будет выделять новый `Int` массив `i + 1` элементами.

Элементы нового массива инициализируются значением по умолчанию, зависящим от типа.
В большинстве случаев это разновидность нуля.

Для Кубитс и вызываемых объектов, которые являются ссылками на сущности, не существует разумного значения по умолчанию.
Таким же для этих типов по умолчанию используется недопустимая ссылка, которую нельзя использовать, не вызывая ошибку во время выполнения.
Это похоже на пустую ссылку на таких языках, как C# или Java.
Массивы, содержащие Кубитс или вызываемые, должны быть правильно инициализированы значениями, отличными от значений по умолчанию, прежде чем их элементы могут быть безопасно использованы. Подходящие процедуры инициализации можно найти в <xref:microsoft.quantum.arrays> .

Значения по умолчанию для каждого типа:

Тип | По умолчанию
---------|----------
 `Int` | `0`
 `BigInt` | `0L`
 `Double` | `0.0`
 `Bool` | `false`
 `String` | `""`
 `Qubit` | _Недопустимый кубит_
 `Pauli` | `PauliI`
 `Result` | `Zero`
 `Range` | Пустой диапазон,`1..1..0`
 `Callable` | _Недопустимый вызываемый_
 `Array['T]` | `'T[0]`

Типы кортежей инициализируются элементом по элементу.


### <a name="array-elements"></a>Элементы массива

При наличии выражения массива и `Int` выражения можно формировать новое выражение с помощью `[` `]` оператора и элемента массива.
Новое выражение будет иметь тот же тип, что и тип элемента массива.
Например, если `a` привязан к массиву `Double` s, то `a[4]` является `Double` выражением.

Если выражение массива не является простым идентификатором, его необходимо заключить в круглые скобки, чтобы выбрать элемент.
Например, если `a` и `b` являются массивами `Int` s, элемент из объединения будет выражаться следующим образом:

```qsharp
(a + b)[13]
```

Все массивы в Q # отсчитываются от нуля.
То есть первый элемент массива `a` всегда имеет значение `a[0]` .


### <a name="array-slices"></a>Срезы массива

При наличии выражения массива и `Range` выражения можно формировать новое выражение, используя `[` `]` оператор среза массива и.
Новое выражение будет иметь тот же тип, что и массив, и будет содержать элементы массива, индексируемые элементами `Range` , в порядке, определенном `Range` .
Например, если `a` привязан к массиву `Double` s, то `a[3..-1..0]` является `Double[]` выражением, содержащим первые четыре элемента, `a` но в порядке, в котором они отображаются в `a` .

Если параметр `Range` пуст, результирующий срез массива будет иметь нулевую длину.

Как и для ссылок на элементы массива, если выражение массива не является простым идентификатором, оно должно быть заключено в круглые скобки для среза.
Если `a` и `b` являются массивами типа `Int` s, срез из объединения будет выражаться следующим образом:

```qsharp
(a+b)[1..2..7]
```

#### <a name="inferred-startend-values"></a>Выводимые начальные и конечные значения

Начиная с нашего выпуска 0,8 мы поддерживаем контекстные выражения для среза диапазона. В частности, начальные и конечные значения диапазона могут быть опущены в контексте выражения среза диапазона. В этом случае компилятор применит следующие правила, чтобы определить предполагаемые разделители для диапазона. 

Например, если начальное значение диапазона опущено, то выводимое начальное значение 
- равно нулю, если шаг не указан или указанный шаг является положительным; 
- Длина фрагментированного массива минус один, если указанный шаг является отрицательным. 

Если значение конца диапазона опущено, то выводимое конечное значение 
- Длина фрагментированного массива минус один, если шаг не указан или указанный шаг является положительным; 
- равно нулю, если указанный шаг является отрицательным. 

```qsharp
let arr = [1,2,3,4,5,6];
let slice1  = arr[3...];      // slice1 is [4,5,6];
let slice2  = arr[0..2...];   // slice2 is [1,3,5];
let slice3  = arr[...2];      // slice3 is [1,2,3];
let slice4  = arr[...2..3];   // slice4 is [1,3];
let slice5  = arr[...2...];   // slice5 is [1,3,5];
let slice7  = arr[4..-2...];  // slice7 is [5,3,1];
let slice8  = arr[...-1..3];  // slice8 is [6,5,4];
let slice9  = arr[...-1...];  // slice9 is [6,5,4,3,2,1];
let slice10 = arr[...];       // slice10 is [1,2,3,4,5,6];
```

### <a name="copy-and-update-expressions"></a>Выражения копирования и обновления

Так как все типы Q # являются типами значений — с Кубитс, принимающей более специальную роль — формально — «копия» создается, когда значение привязывается к символу, или при повторной привязке символа. То есть, поведение Q # аналогично тому, как если бы копия была создана при назначении.
Разумеется, на практике при необходимости воссоздаются только соответствующие части. 

В частности, это также касается массивов.
В частности, невозможно обновить элементы массива. Чтобы изменить существующий массив, необходимо использовать механизм *копирования и обновления* .

Новые массивы можно создавать из существующих с помощью выражений *копирования и обновления* .
Выражение копирования и обновления является выражением формы `expression1 w/ expression2 <- expression3` , где должно `expression1` иметь тип `T[]` для какого-либо типа `T` .
Второй `expression2` определяет индексы элементов, которые необходимо изменить, по сравнению с массивом в `expression1` и должны иметь тип `Int` или `Range` .
Если `expression2` имеет тип `Int` , должен `expression3` иметь тип `T` . Если `expression2` имеет тип `Range` , должен `expression3` иметь тип `T[]` .

Выражение копирования и обновления `arr w/ idx <- value` формирует новый массив со всеми элементами, заданными в соответствующем элементе в `arr` , за исключением элементов в `idx` , для которых заданы единицы в `value` . Например, если `arr` содержит массив `[0,1,2,3]` , то 
- `arr w/ 0 <- 10`является массивом `[10,1,2,3]` .
- `arr w/ 2 <- 10`является массивом `[0,1,10,3]` .
- `arr w/ 0..2..3 <- [10,12]`является массивом `[10,1,12,3]` .

#### <a name="copy-and-update-expressions-for-named-items"></a>Выражения копирования и обновления для именованных элементов

Аналогичные выражения существуют для именованных элементов в определяемых пользователем типах. 

Рассмотрим, например, тип 

```qsharp
newtype Complex = (Re : Double, Im : Double);
```
Если `c` параметр содержит значение типа `Complex(1., -1.)` , то `c w/ Re <- 0.` является выражением типа `Complex` , результатом вычисления которого является `Complex(0., -1.)` .

### <a name="jagged-arrays"></a>Массивы массивов

Массив массива, иногда называемый «массивом массивов», представляет собой массив, элементы которого являются массивами.
Элементы массива массивов могут иметь разные размеры.
В следующем примере показано объявление и инициализация массива массивов, представляющего таблицу умножения.

```qsharp
let N = 4;
mutable multiplicationTable = new Int[][N];
for (i in 1..N) {
    mutable row = new Int[i];
    for (j in 1..i) {
        set row w/= j-1 <- i * j;
    }
    set multiplicationTable w/= i-1 <- row;
}
```

### <a name="arrays-of-callables"></a>Массивы вызываемых элементов 

Обратите внимание, что дополнительные сведения о вызываемых типах можно найти ниже, а также на следующей странице, [операциях и функциях в Q #](xref:microsoft.quantum.guide.operationsfunctions).

Если тип общего элемента является операцией или типом функции, все элементы должны иметь одинаковые входные и выходные типы.
Тип элемента массива будет поддерживать любые операторов, поддерживаемые всеми элементами.
Например, если `Op1` , `Op2` , и `Op3` все являются `Qubit[] => Unit` , но поддерживают, поддерживают `Op1` `Adjoint` `Op2` `Controlled` и `Op3` поддерживают оба:

- `[Op1, Op2]`является массивом `(Qubit[] => Unit)` операций.
- `[Op1, Op3]`является массивом `(Qubit[] => Unit is Adj)` операций.
- `[Op2, Op3]`является массивом `(Qubit[] => Unit is Ctl)` операций.

Пустые литералы массива `[]` не допускаются.
Вместо этого с помощью `new ★[0]` , где `★` является заполнителем для подходящего типа, позволяет создать требуемый массив нулевой длины.


## <a name="conditional-expressions"></a>Условные выражения

Учитывая два других выражения одного и того же типа и логического выражения, условное выражение может быть сформировано с помощью вопросительного знака `?` и вертикальной черты `|` .
Например, `a==b ? c | d` .
В этом примере значение условного выражения будет равно `c` `a==b` true, а `d` Если — false.

### <a name="conditional-expressions-with-callables"></a>Условные выражения с вызываемыми

Эти два выражения могут возвращать операции с одинаковыми входными и выходными данными, но поддерживают разные операторов.
В этом случае тип условного выражения является операцией с входными и выходными данными, которые поддерживают любые операторов, поддерживаемые обоими выражениями.
Например, если `Op1` , `Op2` , и `Op3` все являются `Qubit[]=>Unit` , но поддерживают, поддерживают `Op1` `Adjoint` `Op2` `Controlled` и `Op3` поддерживают оба:

- `flag ? Op1 | Op2`является `(Qubit[] => Unit)` операцией.
- `flag ? Op1 | Op3`является `(Qubit[] => Unit is Adj)` операцией.
- `flag ? Op2 | Op3`является `(Qubit[] => Unit is Ctl)` операцией.

Если одно из двух возможных результатов содержит вызов функции или операции, этот вызов будет выполняться только в том случае, если результатом является значение, которое будет значением вызова.
Например, `a==b ? C(qs) | D(qs)` Если `a==b` имеет значение true, то `C` операция будет вызвана, и если значение равно false, `D` будет вызываться только.
Это похоже на сокращенное вычисление на других языках.

## <a name="callable-expressions"></a>Вызываемые выражения

Вызываемый литерал — это имя операции или функции, определенной в области компиляции.
Например, `X` — это литерал операции, который ссылается на стандартную `X` операцию библиотеки и `Message` является литералом функции, который ссылается на стандартную библиотеку `Message` .

Если операция поддерживает `Adjoint` функтор, то `Adjoint op` это выражение операции.
Аналогично, если операция поддерживает `Controlled` функтор, то `Controlled op` это выражение операции.
Типы этих выражений задаются при [выполнении специализаций операции вызова](xref:microsoft.quantum.guide.operationsfunctions#calling-operation-specializations).

Операторов ( `Adjoint` и `Controlled` ) привязываются более тесно, чем все другие операторы, за исключением оператора Unwrap `!` и индексации массива с [] '.
Таким образом, все следующие юридические, предполагая, что операции поддерживают операторов.

```qsharp
Adjoint Op(qs)
Controlled Op(controls, targets)
Controlled Adjoint Op(controls, targets)
Adjoint WrappedOp!(qs)
```

### <a name="type-parameterized-callable-expressions"></a>Вызываемые выражения типа с параметрами

В качестве значения можно использовать вызываемый литерал, например, чтобы присвоить значение переменной или передать другому вызываемому.
В этом случае, если вызываемый [тип имеет параметры типа](xref:microsoft.quantum.guide.operationsfunctions#generic-type-parameterized-callables), они должны быть предоставлены как часть вызываемого значения.
Вызываемое значение не может иметь неопределенные параметры типа.

Например, если `Fun` является функцией с сигнатурой `'T1->Unit` :

```qsharp
let f = Fun<Int>;            // f is (Int->Unit).
let g = Fun;                 // This causes a compilation error.
SomeOtherFun(Fun<Double>);   // A (Double->Unit) is passed to SomOtherFun.
SomeOtherFun(Fun);           // This also causes a compilation error.
```

## <a name="callable-invocation-expressions"></a>Выражения вызываемого вызова

При наличии вызываемого выражения (операции или функции) и кортежного выражения входного типа сигнатуры вызываемого метода выражение вызова может быть сформировано путем добавления кортежного выражения к вызываемому выражению.
Тип выражения вызова является выходным типом сигнатуры вызываемого метода.

Например, если `Op` является операцией с сигнатурой `((Int, Qubit) => Double)` , `Op(3, qubit1)` является выражением типа `Double` .
Аналогично, если `Sin` является функцией с сигнатурой `(Double -> Double)` , `Sin(0.1)` является выражением типа `Double` .
Наконец, если `Builder` является функцией с сигнатурой `(Int -> (Int -> Int))` , функция преобразуется `Builder(3)` в тип в int.

Для вызова результата выражения с вызываемым значением требуется еще одна пара круглых скобок вокруг вызываемого выражения.
Таким образом, чтобы вызвать результат вызова `Builder` из предыдущего абзаца, правильным синтаксисом является:

```qsharp
(Builder(3))(2)
```

При вызове вызываемого [типа с параметрами](xref:microsoft.quantum.guide.operationsfunctions#generic-type-parameterized-callables) , фактические параметры типа могут быть указаны в угловых скобках `<` и `>` после вызываемого выражения.
Обычно это не требуется, так как компилятор Q # будет вычислять фактические типы.
Однако *он необходим* для [частичного приложения](xref:microsoft.quantum.guide.operationsfunctions#partial-application) , если аргумент с параметризованным типом не указан.
Кроме того, она иногда полезна при передаче операций с разными функтор, которые поддерживаются для вызова.

Например, если имеет сигнатуру и имеет сигнатуру и имеет сигнатуру, то `Func` `('T1, 'T2, 'T1) -> 'T2` `Op1` `Op2` `(Qubit[] => Unit is Adj)` `Op3` `(Qubit[] => Unit)` для вызова `Func` с помощью в `Op1` качестве первого аргумента, `Op2` а также в `Op3` качестве третьей:

```qsharp
let combinedOp = Func<(Qubit[] => Unit), (Qubit[] => Unit is Adj)>(Op1, Op2, Op3);
```

Спецификация типа является обязательной `Op3` , поскольку и `Op1` имеет разные типы, поэтому компилятор будет считать его неоднозначным без спецификации.


## <a name="operator-precedence"></a>Приоритет операторов

Все бинарные операторы являются правой ассоциативными, за исключением `^` .

Квадратные скобки `[` и `]` , для среза и индексирования массива, выполните привязку перед любым оператором.

Операторов `Adjoint` и `Controlled` BIND после индексирования массива, но перед всеми другими операторами.

Круглые скобки для операции и вызова функции также привязываются перед любым оператором, но после индексирования массива и операторов.

Операторы в порядке приоритета, от самого высокого до самого низкого:

Оператор | Арность | Описание | Типы операндов
---------|----------|---------|---------------
 конечные`!` | Унарный | разворачивание; | Любой определяемый пользователем тип
 `-`, `~~~`, `not` | Унарный | Числовое отрицательное, побитовое дополнение, логическое отрицание | `Int`, `BigInt` или `Double` для `-` , `Int` или `BigInt` для `~~~` `Bool` для`not`
 `^` | Двоичные данные | Целочисленное энергопотребление | `Int`или `BigInt` для основания, `Int` для показателя степени
 `/`, `*`, `%` | Двоичные данные | Деление, умножение, целочисленный модуль | `Int`, `BigInt` или `Double` для `/` и `*` , `Int` или `BigInt` для`%`
 `+`, `-` | Двоичные данные | Сложение или объединение строк и массивов, вычитание | `Int`, `BigInt` или `Double` , Кроме того, `String` или любого типа массива для`+`
 `<<<`, `>>>` | Двоичные данные | Сдвиг влево, сдвиг вправо | `Int` или `BigInt`
 `<`, `<=`, `>`, `>=` | Двоичные данные | Сравнения "меньше чем", "меньше или равно", "больше чем", "больше или равно" | `Int`, `BigInt` или`Double`
 `==`, `!=` | Двоичные данные | сравнения «равно» и «не равно» | любой тип-примитив
 `&&&` | Двоичные данные | Побитовое И | `Int` или `BigInt`
 `^^^` | Двоичные данные | Побитовое исключающее ИЛИ | `Int` или `BigInt`
 <code>\|\|\|</code> | Двоичные данные | Побитовое ИЛИ | `Int` или `BigInt`
 `and` | Двоичные данные | Логическое И | `Bool`
 `or` | Двоичные данные | Логическое ИЛИ | `Bool`
 `..` | Двоичный/Ternary | Оператор Range | `Int`
 `?` `|` | Ternary | Условная логика | `Bool`для левой стороны
`w/` `<-` | Ternary | Копирование и обновление | см. раздел [выражения копирования и обновления](#copy-and-update-expressions) .

## <a name="whats-next"></a>Дальнейшая работа
Теперь, когда вы можете работать с выражениями в Q #, вы можете заголовкить [операции и функции в q #](xref:microsoft.quantum.guide.operationsfunctions) , чтобы научиться определять и вызывать операции и функции.
