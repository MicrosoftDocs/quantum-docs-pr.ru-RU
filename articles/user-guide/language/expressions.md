---
title: Выражения вQ#
description: Узнайте, как указывать, ссылаться и объединять константы, переменные, операторы, операции и функции в качестве выражений в Q# .
author: gillenhaalb
ms.author: a-gibec@microsoft.com
ms.date: 03/05/2020
ms.topic: article
uid: microsoft.quantum.guide.expressions
no-loc:
- Q#
- $$v
ms.openlocfilehash: b6cc97dfee05dc843e213e84f17043714a8a9656
ms.sourcegitcommit: 6bf99d93590d6aa80490e88f2fd74dbbee8e0371
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/06/2020
ms.locfileid: "87869619"
---
# <a name="expressions-in-no-locq"></a>Выражения вQ#

## <a name="numeric-expressions"></a>Числовые выражения

Числовые выражения — это выражения типа `Int` , `BigInt` или `Double` .
То есть это либо целочисленное, либо числовое число с плавающей запятой.

`Int`литералы в Q# записываются как последовательность цифр.
Шестнадцатеричные и двоичные целые числа поддерживаются и записываются с `0x` `0b` префиксом и соответственно.

`BigInt`литералы в Q# имеют завершающий `l` суффикс или `L` .
Шестнадцатеричные большие целые числа поддерживаются и записываются с помощью префикса "0x".
Таким образом, все следующие допустимые варианты использования `BigInt` литералов:

```qsharp
let bigZero = 0L;
let bigHex = 0x123456789abcdef123456789abcdefL;
let bigOne = bigZero + 1L;
```

`Double`литералы в Q# — это числа с плавающей запятой, записанные с использованием десятичных цифр.
Они могут быть записаны с десятичной запятой или без нее, `.` или экспоненциальной частью, обозначенной как "e" или "e" (после чего допустимы только возможные отрицательные знаки и знаки после запятой).
Ниже приведены допустимые `Double` литералы: `0.0` , `1.2e5` , `1e-5` .

При наличии выражения массива любого типа элементов можно сформировать `Int` выражение с помощью [`Length`](xref:microsoft.quantum.core.length) встроенной функции с выражением массива, заключенным в круглые скобки.
Например, если `a` привязан к массиву, то `Length(a)` является целочисленным выражением.
Если `b` является массивом массивов целых чисел, то `Int[][]` `Length(b)` — число подмассивов в `b` , а `Length(b[1])` — число целых чисел во втором подмассиве в `b` .

При наличии двух числовых выражений одного типа бинарные операторы,, `+` `-` `*` и `/` могут использоваться для формирования нового числового выражения.
Тип нового выражения совпадает с типами составных выражений.

При наличии двух целочисленных выражений используйте бинарный оператор `^` (Power) для формирования нового целочисленного выражения.
Аналогично, можно также использовать `^` с двумя двойными выражениями для формирования нового двойного выражения.
Наконец, можно использовать `^` с большим целым числом слева и целым числом справа, чтобы сформировать новое большое целочисленное выражение.
В этом случае второй параметр должен соответствовать 32 бит; в противном случае возникает ошибка времени выполнения.

При наличии двух целочисленных или больших целочисленных выражений формирует новое целочисленное или большое целочисленное выражение с помощью `%` операторов (модуль), `&&&` (побитовое и), `|||` (побитовое или) или `^^^` (побитовое исключающее).

При наличии целочисленного или длинного целочисленного выражения слева и целочисленного выражения справа используйте `<<<` операторы (арифметические сдвиги влево) или `>>>` (арифметические сдвиги вправо) для создания нового выражения с тем же типом, что и у левого выражения.

Второй параметр (сумма сдвига) для операции сдвига должен быть больше или равен нулю; поведение для отрицательных сумм сдвига не определено.
Сумма сдвига для операции сдвига также должна соответствовать 32 бит; в противном случае возникает ошибка времени выполнения.
Если число, смещенное, является целым числом, то величина сдвига интерпретируется, `mod 64` то есть сдвиг 1 и сдвиг 65 имеют одинаковый результат.

Для целочисленных и больших целочисленных значений сдвиги являются арифметическими.
Сдвиг отрицательного значения влево или вправо приводит к отрицательному числу.
Это значит, что сдвиг на один шаг влево или вправо аналогичен умножению или делению на 2 соответственно.

Целочисленный разделитель и модуль целых чисел соответствуют тому же поведению для отрицательных чисел, что и в C#.
То есть `a % b` всегда имеет тот же знак, что `a` и, и `b * (a / b) + a % b` всегда равно `a` .
Пример:

 `A` | `B` | `A / B` | `A % B`
---------|----------|---------|---------
 5 | 2 | 2 | 1
 5 | -2 | -2 | 1
 -5 | 2 | -2 | -1
 -5 | -2 | 2 | -1

Операции деления больших целых чисел и операций с модулями работают аналогичным образом.

Учитывая любое числовое выражение, можно сформировать новое выражение с помощью `-` унарного оператора.
Новое выражение имеет тот же тип, что и составное выражение.

При наличии целочисленного или длинного целочисленного выражения можно сформировать новое выражение того же типа с помощью `~~~` унарного оператора (побитовое дополнение).

## <a name="boolean-expressions"></a>Логические выражения

Двумя `Bool` литеральными значениями являются `true` и `false` .

При наличии двух выражений одного и того же примитивного типа `==` `!=` для создания выражения можно использовать бинарные операторы и `Bool` .
Выражение имеет значение true, если два выражения равны, и false в противном случае.

Значения определяемых пользователем типов могут не сравниваться, можно сравнивать только их неупакованные значения. Например, с помощью оператора "Unwrap" `!` (подробно описывается в [типах в Q# ](xref:microsoft.quantum.guide.types#access-anonymous-items-with-the-unwrap-operator)),

```qsharp
newtype WrappedInt = Int;     // Yes, this is a contrived example
let x = WrappedInt(1);
let y = WrappedInt(2);
let z = x! == y!;             // This will compile and yield z = false.
let t = x == y;               // This will cause a compiler error.
```

Сравнение на равенство для `Qubit` значений — равенство по идентификатору, то есть, определяет, совпадают ли два выражения с одинаковым кубит.
Состояния двух Кубитс не сравниваются, обращаются, измеряются или изменяются при этом сравнении.

Сравнение значений на равенство `Double` может привести к неверному результату из-за эффектов округления.
Например, `49.0 * (1.0/49.0) != 1.0`.

При наличии двух числовых выражений бинарные операторы, `>` , `<` `>=` и `<=` могут использоваться для создания нового логического выражения, которое имеет значение true, если первое выражение соответственно больше, меньше, больше или равно или меньше или равно второму выражению.

При наличии двух логических выражений используйте `and` бинарный оператор для создания нового логического выражения, которое имеет значение true, если оба выражения имеют значение true. Аналогично, `or` при использовании оператора создается выражение, которое имеет значение true, если одно из двух выражений имеет значение true.

При наличии любого логического выражения `not` унарный оператор может использоваться для создания нового логического выражения, которое имеет значение true, если составное выражение имеет значение false.

## <a name="string-expressions"></a>Строковые выражения

Q#позволяет использовать строки в `fail` инструкции (объясняются в [потоке управления](xref:microsoft.quantum.guide.controlflow#fail-statement)) и в [`Message`](xref:microsoft.quantum.intrinsic.message) стандартной функции. Конкретное поведение второго зависит от используемого симулятора, но обычно записывает сообщение в консоль узла при вызове во время выполнения Q# программы.

Строки в Q# являются либо литералами, либо интерполяциями строк.

Строковые литералы похожи на простые строковые литералы в большинстве языков: последовательность символов Юникода, заключенная в двойные кавычки `" "` .
Внутри строки используйте символ обратной косой черты `\` для экранирования символа двойной кавычки ( `\"` ) или для вставки новой строки ( `\n` ), возврата каретки ( `\r` ) или табуляции ( `\t` ).
Пример:

```qsharp
"\"Hello world!\", she said.\n"
```
### <a name="interpolated-strings"></a>Интерполированные строки

Q#Синтаксис интерполяции строк представляет собой подмножество синтаксиса C#. Ниже приведены основные моменты, к которым они относятся Q# .

* Для определения строкового литерала в качестве интерполированной строки добавьте к началу символ `$`. Между элементом `$` и `"` , который запускает строковый литерал, не должно быть пробелов.

* Ниже приведен простой пример использования [`Message`](xref:microsoft.quantum.intrinsic.message) функции для записи результата измерения в консоль вместе с другими Q# выражениями.

```qsharp
    let num = 8;       // some Q# expression
    let res = M(q);
    Message($"Number: {num}, Result: {res}");
```

* Любое допустимое Q# выражение может присутствовать в интерполяции строки.

* Выражения внутри строки с интерполяцией следуют Q# синтаксису, а не синтаксису C#. Самым заметным отличием является то, что не Q# поддерживает буквальные строки с интерполяцией (многострочные).

Дополнительные сведения о синтаксисе C# см. в разделе [*интерполяция строк*](https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/interpolated-strings).

## <a name="range-expressions"></a>Выражения диапазона

Учитывая все три `Int` выражения `start` , `step` и `stop` , выражение `start .. step .. stop` является выражением диапазона, первый элемент которого имеет значение `start` , второй элемент —, `start+step` третий элемент — `start+step+step` и т. д., пока не будет пройден `stop` .
Диапазон может быть пустым, если, например, `step` является положительным и `stop < start` .

Диапазон является инклюзивным на обоих концах. То есть, если разница между `start` и `stop` является целым числом, кратным `step` , последний элемент диапазона будет иметь значение `stop` .

При наличии двух `Int` выражений `start` и `stop` выражение `start .. stop` является выражением диапазона, равным `start .. 1 .. stop` .
Обратите внимание, что подразумеваемым `step` является + 1, даже если `stop` значение меньше `start` ; в этом случае диапазон пуст.

Ниже приведены некоторые примеры диапазонов.

- `1..3`диапазон значений 1, 2, 3.
- `2..2..5`диапазон 2, 4.
- `2..2..6`— диапазон 2, 4, 6.
- `6..-2..2`— диапазон 6, 4, 2.
- `2..1`является пустым диапазоном.
- `2..6..7`— диапазон 2.
- `2..2..1`является пустым диапазоном.
- `1..-1..2`является пустым диапазоном.

## <a name="qubit-expressions"></a>Выражения кубит

Единственными `Qubit` выражениями являются символы, привязанные к `Qubit` значениям или элементам массива `Qubit` массивов.
`Qubit`Литералы отсутствуют.

## <a name="pauli-expressions"></a>Выражения Паули

Все четыре `Pauli` значения,,, `PauliI` `PauliX` `PauliY` и `PauliZ` , являются допустимыми `Pauli` выражениями.

Кроме того, единственными `Pauli` выражениями являются символы, привязанные к `Pauli` значениям или элементам массива `Pauli` массивов.

## <a name="result-expressions"></a>Выражения результатов

Два `Result` значения, `One` и `Zero` , являются допустимыми `Result` выражениями.

Кроме того, единственными `Result` выражениями являются символы, привязанные к `Result` значениям или элементам массива `Result` массивов.
В частности, обратите внимание, что `One` не совпадает с целым числом `1` и прямое преобразование между ними отсутствует.
Это справедливо `Zero` и для и `0` .

## <a name="tuple-expressions"></a>Кортежные выражения

Литерал кортежа — это последовательность выражений элементов соответствующего типа, разделенных запятыми, заключенная в круглые скобки.
Например, `(1, One)` является `(Int, Result)` выражением.

Кроме литералов, единственными кортежными выражениями являются символы, привязанные к значениям кортежа, элементы массива кортежей и вызываемые вызовы, возвращающие кортежи.

## <a name="user-defined-type-expressions"></a>Выражения определяемого пользователем типа

Литерал определяемого пользователем типа состоит из имени типа, за которым следует литерал кортежа базового типа кортежа типа.
Например, если `IntPair` является определяемым пользователем типом, основанным на `(Int, Int)` , то `IntPair(2, 3)` является допустимым литералом этого типа.

Кроме литералов, единственными выражениями определяемого пользователем типа являются символы, привязанные к значениям этого типа, элементы массива массивов этого типа и вызываемые вызовы, возвращающие этот тип.

## <a name="unwrap-expressions"></a>Разносить выражения

В Q# оператор Unwrap — это восклицательный знак в конце `!` .
Например, если `IntPair` является определяемым пользователем типом с базовым типом `(Int, Int)` и `s` является переменной со значением `IntPair(2, 3)` , то `s!` имеет значение `(2, 3)` .

Для определяемых пользователем типов, определенных с точки зрения других определяемых пользователем типов, можно повторить оператор Unwrap. Например, `s!!` указывает значение удвоенного неупакованного значения `s` .
Таким же, если `WrappedPair` является определяемым пользователем типом с базовым типом `IntPair` и `t` является переменной со значением `WrappedPair(IntPair(1,2))` , то имеет значение `t!!` `(1,2)` .

`!`Оператор имеет более высокий приоритет, чем все остальные операторы `[]` , кроме для индексирования и среза массива.
`!`и `[]` привяжите позиционированное значение, то есть `a[i]![3]` считывается следующим образом `((a[i])!)[3]` : взять `i` элемент th `a` , распаковать его, а затем получить третий элемент неупакованного значения (который должен быть массивом).

Приоритет `!` оператора имеет одно влияние, которое может быть неочевидным.
Если функция или операция возвращает значение, которое затем извлекается, функция или вызов операции должны быть заключены в круглые скобки, чтобы кортеж аргументов привязывается к вызову, а не к развернутому.
Пример:

```qsharp
let f = (Foo(arg))!;    // Calls Foo(arg), then unwraps the result
let g = Foo(arg)!;      // Syntax error
```

## <a name="array-expressions"></a>Выражения массива

Литерал массива — это последовательность из одного или нескольких выражений элементов, разделенных запятыми, заключенная в квадратные скобки `[]` .
Все элементы должны быть совместимы с одним и тем же типом.

При наличии двух массивов одного типа используйте бинарный `+` оператор для формирования нового массива, который объединяет два массива.
Например, `[1,2,3] + [4,5,6]` = `[1,2,3,4,5,6]`.

### <a name="array-creation"></a>Создание массива

При наличии типа и `Int` выражения используйте `new` оператор для выделения нового массива заданного размера.
Например, `new Int[i + 1]` выделяет новый `Int` массив с `i + 1` элементами.

Пустые литералы массива, такие как `[]` , не допускаются.
Вместо этого можно создать массив нулевой длины с помощью `new T[0]` , где — это `T` заполнитель для подходящего типа.

Элементы нового массива инициализируются значением по умолчанию, зависящим от типа.
В большинстве случаев это разновидность нуля.

Для Кубитс и вызываемых объектов, которые являются ссылками на сущности, не существует разумного значения по умолчанию.
Таким образом, для этих типов по умолчанию используется недопустимая ссылка, которую нельзя использовать, не вызывая ошибку времени выполнения, аналогичную пустой ссылке на таких языках, как C# или Java.
Массивы, содержащие Кубитс или вызываемые, должны быть инициализированы значениями, отличными от значений по умолчанию, прежде чем можно будет использовать их элементы безопасно. Подходящие процедуры инициализации см. в разделе <xref:microsoft.quantum.arrays> .

Значения по умолчанию для каждого типа:

Тип | По умолчанию
---------|----------
 `Int` | `0`
 `BigInt` | `0L`
 `Double` | `0.0`
 `Bool` | `false`
 `String` | `""`
 `Qubit` | _Недопустимый кубит_
 `Pauli` | `PauliI`
 `Result` | `Zero`
 `Range` | Пустой диапазон,`1..1..0`
 `Callable` | _Недопустимый вызываемый_
 `Array['T]` | `'T[0]`

Типы кортежей инициализируют элемент по элементу.


### <a name="array-elements"></a>Элементы массива

При наличии выражения массива и `Int` выражения формируют новое выражение с помощью оператора элемента массива `[]` .
Новое выражение имеет тот же тип, что и тип элемента массива.
Например, если `a` привязан к массиву типа `Double` , то `a[4]` является `Double` выражением.

Если выражение массива не является простым идентификатором, необходимо заключить его в круглые скобки, чтобы выбрать элемент.
Например, если `a` и `b` являются массивами типа `Int` , элемент из объединения выражается следующим образом:

```qsharp
(a + b)[13]
```

Все массивы в Q# отсчитываются от нуля.
То есть первый элемент массива `a` всегда имеет значение `a[0]` .


### <a name="array-slices"></a>Срезы массива

При наличии выражения массива и `Range` выражения формируют новое выражение с помощью оператора среза массива `[ ]` .
Новое выражение имеет тот же тип, что и массив, и содержит элементы массива, индексируемые элементами `Range` , в порядке, определенном `Range` .
Например, если `a` привязан к массиву типа `Double` , то `a[3..-1..0]` представляет собой `Double[]` выражение, содержащее первые четыре элемента, `a` но в порядке, в котором они отображаются в `a` .

Если объект `Range` пуст, результирующий срез массива имеет нулевую длину.

Как и для ссылок на элементы массива, если выражение массива не является простым идентификатором, его необходимо заключить в круглые скобки, чтобы разделить его.
Например, если `a` и `b` являются массивами типа `Int` , срез из объединения выражается следующим образом:

```qsharp
(a+b)[1..2..7]
```

#### <a name="inferred-startend-values"></a>Выводимые начальные и конечные значения

Начиная с нашего [выпуска 0,8](xref:microsoft.quantum.relnotes)мы поддерживаем контекстные выражения для среза диапазона. В частности, можно опустить начальные и конечные значения диапазона в контексте выражения среза диапазона. В этом случае компилятор применяет следующие правила, чтобы определить предполагаемые разделители для диапазона:

* Если *Начальное* значение диапазона опущено, то выводимое начальное значение
  * равно нулю, если шаг не указан или указанный шаг является положительным.  
  * Длина фрагментированного массива минус один, если указанный шаг является отрицательным.

* Если значение *конца* диапазона опущено, то выводимое конечное значение
  * длина среза массива минус единица, если шаг не указан или указанный шаг является положительным.
  * равно нулю, если указанный шаг является отрицательным.

Некоторые примеры.

```qsharp
let arr = [1,2,3,4,5,6];
let slice1  = arr[3...];      // slice1 is [4,5,6];
let slice2  = arr[0..2...];   // slice2 is [1,3,5];
let slice3  = arr[...2];      // slice3 is [1,2,3];
let slice4  = arr[...2..3];   // slice4 is [1,3];
let slice5  = arr[...2...];   // slice5 is [1,3,5];
let slice7  = arr[4..-2...];  // slice7 is [5,3,1];
let slice8  = arr[...-1..3];  // slice8 is [6,5,4];
let slice9  = arr[...-1...];  // slice9 is [6,5,4,3,2,1];
let slice10 = arr[...];       // slice10 is [1,2,3,4,5,6];
```

### <a name="copy-and-update-expressions"></a>Выражения копирования и обновления

Так как все Q# типы являются типами значений (с Кубитс, принимающей несколько специальных ролей), формально «Copy» создается при привязке значения к символу или при повторной привязке символа. Это означает, что поведение Q# аналогично тому, как если бы копия была создана с помощью оператора присваивания. 

Конечно, на практике при необходимости создаются только соответствующие части. Это влияет на способ копирования массивов, поскольку невозможно обновить элементы массива. Чтобы изменить существующий массив, необходимо использовать механизм *копирования и обновления* .

Можно создать новый массив из существующего массива с помощью выражений *копирования и обновления* , использующих операторы `w/` и `<-` .
Выражение копирования и обновления является выражением формы `expression1 w/ expression2 <- expression3` , где

* `expression1`тип должен быть типом `T[]` `T` .
* `expression2`Определяет, какие индексы в массиве задаются в `expression1` для изменения. `expression2`должен быть либо типом `Int` , либо типом `Range` .
* `expression3`— Это значения, используемые для обновления элементов в `expression1` на основе индексов, указанных в параметре `expression2` . Если `expression2` имеет тип `Int` , то `expression3` должен иметь тип `T` . Если `expression2` имеет тип `Range` , то `expression3` должен иметь тип `T[]` .

Например, выражение копирования и обновления `arr w/ idx <- value` формирует новый массив со всеми элементами, для которых заданы соответствующие элементы в `arr` , за исключением элементов, заданных параметром `idx` , для которого заданы значения в `value` . 

Заданный `arr` объект содержит массив `[0,1,2,3]` , затем 

- `arr w/ 0 <- 10`является массивом `[10,1,2,3]` .
- `arr w/ 2 <- 10`является массивом `[0,1,10,3]` .
- `arr w/ 0..2..3 <- [10,12]`является массивом `[10,1,12,3]` .

#### <a name="copy-and-update-expressions-for-named-items"></a>Выражения копирования и обновления для именованных элементов

Аналогичные выражения существуют для именованных элементов в определяемых пользователем типах. 

Например, рассмотрим тип 

```qsharp
newtype Complex = (Re : Double, Im : Double);
```
Если `c` параметр содержит значение типа `Complex(1., -1.)` , то `c w/ Re <- 0.` является выражением типа `Complex` , результатом вычисления которого является `Complex(0., -1.)` .

### <a name="jagged-arrays"></a>Массивы массивов

Массив массива, иногда называемый «массивом массивов», представляет собой массив, элементы которого являются массивами.
Элементы массива массивов могут иметь разные размеры.
В следующем примере показано объявление и инициализация массива массивов, представляющего таблицу умножения.

```qsharp
let N = 4;
mutable multiplicationTable = new Int[][N];
for (i in 1..N) {
    mutable row = new Int[i];
    for (j in 1..i) {
        set row w/= j-1 <- i * j;
    }
    set multiplicationTable w/= i-1 <- row;
}
```

### <a name="arrays-of-callables"></a>Массивы вызываемых элементов 

Можно также создать массив вызываемых элементов.

* Если тип общего элемента является операцией или типом функции, все элементы должны иметь одинаковые входные и выходные типы.
* Тип элемента массива поддерживает любые [операторов](xref:microsoft.quantum.guide.operationsfunctions) , поддерживаемые всеми элементами.
Например, если `Op1` , `Op2` и `Op3` все являются `Qubit[] => Unit` операциями, но `Op1` поддерживают, поддерживают `Adjoint` `Op2` `Controlled` и `Op3` поддерживают оба:
  * `[Op1, Op2]`является массивом `(Qubit[] => Unit)` операций.
  * `[Op1, Op3]`является массивом `(Qubit[] => Unit is Adj)` операций.
  * `[Op2, Op3]`является массивом `(Qubit[] => Unit is Ctl)` операций.

Однако, хотя операции `(Qubit[] => Unit is Adj)` и `(Qubit[] => Unit is Ctl)` имеют общий базовый тип `(Qubit[] => Unit)` , *массивы* этих операций не имеют общего базового типа.

Например, `[[Op1], [Op2]]` в настоящее время вызовет ошибку, так как пытается создать массив из двух несовместимых типов массивов `(Qubit[] => Unit is Adj)[]` и `(Qubit[] => Unit is Ctl)[]` .

Дополнительные сведения о вызываемых функциях см. в разделе [вызываемые выражения](#callable-expressions) на этой странице, [операции и функции в Q# ](xref:microsoft.quantum.guide.operationsfunctions).

## <a name="conditional-expressions"></a>Условные выражения

При наличии двух выражений одного типа и логического выражения формируют условное выражение с помощью вопросительного знака, `?` и вертикальной черты `|` . `a==b ? c | d`В данном случае значение условного выражения равно, `c` Если `a==b` равно true и `d` если оно имеет значение false.

### <a name="conditional-expressions-with-callables"></a>Условные выражения с вызываемыми

Условные выражения могут возвращать операции с одинаковыми входными и выходными данными, но поддерживают разные операторов. В этом случае тип условного выражения является операцией с входными и выходными данными, которые поддерживают любой операторов, поддерживаемый обоими выражениями.
Например, если `Op1` , `Op2` , и `Op3` все являются `Qubit[]=>Unit` , но поддерживают, поддерживают `Op1` `Adjoint` `Op2` `Controlled` и `Op3` поддерживают оба:

- `flag ? Op1 | Op2`является `(Qubit[] => Unit)` операцией.
- `flag ? Op1 | Op3`является `(Qubit[] => Unit is Adj)` операцией.
- `flag ? Op2 | Op3`является `(Qubit[] => Unit is Ctl)` операцией.

Если одно из двух возможных результатов содержит вызов функции или операции, этот вызов выполняется только в том случае, если результатом является значение, которое является значением вызова. Например, `a==b ? C(qs) | D(qs)` Если `a==b` имеет значение true, то `C` вызывается операция, и если это значение равно false, `D` вызывается только операция. Этот подход аналогичен *сокращению* в других языках.

## <a name="callable-expressions"></a>Вызываемые выражения

Вызываемый литерал — это имя операции или функции, определенной в области компиляции. Например, `X` — это литерал операции, который ссылается на стандартную `X` операцию библиотеки и `Message` является литералом функции, который ссылается на стандартную библиотеку `Message` .

Если операция поддерживает `Adjoint` функтор, то `Adjoint op` это выражение операции.
Аналогично, если операция поддерживает `Controlled` функтор, то `Controlled op` это выражение операции.
Дополнительные сведения о типах этих выражений см. в разделе [вызов специализаций операций](xref:microsoft.quantum.guide.operationsfunctions#calling-operation-specializations).

Операторов ( `Adjoint` и `Controlled` ) привязываются более тесно, чем все другие операторы, за исключением оператора Unwrap `!` и индексирования массивов с помощью `[ ]` .
Таким образом, все приведенные ниже действия являются допустимыми, предполагая, что операции поддерживают используемую операторов:

```qsharp
Adjoint Op(qs)
Controlled Op(controls, targets)
Controlled Adjoint Op(controls, targets)
Adjoint WrappedOp!(qs)
```

### <a name="type-parameterized-callable-expressions"></a>Вызываемые выражения типа с параметрами

Можно использовать вызываемый литерал в качестве значения, например, чтобы присвоить ему переменную или передать ее другому вызываемому. В этом случае, если вызываемый [тип имеет параметры типа](xref:microsoft.quantum.guide.operationsfunctions#generic-type-parameterized-callables), необходимо указать параметры в качестве части вызываемого значения.

Вызываемое значение не может иметь неопределенные параметры типа. Например, если `Fun` является функцией с сигнатурой `'T1->Unit` :

```qsharp
let f = Fun<Int>;            // f is (Int->Unit).
let g = Fun;                 // This causes a compilation error.
SomeOtherFun(Fun<Double>);   // A (Double->Unit) is passed to SomeOtherFun.
SomeOtherFun(Fun);           // This also causes a compilation error.
```

## <a name="callable-invocation-expressions"></a>Выражения вызываемого вызова

При наличии вызываемого выражения (операции или функции) и кортежного выражения входного типа сигнатуры вызываемого метода можно сформировать *выражение вызова* , добавив выражение кортежа в вызываемое выражение.
Тип выражения вызова является выходным типом сигнатуры вызываемого метода.

Например, если `Op` является операцией с сигнатурой `((Int, Qubit) => Double)` , `Op(3, qubit1)` то является выражением типа `Double` .
Аналогично, если `Sin` является функцией с сигнатурой `(Double -> Double)` , `Sin(0.1)` является выражением типа `Double` .
Наконец, если `Builder` является функцией с сигнатурой `(Int -> (Int -> Int))` , то `Builder(3)` функция является функцией из `Int` to `Int` .

Для вызова результата выражения с вызываемым значением требуется еще одна пара круглых скобок вокруг вызываемого выражения.
Таким образом, чтобы вызвать результат вызова `Builder` из предыдущего абзаца, правильным синтаксисом является:

```qsharp
(Builder(3))(2)
```

При вызове вызываемого [параметризованного типа](xref:microsoft.quantum.guide.operationsfunctions#generic-type-parameterized-callables) можно указать фактические параметры типа в угловых скобках `< >` после вызываемого выражения.
Это действие обычно не требуется, так как Q# компилятор выводит фактические типы.
Однако *он необходим* для [частичного приложения](xref:microsoft.quantum.guide.operationsfunctions#partial-application) , если аргумент с параметризованным типом не указан.
Он также полезен при передаче операций с разными функтор, которые поддерживаются для вызова.

Например, если `Func` имеет сигнатуру и имеет сигнатуру `('T1, 'T2, 'T1) -> 'T2` `Op1` `Op2` `(Qubit[] => Unit is Adj)` и `Op3` имеет сигнатуру, то `(Qubit[] => Unit)` для вызова `Func` с помощью в `Op1` качестве первого аргумента, `Op2` а также в `Op3` качестве третьей:

```qsharp
let combinedOp = Func<(Qubit[] => Unit), (Qubit[] => Unit is Adj)>(Op1, Op2, Op3);
```

Спецификация типа является обязательной `Op3` , поскольку и `Op1` имеет разные типы, поэтому компилятор будет считать его неоднозначным без спецификации.


## <a name="operator-precedence"></a>Приоритет операторов

* Все бинарные операторы являются правой ассоциативными, за исключением `^` .

* Квадратные скобки, `[ ]` для среза и индексирования массива перед любым оператором.

* Операторов `Adjoint` и `Controlled` BIND после индексирования массива, но перед всеми другими операторами.

* Круглые скобки для операции и вызова функции также привязываются перед любым оператором, но после индексирования массива и операторов.

Q#операторы в порядке приоритета, от самого высокого до самого низкого:

Оператор | Арность | Описание: | Типы операндов
---------|----------|---------|---------------
 конечные`!` | Унарный | разворачивание; | Любой определяемый пользователем тип
 `-`, `~~~`, `not` | Унарный | Числовое отрицательное, побитовое дополнение, логическое отрицание | `Int`, `BigInt` или `Double` для `-` , `Int` или `BigInt` для `~~~` `Bool` для`not`
 `^` | Двоичные данные | Целочисленное энергопотребление | `Int`или `BigInt` для основания, `Int` для показателя степени
 `/`, `*`, `%` | Двоичные данные | Деление, умножение, целочисленный модуль | `Int`, `BigInt` или `Double` для `/` и `*` , `Int` или `BigInt` для`%`
 `+`, `-` | Двоичные данные | Сложение или объединение строк и массивов, вычитание | `Int`, `BigInt` или `Double` , Кроме того, `String` или любого типа массива для`+`
 `<<<`, `>>>` | Двоичные данные | Сдвиг влево, сдвиг вправо | `Int` или `BigInt`
 `<`, `<=`, `>`, `>=` | Двоичные данные | Сравнения "меньше чем", "меньше или равно", "больше чем", "больше или равно" | `Int`, `BigInt` или`Double`
 `==`, `!=` | Двоичные данные | сравнения «равно» и «не равно» | любой тип-примитив
 `&&&` | Двоичные данные | Побитовое И | `Int` или `BigInt`
 `^^^` | Двоичные данные | Побитовое исключающее ИЛИ | `Int` или `BigInt`
 <code>\|\|\|</code> | Двоичные данные | Побитовое ИЛИ | `Int` или `BigInt`
 `and` | Двоичные данные | Логическое И | `Bool`
 `or` | Двоичные данные | Логическое ИЛИ | `Bool`
 `..` | Двоичный/Ternary | Оператор Range | `Int`
 `?` `|` | Ternary | Условная логика | `Bool`для левой стороны
`w/` `<-` | Ternary | Копирование и обновление | См. раздел [выражения копирования и обновления](#copy-and-update-expressions) .

## <a name="next-steps"></a>Дальнейшие шаги

Теперь, когда вы можете работать с выражениями в Q# , переходите к [операциям Q# и функциям в](xref:microsoft.quantum.guide.operationsfunctions) , чтобы научиться определять и вызывать операции и функции.
