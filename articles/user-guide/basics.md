---
title: 'Основные сведения об Q #'
description: 'Основные понятия Q #'
author: gillenhaalb
ms.author: a-gibec@microsoft.com
ms.date: 02/28/2020
ms.topic: article
uid: microsoft.quantum.guide.basics
ms.openlocfilehash: 45e6f2f33dafc2aec177091d3cfa94aca14fbf0a
ms.sourcegitcommit: af10179284967bd7a72a52ae7e1c4da65c7d128d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/26/2020
ms.locfileid: "85415371"
---
# <a name="q-basics"></a>Основные сведения об Q #

Эта статья содержит краткое введение в основные стандартные блоки Q #.

Общие сведения о том, что такое Q # и где он подходит в качестве фундаментального компонента пакета средств разработки тактов, см. в разделе [что такое q #?](xref:microsoft.quantum.overview.q-sharp). 

## <a name="what-is-a-quantum-program"></a>Что такое тактовая программа?

С технической точки зрения, тактовая программа — это определенный набор классических подпрограмм, которые при вызове выполняют определенные операции в тактовой системе.
Важным следствием этого представления является то, что программа Q # не напрямую моделирует Кубитс, а описывает, как классический управляемый компьютер взаимодействует с этими Кубитс.
В соответствии с разработкой Q # не определяет состояния такта или другие свойства генератора тактов напрямую.
Например, рассмотрим состояние $ \кет{+} = \лефт (\кет {0} + \кет {1} \ригхт)/\скрт {2} $, обсуждаемое в этом [Quantum Computing Concepts](xref:microsoft.quantum.concepts.intro) руководством.
Чтобы подготовить это состояние в Q #, начните с факта инициализации Кубитс в \кет $ {0} State, а также в том, что $ \кет{+} = х\кет {0} $, где $H $ — это [Преобразование хадамард](xref:microsoft.quantum.glossary#hadamard), реализованное [ `H` операцией](xref:microsoft.quantum.intrinsic.h). Базовый код Q # для инициализации и преобразования кубит, затем выглядит следующим образом:

```qsharp
using (qubit = Qubit()) {
    // At this point, the qubit is in the state |0⟩.
    H(qubit);
    // H is now applied, such that the qubit is in H|0⟩ = |+⟩, as desired.
}
```
Дополнительные сведения об инициализации и *выделении*Кубитс см. в разделе [Работа с Кубитс](xref:microsoft.quantum.guide.qubits).

## <a name="quantum-states-in-q"></a>Состояния тактов в Q #

Важно, что предыдущая программа не ссылается явно на состояние в Q #, но описывает, как наша программа *преобразует* состояние.
При таком подходе можно полностью относиться к состоянию такта даже *на* каждом целевом компьютере, который может иметь различные интерпретации в зависимости от компьютера. 

Программа Q # не может интроспект в состояние кубит.
Вместо этого программа может вызывать такие операции, как, [`Measure`](xref:microsoft.quantum.intrinsic.measure) чтобы получить сведения из кубит и вызвать операции, такие как [`X`](xref:microsoft.quantum.intrinsic.x) и, [`H`](xref:microsoft.quantum.intrinsic.h) чтобы действовать в состоянии кубит.
*Фактически эти операции делаются* только на целевом компьютере, используемом для запуска конкретной программы Q #.
Например, если запустить программу в [симуляторе полного состояния](xref:microsoft.quantum.machines.full-state-simulator), симулятор выполняет соответствующие математические операции с имитацией тактовой системы.
Но в будущем, когда целевой компьютер является реальным компьютером-тактом, вызов таких операций в Q # направляет компьютер-такт для выполнения соответствующих *реальных* операций в *реальной* тактовой системе, например, для точного времени лазерных импульсов.

Программа Q # повторно объединяет эти операции, как определено на целевом компьютере, для создания новых операций более высокого уровня для вычисления тактовых вычислений.
Таким образом, Q # упрощает выражать логику базового и гибридного такта, а также общие алгоритмы в отношении структуры целевого компьютера или симулятора.

## <a name="q-operations-and-functions"></a>Q # операции и функции

Конкретная программа Q # состоит из *операций*, *функций*и любых определяемых пользователем типов. 

Операции используются для описания преобразований тактовых систем и являются наиболее фундаментальным стандартным блоком программ Q #. Каждая операция, определенная в Q #, может затем вызывать любое количество других операций.

В отличие от операций, функции используются для описания чисто *детерминированного* классического поведения и не имеют каких либо эффектов, помимо вычисления классических значений. Например, предположим, что необходимо измерить Кубитс в конце программы и добавить результаты измерения в массив.
В этом случае `Measure` — это *Операция* , которая указывает целевому компьютеру на выполнение измерения в (реальном или смоделированной) Кубитс. В то же время *функции* обрабатывают классический процесс добавления возвращаемых результатов в массив.

Вместе операции и функции называются *вызываемыми*. Их базовая структура и поведение представлены и подробно описаны в [операциях и функциях в Q #](xref:microsoft.quantum.guide.operationsfunctions).


## <a name="q-syntax-overview"></a>Обзор синтаксиса Q #

Синтаксис языка описывает различные сочетания символов, которые формируют синтаксическую правильную программу.
В Q # элементы синтаксиса классифицируются в три различные группы: типы, выражения и операторы.

### <a name="types"></a>Типы
Q # является строго типизированным языком, поэтому использование типов может помочь компилятору обеспечить строгую гарантию для программ Q # во время компиляции.
В дополнение к стандартным и основанным на тактам встроенным примитивным типам, например,,, `Int` `Bool` `Qubit` и `Result` , Q # обеспечивает поддержку определяемых пользователем типов.

Описание всех типов-примитивов, сведения о типах массивов и кортежей, а также действия по определению новых типов в файле Q # см. [в разделе Типы в q #](xref:microsoft.quantum.guide.types).

### <a name="expressions"></a>Выражения
Выражение в языке программирования — это сочетание одной или нескольких констант, переменных, операторов и функций, которые язык программирования интерпретирует и вычисляет в определенном значении.
Чаще всего для каждого типа в языке выражения этого типа могут быть либо *литералами* , либо символами, привязанными к значению этого типа.
Например, `5` является `Int` литералом (то есть выражением типа `Int` ), и если символ `count` привязан к целому значению `5` , то `count` также является целочисленным выражением.

Кроме того, выражение может состоять из других выражений, Объединенных определенными операторами.
Например, другое `Int` выражение, результатом которого `5` является `2+3` .

Дополнительные сведения о выражениях и совместимых операторах в Q # см. в разделе [выражения типа в q #](xref:microsoft.quantum.guide.expressions). 

### <a name="statements"></a>Операторы 
Оператор — это Синтаксическая единица императивного языка программирования, который выражает какое-то действие для выполнения. Операторы, которые отличаются от выражений в этих инструкциях, не возвращают результаты и выполняются исключительно для своих побочных эффектов. Однако выражения всегда возвращают результат и часто не имеют побочных эффектов. Вкратце, инструкции Q # выполняются, тогда как выражения оцениваются.

Простой пример оператора в Q # — назначение символа выражению:
```qsharp
let count = 5;
```

Более интересным примером является оператор, `for` который поддерживает итерацию и включает *блок операторов*.
Предположим, `qubits` символ привязан к регистру Кубитс (техническим типом `Qubit[]` или массиву `Qubit` типов). Следующее действие
```qsharp
for (qubit in qubits) {
    H(qubit);
}
```
Инструкция, которая выполняет перебор каждого кубит в регистре, выполняя `H` операцию с каждым из них. Обратите внимание, что `H(qubit);` также является оператором.

Можно использовать любое выражение вызова типа `Unit` ( `Unit` тип не возвращает никакой информации) в качестве инструкции.
Этот тип выражения полезен при вызове операций с Кубитс, которые возвращают, `Unit` поскольку целью оператора является изменение неявного состояния такта.
Для операторов вычисления выражения требуется завершающая точка с запятой.

Инструкции используются для создания практически всех аспектов программы Q #, и ни одна страница не может охватывать всю информацию, относящуюся к ним.
Дополнительные сведения о лексической структуре и форматировании см. в разделе [Q # File Structure](xref:microsoft.quantum.guide.filestructure); сведения о назначении и области привязки символов см. [в разделе переменные в Q #](xref:microsoft.quantum.guide.variables); а для циклов потока управления, таких как `for` , см. раздел [поток управления в Q #](xref:microsoft.quantum.guide.controlflow).

## <a name="next-steps"></a>Следующие шаги

Начните изучать [типы в Q #](xref:microsoft.quantum.guide.types).

Дополнительные сведения об основах и мотивации в Q # см. в разделе [почему нам требуется q #?](https://devblogs.microsoft.com/qsharp/why-do-we-need-q/).
