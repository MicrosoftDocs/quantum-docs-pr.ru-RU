---
title: Q# Основы
description: Основные понятия Q#
author: gillenhaalb
ms.author: a-gibec
ms.date: 02/28/2020
ms.topic: article
uid: microsoft.quantum.guide.basics
no-loc:
- Q#
- $$v
ms.openlocfilehash: b3bc0841eabeac5d3968776f9dab3a02b1a1eef9
ms.sourcegitcommit: 29e0d88a30e4166fa580132124b0eb57e1f0e986
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/27/2020
ms.locfileid: "92691635"
---
# <a name="no-locq-basics"></a>Q# Основы

Эта статья содержит краткое введение в основные стандартные блоки Q# .

Общие сведения о том, что такое Q# и где оно подходит в качестве фундаментального компонента пакета средств разработки тактов, см. в разделе [что такое Q# ?](xref:microsoft.quantum.overview.q-sharp). 

## <a name="what-is-a-quantum-program"></a>Что такое тактовая программа?

С технической точки зрения, тактовая программа — это определенный набор классических подпрограмм, которые при вызове выполняют определенные операции в тактовой системе.
Важным следствием этого представления является то, что Q# Программа напрямую не моделирует Кубитс самостоятельно, а описывает, как классический управляемый компьютер взаимодействует с этими Кубитс.
По проекту не Q# определяет состояния тактов или другие свойства генератора тактов напрямую.
Например, рассмотрим состояние $ \кет{+} = \лефт (\кет {0} + \кет {1} \ригхт)/\скрт {2} $, обсуждаемое в этом [Quantum Computing Concepts](xref:microsoft.quantum.concepts.intro) руководством.
Чтобы подготовить это состояние в Q# , начните с факта инициализации Кубитс в состоянии $ \кет {0} $, а также в том, что $ \кет{+} = х\кет {0} $, где $H $ — это [Преобразование хадамард](xref:microsoft.quantum.glossary#hadamard), реализованное [ `H` операцией](xref:Microsoft.Quantum.Intrinsic.H). Базовый Q# код для инициализации и преобразования кубит, затем выглядит следующим образом:

```qsharp
using (qubit = Qubit()) {
    // At this point, the qubit is in the state |0⟩.
    H(qubit);
    // H is now applied, such that the qubit is in H|0⟩ = |+⟩, as desired.
}
```
Дополнительные сведения об инициализации и *выделении* Кубитс см. в разделе [Работа с Кубитс](xref:microsoft.quantum.guide.qubits).

## <a name="quantum-states-in-no-locq"></a>Состояния тактов в Q#

Важно, что предыдущая программа не ссылается явно на состояние в, Q# но описывает, как наша программа *преобразует* состояние.
При таком подходе можно полностью относиться к состоянию такта даже *на* каждом целевом компьютере, который может иметь различные интерпретации в зависимости от компьютера. 

Q#Программа не может интроспект в состояние кубит.
Вместо этого программа может вызывать такие операции, как, [`Measure`](xref:Microsoft.Quantum.Intrinsic.Measure) чтобы получить сведения из кубит и вызвать операции, такие как [`X`](xref:Microsoft.Quantum.Intrinsic.X) и, [`H`](xref:Microsoft.Quantum.Intrinsic.H) чтобы действовать в состоянии кубит.
*Фактически эти операции делаются* только на целевом компьютере, используемом для запуска конкретной Q# программы.
Например, если запустить программу в [симуляторе полного состояния](xref:microsoft.quantum.machines.full-state-simulator), симулятор выполняет соответствующие математические операции с имитацией тактовой системы.
Но в будущем, когда целевой компьютер является реальным компьютером-тактом, вызов таких операций в Q# направляет тактовый компьютер на выполнение соответствующих *реальных* операций в *реальной* тактовой системе, например, в точности лазерных импульсов.

Q#Программа повторно объединяет эти операции в соответствии с определением на целевом компьютере для создания новых операций более высокого уровня для вычисления тактового времени.
Таким образом, Q# упрощает выражать логику базового такта и гибридного такта, а также общие алгоритмы в отношении структуры целевого компьютера или симулятора.

## <a name="no-locq-operations-and-functions"></a>Q# операции и функции

Конкретнее, Q# Программа состоит из *операций* , *функций* и любых определяемых пользователем типов. 

Операции используются для описания преобразований тактовых систем и являются наиболее фундаментальным стандартным блоком Q# программ. Каждая операция, определенная в Q# , может вызвать любое количество других операций.

В отличие от операций, функции используются для описания чисто *детерминированного* классического поведения и не имеют каких либо эффектов, помимо вычисления классических значений. Например, предположим, что необходимо измерить Кубитс в конце программы и добавить результаты измерения в массив.
В этом случае `Measure` — это *Операция* , которая указывает целевому компьютеру на выполнение измерения в (реальном или смоделированной) Кубитс. В то же время *функции* обрабатывают классический процесс добавления возвращаемых результатов в массив.

Вместе операции и функции называются *вызываемыми* . Их базовая структура и поведение представлены и подробно описаны в [операциях и функциях в Q# ](xref:microsoft.quantum.guide.operationsfunctions).


## <a name="no-locq-syntax-overview"></a>Q# обзор синтаксиса

Синтаксис языка описывает различные сочетания символов, которые формируют синтаксическую правильную программу.
В Q# элементы синтаксиса классифицируются в три различные группы: типы, выражения и операторы.

### <a name="types"></a>Типы
Q# — Это строго типизированный язык, позволяющий компилятору обеспечить строгую гарантию для Q# программ во время компиляции.
Помимо стандартных и потактовых встроенных типов-примитивов, например,,, `Int` `Bool` `Qubit` и `Result` , Q# обеспечивает поддержку определяемых пользователем типов.

Описание всех типов-примитивов, сведений о типах массивов и кортежей, а также действиях по определению новых типов в Q# файле см. [в разделе Типы в Q# ](xref:microsoft.quantum.guide.types).

### <a name="expressions"></a>Выражения
Выражение в языке программирования — это сочетание одной или нескольких констант, переменных, операторов и функций, которые язык программирования интерпретирует и вычисляет в определенном значении.
Чаще всего для каждого типа в языке выражения этого типа могут быть либо *литералами* , либо символами, привязанными к значению этого типа.
Например, `5` является `Int` литералом (то есть выражением типа `Int` ), и если символ `count` привязан к целому значению `5` , то `count` также является целочисленным выражением.

Кроме того, выражение может состоять из других выражений, Объединенных определенными операторами.
Например, другое `Int` выражение, результатом которого `5` является `2+3` .

Дополнительные сведения о выражениях и совместимых операторах в см Q# . в разделе [выражения типа Q# в ](xref:microsoft.quantum.guide.expressions). 

### <a name="statements"></a>Инструкции 
Оператор — это Синтаксическая единица императивного языка программирования, который выражает какое-то действие для выполнения. Операторы, которые отличаются от выражений в этих инструкциях, не возвращают результаты и выполняются исключительно для своих побочных эффектов. Однако выражения всегда возвращают результат и часто не имеют побочных эффектов. Вкратце, Q# инструкции выполняются, а выражения оцениваются.

Простой пример оператора в Q# заключается в назначении символа выражению:
```qsharp
let count = 5;
```

Более интересным примером является оператор, `for` который поддерживает итерацию и включает *блок операторов* .
Предположим, `qubits` символ привязан к регистру Кубитс (техническим типом `Qubit[]` или массиву `Qubit` типов). Следующее действие
```qsharp
for (qubit in qubits) {
    H(qubit);
}
```
Инструкция, которая выполняет перебор каждого кубит в регистре, выполняя `H` операцию с каждым из них. Обратите внимание, что `H(qubit);` также является оператором.

Можно использовать любое выражение вызова типа `Unit` ( `Unit` тип не возвращает никакой информации) в качестве инструкции.
Этот тип выражения полезен при вызове операций с Кубитс, которые возвращают, `Unit` поскольку целью оператора является изменение неявного состояния такта.
Для операторов вычисления выражения требуется завершающая точка с запятой.

Инструкции используются для создания практически всех аспектов Q# программы, и ни одна страница не может охватывать всю информацию, относящуюся к ним.
Дополнительные сведения о своей лексической структуре и форматировании см. в разделе [ Q# File Structure](xref:microsoft.quantum.guide.filestructure); для назначения и области привязки символов, см. [в разделе переменные Q# в ](xref:microsoft.quantum.guide.variables); и для циклов потока управления, таких как `for` , см. раздел [поток управления в Q# ](xref:microsoft.quantum.guide.controlflow).

## <a name="next-steps"></a>Дальнейшие действия

Начните изучение [типов в Q# ](xref:microsoft.quantum.guide.types).

Дополнительные сведения об основах и мотивации Q# см. в разделе [Зачем нужно Q# ?](https://devblogs.microsoft.com/qsharp/why-do-we-need-q/)
