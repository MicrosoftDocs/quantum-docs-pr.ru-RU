---
title: 'Основные сведения об Q #'
description: 'Основные понятия Q #'
author: gillenhaalb
ms.author: a-gibec@microsoft.com
ms.date: 02/28/2020
ms.topic: article
uid: microsoft.quantum.guide.basics
ms.openlocfilehash: fd0ea47f00b1456ec460808ef7d451c8427677cd
ms.sourcegitcommit: 2317473fdf2b80de58db0f43b9fcfb57f56aefff
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/15/2020
ms.locfileid: "83431161"
---
# <a name="q-basics"></a>Основные сведения об Q #

В этом разделе представлены краткие сведения о базовых стандартных блоках Q #.

Краткий обзор того, что такое Q # и где он подходит в качестве фундаментального компонента пакета средств разработки тактов, можно узнать в статье [q #?](xref:microsoft.quantum.overview.q-sharp). 

## <a name="what-is-a-quantum-program"></a>Что такое тактовая программа?

С технической точки зрения, тактовая программа может рассматриваться как определенный набор классических подпрограмм, которые при вызове выполняют определенные операции в тактовой системе.
Важным следствием этого представления является то, что программа, написанная в Q #, напрямую не моделирует Кубитс, а описывает, как классический контрольный компьютер взаимодействует с этими Кубитс.
В соответствии с разработкой Q # не определяет состояния такта или другие свойства генератора тактов напрямую.
Например, рассмотрим состояние $ \кет{+} = \лефт (\кет {0} + \кет {1} \ригхт)/\скрт {2} $, обсуждаемое в этом [Quantum Computing Concepts](xref:microsoft.quantum.concepts.intro) руководством.
Чтобы подготовить это состояние в Q #, мы используем факты, которые Кубитс инициализируются в $ \кет {0} $ State и $ \кет{+} = х\кет {0} $, где $H $ является хадамард преобразованием, реализованным [ `H` Operation] (] (xref: Microsoft. тактов. внутренний. H):

```qsharp
using (qubit = Qubit()) {
    // At this point, qubit is in the state |0⟩.
    H(qubit);
    // We've now applied H, such that our qubit is in H|0⟩ = |+⟩, as we wanted.
}
```

## <a name="quantum-states-in-q"></a>Состояния тактов в Q #

Важно, что при написании приведенной выше программы мы не ссылались явно на состояние в Q #, а не описывали, как состояние было *преобразовано* нашей программой.
Это позволяет нам полностью *не* зависеть от состояния такта, даже на каждом целевом компьютере, для которого в зависимости от компьютера могут использоваться разные интерпретации. 

Программа Q # не может интроспект в состояние кубит.
Вместо этого программа может вызывать такие операции, как [`Measure`](xref:microsoft.quantum.intrinsic.measure) , чтобы получить сведения из кубит и вызвать операции, такие как [`X`](xref:microsoft.quantum.intrinsic.x) и, [`H`](xref:microsoft.quantum.intrinsic.h) чтобы действовать в состоянии кубит.
*Фактически эти операции делаются* только на целевом компьютере, используемом для запуска конкретной программы Q #.
Например, если запустить программу в [симуляторе полного состояния](xref:microsoft.quantum.machines.full-state-simulator), симулятор выполнит соответствующие математические операции в имитацию тактовой системы.
Но в будущем, когда целевой компьютер является реальным компьютером-тактом, вызов таких операций в Q # направляет компьютер-такт для выполнения соответствующих *реальных* операций в *реальной* тактовой системе (например, для точного времени лазерных импульсов).

Программа Q # повторно объединяет эти операции, как определено на целевом компьютере, для создания новых операций более высокого уровня для вычисления тактовых вычислений.
Таким образом, Q # упрощает выражать логику базового и гибридного такта, а также общие алгоритмы в отношении структуры целевого компьютера или симулятора.

## <a name="q-operations-and-functions"></a>Q # операции и функции

Конкретная программа Q # состоит из *операций*, *функций*и любых определяемых пользователем типов. 

Операции используются для описания преобразований тактовых систем и являются наиболее базовым стандартным блоком программ Q #. Каждая операция, определенная в Q #, может затем вызывать любое количество других операций.

В отличие от операций, функции используются для описания чисто *детерминированного* классического поведения и не имеют каких либо эффектов, помимо вычисления классических значений. Например, предположим, что мы хотим измерить Кубитс в конце программы и добавим результаты измерения в массив.
В этом случае `Measure` является *операцией* , которая указывает целевому компьютеру выполнить измерение в (реальном или смоделированном) Кубитс, а классический процесс добавления возвращаемых результатов в массив будет обрабатываться *функциями*.

Вместе операции и функции называются *вызываемыми*, а их базовая структура и поведение представлены в [операциях и функциях на странице Q #](xref:microsoft.quantum.guide.operationsfunctions) .


## <a name="q-syntax-overview"></a>Обзор синтаксиса Q #

Синтаксис языка описывает различные сочетания символов, которые формируют синтаксическую правильную программу.
В Q # мы можем классифицировать элементы своего синтаксиса в трех разных группах: типы, выражения и операторы.

### <a name="types"></a>Типы
Q # является строго типизированным языком, поэтому использование типов может помочь компилятору обеспечить строгую гарантию для программ Q # во время компиляции.
Помимо стандартных и потактовых встроенных типов-примитивов (например,, `Int` , `Bool` `Qubit` и `Result` ), Q # обеспечивает поддержку определяемых пользователем типов.
Все различные типы-примитивы Q # описаны на странице [типы в Q #](xref:microsoft.quantum.guide.types) , а также подробные сведения о типах массивов и кортежей и о том, как определять новые типы в файле Q #.

### <a name="expressions"></a>Выражения
Выражение в языке программирования — это сочетание одной или нескольких констант, переменных, операторов и функций, которые язык программирования интерпретирует и вычисляет в определенном значении.
Чаще всего для каждого типа в языке выражения этого типа могут быть либо *литералами* , либо символами, привязанными к значению этого типа.
Например, `5` является `Int` литералом (то есть выражением типа `Int` ), и если символ `count` привязан к целому значению `5` , то `count` также является целочисленным выражением.

Кроме того, выражение может состоять из других выражений, Объединенных с определенными операторами.
Поэтому еще один пример `Int` выражения, результатом которого является значение `5` `2+3` .

Возможные выражения типов в Q #, а также совместимые операторы, которые можно использовать для их формирования, подробно описаны в [выражениях типа на странице Q #](xref:microsoft.quantum.guide.expressions) . 

### <a name="statements"></a>Инструкции 
Оператор — это Синтаксическая единица императивного языка программирования, который выражает определенное действие для выполнения. Операторы, которые отличаются от выражений в этих инструкциях, не возвращают результаты и выполняются исключительно для своих побочных эффектов, тогда как выражения всегда возвращают результат и часто не имеют побочных эффектов.
Это различие часто наблюдается в словах: вычисляется выражение, в то время как выполняется инструкция.

Очень простой пример оператора в Q # — назначение символа выражению:
```qsharp
let count = 5;
```

Чуть более интересный пример — это `for` инструкция, которая поддерживает итерацию и включает *блок операторов*.
Предположим, `qubits` символ привязан к регистру Кубитс (техническим типом `Qubit[]` , т. е. массивом `Qubit` типов). Следующее действие
```qsharp
for (qubit in qubits) {
    H(qubit);
}
```
Инструкция, которая выполняет итерацию каждого кубит в регистре, выполняя `H` операцию с каждым из них. Обратите внимание, что `H(qubit);` также является оператором.

Фактически любое выражение вызова типа `Unit` (те, которые не возвращают сведения) можно использовать в качестве инструкции.
Это в первую очередь используется при вызове операций с Кубитс, которые возвращают, `Unit` поскольку целью инструкции является изменение неявного состояния такта.
Для операторов вычисления выражения требуется завершающая точка с запятой.

Практически все аспекты программы Q # создаются с помощью инструкций, поэтому ни одна страница не может охватывать всю информацию, относящуюся к ним.
Однако их лексическая структура и форматирование описаны на странице [структуры файлов q #](xref:microsoft.quantum.guide.filestructure) , назначении привязки символов и области в [переменных в q #](xref:microsoft.quantum.guide.variables), а также в циклах потока управления, таких как `for` [поток управления в q #](xref:microsoft.quantum.guide.controlflow).


## <a name="whats-next"></a>Что дальше?
В оставшейся части этого руководства мы покажем, как использовать Q # для создания сложных тактовых программ с помощью основных стандартных блоков операций, функций и типов.

Чтобы приступить к работе, можно приступить к изучению [типов в Q #](xref:microsoft.quantum.guide.types).

Если вы заинтересованы в изучении основ и мотивации по Q #, ознакомьтесь с тем, [Зачем нам нужно q #?](https://devblogs.microsoft.com/qsharp/why-do-we-need-q/).
