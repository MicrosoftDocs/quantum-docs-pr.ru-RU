---
title: Создание квантового генератора случайных чисел
description: Создайте проект Q#, который демонстрирует фундаментальные квантовые понятия, например суперпозицию, на примере квантового генератора случайных чисел.
author: bromeg
ms.author: megbrow@microsoft.com
ms.date: 10/25/2019
ms.topic: article
uid: microsoft.quantum.quickstarts.qrng
ms.openlocfilehash: c3039b92c4b3235a397d5cf31280ac2673706e9d
ms.sourcegitcommit: 2ca4755d1a63431e3cb2d2918a10ad477ec2e368
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/03/2019
ms.locfileid: "73462839"
---
# <a name="quickstart-implement-a-quantum-random-number-generator-in-q"></a>Краткое руководство. Реализация квантового генератора случайных чисел на языке Q#
Простой пример квантового алгоритма на языке Q#, который моделирует генератор случайных чисел. Этот алгоритм использует природу квантовой механики для получения случайного числа. 

## <a name="prerequisites"></a>Предварительные требования

- [Microsoft Quantum Development Kit](xref:microsoft.quantum.install).
- [Создание проекта Q#](xref:microsoft.quantum.howto.createproject)


## <a name="write-a-q-operation"></a>Создание операции Q#

### <a name="q-operation-code"></a>Код операции Q#

1. Замените содержимое файла Operation.cs следующим кодом:

    ```qsharp
    namespace Quantum {
        open Microsoft.Quantum.Intrinsic;

        operation QuantumRandomNumberGenerator() : Result {
            using(q = Qubit())  { // Allocate a qubit.
                H(q);             // Put the qubit to superposition. It now has a 50% chance of being 0 or 1.
                let r = M(q);     // Measure the qubit value.
                Reset(q);
                return r;
            }
        }
    }
    ```

Как упоминалось в статье [Сведения о квантовых вычислениях](xref:microsoft.quantum.overview.what), кубит представляет собой единицу квантовой информации и может находиться в состоянии суперпозиции. При измерении он всегда возвращает значение 0 или 1. Но во время выполнения состояние кубита отражает вероятность получить значение 0 или 1 при измерении. Такое вероятностное состояние называется суперпозицией. Эту вероятность мы можем применить для создания случайных чисел.

Мы создадим операцию Q#, в которой используется тип данных `Qubit`,уникальный для языка Q#. `Qubit` можно выделить инструкцией `using`. Только что выделенный кубит всегда находится в состоянии `Zero`. 

С помощью операции `H` мы можем перевести `Qubit` в состояние суперпозиции. Чтобы измерить кубит, т. е. определить его значение, используется специальная операция `M`.

Каждый раз, когда мы переводим `Qubit` в состояние суперпозиции и измеряем его, мы получаем разные значения. 

При отмене выделения `Qubit` необходимо явным образом вернуть ему состояние `Zero`. В противном случае симулятор вернет ошибку при выполнении. Для этого проще всего вызвать `Reset`.

### <a name="visualizing-the-code-with-the-bloch-sphere"></a>Визуализация кода в формате сферы Блоха

В сфере Блоха северный полюс соответствует классическому значению **0**, а южный — классическому значению **1**. Любое состояние суперпозиции обозначается точкой на этой сфере (или стрелкой на схеме). Чем ближе конец этой стрелки к одному из полюсов, тем выше вероятность схлопывания этого кубита при измерении в то классическое состояние, которое соответствует этому полюсу. В примере ниже красная стрелка обозначает состояние с более высокой вероятностью получить значение **0** при измерении кубита.

<img src="./Bloch.svg" width="175">

Мы можем использовать это представление для визуализации работы нашего кода.

* Для начала мы инициализируем кубит в состоянии **0** и применим `H`, чтобы создать состояние суперпозиции с равной вероятностью получить значения **0** и **1**.

<img src="./H.svg" width="450">

* Затем мы измерим состояние кубита и сохраним выходное значение:

<img src="./Measurement2.svg" width="450">

Так как исход этого измерения является полностью случайным, можно считать, что мы получили случайный бит. Вызывая эту операцию несколько раз, мы получим большое целое число. Например, три вызова этой операции возвращают три случайных бита, позволяя создать трехбитовое число (т. е. случайное число в диапазоне от 0 до 7).
