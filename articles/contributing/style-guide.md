---
title: Вопросы и ответы по стилю | Документация Майкрософт
description: 'Инструкции в стиле Q #'
author: cgranade
ms.author: chgranad
ms.date: 10/12/2018
ms.topic: article
uid: microsoft.quantum.contributing.style
ms.openlocfilehash: 4050e2ee9e516aed7a8ba1398792562926808ee0
ms.sourcegitcommit: c93fea5980d1d46fbda1e7c7153831b9337134bf
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/04/2019
ms.locfileid: "73463325"
---
# <a name="q-style-guide"></a>Инструкции в стиле Q # #
## <a name="general-conventions"></a>Общие соглашения ##

Соглашения, предлагаемые в этом разделе, призваны помочь сделать программы и библиотеки, написанные в Q #, проще читать и понимать.

## <a name="guidance"></a>Руководство

Мы рекомендуем:

- Не следует игнорировать соглашение, если это не сделано намеренно, чтобы предоставить пользователям более понятный и понятный код.

## <a name="naming-conventions"></a>Соглашения об именовании ##

В составе пакета средств разработки тактов мы стремимся использовать имена функций и операций, которые помогают разработчикам создавать программы, которые просты в чтении, и сокращают их сюрприз.
Важной частью является то, что при выборе имен для функций, операций и типов мы создаем *словарь* , используемый программистами для выражения тактовых концепций. с нашими вариантами мы можем либо отнестись к их усилиям, чтобы четко взаимодействовать.
Это полагает ответственность за то, чтобы имена, которые мы предложит, были понятны, а не скрыты.
В этом разделе мы подробно расскажу о том, как мы удовлетворены этим обязательством с точки зрения явных руководств, которые помогут нам лучше всего сделать это в сообществе разработчиков Q #.

### <a name="operations-and-functions"></a>Операции и функции ###

Одно из первых действий, которое должно установить имя, — это то, представляет ли заданный символ функцию или операцию.
Разница между функциями и операциями крайне важна для понимания того, как работает блок кода.
Чтобы обеспечить различие между функциями и операциями для пользователей, мы будем полагаться на то, что в Q # моделируется выполнение тактовых операций с помощью побочных эффектов.
Это значит, что операция *делает* что-то.

Функции, напротив, описывают математические связи между данными.
Выражение *`Sin(PI() / 2.0)` `1.0`и не подразумевает* никакого состояния программы или ее Кубитс.

Формирование сводных данных, операции выполняются, когда функции являются объектами.
Это различие подразумевает, что операции именования являются глаголами и функциями в качестве существительных.

> [!NOTE]
> При объявлении определяемого пользователем типа Новая функция, которая конструирует экземпляры этого типа, неявно определяется в то же время.
> С этой точки зрения определяемые пользователем типы должны называться существительными, чтобы оба типа и функции конструктора имели одинаковые имена.

В разумных случаях убедитесь, что имена операций начинаются с глаголов, которые четко указывают на результат операции.
Пример.

- `MeasureInteger`
- `EstimateEnergy`
- `SampleInt`

Одним из случаев, которым заслуживает особое упоминание, является то, что операция принимает в качестве входных данных другую операцию и вызывает ее.
В таких случаях действие, выполняемое входной операцией, не ясно при определении внешней операции, что означает, что правая команда не будет немедленно очищена.
Рекомендуется использовать глагол `Apply`, как в `ApplyIf`, `ApplyToEach`и `ApplyToFirst`.
Другие глаголы также могут оказаться полезными в этом случае, как в `IterateThroughCartesianPower`.

| Команда | Ожидаемый результат |
| ---- | ------ |
| Применить | Операция, предоставленная в качестве входных данных, называется |
| Assert | Гипотеза о результате возможного измерения такта проверяется симулятором. |
| Оценка | Возвращается классический параметр, представляющий оценку, полученную от одного или нескольких измерений. |
| Measure | Выполняется измерение такта, и результат возвращается пользователю. |
| Подготовка. | Заданный регистр Кубитс инициализируется в определенном состоянии |
| Пример | Классическое значение возвращается случайным образом из некоторого распределения |

Для функций мы рекомендуем избегать использования глаголов в пользу общих существительных (см. Руководство по правильным существительным ниже) или прилагательные:

- `ConstantArray`
- `Head`
- `LookupFunction`

В частности, в большинстве случаев мы рекомендуем использовать последние партиЦиплес, где нужно указать, что имя функции строго соединено с действием или побочным эффектов в другом месте в тактовой программе.
Например, `ControlledOnInt` использует форму части причастий команды "Control", чтобы указать, что функция выступает в качестве прилагательной для изменения ее аргумента.
Это имя имеет дополнительное преимущество в соответствии с семантикой встроенного `Controlled` функтор, как описано ниже.
Аналогичным образом можно использовать _существительные агентов_ для создания имен функций и определяемых пользователем типов из имен операций, как в случае с именем `Encoder` для определяемого пользователем типа, который строго связан с `Encode`.

# <a name="guidancetabguidance"></a>[Руководство](#tab/guidance)

Мы рекомендуем:

- Используйте глаголы для имен операций.
- Для имен функций используйте существительные или прилагательные.
- Используйте существительные для определяемых пользователем типов и атрибутов.
- Для всех вызываемых имен используйте `CamelCase` строгими предпочтениями для `pascalCase`, `snake_case`или `ANGRY_CASE`. В частности, убедитесь, что вызываемые имена начинаются с прописных букв.
- Для всех локальных переменных используйте `pascalCase` строгими предпочтениями для `CamelCase`, `snake_case`или `ANGRY_CASE`. В частности, убедитесь, что локальные переменные начинаются с строчных букв.
- Старайтесь не использовать знаки подчеркивания `_` в именах функций и операций; Если требуются дополнительные уровни иерархии, используйте пространства имен и псевдонимы пространств имен.

# <a name="examplestabexamples"></a>[Примеры](#tab/examples)

|   | Name | Описание |
|---|------|-------------|
| ☑ | `operation ReflectAboutStart` | Снимите флажок использовать глагол ("отражать"), чтобы указать результат операции. |
| ☒ | <s>`operation XRotation`</s> | Использование фразы существительное предлагает функцию, а не операцию. |
| ☒ | <s>`operation search_oracle`</s> | Используйте `snake_case` контравенес Q # Notation. |
| ☒ | <s>`operation Search_Oracle`</s> | Используйте символы подчеркивания internal в качестве внутренних для имени операции контравенес Q # Notation. |
| ☑ | `function StatePreparationOracle` | Использование фразы с существительным предполагает, что функция возвращает операцию. |
| ☑ | `function EqualityFact` | Снимите флажок использовать существительное (факт), чтобы указать, что это функция, в то время как прилагательное. |
| ☒ | <s>`function GetRotationAngles`</s> | Использование глагола ("Get") предполагает, что это операция. |
| ☑ | `newtype GeneratorTerm` | Явное использование фразы с существительным означает результат вызова конструктора определяемого пользователем типа. |
| ☒ | <s>`@Attribute() newtype RunOnce()`</s> | Использование глагола-фразы предполагает, что конструктор определяемого пользователем типа является операцией. |
| ☑ | `@Attribute() newtype Deprecated(Reason : String)` | Использование фразы существительное сообщает об использовании атрибута. |

***

### <a name="shorthand-and-abbreviations"></a>Сокращенные и сокращенные обозначения ###

Приведенный выше Совет не отменяется, существует множество форм сокращений, которые являются распространенным и распространенным использованием в тактовых вычислениях.
Мы рекомендуем использовать существующую и распространенную краткую форму, в которой он существует, особенно для операций, которые являются встроенными для работы целевого компьютера.
Например, можно выбрать имя `X` вместо `ApplyX`и `Rz` вместо `RotateAboutZ`.
При использовании такой сокращенной формы имена операций должны быть все прописными (например: `MAJ`).

При применении этого соглашения необходимо соблюдать осторожность в случае часто используемых акронимов и сокращений, например "Кфт" для "преобразования тактов в тактовой области".
Мы рекомендуем использовать следующие общие соглашения .NET для использования акронимов и сокращений в полных именах, которые предписывает:

- двузначные акронимы и сокращений именуются в верхнем регистре (например, `BE` для Big-endian).
- все более длинные акронимы и сокращенийы именуются в `CamelCase` (например, `Qft` для "преобразования в тактовую Фурье").

Таким образом, операция, реализующая Кфт, может либо `QFT` вызываться в качестве краткой, либо записываться как `ApplyQft`.

Для наиболее часто используемых операций и функций может быть желательно предоставить сокращенное имя в качестве _псевдонима_ для более длинной формы:

```qsharp
operation CCNOT(control0 : Qubit, control1 : Qubit, target : Qubit)
is Adj + Ctl {
    Controlled X([control0, control1], target);
}
```

# <a name="guidancetabguidance"></a>[Руководство](#tab/guidance)

Мы рекомендуем:

- При необходимости рекомендуется использовать распространенные и распространенные сокращенные имена.
- Для сокращения используйте прописные буквы.
- Используйте прописные буквы для коротких (двух букв) аббревиатур и сокращений.
- Используйте `CamelCase` для более длинных акронимов (три и более букв) и сокращений.

# <a name="examplestabexamples"></a>[Примеры](#tab/examples)

|   | Name | Описание |
|---|------|-------------|
| ☑ | `X` | Хорошо понятная Краткая форма "применение преобразования $X $" |
| ☑ | `CNOT` | Хорошо понятная Краткая форма для «контролируемых» |
| ☒ | <s>`Cnot`</s> | Краткая форма не должна находиться в `CamelCase`. |
| ☑ | `ApplyQft` | Общий начальный вид "Кфт" отображается как часть имени длинной формы. |
| ☑ | `QFT` | Общий начальный вид "Кфт" отображается как часть сокращенного имени. |



***


### <a name="proper-nouns-in-names"></a>Собственные существительные в именах ###

Хотя в физике мы часто называете вещи, когда первый пользователь публикует их, большинство фисиЦистс не знакомы с именами всех участников и журналами.
Чрезмерная постановка в соглашениях об именовании от физикы может привести к значительному барьеру в записи, так как пользователи из других фоновых рисунков должны изучить большое количество непрозрачных имен, чтобы использовать общие операции и концепции.
<!-- An important part of the task of reducing confusion is to make code more accessible.
Especially in a field such as quantum computing that is rich with domain expertise, we must at all times be cognizant of the demands we place on that expertise as we design quantum software.
In naming code symbols, one way that this cognizance expresses itself is as an awareness of the convention from physics of adopting as the names of algorithms and operations the names of their original publishers.
While we must maintain the history and intellectual provenance of concepts in quantum computing, demanding that all users be versed in this history to use even the most basic of functions and operations places a barrier to entry that is in most cases severe enough to even present an ethical compromise. -->
Таким образом, рекомендуется, чтобы при разумных принципах обычные существительные, описывающие концепцию, были приняты строгими для правильного существительных, описывающих историю публикации концепции.
В качестве конкретного примера, контролируемые с помощью управляемой операции переключения и удвоения часто называются операциями "Фредкин" и "Тоффоли" в учебных литературах, но они определяются в Q # в основном как `CSWAP` и `CCNOT`.
В обоих случаях комментарии к документации по API предоставляют имена синонимов на основе правильных существительных, а также все соответствующие ссылки.

Этот приоритет особенно важен в тех случаях, когда необходимо всегда использовать собственные существительные — Q # соответствует традиции, заданному многими классическими языками, и относится к `Bool`ным типам в ссылке на логическую логику, которая в свою очередь имеет имя. от Георгия.
Некоторые тактовые концепции аналогичны именам, включая тип `Pauli`, встроенный в язык Q #.
Свести к минимуму использование правильных существительных, если такое использование не является обязательным, мы уменьшаем влияние того, что их не удается избежать.

# <a name="guidancetabguidance"></a>[Руководство](#tab/guidance) 

Мы рекомендуем:

- Избегайте использования в именах правильных существительных.

# <a name="examplestabexamples"></a>[Примеры](#tab/examples)

***

### <a name="type-conversions"></a>Преобразования типов ###

Поскольку Q # является строго и статически типизированным языком, значение одного типа может использоваться только как значение другого типа с помощью явного вызова функции преобразования типа.
Это отличается от языков, позволяющих неявным образом изменять типы значений (например, повышение типа) или путем приведения.
В результате функции преобразования типов играют важную роль в вопросах разработки библиотеки Q # и составляют одно из наиболее часто встречающихся решений по именованию.
Однако обратите внимание, что поскольку преобразования типов всегда _детерминированы_, они могут быть написаны как функции и, таким образом, находиться на приведенный выше Совет.
В частности, мы советуем, что функции преобразования типов никогда не должны называться как глаголы (например, `ConvertToX`) или модификаторовные фразы (`ToX`), но должны называться как прилагательные фразы, которые указывают типы источника и назначения (`XAsY`).
При перечислении типов массивов в именах функций преобразования типов рекомендуется использовать краткую `Arr`.
При запрете исключительных обстоятельств рекомендуется, чтобы все функции преобразования типов были именованы с помощью `As`, чтобы их можно было быстро определить.

# <a name="guidancetabguidance"></a>[Руководство](#tab/guidance)

Мы рекомендуем:

- Если функция преобразует значение типа `X` в значение типа `Y`, используйте либо имя `AsY`, либо `XAsY`.

# <a name="examplestabexamples"></a>[Примеры](#tab/examples)

|   | Name | Описание |
|---|------|-------------|
| ☒ | <s>`ToDouble`</s> | В качестве отстановки "до" задается Командная фраза, указывающая на операцию, а не на функцию. |
| ☒ | <s>`AsDouble`</s> | Тип входных данных не является понятным по имени функции. |
| ☒ | <s>`PauliArrFromBoolArr`</s> | Входные и выходные типы отображаются в неправильном порядке. |
| ☑ | `ResultArrAsBoolArr` | Типы входных и выходных данных являются четкими. |

***

### <a name="private-or-internal-names"></a>Частные или внутренние имена ###

Во многих случаях имя предназначено исключительно для внутреннего использования в библиотеке или проекте и не является гарантированной частью API, предоставляемой библиотекой.
Полезно четко указать, что это происходит при именовании функций и операций, так что случайные зависимости от внутреннего кода становятся очевидными.
Если операция или функция не предназначена для непосредственного использования, а должна использоваться соответствующим вызываемым методом, который действует частичным приложением, рекомендуется использовать имя, начинающееся с `_`, для частично примененного вызываемого метода.

# <a name="guidancetabguidance"></a>[Руководство](#tab/guidance)

Мы рекомендуем:

- Если функция, операция или определяемый пользователем тип не являются частью общедоступного API для библиотеки или программы Q #, убедитесь, что ее имя начинается с подчеркивания в начале (`_`).

# <a name="examplestabexamples"></a>[Примеры](#tab/examples)

|   | Name | Описание |
|---|------|-------------|
| ☒ | <s>`ApplyDecomposedOperation_`</s> | Символ подчеркивания `_` не должен располагаться в конце имени. |
| ☑ | `_ApplyDecomposedOperation` | Символ подчеркивания `_` в начале ясно указывает, что эта операция предназначена только для внутреннего использования. |

***

### <a name="variants"></a>Случаях ###

Хотя это ограничение может не сохраняться в будущих версиях Q #, в настоящее время существует ситуация, когда часто встречаются группы связанных операций или функций, которые различаются операторов их входными данными, или конкретными типами их аргументов.
Эти группы можно отличать с помощью одного и того же корневого имени, за которым следует одна или две буквы, указывающие на вариант.

| Суффикс | Значение |
|--------|---------|
| `A` | Ожидается ввод для поддержки `Adjoint` |
| `C` | Ожидается ввод для поддержки `Controlled` |
| `CA` | Ожидается ввод для поддержки `Controlled` и `Adjoint` |
| `I` | Входные или входные данные имеют тип `Int` |
| `D` | Входные или входные данные имеют тип `Double` |
| `L` | Входные или входные данные имеют тип `BigInt` |

# <a name="guidancetabguidance"></a>[Руководство](#tab/guidance)

Мы рекомендуем:

- Если функция или операция не связаны с аналогичными функциями или операциями по типам и функтор поддерживают свои входные данные, не используйте суффикс.
- Если функция или операция связана с любыми аналогичными функциями или операциями типов и функтор поддержки своих входных данных, используйте суффиксы, как показано в таблице выше, чтобы различать варианты.

# <a name="examplestabexamples"></a>[Примеры](#tab/examples)

***

### <a name="arguments-and-variables"></a>Аргументы и переменные ###

Ключевой целью кода Q # для функции или операции является простое чтение и понимание.
Аналогичным образом, имена входов и аргументов типа должны сообщать, как функция или аргумент будут использоваться по мере того, как они предоставлены.


# <a name="guidancetabguidance"></a>[Руководство](#tab/guidance)

Мы рекомендуем:

- Для всех переменных и входных имен используйте `pascalCase` строгими предпочтениями для `CamelCase`, `snake_case`или `ANGRY_CASE`.
- Входные имена должны быть описательными; по возможности избегайте по одному или двум именам букв.
- Операции и функции, принимающие ровно один аргумент типа, должны отметить этот аргумент типа `T`, если его роль очевидна.
- Если функция или операция принимает несколько аргументов типа или если роль одного аргумента типа не очевидна, рассмотрите возможность использования короткого слова в заглавной букве, которое предшествует `T` (например, `TOutput`) для каждого типа.
- Не включайте имена типов в имена аргументов и переменных. Эти сведения могут и должны предоставляться средой разработки.
- Запишите скалярные типы по их литеральным именам (`flagQubit`) и типам массивов во множественном числе (`measResults`).
  Для массивов Кубитс в частности, рассмотрите такие типы, `Register`, где имя относится к последовательности Кубитс, которые тесно связаны друг с другим способом.
- Переменные, используемые в качестве индексов в массивах, должны начинаться с `idx` и быть единственным (например: `things[idxThing]`).
  В частности, настоятельно рекомендуется избегать использования однобуквенных имен переменных в качестве индексов; Рассмотрите возможность использования `idx` как минимум.
- Переменные, используемые для хранения длин массивов, должны начинаться с `n` и должны быть множественными (например: `nThings`).

# <a name="examplestabexamples"></a>[Примеры](#tab/examples)

***

### <a name="user-defined-type-named-items"></a>Определяемый пользователем тип с именем Items ###

Именованные элементы в определяемых пользователем типах должны называться как `CamelCase`, даже при вводе в конструкторы определяемого пользователем типа.
Это помогает в явном отделении именованных элементов от ссылок на переменные в локальной области при использовании нотации метода доступа (например, `callable::Apply`) или нотации копирования и обновления (`set arr w/= Data <- newData`).

# <a name="guidancetabguidance"></a>[Руководство](#tab/guidance)

Мы рекомендуем:

- Именованные элементы в конструкторах определяемых пользователем типов должны называться как `CamelCase`; то есть они должны начинаться с начального верхнего регистра.
- Именованные элементы, которые разрешаются в операции, должны называться этапами глагола.
- Именованные элементы, которые не разрешаются в операции, должны называться как субстантивные словосочетания.
- Для определяемых пользователем типов, которые обносят операции, необходимо определить один именованный элемент с именем `Apply`.

# <a name="examplestabexamples"></a>[Примеры](#tab/examples)

|   | Пример | Описание |
|---|---------|-------------|
| ☑ | `newtype Oracle = (Apply : Qubit[] => Unit is Adj + Ctl)` | Имя `Apply` — это `CamelCase`ая глаголовая фраза, предлагающая, что именованный элемент является операцией. |
| ☒ | <s>`newtype Oracle = (apply : Qubit[] => Unit is Adj + Ctl) `</s> | Именованные элементы должны начинаться с первой прописной буквы. |
| ☒ | <s>`newtype Collection = (Length : Int, Get : Int -> (Qubit => Unit)) `</s> | Именованные элементы, которые разрешаются в функции, должны называться как субстантивные словосочетания, а не как фразы глагола. |

***

## <a name="input-conventions"></a>Соглашения о входе ##

Когда разработчик обращается к операции или функции, различные входные данные этой операции или функции должны быть указаны в определенном порядке, увеличивая при этом функциональную нагрузку, которую разработчик может использовать для создания библиотеки.
В частности, задача по запоминанию порядка входных данных часто является отправной задачей: программированием реализации алгоритма такта.
Хотя широкая поддержка интегрированной среды разработки может снизить это до большого экстента, хорошая разработка и соблюдение общих соглашений также может помочь минимизировать неудачную загрузку, наложенную API.

Там, где это возможно, может быть полезно уменьшить количество входных данных, ожидаемых операцией или функцией, чтобы роль каждого входа была более очевидна для разработчиков, обращающихся к этой операции или функции, а также для разработчиков, считывающих этот код позже.
Особенно если невозможно или разумно уменьшить число аргументов для операции или функции, важно иметь единообразный порядок, позволяющий свести к сведению, что пользователь сталкивается с прогнозированием порядка входных данных.

Мы рекомендуем использовать соглашения о порядке ввода, которые во многом наследуют от мышления частичного приложения как обобщение карринг f (x, y) ≡ f (x) (y).
Таким образом, частичное применение первых аргументов должно привести к вызову, который будет полезен при любом разумном использовании.
Следуя этому принципу, рассмотрите возможность использования следующего порядка аргументов:

- Классические не вызываемые аргументы, такие как углы, векторы степеней и т. д.
- Вызываемые аргументы (функции и аргументы).
  Если обе функции и операции выполняются в качестве аргументов, попробуйте разместить операции после функций.
- Коллекции, обрабатываемые с помощью вызываемых аргументов аналогичным образом для `Map`, `Iter`, `Enumerate`и `Fold`.
- Аргументы кубит, используемые в качестве элементов управления.
- Аргументы кубит, используемые в качестве целевых объектов.

Рассмотрим операцию `ApplyPhaseEstimationIteration` для использования в оценке этапа, которая принимает угол и Oracle, передает угол `Rz`, измененный массивом различных факторов масштабирования, а затем управляет приложениями Oracle.
Мы упорядочиваем входные данные для `ApplyPhaseEstimationIteration` следующим образом:

```qsharp
operation ApplyPhaseEstimationIteration(
    angle : Double,
    callable : (Qubit => () is Ctl),
    scaleFactors : Double[],
    controlQubit : Qubit,
    targetQubits : Qubit[]
)
: Unit
...
```
В качестве особого варианта минимизации неожиданности некоторые функции и операции имитируют поведение встроенных `Adjoint` операторов и `Controlled`.
Например, `ControlledOnInt<'T>` имеет тип `(Int, ('T => Unit is Adj + Ctl)) => ((Qubit[], 'T) => Unit is Adj + Ctl)`, так что `ControlledOnInt<Qubit[]>(5, _)` действует как `Controlled` функтор, но в случае, когда регистр элемента управления представляет состояние $ \кет{5} = \кет{101}$.
Таким образом, разработчику требуется, чтобы входные данные `ControlledOnInt` поместились в последний раз вызываемый объект, а полученная операция принимает в качестве входных `(Qubit[], 'T)`---том же порядке, в котором следуют выходные данные `Controlled` функтор.

# <a name="guidancetabguidance"></a>[Руководство](#tab/guidance)

Мы рекомендуем:

- Используйте порядок ввода в соответствии с использованием частичного приложения.
- Используйте порядок ввода в соответствии со встроенными операторов.
- Разместите все классические входные данные перед любыми входными тактовыми тактами.

# <a name="examplestabexamples"></a>[Примеры](#tab/examples)

***

## <a name="documentation-conventions"></a>Соглашения о документации ##

Язык Q # позволяет прикреплять документацию к операциям, функциям и определяемым пользователем типам с помощью специально отформатированных комментариев к документации.
Эти комментарии к документации, обозначенные тройными косыми чертами (`///`), представляют собой небольшие [Markdown](https://dotnet.github.io/docfx/spec/docfx_flavored_markdown.html) документы, которые можно использовать для описания назначения каждой операции, функции и определяемого пользователем типа, возвращаемых входов и т. д.
Компилятор, поставляемый с пакетом разработки тактов, извлекает эти комментарии и использует их для помощи в документации по типам, похожим на https://docs.microsoft.com/quantum.
Аналогичным образом, языковой сервер, поставляемый с пакетом разработки тактовой передачи, использует эти комментарии для предоставления помощи пользователям при наведении указателя мыши на символы в коде Q #.
Использование комментариев к документации может помочь пользователям лучше понять код, предоставляя полезную ссылку для получения подробных сведений, которые не просто выражаются с помощью других соглашений в этом документе.

<div class="nextstepaction">
    [Справочник по синтаксису комментариев документации](xref:microsoft.quantum.language.statements#documentation-comments)
</div>

Чтобы эффективно использовать эту функцию для пользователей, рекомендуется учитывать некоторые моменты при написании комментариев к документации.

# <a name="guidancetabguidance"></a>[Руководство](#tab/guidance)

Мы рекомендуем:

- Каждая открытая функция, операция и определяемый пользователем тип должны непосредственно предшествовать комментарию документации.
- Каждый комментарий к документации должен содержать как минимум следующие разделы:
    - Резюме
    - Входные данные
    - Выходные данные (если применимо)
- Убедитесь, что все сводки имеют два предложения или меньше. Если требуется больше места, предоставьте `# Description` раздел сразу после `# Summary` с подробными сведениями.
- В разумных случаях не включайте математические вычисления в сводки, так как не все клиенты поддерживают да нотацию в сводках. Обратите внимание, что при написании документов prose (например, да или Markdown) может быть предпочтительнее использовать более длинные строки.
- Укажите все соответствующие математические выражения в разделе `# Description`.
- При описании входных данных не следует повторять типы всех входных данных, так как они могут выводиться компилятором и угрожать несогласованность.
- Укажите нужные примеры, каждый в отдельном разделе `# Example`.
- Кратко опишите каждый пример перед выводом кода.
- Посвящены всем соответствующим академическим публикациям (например, документы, материалы, записи в блоге и альтернативные реализации) в разделе `# References` в виде маркированного списка ссылок.
- Убедитесь, что, где это возможно, все ссылки ссылок относятся к постоянным и неизменяемым идентификаторам (Доис или номера Арксив версий).
- Если операция или функция связана с другими операциями или функциями с помощью функтор Variant, перечислите другие варианты в виде маркеров в разделе `# See Also`.
- Оставьте пустую строку комментария между разделами уровня 1 (`/// #`), но не оставляйте пустую строку между разделами уровня 2 (`/// ##`).

# <a name="examplestabexamples"></a>[Примеры](#tab/examples)

#### <a name=""></a>☑ ####

```
/// # Summary
/// Applies a rotation about the X-axis by a given angle.
///
///
/// # Description
/// This operation rotates a single qubit by the unitary operation
/// \begin{align}
///     R_x(\theta) \mathrel{:=} e^{-i \theta \sigma_x / 2}.
/// \end{align}
///
/// # Input
/// ## theta
/// Angle about which the qubit is to be rotated.
/// ## qubit
/// Qubit to which the gate should be applied.
///
/// # Remarks
/// Equivalent to:
/// ```qsharp
/// R(PauliX, theta, qubit);
/// ```
///
/// # See Also
/// - Ry
/// - Rz
operation Rx(theta : Double, qubit : Qubit) : Unit
is Adj + Ctl {
    body (...) { R(PauliX, theta, qubit); }
    adjoint (...) { R(PauliX, -theta, qubit); }
}
```

***

## <a name="formatting-conventions"></a>Соглашения о форматировании ##

Помимо описанных выше предложений, рекомендуется сделать код максимально удобочитаемым, чтобы использовать единообразные правила форматирования.
Такие правила форматирования по сути, как правило, являются несколько произвольными и хорошо эстетичность.
Тем не менее рекомендуется поддерживать единообразный набор соглашений о форматировании в группе участников совместной работы, особенно для больших проектов Q #, таких как сам пакет разработки такта.
Эти правила могут быть автоматически применены с помощью средства форматирования, интегрированного с компилятором Q #.

# <a name="guidancetabguidance"></a>[Руководство](#tab/guidance) 

Мы рекомендуем:

- Для переносимости используйте четыре пробела вместо вкладок.
  Например, в VS Code:
  ```json
    "editor.insertSpaces": true,
    "editor.tabSize": 4
  ```
- Строка переносится в 79 символов, где это оправданно.
- Используйте пробелы вокруг бинарных операторов.
- Используйте пробелы с обеих сторон двоеточий, используемых для заметок типов.
- Используйте один пробел после запятых, используемых в массивах и литералах кортежа (например, в входных данных для функций и операций).
- Не используйте пробелы после имени функции, операции или определяемого пользователем типа или после `@` в объявлениях атрибутов.
- Каждое объявление атрибута должно располагаться в отдельной строке.

# <a name="examplestabexamples"></a>[Примеры](#tab/examples)

|   | Пример | Описание |
|---|---------|-------------|
| ☒ | <s>`2+3`</s> | Используйте пробелы вокруг бинарных операторов. |
| ☒ | <s>`target:Qubit`</s> | Используйте пробелы вокруг заметок типа двоеточия. |
| ☑ | `Example(a, b, c)` | Элементы во входном кортеже имеют правильный размер для удобочитаемости. |
| ☒ | <s>`Example (a, b, c)`</s> | Пробелы следует подавлять после имени функции, операции или определяемого пользователем типа. |

***

