---
title: 'Принципы проектирования API Q #'
description: 'Принципы проектирования API Q #'
author: cgranade
ms.author: chgranad
ms.date: 3/9/2020
ms.topic: article
uid: microsoft.quantum.contributing.api-design
ms.openlocfilehash: 03c32331f8988181ec6fedcfc207d752b4a880b2
ms.sourcegitcommit: d61b388651351e5abd4bfe7a672e88b84a6697f8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/10/2020
ms.locfileid: "79024208"
---
# <a name="q-api-design-principles"></a>Принципы проектирования API Q #

## <a name="introduction"></a>Введение

Как язык, так и как платформа, Q # позволяет пользователям писать, запускать, анализировать и изучать приложения-такты.
Чтобы расширить возможности пользователей, при проектировании библиотек Q # Мы будем следовать набору принципов проектирования API для разработки и помощи в создании пригодных к использованию библиотек для сообщества разработчиков тактов.
В этой статье описываются эти принципы и приводятся примеры, которые помогут вам применить их при проектировании API Q #.

> [!TIP]
> Это довольно подробный документ, который предназначен для помощи в разработке библиотек и подробной публикации библиотек.
> Скорее всего, вы найдете его наиболее полезное, если вы пишете собственные библиотеки в Q # или используете большие функции в [репозитории библиотек q #](https://github.com/microsoft/QuantumLibraries).
>
> С другой стороны, если вы хотите узнать больше о том, как приступать к работе с пакетом разработки тактов, мы рекомендуем начать с [руководства по публикации](xref:microsoft.quantum.contributing).
> Если вы ищете более общие сведения о том, как мы рекомендуем форматировать код Q #, возможно, вас интересует [руководство по стилю](xref:microsoft.quantum.contributing.style).

## <a name="general-principles"></a>Общие принципы

**Основной принцип:** Предоставление API-интерфейсов, которые помещают фокус на приложения-такты.

- ✅ **выбрать** операции и имена функций, отражающие высокоуровневую структуру алгоритмов и приложений.
- ⛔️ **не** предоставляют интерфейсы API, которые в первую очередь касаются низкоуровневых сведений о реализации.

**Основной принцип:** Запустите каждую конструкцию API с примерами вариантов использования, чтобы обеспечить интуитивное использование API.

- ✅ **убедиться в том,** что каждый компонент общедоступного API имеет соответствующий вариант использования, вместо того чтобы пытаться проектировать все возможные использования с самого начала.
    Иначе говоря, не следует создавать общедоступные API на случай, если они полезны, но убедитесь, что каждая часть API имеет *конкретный* пример, в котором он будет полезен.

  *Примеры:*
  - @"microsoft.quantum.canon.applytoeachca" можно использовать в качестве `ApplyToEachCA(H, _)` для подготовки регистров в едином состоянии геопозиционирования, общей задачи во многих алгоритмах такта. Эту же операцию можно также использовать для многих других задач в подготовке, цифровых и алгоритмах на основе Oracle.

- ✅ **проводить** мозговые штурмы и создавать новые модели API, чтобы убедиться в том, что они интуитивно понятны и соответствуют предложенным вариантам использования.

  *Примеры:*
  - Просмотрите текущий код Q\#, чтобы увидеть, как новые разработки API могут упростить и прояснить существующие реализации.
  - Изучите предлагаемые макеты API с представителями основных аудиторий.

**Основной принцип:** Разработка API-интерфейсов для поддержки и обеспечения читаемости кода.

- ✅ **убедиться, что код** доступен для чтения экспертами по доменам и другим специалистам.
- ✅ **DO** помещайте внимание на влияние каждой операции и функций в рамках алгоритма высокого уровня, используя документацию для подробного изучения реализации.
- При **необходимости ✅ следовать** общему [руководству по стилю\# Q](xref:microsoft.quantum.contributing.style) .

**Основной принцип:** Разработка API-интерфейсов для стабильной и обеспечения прямой совместимости.

- ✅ **сделать** устаревшие API нерекомендуемыми надлежащим образом, если требуются критические изменения.

- ✅ **предоставляют** операции и функции "оболочки совместимости", которые позволяют корректно работать с существующим кодом пользователя во время устаревания.

  *Примеры:*
  - При переименовании операции, именуемой `EstimateExpectation`, в `EstimateAverage`ввести новую операцию с именем `EstimateExpectation`, которая вызывает исходную операцию с новым именем, чтобы существующий код мог продолжать работать правильно.

- ✅ **использовать** атрибут @"microsoft.quantum.core.deprecated" для передачи устаревших информации пользователю.

- ✅ при переименовании операции или **функции введите новое** имя в качестве входного строки для `@Deprecated`.

- ⛔️ **не** удаляйте существующие функции или операции без срока действия не менее 6 месяцев для предварительных выпусков или по крайней мере два года для поддерживаемых выпусков.

## <a name="functions-and-operations"></a>Функции и операции

**Основной принцип.** убедитесь, что каждая функция и операция имеет одну четко определенную цель в API.

- ⛔️ **не** предоставляют функции и операции, выполняющие несколько несвязанных задач.

**Основной принцип:** функции проектирования и операции должны быть максимально пригодными для повторного использования, а также для ожидаемых будущих потребностей.

- ✅ **DO** разрабатывать функции и операции, которые хорошо составлять с другими функциями и операциями в одном API и в ранее существующих библиотеках.

  *Примеры:*
  - Операция @"microsoft.quantum.canon.delay" выполняет минимальные предположения о входных данных и, таким образом, может использоваться для задержки приложений обеих операций в стандартной библиотеке Q # или в соответствии с определением пользователей.
    <!-- TODO: define bad example. -->

- ✅ предоставлять чисто детерминированную классический классическую логику как функции, **а не операции** .

  *Примеры:*
  - Подпрограммы, которые возвращающие входные данные с плавающей запятой, могут быть написаны детерминированно, поэтому они должны предоставляться пользователю как `Squared : Double -> Double`, а не как операция `Square : Double => Double`. Это позволяет вызывать подпрограммы в большем числе (например, в других функциях) и предоставляет компилятору полезные сведения о оптимизации, которые могут повлиять на производительность и оптимизацию.
  - `ForEach<'TInput, 'TOutput>('TInput => 'TOutput, 'TInput[]) => 'TOutput[]` и `Mapped<'TInput, 'TOutput>('TInput -> 'TOutput, 'TInput[]) -> 'TOutput[]` отличаются в гарантии относительно детерминированности. Оба варианта полезны в различных обстоятельствах.
  - Подпрограммы API, которые преобразуют приложение операций с тактовой частотой, часто выполняются в детерминированном виде, поэтому их можно сделать доступными в виде таких функций, как `CControlled<'T>(op : 'T => Unit) => ((Bool, 'T) => Unit)`.

- ✅ **выполнить** обобщение типа входных данных настолько, насколько целесообразно для каждой функции и операции, используя параметры типа по мере необходимости.

  *Примеры:*
  - `ApplyToEach` имеет тип `<'T>(('T => Unit), 'T[]) => Unit`, а не конкретный тип наиболее распространенного приложения `((Qubit => Unit), Qubit[]) => Unit`.

> [!TIP]
> Важно предусмотреть будущие потребности, но также важно решить конкретные проблемы для пользователей.
> В силу этого принципа работы с ключевыми словами всегда требует тщательного рассмотрения и балансировки, чтобы не разрабатывать интерфейсы API «только на тот случай».

**Основной принцип:** Выбор входных и выходных типов для функций и операций, которые являются прогнозируемыми и взаимодействуют с целью вызова.

- ✅ **использовать** типы кортежей для логической группировки входных и выходных данных, которые учитываются только вместе. В таких случаях рассмотрите возможность использования определяемого пользователем типа.

  *Примеры:*
  - Функции для вывода локального прыжка другой функции может потребоваться использовать границы интервала поиска в качестве входных данных, что `LocalMinima(fn : (Double -> Double), (left : Double, right : Double)) : Double` может быть соответствующей сигнатурой.
  - Операция для оценки производного классификатора машинного обучения с использованием метода сдвига параметров может потребовать смещения векторов параметров с сдвигом и без сдвига в качестве входных данных. В этом случае может быть уместным вводом, похожим на `(unshifted : Double[], shifted : Double[])`.

- ✅ **порядок** элементов в входных и выходных кортежах согласованно между различными функциями и операциями.

  *Примеры:*
  - При рассмотрении двух функций или операций, каждый из которых принимает угол поворота и целевой кубит в качестве входных данных, убедитесь, что они упорядочены одинаково в каждом входном кортеже. То есть предпочитаете `ApplyRotation(angle : Double, target : Qubit) : Unit is Adj + Ctl` и `DelayedRotation(angle : Double, target : Qubit) : (Unit => Unit is Adj + Ctl)` `ApplyRotation(target : Qubit, angle : Double) : Unit is Adj + Ctl` и `DelayedRotation(angle : Double, target : Qubit) : (Unit => Unit is Adj + Ctl)`.

**Основной принцип:** функции и операции проектирования, которые хорошо работают с функциями Q\# языка, такими как частичное применение.

- ✅ порядок элементов во входных кортежах таким образом **, чтобы наиболее** часто применяемые входные данные выполнялись первыми (т. е. так что частичное приложение работает аналогично карринг).

  *Примеры:*
  - Операция `ApplyRotation`, которая принимает число с плавающей запятой и кубит, часто может быть частично применена с входными данными с плавающей запятой для использования с операциями, ожидающими вход типа `Qubit => Unit`. Таким словами, сигнатура `operation ApplyRotation(angle : Double, target : Qubit) : Unit is Adj + Ctl`
      будет работать наиболее согласованно с частичным приложением.
  - Как правило, это руководство означает размещение всех классических данных до всех Кубитс во входных кортежах, но используйте хорошее соблюдаство и изучите способ вызова API на практике.

## <a name="user-defined-types"></a>Определяемые пользователем типы

**Основной принцип.** используйте определяемые пользователем типы, чтобы сделать интерфейсы API более выразительными и удобными для использования.

- ✅ **DO** представить новые определяемые пользователем типы, чтобы предоставить полезную краткую форму для длинных и/или сложных типов.

  *Примеры:*
  - В случаях, когда тип операции с тремя входными данными массива кубит обычно принимается в качестве входных данных или возвращается в виде выходных данных, предоставляя определяемые пользователем типы, например `newtype TimeDependentBlockEncoding = ((Qubit[], Qubit[], Qubit[]) => Unit is Adj + Ctl)`
      может помочь в обеспечении удобной краткости.

- ✅ **ввести** новые определяемые пользователем типы, чтобы указать, что данный базовый тип следует использовать только в определенном смысле.

  *Примеры:*
  - Операция, которая должна интерпретироваться в виде операции, которая кодирует классические данные в реестр такта, может быть пригодна для меток с определяемым пользователем типом `newtype InputEncoder = (Apply : (Qubit[] => Unit))`.

- ✅ **DO** представить новые определяемые пользователем типы с именованными элементами, которые допускают дальнейшую расширяемость (например, структуру результатов, которая может содержать дополнительные именованные элементы в будущем).

  *Примеры:*
  - Если операция `TrainModel` предоставляет большое количество параметров конфигурации, предоставляя эти варианты в качестве нового `TrainingOptions` UDT и выполняя новую функцию `DefaultTrainingOptions : Unit -> TrainingOptions` позволяет пользователям переопределять определенные именованные элементы в Траинингоптионс UDT, одновременно позволяя разработчикам библиотек добавлять новые элементы определяемого пользователем типа.

- ✅ **объявлять** именованные элементы для новых определяемых пользователем типов в предпочтениях, чтобы требовать от пользователей знание правильного деконструкции кортежа.

  *Примеры:*
  - Если представляет комплексное число в его полярной декомпозиции, предпочитать `newtype ComplexPolar = (Magnitude: Double, Argument: Double)` `newtype ComplexPolar = (Double, Double)`.

**Основной принцип.** используйте определяемые пользователем типы данных, чтобы сократить изученную нагрузку и не требовать от пользователя изучать дополнительные понятия и номенклатуру.

- ⛔️ **не** представить определяемые пользователем типы, требующие частого использования оператора распаковки (`!`) или, для которого обычно требуется несколько уровней растекания. Возможные стратегии по устранению рисков:

  - При предоставлении определяемого пользователем типа с одним элементом рассмотрите возможность определения имени этого элемента. Например, рассмотрите возможность `newtype Encoder = (Apply : (Qubit[] => Unit is Adj + Ctl))` предпочтение `newtype Encoder = (Qubit[] => Unit is Adj + Ctl)`.

  - Обеспечение того, что другие функции и операции могут принимать "инкапсулированные" экземпляры UDT напрямую.

- ⛔️ **не** добавлять новые определяемые пользователем типы, которые дублируют встроенные типы, не предоставляя дополнительных выразительностей.

  *Примеры:*
  - Определяемый пользователем тип `newtype QubitRegister = Qubit[]` не обеспечивает никакого дополнительного выразительности по сравнению с `Qubit[]`, поэтому он труднее использовать без чрезмерно допустимого преимущества.
  - Определяемый пользователем тип `newtype LittleEndian = Qubit[]` документирует, как будет использоваться и интерпретироваться базовый регистр, что обеспечивает дополнительную выразительность по отношению к базовому типу.

- ⛔️ **не** следует добавлять функции доступа, если не требуется строгое требование;   в этом случае настоятельно рекомендуется использовать именованные элементы.

  *Примеры:*
  - При внедрении определяемого пользователем типа `newtype Complex = (Double, Double)`предпочтение изменению определения на `newtype Complex = (Real : Double, Imag : Double)` для введения функций `GetReal : Complex -> Double` и `GetImag : Complex -> Double`.

## <a name="namespaces-and-organization"></a>Пространства имен и Организация

**Основной принцип:** выберите имена пространств имен, которые являются прогнозируемыми и четко сообщают назначение функций, операций и определяемых пользователем типов в каждом пространстве имен.

- ✅ **имена пространств имен `Publisher.Product.DomainArea`** .

  *Примеры:*
  - Функции, операции и определяемые пользователем типы, опубликованные корпорацией Майкрософт в качестве части функции моделирования такта в пакете разработки тактов, помещаются в пространство имен `Microsoft.Quantum.Simulation`.
  - `Microsoft.Quantum.Math` представляет пространство имен, опубликованное корпорацией Майкрософт в составе пакета средств разработки такта, относящегося к доменной области математики.

- ✅ **DO** помещайте операции, функции и определяемые пользователем типы, используемые для определенных функций, в пространство имен, описывающее эти функциональные возможности, даже если эти функции используются в разных доменах проблем.

  *Примеры:*
  - API-интерфейсы подготовки состояния, опубликованные корпорацией Майкрософт в составе пакета средств разработки тактов, помещаются в `Microsoft.Quantum.Preparation`.
  - API-интерфейсы моделирования тактов, опубликованные корпорацией Майкрософт как часть пакета средств разработки тактов, помещаются в `Microsoft.Quantum.Simulation`.

- ✅ **выполнения** операций, функций и определяемых пользователем типов, используемых только в определенных доменах, в пространства имен, указывающие их доменную программу. При необходимости используйте подпространства имен, чтобы указать задачи с особыми задачами в пределах каждого доменного пространства имен.

  *Примеры:*
  - Библиотека машинного обучения, опубликованная корпорацией Майкрософт, в основном помещается в пространство имен @"microsoft.quantum.machinelearning", но примеры наборов данных предоставляются пространством имен @"microsoft.quantum.machinelearning.datasets".
  - API-интерфейсы тактовой химия, опубликованные корпорацией Майкрософт как часть пакета средств разработки тактов, должны быть помещены в `Microsoft.Quantum.Chemistry`. Функциональные возможности, характерные для реализации Иордания--Вигнер, могут быть помещены в `Microsoft.Quantum.Chemistry.JordanWigner`, чтобы основной интерфейс для химия области домена тактовой зоны не был связан с реализациями.

**Основной принцип:** Используйте пространства имен и модификаторы доступа вместе, чтобы быть преднамеренными к поверхности API, предоставляемой пользователям, а также для скрытия внутренних сведений, связанных с реализацией и тестированием ваших API.

- ✅ разумный, **размещайте все** функции и операции, необходимые для реализации API, в том же пространстве имен, что и реализуемый API, но помечайте ключевыми словами "Private" или "internal", чтобы указать, что они не являются частью общедоступной области API для библиотеки. Используйте имя, начинающееся с символа подчеркивания (`_`), чтобы визуально отличать закрытые и внутренние операции и функции от открытых вызываемых.

  *Примеры:*
  - Имя операции `_Features` указывает на функцию, которая является закрытой для данного пространства имен и сборки, и должна сопровождаться ключевым словом `internal`.

- ✅ в редких случаях, когда для реализации API для данного пространства имен требуется обширный набор закрытых функций или операций, **помещайте их** в новое пространство имен, соответствующее реализуемому пространству имен и завершающему в `.Private`.

- ✅ **DO** помещайте все модульные тесты в пространства имен, соответствующие тестируемому пространству имен и заканчивая в `.Tests`.

## <a name="naming-conventions-and-vocabulary"></a>Соглашения об именовании и словарь

**Основной принцип:** Выберите имена и терминологию, которые понятны, доступны и могут быть доступны для чтения в различных аудиториях, в том числе от двух и экспертов.

- ⛔️ **не** следует использовать имена идентификаторов-дискриминатор и исключаемого идентификатора, а также терминологию в комментариях к документации по API.

- ✅ **использовать** комментарии к документации по API для предоставления соответствующего контекста, примеров и ссылок, особенно для более сложных концепций.

- ⛔️ **не** используйте имена идентификаторов, которые необязательно изотерических или требуют значительных знаний для чтения.

  *Примеры:*
  - Предпочитать "итерации" для усиления амплитуды "Гровер итерации".

- ✅ **выбрать** операции и имена функций, которые четко сообщают о предполагаемом действии вызываемого, а не его реализации. Обратите внимание, что реализация может и должна быть

  *Примеры:*
  - Поменяйте "перекрытие оценок" на "Хадамард Test", так как в последнем случае происходит реализация предыдущего.

- ✅ **использовать** слова согласованно во всех api Q\#:

  - **Команды**

    - **Assert**: Убедитесь, что предположение о состоянии целевого компьютера и его Кубитс содержит, возможно, с помощью нефизических ресурсов. Операции, использующие эту команду, всегда должны быть безопасно съемными, не влияя на функциональность библиотек и исполняемых программ. Обратите внимание, что, в отличие от фактов, утверждения могут быть в общем, зависят от внешнего состояния, такого как состояние регистра кубит, среды выполнения или так далее. Как зависимость от внешнего состояния является разновидностью побочного действия, утверждения должны предоставляться как операции, а не функции.

    - **Оценка**. используя одно или несколько возможных повторных измерений, оцените классический объем из результатов измерения.

      *Примеры:*
      - @"microsoft.quantum.characterization.estimatefrequency"
      - @"microsoft.quantum.characterization.estimateoverlapbetweenstates"

    - **Подготовка**: применение операции-такта или последовательности операций к одному или нескольким Кубитс предполагается начать в определенном начальном состоянии (обычно $ \ket{00\cdots 0} $), что приводит к развитию состояния этих Кубитс до желаемого конечного состояния. Как правило, работа с состояниями, отличными от заданного начального состояния, **может** привести к неопределенному единому преобразованию, но **должно** сохранить операцию и ее смежное "Отмена" и применить оператор No-Op.

      *Примеры:*
      - @"microsoft.quantum.preparation.preparearbitrarystate"
      - @"microsoft.quantum.preparation.prepareuniformsuperposition"

    - **Мера**: применение операции-такта или последовательности операций к одному или нескольким Кубитс, чтение классических данных.

      *Примеры:*
      - @"microsoft.quantum.intrinsic.measure"
      - @"microsoft.quantum.arithmetic.measurefxp"
      - @"microsoft.quantum.arithmetic.measureinteger"

    - **Применение**: применение операции-такта или последовательности операций к одному или нескольким Кубитс, в результате чего состояние этих Кубитс меняется в согласованном виде. Эта команда является наиболее общей командой в Q\# номенклатуры и **не должна** использоваться, если более конкретная команда более релевантна напрямую.

  - **Существительные**:

    - **Факт**. логическое условие, которое зависит только от входных данных, а не от состояния целевого компьютера, его среды или состояния кубитса компьютера. В отличие от утверждения, факт учитывает только *значения* , предоставленные для этого факта. Пример:

      *Примеры:*
      - @"microsoft.quantum.diagnostics.equalityfacti": представляет факт равенства для двух целочисленных значений. либо целые числа, указанные в качестве входных данных, равны друг другу, либо они не зависят от других состояний программы.

    - **Параметры:** Определяемый пользователем тип, содержащий несколько именованных элементов, которые могут действовать как "необязательные аргументы" для функции или операции. Пример:

      *Примеры:*
      - @"microsoft.quantum.machinelearning.trainingoptions" UDT включает именованные элементы для обучения, размер уменьшив и другие настраиваемые параметры для МАШИНного обучения.

  - **Прилагательные**:

    - ⛔️ **New**: этот прилагательный **не следует** использовать, как, чтобы избежать путаницы с его использованием в качестве глагола во многих языках программирования ( C++например C#:,, Java, TypeScript, PowerShell).

  - **Предположении:** В некоторых случаях можно использовать варианты размещения для дальнейшей неоднозначности или уточнения ролей существительных и глаголов в именах функций и операций. Однако следует соблюдать осторожность, чтобы сделать это экономно и постоянно.

    - **Как:** Представляет, что входные и выходные данные функции представляют одни и те же сведения, но выходные данные представляют эту информацию **как** *X* , а не исходное представление. Это особенно распространено для функций преобразования типов.

      *Примеры:*
      - `IntAsDouble(2)` указывает, что входные данные (`2`) и выходные данные (`2.0`) имеют качественную одинаковую информацию, но для этого используются различные типы данных Q\#.

    - **Из:** Чтобы обеспечить согласованность, эту позицию **не следует** использовать для указания функций преобразования типов или любого другого случая **,** где подходит.

    - ⛔️ **:** **не следует** использовать эту возможность, как во многих языках программирования, чтобы избежать путаницы с ее использованием в качестве глагола.
