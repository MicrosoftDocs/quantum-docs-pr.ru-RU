---
title: Q#Руководству по стилю Майкрософт
description: Сведения об именовании, вводе, документации и соглашениях о форматировании для Q# программ и библиотек.
author: cgranade
ms.author: chgranad
ms.date: 10/12/2018
ms.topic: article
uid: microsoft.quantum.contributing.style
no-loc:
- Q#
- $$v
ms.openlocfilehash: 27a2ae5ae9d00329fc369268edae24228a9a9d0d
ms.sourcegitcommit: 6bf99d93590d6aa80490e88f2fd74dbbee8e0371
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/06/2020
ms.locfileid: "87867596"
---
# <a name="no-locq-style-guide"></a>Q#Рекомендации по стилю #
## <a name="general-conventions"></a>Общие соглашения ##

Соглашения, предлагаемые в этом разделе, призваны помочь сделать программы и библиотеки более удобочитаемыми Q# и понятными.

## <a name="guidance"></a>Действие

Мы рекомендуем:

- Не следует игнорировать соглашение, если это не сделано намеренно, чтобы предоставить пользователям более понятный и понятный код.

## <a name="naming-conventions"></a>Соглашения об именах ##

В составе пакета средств разработки тактов мы стремимся использовать имена функций и операций, которые помогают разработчикам создавать программы, которые просты в чтении, и сокращают их сюрприз.
Важной частью является то, что при выборе имен для функций, операций и типов мы создаем *словарь* , используемый программистами для выражения тактовых концепций. с нашими вариантами мы можем либо отнестись к их усилиям, чтобы четко взаимодействовать.
Это полагает ответственность за то, чтобы имена, которые мы предложит, были понятны, а не скрыты.
В этом разделе мы подробно расскажу о том, как мы удовлетворены этим обязательством с точки зрения явных руководств, которые помогут нам лучше всего сделать это в Q# сообществе разработчиков.

### <a name="operations-and-functions"></a>Операции и функции ###

Одно из первых действий, которое должно установить имя, — это то, представляет ли заданный символ функцию или операцию.
Разница между функциями и операциями крайне важна для понимания того, как работает блок кода.
Чтобы обеспечить различие между функциями и операциями для пользователей, мы будем полагаться на то, что модели зависят от Q# использования побочных эффектов.
Это значит, что операция *делает* что-то.

Функции, напротив, описывают математические связи между данными.
Выражение `Sin(PI() / 2.0)` *имеет* значение `1.0` и не подразумевает ничего о состоянии программы или ее Кубитс.

Формирование сводных данных, операции выполняются, когда функции являются объектами.
Это различие подразумевает, что операции именования являются глаголами и функциями в качестве существительных.

> [!NOTE]
> При объявлении определяемого пользователем типа Новая функция, которая конструирует экземпляры этого типа, неявно определяется в то же время.
> С этой точки зрения определяемые пользователем типы должны называться существительными, чтобы оба типа и функции конструктора имели одинаковые имена.

В разумных случаях убедитесь, что имена операций начинаются с глаголов, которые четко указывают на результат операции.
Пример:

- `MeasureInteger`
- `EstimateEnergy`
- `SampleInt`

Одним из случаев, которым заслуживает особое упоминание, является то, что операция принимает в качестве входных данных другую операцию и вызывает ее.
В таких случаях действие, выполняемое входной операцией, не ясно при определении внешней операции, что означает, что правая команда не будет немедленно очищена.
Рекомендуется использовать команду `Apply` , как в `ApplyIf` , `ApplyToEach` и `ApplyToFirst` .
Другие глаголы также могут быть полезны в этом случае, как в `IterateThroughCartesianPower` .

| Команда | Ожидаемый результат |
| ---- | ------ |
| Применить | Операция, предоставленная в качестве входных данных, называется |
| Assert | Гипотеза о результате возможного измерения такта проверяется симулятором. |
| Оценка | Возвращается классический параметр, представляющий оценку, полученную от одного или нескольких измерений. |
| Measure | Выполняется измерение такта, и результат возвращается пользователю. |
| Подготовка. | Заданный регистр Кубитс инициализируется в определенном состоянии |
| Образец | Классическое значение возвращается случайным образом из некоторого распределения |

Для функций мы рекомендуем избегать использования глаголов в пользу общих существительных (см. Руководство по правильным существительным ниже) или прилагательные:

- `ConstantArray`
- `Head`
- `LookupFunction`

В частности, в большинстве случаев мы рекомендуем использовать последние партиЦиплес, где нужно указать, что имя функции строго соединено с действием или побочным эффектов в другом месте в тактовой программе.
Например, `ControlledOnInt` использует форму части причастий команды "Control", чтобы указать, что функция выступает в качестве прилагательного для изменения своего аргумента.
Это имя имеет дополнительное преимущество в соответствии с семантикой встроенных `Controlled` функтор, как описано ниже.
Аналогичным образом можно использовать _существительные агентов_ для создания имен функций и определяемых пользователем типов из имен операций, как в случае имени `Encoder` определяемого пользователем типа, который строго связан с `Encode` .

# <a name="guidance"></a>[Действие](#tab/guidance)

Мы рекомендуем:

- Используйте глаголы для имен операций.
- Для имен функций используйте существительные или прилагательные.
- Используйте существительные для определяемых пользователем типов и атрибутов.
- Для всех вызываемых имен используйте `CamelCase` строгое предпочтение для `pascalCase` , `snake_case` или `ANGRY_CASE` . В частности, убедитесь, что вызываемые имена начинаются с прописных букв.
- Для всех локальных переменных используйте `pascalCase` строгое предпочтение в `CamelCase` , `snake_case` или `ANGRY_CASE` . В частности, убедитесь, что локальные переменные начинаются с строчных букв.
- Избегайте использования знаков подчеркивания `_` в именах функций и операций, где требуются дополнительные уровни иерархии, используйте пространства имен и псевдонимы пространств имен.

# <a name="examples"></a>[Примеры](#tab/examples)

|   | Имя | Описание: |
|---|------|-------------|
| ☑ | `operation ReflectAboutStart` | Снимите флажок использовать глагол ("отражать"), чтобы указать результат операции. |
| ☒ | <s>`operation XRotation`</s> | Использование фразы существительное предлагает функцию, а не операцию. |
| ☒ | <s>`operation search_oracle`</s> | Использование `snake_case` Q# нотации контравенес. |
| ☒ | <s>`operation Search_Oracle`</s> | Использование символов подчеркивания Internal для обозначения операции контравенес Q# . |
| ☑ | `function StatePreparationOracle` | Использование фразы с существительным предполагает, что функция возвращает операцию. |
| ☑ | `function EqualityFact` | Снимите флажок использовать существительное (факт), чтобы указать, что это функция, в то время как прилагательное. |
| ☒ | <s>`function GetRotationAngles`</s> | Использование глагола ("Get") предполагает, что это операция. |
| ☑ | `newtype GeneratorTerm` | Явное использование фразы с существительным означает результат вызова конструктора определяемого пользователем типа. |
| ☒ | <s>`@Attribute() newtype RunOnce()`</s> | Использование глагола-фразы предполагает, что конструктор определяемого пользователем типа является операцией. |
| ☑ | `@Attribute() newtype Deprecated(Reason : String)` | Использование фразы существительное сообщает об использовании атрибута. |

***

### <a name="entry-points"></a>Точки входа

При определении точки входа в Q# программу Q# компилятор распознает [ `@EntryPoint()` атрибут](xref:microsoft.quantum.core.entrypoint) , а не требует, чтобы точки входа имели определенное имя (например `main` ,, `Main` или `__main__` ).
То есть с точки зрения Q# разработчика точки входа являются обычными операциями с заметками `@EntryPoint()` .
Более того, Q# точки входа могут быть точками входа для всего приложения (т. е. в Q# автономных исполняемых файлах) или интерфейсом между Q# программой и основной программой для приложения (т. е. при использовании Q# с Python или .NET), в результате чего имя «main» может быть ошибочным при применении к Q# точке входа.

Рекомендуется использовать именование точек входа для отражения использования `@EntryPoint()` атрибута с помощью общих рекомендаций для операций именования, перечисленных выше.


# <a name="guidance"></a>[Действие](#tab/guidance)

Мы рекомендуем:

- Не назовите операции точки входа как "Main".
- Назовите операции точки входа как обычные операции.

# <a name="examples"></a>[Примеры](#tab/examples)

|   | Имя | Описание: |
|---|------|-------------|
| ☑ | `@EntryPoint() operation RunSimulation` | Явно сообщает назначение точки входа через имя операции. |
| ☒ | <s>`@EntryPoint() operation Main`</s> | Использование объекта `Main` не позволяет явно передавать цель точки входа и является избыточным `@EntryPoint()` атрибутом. |

***

### <a name="shorthand-and-abbreviations"></a>Сокращенные и сокращенные обозначения ###

Приведенный выше Совет не отменяется, существует множество форм сокращений, которые являются распространенным и распространенным использованием в тактовых вычислениях.
Мы рекомендуем использовать существующую и распространенную краткую форму, в которой он существует, особенно для операций, которые являются встроенными для работы целевого компьютера.
Например, мы выбираем имя, а не `X` `ApplyX` `Rz` `RotateAboutZ` .
При использовании такой сокращенной формы имена операций должны быть все прописными (например: `MAJ` ).

При применении этого соглашения необходимо соблюдать осторожность в случае часто используемых акронимов и сокращений, например "Кфт" для "преобразования тактов в тактовой области".
Мы рекомендуем использовать следующие общие соглашения .NET для использования акронимов и сокращений в полных именах, которые предписывает:

- двузначные акронимы и сокращений именуются в верхнем регистре (например, `BE` для «Big-endian»),
- все более длинные акронимы и сокращений именуются в `CamelCase` (например, `Qft` для "преобразования в тактовую Фурье").

Таким образом, операция, реализующая Кфт, может быть либо вызвана `QFT` как краткая, либо записана как `ApplyQft` .

Для наиболее часто используемых операций и функций может быть желательно предоставить сокращенное имя в качестве _псевдонима_ для более длинной формы:

```qsharp
operation CCNOT(control0 : Qubit, control1 : Qubit, target : Qubit)
is Adj + Ctl {
    Controlled X([control0, control1], target);
}
```

# <a name="guidance"></a>[Действие](#tab/guidance)

Мы рекомендуем:

- При необходимости рекомендуется использовать распространенные и распространенные сокращенные имена.
- Для сокращения используйте прописные буквы.
- Используйте прописные буквы для коротких (двух букв) аббревиатур и сокращений.
- Используйте `CamelCase` более длинные (три и более буквы) акронимы и сокращений.

# <a name="examples"></a>[Примеры](#tab/examples)

|   | Имя | Описание: |
|---|------|-------------|
| ☑ | `X` | Хорошо понятная Краткая форма "применение преобразования $X $" |
| ☑ | `CNOT` | Хорошо понятная Краткая форма для «контролируемых» |
| ☒ | <s>`Cnot`</s> | Сокращенная форма не должна находиться в `CamelCase` . |
| ☑ | `ApplyQft` | Общий начальный вид "Кфт" отображается как часть имени длинной формы. |
| ☑ | `QFT` | Общий начальный вид "Кфт" отображается как часть сокращенного имени. |



***


### <a name="proper-nouns-in-names"></a>Собственные существительные в именах ###

Хотя в физике мы часто называете вещи, когда первый пользователь публикует их, большинство фисиЦистс не знакомы с именами всех участников и журналами.
Чрезмерная постановка в соглашениях об именовании от физикы может привести к значительному барьеру в записи, так как пользователи из других фоновых рисунков должны изучить большое количество непрозрачных имен, чтобы использовать общие операции и концепции.
<!-- An important part of the task of reducing confusion is to make code more accessible.
Especially in a field such as quantum computing that is rich with domain expertise, we must at all times be cognizant of the demands we place on that expertise as we design quantum software.
In naming code symbols, one way that this cognizance expresses itself is as an awareness of the convention from physics of adopting as the names of algorithms and operations the names of their original publishers.
While we must maintain the history and intellectual provenance of concepts in quantum computing, demanding that all users be versed in this history to use even the most basic of functions and operations places a barrier to entry that is in most cases severe enough to even present an ethical compromise. -->
Таким образом, рекомендуется, чтобы при разумных принципах обычные существительные, описывающие концепцию, были приняты строгими для правильного существительных, описывающих историю публикации концепции.
В качестве конкретного примера, управляемые с помощью одной и той же операции перестановки и управления удвоением часто называются операциями «Фредкин» и «Тоффоли» в учебных литературах, но в основном они определены Q# как `CSWAP` и `CCNOT` .
В обоих случаях комментарии к документации по API предоставляют имена синонимов на основе правильных существительных, а также все соответствующие ссылки.

Этот приоритет особенно важен в тех случаях, когда необходимо всегда использовать собственные существительные — Q# в соответствии с традицией, установленной многими классическими языками, и ссылается на `Bool` типы в ссылке на логическую логику, которая, в свою очередь, имеет имя, соблюдающая bool.
Несколько концепций такта аналогичным образом именуются, включая `Pauli` тип, встроенный в Q# язык.
Свести к минимуму использование правильных существительных, если такое использование не является обязательным, мы уменьшаем влияние того, что их не удается избежать.

# <a name="guidance"></a>[Действие](#tab/guidance) 

Мы рекомендуем:

- Избегайте использования в именах правильных существительных.

# <a name="examples"></a>[Примеры](#tab/examples)

***

### <a name="type-conversions"></a>Преобразования типов ###

Поскольку Q# является строго и статически типизированным языком, значение одного типа может использоваться только как значение другого типа с помощью явного вызова функции преобразования типа.
Это отличается от языков, позволяющих неявным образом изменять типы значений (например, повышение типа) или путем приведения.
В результате функции преобразования типов играют важную роль при Q# разработке библиотеки и составляют одно из наиболее часто встречающихся решений по именованию.
Однако обратите внимание, что поскольку преобразования типов всегда _детерминированы_, они могут быть написаны как функции и, таким образом, находиться на приведенный выше Совет.
В частности, мы советуем, что функции преобразования типов никогда не должны называться как глаголы (например, `ConvertToX` ) или модификаторовные фразы ( `ToX` ), но они должны называться как прилагательные фразы, указывающие исходный и целевой типы ( `XAsY` ).
При перечислении типов массивов в именах функций преобразования типов рекомендуется использовать краткую форму `Arr` .
При запрете исключительных обстоятельств рекомендуется, чтобы все функции преобразования типов были именованы с помощью, `As` чтобы их можно было быстро определить.

# <a name="guidance"></a>[Действие](#tab/guidance)

Мы рекомендуем:

- Если функция преобразует значение типа `X` в значение типа `Y` , используйте либо имя, `AsY` либо `XAsY` .

# <a name="examples"></a>[Примеры](#tab/examples)

|   | Имя | Описание: |
|---|------|-------------|
| ☒ | <s>`ToDouble`</s> | В качестве отстановки "до" задается Командная фраза, указывающая на операцию, а не на функцию. |
| ☒ | <s>`AsDouble`</s> | Тип входных данных не является понятным по имени функции. |
| ☒ | <s>`PauliArrFromBoolArr`</s> | Входные и выходные типы отображаются в неправильном порядке. |
| ☑ | `ResultArrAsBoolArr` | Типы входных и выходных данных являются четкими. |

***

### <a name="private-or-internal-names"></a>Частные или внутренние имена ###

Во многих случаях имя предназначено исключительно для внутреннего использования в библиотеке или проекте и не является гарантированной частью API, предоставляемой библиотекой.
Полезно четко указать, что это происходит при именовании функций и операций, так что случайные зависимости от внутреннего кода становятся очевидными.
Если операция или функция не предназначена для непосредственного использования, а должна использоваться соответствующим вызываемым методом, который действует частичным приложением, рассмотрите возможность использования имени, начинающегося с `internal` ключевого слова, для вызываемого частично применяемого метода.

# <a name="guidance"></a>[Действие](#tab/guidance)

Мы рекомендуем:

- Если функция, операция или определяемый пользователем тип не являются частью общедоступного API для Q# библиотеки или программы, убедитесь, что она помечена как внутренняя, поместив `internal` ключевое слово перед `function` `operation` `newtype` объявлением, или.

# <a name="examples"></a>[Примеры](#tab/examples)

|   | Имя | Описание: |
|---|------|-------------|
| ☒ | <s>`operation _ApplyDecomposedOperation`</s> | Не используйте символ подчеркивания `_` , чтобы указать, что эта операция предназначена только для внутреннего использования. |
| ☑ | `internal operation ApplyDecomposedOperation` | `internal`Ключевое слово в начале ясно указывает, что эта операция предназначена только для внутреннего использования. |

***
### <a name="variants"></a>Варианты ###

Несмотря на то, что это ограничение может не сохраняться в будущих версиях Q# , оно, в своюмся случае, будет представлять собой группы связанных операций или функций, которые различаются операторов их входными данными или конкретными типами их аргументов.
Эти группы можно отличать с помощью одного и того же корневого имени, за которым следует одна или две буквы, указывающие на вариант.

| Суффикс | Значение |
|--------|---------|
| `A` | Ожидается ввод для поддержки`Adjoint` |
| `C` | Ожидается ввод для поддержки`Controlled` |
| `CA` | Ожидается ввод для поддержки `Controlled` и`Adjoint` |
| `I` | Входные или входные данные имеют тип`Int` |
| `D` | Входные или входные данные имеют тип`Double` |
| `L` | Входные или входные данные имеют тип`BigInt` |

# <a name="guidance"></a>[Действие](#tab/guidance)

Мы рекомендуем:

- Если функция или операция не связаны с аналогичными функциями или операциями по типам и функтор поддерживают свои входные данные, не используйте суффикс.
- Если функция или операция связана с любыми аналогичными функциями или операциями типов и функтор поддержки своих входных данных, используйте суффиксы, как показано в таблице выше, чтобы различать варианты.

# <a name="examples"></a>[Примеры](#tab/examples)

***

### <a name="arguments-and-variables"></a>Аргументы и переменные ###

Ключевой целью Q# кода для функции или операции является простое чтение и понимание.
Аналогичным образом, имена входов и аргументов типа должны сообщать, как функция или аргумент будут использоваться по мере того, как они предоставлены.


# <a name="guidance"></a>[Действие](#tab/guidance)

Мы рекомендуем:

- Для всех переменных и входных имен используйте `pascalCase` строгое предпочтение в `CamelCase` , `snake_case` или `ANGRY_CASE` .
- Входные имена должны быть описательными; по возможности избегайте по одному или двум именам букв.
- Операции и функции, принимающие ровно один аргумент типа, должны отметить этот аргумент типа, `T` если его роль очевидна.
- Если функция или операция принимает несколько аргументов типа или если роль одного аргумента типа не очевидна, рассмотрите возможность использования короткого слова с прописной буквой, которое предшествует `T` (например, `TOutput` ) для каждого типа.
- Не включайте имена типов в имена аргументов и переменных. Эти сведения могут и должны предоставляться средой разработки.
- Запишите скалярные типы по их литеральным именам ( `flagQubit` ) и типам массивов во множественном числе ( `measResults` ).
  Для массивов Кубитс в частности, рассмотрите такие типы, в `Register` которых имя ссылается на последовательность Кубитс, тесно связанных каким-либо образом.
- Переменные, используемые в качестве индексов в массивах, должны начинаться с `idx` и должны быть в единственном числе, например: `things[idxThing]` ).
  В частности, настоятельно рекомендуется избегать использования однобуквенных имен переменных в качестве индексов; рекомендуется использовать `idx` как минимум.
- Переменные, используемые для хранения длин массивов, должны начинаться с `n` и должны быть в множественном числе, например: `nThings` ).

# <a name="examples"></a>[Примеры](#tab/examples)

***

### <a name="user-defined-type-named-items"></a>Определяемый пользователем тип с именем Items ###

Именованные элементы в определяемых пользователем типах должны называться как `CamelCase` , даже при вводе в конструкторы определяемого пользователем типа.
Это помогает в четком разделении именованных элементов со ссылок на переменные в локальной области при использовании представления метода доступа (например, `callable::Apply` ) или нотации копирования и обновления ( `set arr w/= Data <- newData` ).

# <a name="guidance"></a>[Действие](#tab/guidance)

Мы рекомендуем:

- Именованные элементы в конструкторах определяемых пользователем типов должны называться как `CamelCase` ; то есть должны начинаться с прописной буквы.
- Именованные элементы, которые разрешаются в операции, должны называться этапами глагола.
- Именованные элементы, которые не разрешаются в операции, должны называться как субстантивные словосочетания.
- Для определяемых пользователем типов, которые обносят операции, необходимо определить один именованный элемент `Apply` .

# <a name="examples"></a>[Примеры](#tab/examples)

|   | Фрагмент кода | Описание: |
|---|---------|-------------|
| ☑ | `newtype Oracle = (Apply : Qubit[] => Unit is Adj + Ctl)` | Имя `Apply` является `CamelCase` фразой-командой, предлагающей, что именованный элемент является операцией. |
| ☒ | <s>`newtype Oracle = (apply : Qubit[] => Unit is Adj + Ctl) `</s> | Именованные элементы должны начинаться с первой прописной буквы. |
| ☒ | <s>`newtype Collection = (Length : Int, Get : Int -> (Qubit => Unit)) `</s> | Именованные элементы, которые разрешаются в функции, должны называться как субстантивные словосочетания, а не как фразы глагола. |

***

## <a name="input-conventions"></a>Соглашения о входе ##

Когда разработчик обращается к операции или функции, различные входные данные этой операции или функции должны быть указаны в определенном порядке, увеличивая при этом функциональную нагрузку, которую разработчик может использовать для создания библиотеки.
В частности, задача по запоминанию порядка входных данных часто является отправной задачей: программированием реализации алгоритма такта.
Хотя широкая поддержка интегрированной среды разработки может снизить это до большого экстента, хорошая разработка и соблюдение общих соглашений также может помочь минимизировать неудачную загрузку, наложенную API.

Там, где это возможно, может быть полезно уменьшить количество входных данных, ожидаемых операцией или функцией, чтобы роль каждого входа была более очевидна для разработчиков, обращающихся к этой операции или функции, а также для разработчиков, считывающих этот код позже.
Особенно если невозможно или разумно уменьшить число аргументов для операции или функции, важно иметь единообразный порядок, позволяющий свести к сведению, что пользователь сталкивается с прогнозированием порядка входных данных.

Мы рекомендуем использовать соглашения о порядке ввода, которые во многом наследуют от мышления частичного приложения как обобщение карринг f (x, y) ≡ f (x) (y).
Таким образом, частичное применение первых аргументов должно привести к вызову, который будет полезен при любом разумном использовании.
Следуя этому принципу, рассмотрите возможность использования следующего порядка аргументов:

- Классические не вызываемые аргументы, такие как углы, векторы степеней и т. д.
- Вызываемые аргументы (функции и аргументы).
  Если обе функции и операции выполняются в качестве аргументов, попробуйте разместить операции после функций.
- Коллекции, обрабатываемые вызываемыми аргументами аналогично методу `Map` , `Iter` , `Enumerate` и `Fold` .
- Аргументы кубит, используемые в качестве элементов управления.
- Аргументы кубит, используемые в качестве целевых объектов.

Рассмотрим операцию `ApplyPhaseEstimationIteration` для использования в оценке этапа, которая принимает угол и Oracle, передает угол `Rz` , измененный массивом различных факторов масштабирования, а затем управляет приложениями Oracle.
Мы будем упорядочивать входные данные `ApplyPhaseEstimationIteration` следующим образом:

```qsharp
operation ApplyPhaseEstimationIteration(
    angle : Double,
    callable : (Qubit => () is Ctl),
    scaleFactors : Double[],
    controlQubit : Qubit,
    targetQubits : Qubit[]
)
: Unit
...
```
В качестве особого случая минимизации неожиданности некоторые функции и операции воспроизводят поведение встроенных операторов `Adjoint` и `Controlled` .
Например, `ControlledOnInt<'T>` имеет тип `(Int, ('T => Unit is Adj + Ctl)) => ((Qubit[], 'T) => Unit is Adj + Ctl)` , который `ControlledOnInt<Qubit[]>(5, _)` действует как `Controlled` функтор, но в условии, что регистр элемента управления представляет состояние $ \кет {5} = \кет {101} $.
Таким образом, разработчику требуется, чтобы входные данные `ControlledOnInt` были преобразованы последними, а Результирующая операция принимает в качестве входных данных `(Qubit[], 'T)` ---том же порядке, в котором следуют выходные данные `Controlled` функтор.

# <a name="guidance"></a>[Действие](#tab/guidance)

Мы рекомендуем:

- Используйте порядок ввода в соответствии с использованием частичного приложения.
- Используйте порядок ввода в соответствии со встроенными операторов.
- Разместите все классические входные данные перед любыми входными тактовыми тактами.

# <a name="examples"></a>[Примеры](#tab/examples)

***

## <a name="documentation-conventions"></a>Обозначения в документации ##

Q#Язык позволяет прикреплять документацию к операциям, функциям и определяемым пользователем типам с помощью специально отформатированных комментариев к документации.
В соответствии с тройными косыми чертами ( `///` ) эти комментарии документации представляют собой небольшие [DocFX документы Markdown](https://dotnet.github.io/docfx/spec/docfx_flavored_markdown.html) , которые можно использовать для описания назначения каждой операции, функции и определяемого пользователем типа, возвращаемых входов и т. д.
Компилятор, поставляемый с пакетом разработки тактов, извлекает эти комментарии и использует их для помощи в документации по наборам типов, похожим на эту https://docs.microsoft.com/quantum .
Аналогичным образом, языковой сервер, поставляемый с пакетом разработки тактовой передачи, использует эти комментарии для предоставления помощи пользователям при наведении указателя мыши на символы в Q# коде.
Использование комментариев к документации может помочь пользователям лучше понять код, предоставляя полезную ссылку для получения подробных сведений, которые не просто выражаются с помощью других соглашений в этом документе.

> [!div class="nextstepaction"]
> [Справочник по синтаксису комментариев документации](xref:microsoft.quantum.guide.filestructure#documentation-comments).

Чтобы эффективно использовать эту функцию для пользователей, рекомендуется учитывать некоторые моменты при написании комментариев к документации.

# <a name="guidance"></a>[Действие](#tab/guidance)

Мы рекомендуем:

- Каждая открытая функция, операция и определяемый пользователем тип должны непосредственно предшествовать комментарию документации.
- Каждый комментарий к документации должен содержать как минимум следующие разделы:
    - Итоги
    - Входные данные
    - Выходные данные (если применимо)
- Убедитесь, что все сводки имеют два предложения или меньше. Если требуется больше места, укажите раздел, `# Description` приведенный сразу за `# Summary` полными сведениями.
- В разумных случаях не включайте математические вычисления в сводки, так как не все клиенты поддерживают да нотацию в сводках. Обратите внимание, что при написании документов prose (например, да или Markdown) может быть предпочтительнее использовать более длинные строки.
- Укажите все соответствующие математические выражения в `# Description` разделе.
- При описании входных данных не следует повторять типы всех входных данных, так как они могут выводиться компилятором и угрожать несогласованность.
- Укажите нужные примеры, каждый в отдельном `# Example` разделе.
- Кратко опишите каждый пример перед выводом кода.
- В разделе представлены все соответствующие академические публикации (например, документы, материалы, записи в блоге и альтернативные реализации) `# References` раздела в виде маркированного списка ссылок.
- Убедитесь, что, где это возможно, все ссылки ссылок относятся к постоянным и неизменяемым идентификаторам (Доис или номера Арксив версий).
- Если операция или функция связана с другими операциями или функциями с помощью функтор Variant, перечислите другие варианты в виде маркеров в `# See Also` разделе.
- Оставьте пустую строку комментария между разделами уровня 1 ( `/// #` ), но не оставляйте пустых строк между разделами уровня 2 ( `/// ##` ).

# <a name="examples"></a>[Примеры](#tab/examples)

#### <a name=""></a>☑ ####

```
/// # Summary
/// Applies a rotation about the X-axis by a given angle.
///
///
/// # Description
/// This operation rotates a single qubit by the unitary operation
/// \begin{align}
///     R_x(\theta) \mathrel{:=} e^{-i \theta \sigma_x / 2}.
/// \end{align}
///
/// # Input
/// ## theta
/// Angle about which the qubit is to be rotated.
/// ## qubit
/// Qubit to which the gate should be applied.
///
/// # Remarks
/// Equivalent to:
/// ```qsharp
/// R(PauliX, theta, qubit);
/// ```
///
/// # See Also
/// - Ry
/// - Rz
operation Rx(theta : Double, qubit : Qubit) : Unit
is Adj + Ctl {
    body (...) { R(PauliX, theta, qubit); }
    adjoint (...) { R(PauliX, -theta, qubit); }
}
```

***

## <a name="formatting-conventions"></a>Соглашения о форматировании ##

Помимо описанных выше предложений, рекомендуется сделать код максимально удобочитаемым, чтобы использовать единообразные правила форматирования.
Такие правила форматирования по сути, как правило, являются несколько произвольными и хорошо эстетичность.
Тем не менее рекомендуется поддерживать единообразный набор соглашений о форматировании в группе участников совместной работы, особенно для крупных Q# проектов, таких как сам пакет разработки такта.
Эти правила могут быть автоматически применены с помощью средства форматирования, интегрированного с Q# компилятором.

# <a name="guidance"></a>[Действие](#tab/guidance) 

Мы рекомендуем:

- Для переносимости используйте четыре пробела вместо вкладок.
  Например, в VS Code:
  ```json
    "editor.insertSpaces": true,
    "editor.tabSize": 4
  ```
- Строка переносится в 79 символов, где это оправданно.
- Используйте пробелы вокруг бинарных операторов.
- Используйте пробелы с обеих сторон двоеточий, используемых для заметок типов.
- Используйте один пробел после запятых, используемых в массивах и литералах кортежа (например, в входных данных для функций и операций).
- Не используйте пробелы после имени функции, операции или определяемого пользователем типа или после `@` объявлений атрибута in.
- Каждое объявление атрибута должно располагаться в отдельной строке.

# <a name="examples"></a>[Примеры](#tab/examples)

|   | Фрагмент кода | Описание: |
|---|---------|-------------|
| ☒ | <s>`2+3`</s> | Используйте пробелы вокруг бинарных операторов. |
| ☒ | <s>`target:Qubit`</s> | Используйте пробелы вокруг заметок типа двоеточия. |
| ☑ | `Example(a, b, c)` | Элементы во входном кортеже имеют правильный размер для удобочитаемости. |
| ☒ | <s>`Example (a, b, c)`</s> | Пробелы следует подавлять после имени функции, операции или определяемого пользователем типа. |

***
