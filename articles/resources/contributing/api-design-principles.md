---
title: Q# Принципы проектирования API
description: Q# Принципы проектирования API
author: cgranade
ms.author: chgranad
ms.date: 3/9/2020
ms.topic: article
uid: microsoft.quantum.contributing.api-design
no-loc:
- Q#
- $$v
ms.openlocfilehash: 6b196cf1be584a3157c7a9eb8cf497fe1121dd7a
ms.sourcegitcommit: 29e0d88a30e4166fa580132124b0eb57e1f0e986
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/27/2020
ms.locfileid: "92691826"
---
# <a name="no-locq-api-design-principles"></a>Q# Принципы проектирования API

## <a name="introduction"></a>Введение

Как язык и как платформа, дает Q# пользователям возможность создавать, запускать, анализировать и изучать приложения-такты.
Чтобы расширить возможности пользователей, при проектировании Q# библиотек мы будем следовать набору принципов проектирования API для разработки и помощи в создании пригодных к использованию библиотек для сообщества разработчиков тактов.
В этой статье описываются эти принципы и приводятся примеры, которые помогут вам применить их при проектировании Q# API.

> [!TIP]
> Это довольно подробный документ, который предназначен для помощи в разработке библиотек и подробной публикации библиотек.
> Скорее всего, вы найдете его наиболее полезное, если вы пишете собственные библиотеки в Q# или используете большие функции в [ Q# репозитории библиотек](https://github.com/microsoft/QuantumLibraries).
>
> С другой стороны, если вы хотите узнать больше о том, как приступать к работе с пакетом разработки тактов, мы рекомендуем начать с [руководства по публикации](xref:microsoft.quantum.contributing).
> Если вы ищете более общие сведения о том, как мы рекомендуем форматировать Q# код, возможно, вас интересует [руководство по стилю](xref:microsoft.quantum.contributing.style).

## <a name="general-principles"></a>Общие принципы

**Основной принцип:** Предоставление API-интерфейсов, которые помещают фокус на приложения-такты.

- ✅**Выберите операции** и имена функций, отражающие высокоуровневую структуру алгоритмов и приложений.
- ⛔️ **не** предоставляют интерфейсы API, которые в первую очередь касаются низкоуровневых сведений о реализации.

**Основной принцип:** Запустите каждую конструкцию API с примерами вариантов использования, чтобы обеспечить интуитивное использование API.

- ✅**Убедитесь, что каждый** компонент общедоступного API имеет соответствующий вариант использования, вместо того чтобы пытаться проектировать все возможные использования с самого начала.
    Иначе говоря, не следует создавать общедоступные API на случай, если они полезны, но убедитесь, что каждая часть API имеет *конкретный* пример, в котором он будет полезен.

  *Примеры:*
  - @"microsoft.quantum.canon.applytoeachca" можно использовать `ApplyToEachCA(H, _)` для подготовки регистров в едином состоянии геопозиционирования, общей задаче во многих тактовых алгоритмах. Эту же операцию можно также использовать для многих других задач в подготовке, цифровых и алгоритмах на основе Oracle.

- ✅**Выполните** мозговые штурмы и познакомьтесь с новыми разработками API, чтобы убедиться, что они интуитивно понятны и соответствуют предложенным вариантам использования.

  *Примеры:*
  - Просмотрите текущий \# код Q, чтобы увидеть, как новые разработки API могут упростить и прояснить существующие реализации.
  - Изучите предлагаемые макеты API с представителями основных аудиторий.

**Основной принцип:** Разработка API-интерфейсов для поддержки и обеспечения читаемости кода.

- ✅**Убедитесь, что код** доступен для чтения экспертами по доменам и другим специалистам.
- ✅**Разместите фокус** на влиянии каждой операции и функции в рамках алгоритма высокого уровня, используя документацию, чтобы углубиться в детали реализации по мере необходимости.
- ✅При **необходимости следуйте** стандартному [ \# руководству по стилю Q](xref:microsoft.quantum.contributing.style) .

**Основной принцип:** Разработка API-интерфейсов для стабильной и обеспечения прямой совместимости.

- ✅**Не следует** корректно использовать старые API, если требуются критические изменения.

- ✅**Предоставляют операции** и функции "оболочки совместимости", позволяющие корректно работать с кодом пользователя во время устаревания.

  *Примеры:*
  - При переименовании операции `EstimateExpectation` с именем в   `EstimateAverage` вводится новая операция   `EstimateExpectation` , которая вызывает исходную операцию с новым именем, чтобы существующий код мог продолжать работать правильно.

- ✅**Используйте** @"microsoft.quantum.core.deprecated" атрибут для передачи устаревших информации пользователю.

- ✅ При переименовании операции или **функции укажите новое** имя в качестве входных строк для `@Deprecated` .

- ⛔️ **не** удаляйте существующие функции или операции без срока действия не менее 6 месяцев для предварительных выпусков или по крайней мере два года для поддерживаемых выпусков.

## <a name="functions-and-operations"></a>Функции и операции

**Основной принцип.** убедитесь, что каждая функция и операция имеет одну четко определенную цель в API.

- ⛔️ **не** предоставляют функции и операции, выполняющие несколько несвязанных задач.

**Основной принцип:** функции проектирования и операции должны быть максимально пригодными для повторного использования, а также для ожидаемых будущих потребностей.

- ✅**Разработайте** функции и операции с другими функциями и операциями в одном API и в ранее существующих библиотеках.

  *Примеры:*
  - @"microsoft.quantum.canon.delay"Операция принимает минимальные предположения о входных данных и, таким образом, может использоваться для задержки приложений любой из этих операций в Q# стандартной библиотеке или в соответствии с определением пользователей.
    <!-- TODO: define bad example. -->

- ✅**Предоставьте чисто** детерминированную классический классическую логику как функции, а не операции.

  *Примеры:*
  - Подпрограммы, которые возвращающие входные данные с плавающей запятой, могут быть написаны детерминированным образом, поэтому они должны предоставляться пользователю как, `Squared : Double -> Double` а не как операции `Square : Double => Double` . Это позволяет вызывать подпрограммы в большем числе (например, в других функциях) и предоставляет компилятору полезные сведения о оптимизации, которые могут повлиять на производительность и оптимизацию.
  - `ForEach<'TInput, 'TOutput>('TInput => 'TOutput, 'TInput[]) => 'TOutput[]` и `Mapped<'TInput, 'TOutput>('TInput -> 'TOutput, 'TInput[]) -> 'TOutput[]` различаются в отношении детерминированности. оба варианта полезны в различных обстоятельствах.
  - Подпрограммы API, которые преобразуют приложение операций с тактовой частотой, часто выполняются в детерминированном виде, поэтому их можно сделать доступными в виде таких функций, как   `CControlled<'T>(op : 'T => Unit) => ((Bool, 'T) => Unit)` .

- ✅**Выполните** обобщение типа входных данных настолько, насколько целесообразно для каждой функции и операции, используя параметры типа по мере необходимости.

  *Примеры:*
  - `ApplyToEach` имеет тип `<'T>(('T => Unit), 'T[]) => Unit` , а не конкретный тип наиболее распространенного приложения `((Qubit => Unit), Qubit[]) => Unit` .

> [!TIP]
> Важно предусмотреть будущие потребности, но также важно решить конкретные проблемы для пользователей.
> В силу этого принципа работы с ключевыми словами всегда требует тщательного рассмотрения и балансировки, чтобы не разрабатывать интерфейсы API «только на тот случай».

**Основной принцип:** Выбор входных и выходных типов для функций и операций, которые являются прогнозируемыми и взаимодействуют с целью вызова.

- ✅**Используйте типы** кортежей для логической группировки входных и выходных данных, которые учитываются только вместе. В таких случаях рассмотрите возможность использования определяемого пользователем типа.

  *Примеры:*
  - Функции для вывода локального прыжка другой функции может потребоваться использовать границы интервала поиска в качестве входных данных, что `LocalMinima(fn : (Double -> Double), (left : Double, right : Double)) : Double` может быть соответствующей сигнатурой.
  - Операция для оценки производного классификатора машинного обучения с использованием метода сдвига параметров может потребовать смещения векторов параметров с сдвигом и без сдвига в качестве входных данных. `(unshifted : Double[], shifted : Double[])`В этом случае может быть уместным вводом, похожим на.

- ✅**Упорядочение** элементов в входных и выходных кортежах согласованно между различными функциями и операциями.

  *Примеры:*
  - При рассмотрении двух функций или операций, каждый из которых принимает угол поворота и целевой кубит в качестве входных данных, убедитесь, что они упорядочены одинаково в каждом входном кортеже. То есть, предпочитаете `ApplyRotation(angle : Double, target : Qubit) : Unit is Adj + Ctl` и `DelayedRotation(angle : Double, target : Qubit) : (Unit => Unit is Adj + Ctl)` `ApplyRotation(target : Qubit, angle : Double) : Unit is Adj + Ctl` `DelayedRotation(angle : Double, target : Qubit) : (Unit => Unit is Adj + Ctl)` .

**Основной принцип:** функции и операции проектирования, которые хорошо работают с \# функциями языка Q, такими как частичное применение.

- ✅**Упорядочивайте** элементы во входных кортежах таким образом, чтобы наиболее часто применяемые входные данные выполнялись первыми (т. е. так что частичное приложение работает аналогично карринг).

  *Примеры:*
  - Операция `ApplyRotation` , которая принимает число с плавающей запятой и кубит в качестве входных данных, часто может быть частично применена с входными данными с плавающей запятой для использования с операциями, ожидающими ввода типа `Qubit => Unit` . Таким словами, сигнатура `operation ApplyRotation(angle : Double, target : Qubit) : Unit is Adj + Ctl`
      будет работать наиболее согласованно с частичным приложением.
  - Как правило, это руководство означает размещение всех классических данных до всех Кубитс во входных кортежах, но используйте хорошее соблюдаство и изучите способ вызова API на практике.

## <a name="user-defined-types"></a>Определяемые пользователем типы

**Основной принцип.** используйте определяемые пользователем типы, чтобы сделать интерфейсы API более выразительными и удобными для использования.

- ✅**Познакомьтесь с** новыми пользовательскими типами, чтобы предоставить полезную краткую форму для длинных и/или сложных типов.

  *Примеры:*
  - В случаях, когда тип операции с тремя входными данными массива кубит обычно принимается в качестве входных данных или возвращается в виде выходных данных, предоставляя определяемый пользователем типов, например `newtype TimeDependentBlockEncoding = ((Qubit[], Qubit[], Qubit[]) => Unit is Adj + Ctl)`
      может помочь в обеспечении удобной краткости.

- ✅**Познакомьтесь с** новыми определяемыми пользователем типами, чтобы указать, что данный базовый тип следует использовать только в определенном смысле.

  *Примеры:*
  - Операция, которая должна интерпретироваться в виде операции, которая кодирует классические данные в реестр такта, может быть пригодна для меток с определяемым пользователем типом `newtype InputEncoder = (Apply : (Qubit[] => Unit))` .

- ✅Представите новые определяемые пользователем типы с именованными элементами, которые **позволяют реализовать** дальнейшую расширяемость (например, структуру результатов, которая может содержать дополнительные именованные элементы в будущем).

  *Примеры:*
  - Если операция `TrainModel` предоставляет большое количество параметров конфигурации, предоставление этих вариантов в качестве нового   `TrainingOptions` определяемого пользователем типа и предоставление новой функции   `DefaultTrainingOptions : Unit -> TrainingOptions` позволяет пользователям переопределять определенные именованные элементы в траинингоптионс UDT, одновременно позволяя разработчикам библиотек добавлять новые элементы определяемого пользователем типа.

- ✅**Объявите** именованные элементы для новых определяемых пользователем типов в предпочтениях, чтобы требовать от пользователей знание правильного деконструкции кортежа.

  *Примеры:*
  - Если представляет комплексное число в его полярной декомпозиции, предпочтительно   `newtype ComplexPolar = (Magnitude: Double, Argument: Double)`   `newtype ComplexPolar = (Double, Double)` .

**Основной принцип.** используйте определяемые пользователем типы данных, чтобы сократить изученную нагрузку и не требовать от пользователя изучать дополнительные понятия и номенклатуру.

- ⛔️ **не** представить определяемые пользователем типы, требующие частого использования оператора распаковки ( `!` ) или, для которого обычно требуется несколько уровней растекания. Возможные стратегии по устранению рисков:

  - При предоставлении определяемого пользователем типа с одним элементом рассмотрите возможность определения имени этого элемента. Например, рассмотрим `newtype Encoder = (Apply : (Qubit[] => Unit is Adj + Ctl))` в качестве предпочтений `newtype Encoder = (Qubit[] => Unit is Adj + Ctl)` .

  - Обеспечение того, что другие функции и операции могут принимать "инкапсулированные" экземпляры UDT напрямую.

- ⛔️ **не** добавлять новые определяемые пользователем типы, которые дублируют встроенные типы, не предоставляя дополнительных выразительностей.

  *Примеры:*
  - Определяемый пользователем тип `newtype QubitRegister = Qubit[]` не предоставляет дополнительного выразительности по сравнению `Qubit[]` с, поэтому он труднее использовать без чрезмерно допустимого преимущества.
  - Определяемый пользователем тип `newtype LittleEndian = Qubit[]` документирует, как базовый регистр используется и интерпретируется, что обеспечивает дополнительную выразительность по сравнению с базовым типом.

- ⛔️ **не** следует добавлять функции доступа, если не требуется строгое требование;   в этом случае настоятельно рекомендуется использовать именованные элементы.

  *Примеры:*
  - При внедрении определяемого пользователем типа `newtype Complex = (Double, Double)` предпочтительнее изменить его в   `newtype Complex = (Real : Double, Imag : Double)` для введения функций `GetReal : Complex -> Double` и   `GetImag : Complex -> Double` .

## <a name="namespaces-and-organization"></a>Пространства имен и Организация

**Основной принцип:** выберите имена пространств имен, которые являются прогнозируемыми и четко сообщают назначение функций, операций и определяемых пользователем типов в каждом пространстве имен.

- ✅Имена пространств имен **следует** заменять на `Publisher.Product.DomainArea` .

  *Примеры:*
  - Функции, операции и определяемые пользователем типы, опубликованные корпорацией Майкрософт в качестве части функции моделирования такта в пакете разработки тактов, помещаются в   `Microsoft.Quantum.Simulation` пространство имен.
  - `Microsoft.Quantum.Math` представляет пространство имен, опубликованное корпорацией Майкрософт в составе пакета средств разработки такта, относящегося к доменной области математики.

- ✅**Помещайте операции** , функции и определяемые пользователем типы, используемые для определенных функций, в пространство имен, которое описывает эти функциональные возможности, даже если эти функции используются в разных доменах проблем.

  *Примеры:*
  - API-интерфейсы подготовки состояния, опубликованные корпорацией Майкрософт в составе пакета средств разработки тактов, помещаются в   `Microsoft.Quantum.Preparation` .
  - Интерфейсы API моделирования тактов, опубликованные корпорацией Майкрософт в составе пакета средств разработки тактов, помещаются в   `Microsoft.Quantum.Simulation` .

- ✅Операции **размещения,** функции и определяемые пользователем типы используются только в определенных доменах в пространствах имен, указывающих на их домен служебной программы. При необходимости используйте подпространства имен, чтобы указать задачи с особыми задачами в пределах каждого доменного пространства имен.

  *Примеры:*
  - Библиотека машинного обучения, опубликованная корпорацией Майкрософт, во многом помещается в @"microsoft.quantum.machinelearning" пространство имен, но примеры наборов данных предоставляются @"microsoft.quantum.machinelearning.datasets"   пространством имен.
  - API-интерфейсы тактовой химия, опубликованные корпорацией Майкрософт как часть пакета средств разработки тактов, должны быть помещены в `Microsoft.Quantum.Chemistry` . Функциональность, характерная для реализации Иордания--Вигнер, может быть помещена в `Microsoft.Quantum.Chemistry.JordanWigner` , чтобы основной интерфейс для области домена тактовой химия не был связан с реализациями.

**Основной принцип:** Используйте пространства имен и модификаторы доступа вместе, чтобы быть преднамеренными к поверхности API, предоставляемой пользователям, а также для скрытия внутренних сведений, связанных с реализацией и тестированием ваших API.

- ✅ Каждый раз, когда разумно, размещайте все функции и **операции, необходимые** для реализации API, в том же пространстве имен, что и реализуемый API, но помечайте ключевыми словами private или internal, чтобы указать, что они не являются частью общедоступной области API для библиотеки. Используйте имя, начинающееся с символа подчеркивания ( `_` ), чтобы визуально отличать закрытые и внутренние операции и функции от открытых.

  *Примеры:*
  - Имя операции `_Features` указывает на функцию, которая является закрытой для данного пространства имен и сборки, и должна сопровождаться либо `internal` ключевым словом.

- ✅ В редких случаях, когда для реализации API для данного пространства имен требуется обширный набор закрытых функций или операций **, поместите их** в новое пространство имен, соответствующее реализуемому пространству имен и концу `.Private` .

- ✅**Разместите все** модульные тесты в пространствах имен, соответствующие тестируемому пространству имен и заканчивая в `.Tests` .

## <a name="naming-conventions-and-vocabulary"></a>Соглашения об именовании и словарь

**Основной принцип:** Выберите имена и терминологию, которые понятны, доступны и могут быть доступны для чтения в различных аудиториях, в том числе от двух и экспертов.

- ⛔️ **не** следует использовать имена идентификаторов-дискриминатор и исключаемого идентификатора, а также терминологию в комментариях к документации по API.

- ✅**Используйте комментарии** к документации по API для предоставления соответствующего контекста, примеров и ссылок, особенно для более сложных концепций.

- ⛔️ **не** используйте имена идентификаторов, которые необязательно изотерических или требуют значительных знаний для чтения.

  *Примеры:*
  - Предпочитать "итерации" для усиления амплитуды "Гровер итерации".

- ✅**Выберите операции** и имена функций, которые четко сообщают о предполагаемом действии вызываемого, а не его реализации. Обратите внимание, что реализацию можно и следует документировать в [комментариях к документации по API](xref:microsoft.quantum.guide.filestructure#documentation-comments).

  *Примеры:*
  - Поменяйте "перекрытие оценок" на "Хадамард Test", так как в последнем случае происходит реализация предыдущего.

- ✅**Используйте слова** согласованно во всех \# API Q:

  - **Команды**

    - **Assert** : Убедитесь, что предположение о состоянии целевого компьютера и его Кубитс содержит, возможно, с помощью нефизических ресурсов. Операции, использующие эту команду, всегда должны быть безопасно съемными, не влияя на функциональность библиотек и исполняемых программ. Обратите внимание, что в отличие от фактов, утверждения могут, в общем, зависеть от внешнего состояния, такого как состояние регистра кубит, среды выполнения или так далее. Как зависимость от внешнего состояния является разновидностью побочного действия, утверждения должны предоставляться как операции, а не функции.

    - **Оценка** . используя одно или несколько возможных повторных измерений, оцените классический объем из результатов измерения.

      *Примеры:*
      - @"microsoft.quantum.characterization.estimatefrequency"
      - @"microsoft.quantum.characterization.estimateoverlapbetweenstates"

    - **Подготовка** : применение операции-такта или последовательности операций к одному или нескольким Кубитс предполагается начать в определенном начальном состоянии (обычно $ \ket{00\cdots 0} $), что приводит к развитию состояния этих Кубитс до желаемого конечного состояния. Как правило, работа с состояниями, отличными от заданного начального состояния, **может** привести к неопределенному единому преобразованию, но **должно** сохранить операцию и ее смежное "Отмена" и применить оператор No-Op.

      *Примеры:*
      - @"microsoft.quantum.preparation.preparearbitrarystate"
      - @"microsoft.quantum.preparation.prepareuniformsuperposition"

    - **Мера** : применение операции-такта или последовательности операций к одному или нескольким Кубитс, чтение классических данных.

      *Примеры:*
      - @"Microsoft.Quantum.Intrinsic.Measure"
      - @"microsoft.quantum.arithmetic.measurefxp"
      - @"microsoft.quantum.arithmetic.measureinteger"

    - **Применение** : применение операции-такта или последовательности операций к одному или нескольким Кубитс, в результате чего состояние этих Кубитс меняется в согласованном виде. Эта команда является наиболее общей командой в элементе Q \# , и ее **не следует** использовать, если более конкретная команда более релевантна напрямую.

  - **Существительные** :

    - **Факт** . логическое условие, которое зависит только от входных данных, а не от состояния целевого компьютера, его среды или состояния кубитса компьютера. В отличие от утверждения, факт учитывает только *значения* , предоставленные для этого факта. Пример:

      *Примеры:*
      - @"microsoft.quantum.diagnostics.equalityfacti": представляет факт равенства для двух целочисленных значений. либо целые числа, указанные в качестве входных данных, равны друг другу, либо они не зависят от других состояний программы.

    - **Параметры:** Определяемый пользователем тип, содержащий несколько именованных элементов, которые могут действовать как "необязательные аргументы" для функции или операции. Пример:

      *Примеры:*
      - @"microsoft.quantum.machinelearning.trainingoptions"Определяемый пользователем тип включает именованные элементы для обучения, размер уменьшив и другие настраиваемые параметры для машинного обучения.

  - **Прилагательные** :

    - ⛔️ **New** : этот Прилагательный **не следует** использовать, как, чтобы избежать путаницы с его использованием в качестве глагола во многих языках программирования (например, C++, C#, Java, TypeScript, PowerShell).

  - **Предположении:** В некоторых случаях можно использовать варианты размещения для дальнейшей неоднозначности или уточнения ролей существительных и глаголов в именах функций и операций. Однако следует соблюдать осторожность, чтобы сделать это экономно и постоянно.

    - **Как:** Представляет, что входные и выходные данные функции представляют одни и те же сведения, но выходные данные представляют эту информацию **как** *X* , а не исходное представление. Это особенно распространено для функций преобразования типов.

      *Примеры:*
      - `IntAsDouble(2)` Указывает, что входные ( `2` ) и выходные ( `2.0` ) представляют качественно одинаковую информацию, но для этого используются различные \# типы данных Q.

    - **Из:** Чтобы обеспечить согласованность, эту позицию   **не следует** использовать для указания функций преобразования типов или любого другого случая **,** где подходит.

    - ⛔️ **:** **не следует** использовать эту возможность, как во многих языках программирования, чтобы избежать путаницы с ее использованием в качестве глагола.
