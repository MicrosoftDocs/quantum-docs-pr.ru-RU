---
title: Q# Принципы проектирования API
description: Q# Принципы проектирования API
author: cgranade
ms.author: chgranad
ms.date: 3/9/2020
ms.topic: article
uid: microsoft.quantum.contributing.api-design
no-loc:
- Q#
- $$v
ms.openlocfilehash: 8714d3290e4099f901dab20a9ee9334699c4ad81
ms.sourcegitcommit: 9b0d1ffc8752334bd6145457a826505cc31fa27a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/21/2020
ms.locfileid: "90834917"
---
# <a name="no-locq-api-design-principles"></a><span data-ttu-id="7d35b-103">Q# Принципы проектирования API</span><span class="sxs-lookup"><span data-stu-id="7d35b-103">Q# API Design Principles</span></span>

## <a name="introduction"></a><span data-ttu-id="7d35b-104">Введение</span><span class="sxs-lookup"><span data-stu-id="7d35b-104">Introduction</span></span>

<span data-ttu-id="7d35b-105">Как язык и как платформа, дает Q# пользователям возможность создавать, запускать, анализировать и изучать приложения-такты.</span><span class="sxs-lookup"><span data-stu-id="7d35b-105">As a language and as a platform, Q# empowers users to write, run, understand, and explore quantum applications.</span></span>
<span data-ttu-id="7d35b-106">Чтобы расширить возможности пользователей, при проектировании Q# библиотек мы будем следовать набору принципов проектирования API для разработки и помощи в создании пригодных к использованию библиотек для сообщества разработчиков тактов.</span><span class="sxs-lookup"><span data-stu-id="7d35b-106">In order to empower users, when we design Q# libraries, we follow a set of API design principles to guide our designs and to help us make usable libraries for the the quantum development community.</span></span>
<span data-ttu-id="7d35b-107">В этой статье описываются эти принципы и приводятся примеры, которые помогут вам применить их при проектировании Q# API.</span><span class="sxs-lookup"><span data-stu-id="7d35b-107">This article lists these principles, and gives examples to help guide how to apply them when designing Q# APIs.</span></span>

> [!TIP]
> <span data-ttu-id="7d35b-108">Это довольно подробный документ, который предназначен для помощи в разработке библиотек и подробной публикации библиотек.</span><span class="sxs-lookup"><span data-stu-id="7d35b-108">This is a fairly detailed document that's intended to help guide library development and in-depth library contributions.</span></span>
> <span data-ttu-id="7d35b-109">Скорее всего, вы найдете его наиболее полезное, если вы пишете собственные библиотеки в Q# или используете большие функции в [ Q# репозитории библиотек](https://github.com/microsoft/QuantumLibraries).</span><span class="sxs-lookup"><span data-stu-id="7d35b-109">You'll probably find it most useful if you're writing your own libraries in Q#, or if you're contributing larger features to the [Q# libraries repository](https://github.com/microsoft/QuantumLibraries).</span></span>
>
> <span data-ttu-id="7d35b-110">С другой стороны, если вы хотите узнать больше о том, как приступать к работе с пакетом разработки тактов, мы рекомендуем начать с [руководства по публикации](xref:microsoft.quantum.contributing).</span><span class="sxs-lookup"><span data-stu-id="7d35b-110">On the other hand, if you're looking to learn how to contribute to the Quantum Development Kit more generally, we suggest starting with the [contribution guide](xref:microsoft.quantum.contributing).</span></span>
> <span data-ttu-id="7d35b-111">Если вы ищете более общие сведения о том, как мы рекомендуем форматировать Q# код, возможно, вас интересует [руководство по стилю](xref:microsoft.quantum.contributing.style).</span><span class="sxs-lookup"><span data-stu-id="7d35b-111">If you're looking for more general information about how we recommend formatting your Q# code, you may be interested in checking out the [style guide](xref:microsoft.quantum.contributing.style).</span></span>

## <a name="general-principles"></a><span data-ttu-id="7d35b-112">Общие принципы</span><span class="sxs-lookup"><span data-stu-id="7d35b-112">General Principles</span></span>

<span data-ttu-id="7d35b-113">**Основной принцип:** Предоставление API-интерфейсов, которые помещают фокус на приложения-такты.</span><span class="sxs-lookup"><span data-stu-id="7d35b-113">**Key principle:** Expose APIs that places the focus on quantum applications.</span></span>

- <span data-ttu-id="7d35b-114">✅**Выберите операции** и имена функций, отражающие высокоуровневую структуру алгоритмов и приложений.</span><span class="sxs-lookup"><span data-stu-id="7d35b-114">✅ **DO** choose operation and function names that reflect the   high-level structure of algorithms and applications.</span></span>
- <span data-ttu-id="7d35b-115">⛔️ **не** предоставляют интерфейсы API, которые в первую очередь касаются низкоуровневых сведений о реализации.</span><span class="sxs-lookup"><span data-stu-id="7d35b-115">⛔️ **DON'T** expose APIs that focus primarily on low-level   implementation details.</span></span>

<span data-ttu-id="7d35b-116">**Основной принцип:** Запустите каждую конструкцию API с примерами вариантов использования, чтобы обеспечить интуитивное использование API.</span><span class="sxs-lookup"><span data-stu-id="7d35b-116">**Key principle:** Start each API design with sample use cases to ensure that APIs are intuitive to use.</span></span>

- <span data-ttu-id="7d35b-117">✅**Убедитесь, что каждый** компонент общедоступного API имеет соответствующий вариант использования, вместо того чтобы пытаться проектировать все возможные использования с самого начала.</span><span class="sxs-lookup"><span data-stu-id="7d35b-117">✅ **DO** ensure that each component of a public API has a corresponding use case, rather than trying to design for all possible uses from the start.</span></span>
    <span data-ttu-id="7d35b-118">Иначе говоря, не следует создавать общедоступные API на случай, если они полезны, но убедитесь, что каждая часть API имеет *конкретный* пример, в котором он будет полезен.</span><span class="sxs-lookup"><span data-stu-id="7d35b-118">Put differently, don't introduce public APIs in case they are useful, but make sure that each part of an API has a *concrete* example in which it will be useful.</span></span>

  <span data-ttu-id="7d35b-119">*Примеры:*</span><span class="sxs-lookup"><span data-stu-id="7d35b-119">*Examples:*</span></span>
  - <span data-ttu-id="7d35b-120">@"microsoft.quantum.canon.applytoeachca" можно использовать `ApplyToEachCA(H, _)` для подготовки регистров в едином состоянии геопозиционирования, общей задаче во многих тактовых алгоритмах.</span><span class="sxs-lookup"><span data-stu-id="7d35b-120">@"microsoft.quantum.canon.applytoeachca" can be used as `ApplyToEachCA(H, _)` to prepare registers in a uniform superposition state, a common task in many quantum algorithms.</span></span> <span data-ttu-id="7d35b-121">Эту же операцию можно также использовать для многих других задач в подготовке, цифровых и алгоритмах на основе Oracle.</span><span class="sxs-lookup"><span data-stu-id="7d35b-121">The same operation can also be used for many other tasks in preparation, numerics, and oracle-based algorithms.</span></span>

- <span data-ttu-id="7d35b-122">✅**Выполните** мозговые штурмы и познакомьтесь с новыми разработками API, чтобы убедиться, что они интуитивно понятны и соответствуют предложенным вариантам использования.</span><span class="sxs-lookup"><span data-stu-id="7d35b-122">✅ **DO** brainstorm and workshop new API designs to double-check   that they are intuitive and meet proposed use cases.</span></span>

  <span data-ttu-id="7d35b-123">*Примеры:*</span><span class="sxs-lookup"><span data-stu-id="7d35b-123">*Examples:*</span></span>
  - <span data-ttu-id="7d35b-124">Просмотрите текущий \# код Q, чтобы увидеть, как новые разработки API могут упростить и прояснить существующие реализации.</span><span class="sxs-lookup"><span data-stu-id="7d35b-124">Inspect current Q\# code to see how new API designs could   simplify and clarify existing implementations.</span></span>
  - <span data-ttu-id="7d35b-125">Изучите предлагаемые макеты API с представителями основных аудиторий.</span><span class="sxs-lookup"><span data-stu-id="7d35b-125">Review proposed API designs with representatives of primary   audiences.</span></span>

<span data-ttu-id="7d35b-126">**Основной принцип:** Разработка API-интерфейсов для поддержки и обеспечения читаемости кода.</span><span class="sxs-lookup"><span data-stu-id="7d35b-126">**Key principle:** Design APIs to support and encourage readable code.</span></span>

- <span data-ttu-id="7d35b-127">✅**Убедитесь, что код** доступен для чтения экспертами по доменам и другим специалистам.</span><span class="sxs-lookup"><span data-stu-id="7d35b-127">✅ **DO** ensure that code is readable by domain experts and   non-experts alike.</span></span>
- <span data-ttu-id="7d35b-128">✅**Разместите фокус** на влиянии каждой операции и функции в рамках алгоритма высокого уровня, используя документацию, чтобы углубиться в детали реализации по мере необходимости.</span><span class="sxs-lookup"><span data-stu-id="7d35b-128">✅ **DO** place the focus on the effects of each operation and   function within the high-level algorithm, using documentation to   delve into implementation details as appropriate.</span></span>
- <span data-ttu-id="7d35b-129">✅При **необходимости следуйте** стандартному [ \# руководству по стилю Q](xref:microsoft.quantum.contributing.style) .</span><span class="sxs-lookup"><span data-stu-id="7d35b-129">✅ **DO** follow the common [Q\# style guide](xref:microsoft.quantum.contributing.style) whenever applicable.</span></span>

<span data-ttu-id="7d35b-130">**Основной принцип:** Разработка API-интерфейсов для стабильной и обеспечения прямой совместимости.</span><span class="sxs-lookup"><span data-stu-id="7d35b-130">**Key principle:** Design APIs to be stable and to provide forward compatibility.</span></span>

- <span data-ttu-id="7d35b-131">✅**Не следует** корректно использовать старые API, если требуются критические изменения.</span><span class="sxs-lookup"><span data-stu-id="7d35b-131">✅ **DO** deprecate old APIs gracefully when breaking changes are   required.</span></span>

- <span data-ttu-id="7d35b-132">✅**Предоставляют операции** и функции "оболочки совместимости", позволяющие корректно работать с кодом пользователя во время устаревания.</span><span class="sxs-lookup"><span data-stu-id="7d35b-132">✅ **DO** provide "shim" operations and functions that allow   existing user code to operate correctly during deprecation.</span></span>

  <span data-ttu-id="7d35b-133">*Примеры:*</span><span class="sxs-lookup"><span data-stu-id="7d35b-133">*Examples:*</span></span>
  - <span data-ttu-id="7d35b-134">При переименовании операции `EstimateExpectation` с именем в   `EstimateAverage` вводится новая операция   `EstimateExpectation` , которая вызывает исходную операцию с новым именем, чтобы существующий код мог продолжать работать правильно.</span><span class="sxs-lookup"><span data-stu-id="7d35b-134">When renaming an operation called `EstimateExpectation` to   `EstimateAverage`, introduce a new operation called   `EstimateExpectation` that calls the original operation at   its new name, so that existing code can continue to work   correctly.</span></span>

- <span data-ttu-id="7d35b-135">✅**Используйте** @"microsoft.quantum.core.deprecated" атрибут для передачи устаревших информации пользователю.</span><span class="sxs-lookup"><span data-stu-id="7d35b-135">✅ **DO** use the @"microsoft.quantum.core.deprecated" attribute to communicate deprecations to the user.</span></span>

- <span data-ttu-id="7d35b-136">✅ При переименовании операции или **функции укажите новое** имя в качестве входных строк для `@Deprecated` .</span><span class="sxs-lookup"><span data-stu-id="7d35b-136">✅ When renaming an operation or function, **DO** provide the new   name as a string input to `@Deprecated`.</span></span>

- <span data-ttu-id="7d35b-137">⛔️ **не** удаляйте существующие функции или операции без срока действия не менее 6 месяцев для предварительных выпусков или по крайней мере два года для поддерживаемых выпусков.</span><span class="sxs-lookup"><span data-stu-id="7d35b-137">⛔️ **DON'T** remove existing functions or operations without a   deprecation period of at least six months for preview releases,   or at least two years for supported releases.</span></span>

## <a name="functions-and-operations"></a><span data-ttu-id="7d35b-138">Функции и операции</span><span class="sxs-lookup"><span data-stu-id="7d35b-138">Functions and Operations</span></span>

<span data-ttu-id="7d35b-139">**Основной принцип.** убедитесь, что каждая функция и операция имеет одну четко определенную цель в API.</span><span class="sxs-lookup"><span data-stu-id="7d35b-139">**Key principle:** ensure that every function and operation has a single well-defined purpose within the API.</span></span>

- <span data-ttu-id="7d35b-140">⛔️ **не** предоставляют функции и операции, выполняющие несколько несвязанных задач.</span><span class="sxs-lookup"><span data-stu-id="7d35b-140">⛔️ **DON'T** expose functions and operations that perform multiple   unrelated tasks.</span></span>

<span data-ttu-id="7d35b-141">**Основной принцип:** функции проектирования и операции должны быть максимально пригодными для повторного использования, а также для ожидаемых будущих потребностей.</span><span class="sxs-lookup"><span data-stu-id="7d35b-141">**Key principle:** design functions and operations to be as reusable as possible, and to anticipate future needs.</span></span>

- <span data-ttu-id="7d35b-142">✅**Разработайте** функции и операции с другими функциями и операциями в одном API и в ранее существующих библиотеках.</span><span class="sxs-lookup"><span data-stu-id="7d35b-142">✅ **DO** design functions and operations to compose well with other   functions and operations, both in the same API and in previously   existing libraries.</span></span>

  <span data-ttu-id="7d35b-143">*Примеры:*</span><span class="sxs-lookup"><span data-stu-id="7d35b-143">*Examples:*</span></span>
  - <span data-ttu-id="7d35b-144">@"microsoft.quantum.canon.delay"Операция принимает минимальные предположения о входных данных и, таким образом, может использоваться для задержки приложений любой из этих операций в Q# стандартной библиотеке или в соответствии с определением пользователей.</span><span class="sxs-lookup"><span data-stu-id="7d35b-144">The @"microsoft.quantum.canon.delay" operation makes minimal assumptions about its input, and thus can be used to delay applications of either operations across the Q# standard library or as defined by users.</span></span>
    <!-- TODO: define bad example. -->

- <span data-ttu-id="7d35b-145">✅**Предоставьте чисто** детерминированную классический классическую логику как функции, а не операции.</span><span class="sxs-lookup"><span data-stu-id="7d35b-145">✅ **DO** expose purely deterministic classical logic as   as functions rather than operations.</span></span>

  <span data-ttu-id="7d35b-146">*Примеры:*</span><span class="sxs-lookup"><span data-stu-id="7d35b-146">*Examples:*</span></span>
  - <span data-ttu-id="7d35b-147">Подпрограммы, которые возвращающие входные данные с плавающей запятой, могут быть написаны детерминированным образом, поэтому они должны предоставляться пользователю как, `Squared : Double -> Double` а не как операции `Square : Double => Double` .</span><span class="sxs-lookup"><span data-stu-id="7d35b-147">A subroutine which squares its floating-point input can be written deterministically, and so should be exposed to the user as `Squared : Double -> Double` rather than as an operation `Square : Double => Double`.</span></span> <span data-ttu-id="7d35b-148">Это позволяет вызывать подпрограммы в большем числе (например, в других функциях) и предоставляет компилятору полезные сведения о оптимизации, которые могут повлиять на производительность и оптимизацию.</span><span class="sxs-lookup"><span data-stu-id="7d35b-148">This allows for the subroutine to be called in more places (e.g.: inside of other functions), and provides useful optimization information to the compiler that can affect performance and optimizations.</span></span>
  - <span data-ttu-id="7d35b-149">`ForEach<'TInput, 'TOutput>('TInput => 'TOutput, 'TInput[]) => 'TOutput[]` и `Mapped<'TInput, 'TOutput>('TInput -> 'TOutput, 'TInput[]) -> 'TOutput[]` различаются в отношении детерминированности. оба варианта полезны в различных обстоятельствах.</span><span class="sxs-lookup"><span data-stu-id="7d35b-149">`ForEach<'TInput, 'TOutput>('TInput => 'TOutput, 'TInput[]) => 'TOutput[]` and `Mapped<'TInput, 'TOutput>('TInput -> 'TOutput, 'TInput[]) -> 'TOutput[]` differ in the guarantees made with respect to   determinism; both are useful in different circumstances.</span></span>
  - <span data-ttu-id="7d35b-150">Подпрограммы API, которые преобразуют приложение операций с тактовой частотой, часто выполняются в детерминированном виде, поэтому их можно сделать доступными в виде таких функций, как   `CControlled<'T>(op : 'T => Unit) => ((Bool, 'T) => Unit)` .</span><span class="sxs-lookup"><span data-stu-id="7d35b-150">API routines that transform the application of quantum   operations can often be carried out in a deterministic     fashion and hence can be made available as functions such as   `CControlled<'T>(op : 'T => Unit) => ((Bool, 'T) => Unit)`.</span></span>

- <span data-ttu-id="7d35b-151">✅**Выполните** обобщение типа входных данных настолько, насколько целесообразно для каждой функции и операции, используя параметры типа по мере необходимости.</span><span class="sxs-lookup"><span data-stu-id="7d35b-151">✅ **DO** generalize the input type as much as reasonable for each   function and operation, using type parameters as needed.</span></span>

  <span data-ttu-id="7d35b-152">*Примеры:*</span><span class="sxs-lookup"><span data-stu-id="7d35b-152">*Examples:*</span></span>
  - <span data-ttu-id="7d35b-153">`ApplyToEach` имеет тип `<'T>(('T => Unit), 'T[]) => Unit` , а не конкретный тип наиболее распространенного приложения `((Qubit => Unit), Qubit[]) => Unit` .</span><span class="sxs-lookup"><span data-stu-id="7d35b-153">`ApplyToEach` has type `<'T>(('T => Unit), 'T[]) => Unit` rather than the specific type of its most common   application, `((Qubit => Unit), Qubit[]) => Unit`.</span></span>

> [!TIP]
> <span data-ttu-id="7d35b-154">Важно предусмотреть будущие потребности, но также важно решить конкретные проблемы для пользователей.</span><span class="sxs-lookup"><span data-stu-id="7d35b-154">It is important to anticipate future needs, but it is also important to solve concrete problems for your users.</span></span>
> <span data-ttu-id="7d35b-155">В силу этого принципа работы с ключевыми словами всегда требует тщательного рассмотрения и балансировки, чтобы не разрабатывать интерфейсы API «только на тот случай».</span><span class="sxs-lookup"><span data-stu-id="7d35b-155">Acting on this key principle thus always requires careful consideration and balancing to avoid developing APIs "just in case."</span></span>

<span data-ttu-id="7d35b-156">**Основной принцип:** Выбор входных и выходных типов для функций и операций, которые являются прогнозируемыми и взаимодействуют с целью вызова.</span><span class="sxs-lookup"><span data-stu-id="7d35b-156">**Key principle:** choose input and output types for functions and operations that are predictable, and that communicate the purpose of a callable.</span></span>

- <span data-ttu-id="7d35b-157">✅**Используйте типы** кортежей для логической группировки входных и выходных данных, которые учитываются только вместе.</span><span class="sxs-lookup"><span data-stu-id="7d35b-157">✅ **DO** use tuple types to logically group inputs and outputs that are only significant when considered together.</span></span> <span data-ttu-id="7d35b-158">В таких случаях рассмотрите возможность использования определяемого пользователем типа.</span><span class="sxs-lookup"><span data-stu-id="7d35b-158">Consider using a user-defined type in these cases.</span></span>

  <span data-ttu-id="7d35b-159">*Примеры:*</span><span class="sxs-lookup"><span data-stu-id="7d35b-159">*Examples:*</span></span>
  - <span data-ttu-id="7d35b-160">Функции для вывода локального прыжка другой функции может потребоваться использовать границы интервала поиска в качестве входных данных, что `LocalMinima(fn : (Double -> Double), (left : Double, right : Double)) : Double` может быть соответствующей сигнатурой.</span><span class="sxs-lookup"><span data-stu-id="7d35b-160">A function to output the local minima of another function   may need to take bounds of a search interval as input, such   that `LocalMinima(fn : (Double -> Double), (left : Double, right : Double)) : Double` may be an appropriate signature.</span></span>
  - <span data-ttu-id="7d35b-161">Операция для оценки производного классификатора машинного обучения с использованием метода сдвига параметров может потребовать смещения векторов параметров с сдвигом и без сдвига в качестве входных данных.</span><span class="sxs-lookup"><span data-stu-id="7d35b-161">An operation to estimate a derivative of a machine learning classifier using the parameter shift technique may need to take both the shifted and unshifted parameter vectors as inputs.</span></span> <span data-ttu-id="7d35b-162">`(unshifted : Double[], shifted : Double[])`В этом случае может быть уместным вводом, похожим на.</span><span class="sxs-lookup"><span data-stu-id="7d35b-162">An input similar to `(unshifted : Double[], shifted : Double[])` may be appropriate in this case.</span></span>

- <span data-ttu-id="7d35b-163">✅**Упорядочение** элементов в входных и выходных кортежах согласованно между различными функциями и операциями.</span><span class="sxs-lookup"><span data-stu-id="7d35b-163">✅ **DO** order items in input and output tuples consistently   across different functions and operations.</span></span>

  <span data-ttu-id="7d35b-164">*Примеры:*</span><span class="sxs-lookup"><span data-stu-id="7d35b-164">*Examples:*</span></span>
  - <span data-ttu-id="7d35b-165">При рассмотрении двух функций или операций, каждый из которых принимает угол поворота и целевой кубит в качестве входных данных, убедитесь, что они упорядочены одинаково в каждом входном кортеже.</span><span class="sxs-lookup"><span data-stu-id="7d35b-165">If considering two or functions or operations that each take a rotation angle and a target qubit as inputs, ensure that they are ordered the same in each input tuple.</span></span> <span data-ttu-id="7d35b-166">То есть, предпочитаете `ApplyRotation(angle : Double, target : Qubit) : Unit is Adj + Ctl` и `DelayedRotation(angle : Double, target : Qubit) : (Unit => Unit is Adj + Ctl)` `ApplyRotation(target : Qubit, angle : Double) : Unit is Adj + Ctl` `DelayedRotation(angle : Double, target : Qubit) : (Unit => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="7d35b-166">That is, prefer `ApplyRotation(angle : Double, target : Qubit) : Unit is Adj + Ctl` and `DelayedRotation(angle : Double, target : Qubit) : (Unit => Unit is Adj + Ctl)` to `ApplyRotation(target : Qubit, angle : Double) : Unit is Adj + Ctl` and `DelayedRotation(angle : Double, target : Qubit) : (Unit => Unit is Adj + Ctl)`.</span></span>

<span data-ttu-id="7d35b-167">**Основной принцип:** функции и операции проектирования, которые хорошо работают с \# функциями языка Q, такими как частичное применение.</span><span class="sxs-lookup"><span data-stu-id="7d35b-167">**Key principle:** design functions and operations to work well with Q\# language features such as partial application.</span></span>

- <span data-ttu-id="7d35b-168">✅**Упорядочивайте** элементы во входных кортежах таким образом, чтобы наиболее часто применяемые входные данные выполнялись первыми (т. е. так что частичное приложение работает аналогично карринг).</span><span class="sxs-lookup"><span data-stu-id="7d35b-168">✅ **DO** order items in input tuples such that the most commonly   applied inputs occur first (i.e.: so that partial application   acts similarly to currying).</span></span>

  <span data-ttu-id="7d35b-169">*Примеры:*</span><span class="sxs-lookup"><span data-stu-id="7d35b-169">*Examples:*</span></span>
  - <span data-ttu-id="7d35b-170">Операция `ApplyRotation` , которая принимает число с плавающей запятой и кубит в качестве входных данных, часто может быть частично применена с входными данными с плавающей запятой для использования с операциями, ожидающими ввода типа `Qubit => Unit` .</span><span class="sxs-lookup"><span data-stu-id="7d35b-170">An operation `ApplyRotation` that takes a floating-point number and a qubit as inputs may often be partially applied with the floating-point input first for use with operations that expect an input of type `Qubit => Unit`.</span></span> <span data-ttu-id="7d35b-171">Таким словами, сигнатура `operation ApplyRotation(angle : Double, target : Qubit) : Unit is Adj + Ctl`</span><span class="sxs-lookup"><span data-stu-id="7d35b-171">Thus, a signature of `operation ApplyRotation(angle : Double, target : Qubit) : Unit is Adj + Ctl`</span></span>
      <span data-ttu-id="7d35b-172">будет работать наиболее согласованно с частичным приложением.</span><span class="sxs-lookup"><span data-stu-id="7d35b-172">would work most consistently with partial application.</span></span>
  - <span data-ttu-id="7d35b-173">Как правило, это руководство означает размещение всех классических данных до всех Кубитс во входных кортежах, но используйте хорошее соблюдаство и изучите способ вызова API на практике.</span><span class="sxs-lookup"><span data-stu-id="7d35b-173">Typically, this guidance means placing all classical data   before all qubits in input tuples, but use good judgment and   examine how your API is called in practice.</span></span>

## <a name="user-defined-types"></a><span data-ttu-id="7d35b-174">Определяемые пользователем типы</span><span class="sxs-lookup"><span data-stu-id="7d35b-174">User-Defined Types</span></span>

<span data-ttu-id="7d35b-175">**Основной принцип.** используйте определяемые пользователем типы, чтобы сделать интерфейсы API более выразительными и удобными для использования.</span><span class="sxs-lookup"><span data-stu-id="7d35b-175">**Key principle:** use user-defined types to help make APIs more expressive and convenient to use.</span></span>

- <span data-ttu-id="7d35b-176">✅**Познакомьтесь с** новыми пользовательскими типами, чтобы предоставить полезную краткую форму для длинных и/или сложных типов.</span><span class="sxs-lookup"><span data-stu-id="7d35b-176">✅ **DO** introduce new user-defined types to provide helpful   shorthand for long and/or complicated types.</span></span>

  <span data-ttu-id="7d35b-177">*Примеры:*</span><span class="sxs-lookup"><span data-stu-id="7d35b-177">*Examples:*</span></span>
  - <span data-ttu-id="7d35b-178">В случаях, когда тип операции с тремя входными данными массива кубит обычно принимается в качестве входных данных или возвращается в виде выходных данных, предоставляя определяемый пользователем типов, например `newtype TimeDependentBlockEncoding = ((Qubit[], Qubit[], Qubit[]) => Unit is Adj + Ctl)`</span><span class="sxs-lookup"><span data-stu-id="7d35b-178">In cases where an operation type with three qubit array inputs is commonly taken as an input or returned as an output, providing a UDT such as `newtype TimeDependentBlockEncoding = ((Qubit[], Qubit[], Qubit[]) => Unit is Adj + Ctl)`</span></span>
      <span data-ttu-id="7d35b-179">может помочь в обеспечении удобной краткости.</span><span class="sxs-lookup"><span data-stu-id="7d35b-179">can help provide a useful shorthand.</span></span>

- <span data-ttu-id="7d35b-180">✅**Познакомьтесь с** новыми определяемыми пользователем типами, чтобы указать, что данный базовый тип следует использовать только в определенном смысле.</span><span class="sxs-lookup"><span data-stu-id="7d35b-180">✅ **DO** introduce new user-defined types to indicate that a given   base type should only be used in a very particular sense.</span></span>

  <span data-ttu-id="7d35b-181">*Примеры:*</span><span class="sxs-lookup"><span data-stu-id="7d35b-181">*Examples:*</span></span>
  - <span data-ttu-id="7d35b-182">Операция, которая должна интерпретироваться в виде операции, которая кодирует классические данные в реестр такта, может быть пригодна для меток с определяемым пользователем типом `newtype InputEncoder = (Apply : (Qubit[] => Unit))` .</span><span class="sxs-lookup"><span data-stu-id="7d35b-182">An operation that should be interpreted specifically as an   operation that encodes classical data into a quantum   register may be appropriate to label with a user-defined   type `newtype InputEncoder = (Apply : (Qubit[] => Unit))`.</span></span>

- <span data-ttu-id="7d35b-183">✅Представите новые определяемые пользователем типы с именованными элементами, которые **позволяют реализовать** дальнейшую расширяемость (например, структуру результатов, которая может содержать дополнительные именованные элементы в будущем).</span><span class="sxs-lookup"><span data-stu-id="7d35b-183">✅ **DO** introduce new user-defined types with named items that   allow for future extensibility (e.g.: a results structure that   may contain additional named items in the future).</span></span>

  <span data-ttu-id="7d35b-184">*Примеры:*</span><span class="sxs-lookup"><span data-stu-id="7d35b-184">*Examples:*</span></span>
  - <span data-ttu-id="7d35b-185">Если операция `TrainModel` предоставляет большое количество параметров конфигурации, предоставление этих вариантов в качестве нового   `TrainingOptions` определяемого пользователем типа и предоставление новой функции   `DefaultTrainingOptions : Unit -> TrainingOptions` позволяет пользователям переопределять определенные именованные элементы в траинингоптионс UDT, одновременно позволяя разработчикам библиотек добавлять новые элементы определяемого пользователем типа.</span><span class="sxs-lookup"><span data-stu-id="7d35b-185">When an operation `TrainModel` exposes a large number of   configuration options, exposing these options as a new   `TrainingOptions` UDT and providing a new function   `DefaultTrainingOptions : Unit -> TrainingOptions` allows   users to override specific named items in TrainingOptions   UDT values while still allowing library developers to add   new UDT items as appropriate.</span></span>

- <span data-ttu-id="7d35b-186">✅**Объявите** именованные элементы для новых определяемых пользователем типов в предпочтениях, чтобы требовать от пользователей знание правильного деконструкции кортежа.</span><span class="sxs-lookup"><span data-stu-id="7d35b-186">✅ **DO** declare named items for new user-defined types in   preference to requiring users to know the correct tuple   deconstruction.</span></span>

  <span data-ttu-id="7d35b-187">*Примеры:*</span><span class="sxs-lookup"><span data-stu-id="7d35b-187">*Examples:*</span></span>
  - <span data-ttu-id="7d35b-188">Если представляет комплексное число в его полярной декомпозиции, предпочтительно   `newtype ComplexPolar = (Magnitude: Double, Argument: Double)`   `newtype ComplexPolar = (Double, Double)` .</span><span class="sxs-lookup"><span data-stu-id="7d35b-188">When representing a complex number in its polar   decomposition, prefer   `newtype ComplexPolar = (Magnitude: Double, Argument: Double)` to   `newtype ComplexPolar = (Double, Double)`.</span></span>

<span data-ttu-id="7d35b-189">**Основной принцип.** используйте определяемые пользователем типы данных, чтобы сократить изученную нагрузку и не требовать от пользователя изучать дополнительные понятия и номенклатуру.</span><span class="sxs-lookup"><span data-stu-id="7d35b-189">**Key principle:** use user-defined types in ways reduce  cognitive load and that don't require the user to learn additional concepts and nomenclature.</span></span>

- <span data-ttu-id="7d35b-190">⛔️ **не** представить определяемые пользователем типы, требующие частого использования оператора распаковки ( `!` ) или, для которого обычно требуется несколько уровней растекания.</span><span class="sxs-lookup"><span data-stu-id="7d35b-190">⛔️ **DON'T** introduce user-defined types that require the user to make frequent use of the unwrap operator (`!`), or that commonly require multiple levels of unwrapping.</span></span> <span data-ttu-id="7d35b-191">Возможные стратегии по устранению рисков:</span><span class="sxs-lookup"><span data-stu-id="7d35b-191">Possible mitigation strategies include:</span></span>

  - <span data-ttu-id="7d35b-192">При предоставлении определяемого пользователем типа с одним элементом рассмотрите возможность определения имени этого элемента.</span><span class="sxs-lookup"><span data-stu-id="7d35b-192">When exposing a user-defined type with a single item, consider defining a name for that item.</span></span> <span data-ttu-id="7d35b-193">Например, рассмотрим `newtype Encoder = (Apply : (Qubit[] => Unit is Adj + Ctl))` в качестве предпочтений `newtype Encoder = (Qubit[] => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="7d35b-193">For instance, consider `newtype Encoder = (Apply : (Qubit[] => Unit is Adj + Ctl))` in preference to `newtype Encoder = (Qubit[] => Unit is Adj + Ctl)`.</span></span>

  - <span data-ttu-id="7d35b-194">Обеспечение того, что другие функции и операции могут принимать "инкапсулированные" экземпляры UDT напрямую.</span><span class="sxs-lookup"><span data-stu-id="7d35b-194">Ensuring that other functions and operations can accept   "wrapped" UDT instances directly.</span></span>

- <span data-ttu-id="7d35b-195">⛔️ **не** добавлять новые определяемые пользователем типы, которые дублируют встроенные типы, не предоставляя дополнительных выразительностей.</span><span class="sxs-lookup"><span data-stu-id="7d35b-195">⛔️ **DON'T** introduce new user-defined types that duplicate   built-in types without providing additional expressiveness.</span></span>

  <span data-ttu-id="7d35b-196">*Примеры:*</span><span class="sxs-lookup"><span data-stu-id="7d35b-196">*Examples:*</span></span>
  - <span data-ttu-id="7d35b-197">Определяемый пользователем тип `newtype QubitRegister = Qubit[]` не предоставляет дополнительного выразительности по сравнению `Qubit[]` с, поэтому он труднее использовать без чрезмерно допустимого преимущества.</span><span class="sxs-lookup"><span data-stu-id="7d35b-197">A UDT `newtype QubitRegister = Qubit[]` provides no   additional expressiveness over `Qubit[]`, and is thus harder   to use with no discernable benefit.</span></span>
  - <span data-ttu-id="7d35b-198">Определяемый пользователем тип `newtype LittleEndian = Qubit[]` документирует, как базовый регистр используется и интерпретируется, что обеспечивает дополнительную выразительность по сравнению с базовым типом.</span><span class="sxs-lookup"><span data-stu-id="7d35b-198">A UDT `newtype LittleEndian = Qubit[]` documents how the   underlying register is to be used and interpreted, and thus   provides additional expressiveness over its base type.</span></span>

- <span data-ttu-id="7d35b-199">⛔️ **не** следует добавлять функции доступа, если не требуется строгое требование;   в этом случае настоятельно рекомендуется использовать именованные элементы.</span><span class="sxs-lookup"><span data-stu-id="7d35b-199">⛔️ **DON'T** introduce accessor functions unless strictly required;   strongly prefer named items in this case.</span></span>

  <span data-ttu-id="7d35b-200">*Примеры:*</span><span class="sxs-lookup"><span data-stu-id="7d35b-200">*Examples:*</span></span>
  - <span data-ttu-id="7d35b-201">При внедрении определяемого пользователем типа `newtype Complex = (Double, Double)` предпочтительнее изменить его в   `newtype Complex = (Real : Double, Imag : Double)` для введения функций `GetReal : Complex -> Double` и   `GetImag : Complex -> Double` .</span><span class="sxs-lookup"><span data-stu-id="7d35b-201">When introducing a UDT `newtype Complex = (Double, Double)`,   prefer modifying the definition to   `newtype Complex = (Real : Double, Imag : Double)` to introducing   functions `GetReal : Complex -> Double` and   `GetImag : Complex -> Double`.</span></span>

## <a name="namespaces-and-organization"></a><span data-ttu-id="7d35b-202">Пространства имен и Организация</span><span class="sxs-lookup"><span data-stu-id="7d35b-202">Namespaces and Organization</span></span>

<span data-ttu-id="7d35b-203">**Основной принцип:** выберите имена пространств имен, которые являются прогнозируемыми и четко сообщают назначение функций, операций и определяемых пользователем типов в каждом пространстве имен.</span><span class="sxs-lookup"><span data-stu-id="7d35b-203">**Key principle:** choose namespace names that are predictable and that clearly communicate the purpose of functions, operations, and user-defined types in each namespace.</span></span>

- <span data-ttu-id="7d35b-204">✅Имена пространств имен **следует** заменять на `Publisher.Product.DomainArea` .</span><span class="sxs-lookup"><span data-stu-id="7d35b-204">✅ **DO** name namespaces as `Publisher.Product.DomainArea`.</span></span>

  <span data-ttu-id="7d35b-205">*Примеры:*</span><span class="sxs-lookup"><span data-stu-id="7d35b-205">*Examples:*</span></span>
  - <span data-ttu-id="7d35b-206">Функции, операции и определяемые пользователем типы, опубликованные корпорацией Майкрософт в качестве части функции моделирования такта в пакете разработки тактов, помещаются в   `Microsoft.Quantum.Simulation` пространство имен.</span><span class="sxs-lookup"><span data-stu-id="7d35b-206">Functions, operations, and UDTs published by Microsoft as a   part of the quantum simulation feature of the Quantum   Development Kit are placed in the   `Microsoft.Quantum.Simulation` namespace.</span></span>
  - <span data-ttu-id="7d35b-207">`Microsoft.Quantum.Math` представляет пространство имен, опубликованное корпорацией Майкрософт в составе пакета средств разработки такта, относящегося к доменной области математики.</span><span class="sxs-lookup"><span data-stu-id="7d35b-207">`Microsoft.Quantum.Math` represents a namespace   published by Microsoft as part of the Quantum Development   Kit pertaining to the mathematics domain area.</span></span>

- <span data-ttu-id="7d35b-208">✅**Помещайте операции** , функции и определяемые пользователем типы, используемые для определенных функций, в пространство имен, которое описывает эти функциональные возможности, даже если эти функции используются в разных доменах проблем.</span><span class="sxs-lookup"><span data-stu-id="7d35b-208">✅ **DO** place operations, functions, and user-defined types used   for specific functionality into a namespace that describes that   functionality, even when that functionality is used across   different problem domains.</span></span>

  <span data-ttu-id="7d35b-209">*Примеры:*</span><span class="sxs-lookup"><span data-stu-id="7d35b-209">*Examples:*</span></span>
  - <span data-ttu-id="7d35b-210">API-интерфейсы подготовки состояния, опубликованные корпорацией Майкрософт в составе пакета средств разработки тактов, помещаются в   `Microsoft.Quantum.Preparation` .</span><span class="sxs-lookup"><span data-stu-id="7d35b-210">State preparation APIs published by Microsoft as a part of   the Quantum Development Kit would be placed into   `Microsoft.Quantum.Preparation`.</span></span>
  - <span data-ttu-id="7d35b-211">Интерфейсы API моделирования тактов, опубликованные корпорацией Майкрософт в составе пакета средств разработки тактов, помещаются в   `Microsoft.Quantum.Simulation` .</span><span class="sxs-lookup"><span data-stu-id="7d35b-211">Quantum simulation APIs published by Microsoft as a part of the Quantum   Development Kit would be placed into   `Microsoft.Quantum.Simulation`.</span></span>

- <span data-ttu-id="7d35b-212">✅Операции **размещения,** функции и определяемые пользователем типы используются только в определенных доменах в пространствах имен, указывающих на их домен служебной программы.</span><span class="sxs-lookup"><span data-stu-id="7d35b-212">✅ **DO** place operations, functions, and user-defined types used only within specific domains into namespaces indicating their domain of utility.</span></span> <span data-ttu-id="7d35b-213">При необходимости используйте подпространства имен, чтобы указать задачи с особыми задачами в пределах каждого доменного пространства имен.</span><span class="sxs-lookup"><span data-stu-id="7d35b-213">If needed, use subnamespaces to indicate focused tasks within each domain-specific namespace.</span></span>

  <span data-ttu-id="7d35b-214">*Примеры:*</span><span class="sxs-lookup"><span data-stu-id="7d35b-214">*Examples:*</span></span>
  - <span data-ttu-id="7d35b-215">Библиотека машинного обучения, опубликованная корпорацией Майкрософт, во многом помещается в @"microsoft.quantum.machinelearning" пространство имен, но примеры наборов данных предоставляются @"microsoft.quantum.machinelearning.datasets"   пространством имен.</span><span class="sxs-lookup"><span data-stu-id="7d35b-215">The quantum machine learning library published by Microsoft is largely   placed into the @"microsoft.quantum.machinelearning" namespace, but example   datasets are provided by the @"microsoft.quantum.machinelearning.datasets"   namespace.</span></span>
  - <span data-ttu-id="7d35b-216">API-интерфейсы тактовой химия, опубликованные корпорацией Майкрософт как часть пакета средств разработки тактов, должны быть помещены в `Microsoft.Quantum.Chemistry` .</span><span class="sxs-lookup"><span data-stu-id="7d35b-216">Quantum chemistry APIs published by Microsoft as a part of the Quantum Development Kit should be placed into `Microsoft.Quantum.Chemistry`.</span></span> <span data-ttu-id="7d35b-217">Функциональность, характерная для реализации Иордания--Вигнер, может быть помещена в `Microsoft.Quantum.Chemistry.JordanWigner` , чтобы основной интерфейс для области домена тактовой химия не был связан с реализациями.</span><span class="sxs-lookup"><span data-stu-id="7d35b-217">Functionality specific to implementing the Jordan--Wigner decomposition may be placed in `Microsoft.Quantum.Chemistry.JordanWigner`, so that the primary interface for the quantum chemistry domain area is not concerned with implementations.</span></span>

<span data-ttu-id="7d35b-218">**Основной принцип:** Используйте пространства имен и модификаторы доступа вместе, чтобы быть преднамеренными к поверхности API, предоставляемой пользователям, а также для скрытия внутренних сведений, связанных с реализацией и тестированием ваших API.</span><span class="sxs-lookup"><span data-stu-id="7d35b-218">**Key principle:** Use namespaces and access modifiers together to be intentional about the API surface exposed to users, and to hide internal details related to implementation and testing of your APIs.</span></span>

- <span data-ttu-id="7d35b-219">✅ Каждый раз, когда разумно, размещайте все функции и **операции, необходимые** для реализации API, в том же пространстве имен, что и реализуемый API, но помечайте ключевыми словами private или internal, чтобы указать, что они не являются частью общедоступной области API для библиотеки.</span><span class="sxs-lookup"><span data-stu-id="7d35b-219">✅ Whenever reasonable, **DO** place all functions and operations needed to implement an API into the same namespace as the API being implemented, but marked with the "private" or "internal" keywords to indicate that they are not part of the public API surface for a library.</span></span> <span data-ttu-id="7d35b-220">Используйте имя, начинающееся с символа подчеркивания ( `_` ), чтобы визуально отличать закрытые и внутренние операции и функции от открытых.</span><span class="sxs-lookup"><span data-stu-id="7d35b-220">Use a name beginning with an underscore (`_`) to visually distinguish private and internal operations and functions from public callables.</span></span>

  <span data-ttu-id="7d35b-221">*Примеры:*</span><span class="sxs-lookup"><span data-stu-id="7d35b-221">*Examples:*</span></span>
  - <span data-ttu-id="7d35b-222">Имя операции `_Features` указывает на функцию, которая является закрытой для данного пространства имен и сборки, и должна сопровождаться либо `internal` ключевым словом.</span><span class="sxs-lookup"><span data-stu-id="7d35b-222">The operation name `_Features` indicates a function that is   private to a given namespace and assembly, and should be   accompanied by either the `internal` keyword.</span></span>

- <span data-ttu-id="7d35b-223">✅ В редких случаях, когда для реализации API для данного пространства имен требуется обширный набор закрытых функций или операций **, поместите их** в новое пространство имен, соответствующее реализуемому пространству имен и концу `.Private` .</span><span class="sxs-lookup"><span data-stu-id="7d35b-223">✅ In the rare case that an extensive set of private functions or operations are needed to implement the API for a given namespace, **DO** place them in a new namespace matching the namespace being implemented and ending in `.Private`.</span></span>

- <span data-ttu-id="7d35b-224">✅**Разместите все** модульные тесты в пространствах имен, соответствующие тестируемому пространству имен и заканчивая в `.Tests` .</span><span class="sxs-lookup"><span data-stu-id="7d35b-224">✅ **DO** place all unit tests into namespaces matching the     namespace under test and ending in `.Tests`.</span></span>

## <a name="naming-conventions-and-vocabulary"></a><span data-ttu-id="7d35b-225">Соглашения об именовании и словарь</span><span class="sxs-lookup"><span data-stu-id="7d35b-225">Naming Conventions and Vocabulary</span></span>

<span data-ttu-id="7d35b-226">**Основной принцип:** Выберите имена и терминологию, которые понятны, доступны и могут быть доступны для чтения в различных аудиториях, в том числе от двух и экспертов.</span><span class="sxs-lookup"><span data-stu-id="7d35b-226">**Key principle:** Choose names and terminology that are clear, accessible, and readable across a diverse range of audiences, including both quantum novices and experts.</span></span>

- <span data-ttu-id="7d35b-227">⛔️ **не** следует использовать имена идентификаторов-дискриминатор и исключаемого идентификатора, а также терминологию в комментариях к документации по API.</span><span class="sxs-lookup"><span data-stu-id="7d35b-227">⛔️ **DON'T** use discriminatory or exclusionary identifier names,   nor terminology in API documentation comments.</span></span>

- <span data-ttu-id="7d35b-228">✅**Используйте комментарии** к документации по API для предоставления соответствующего контекста, примеров и ссылок, особенно для более сложных концепций.</span><span class="sxs-lookup"><span data-stu-id="7d35b-228">✅ **DO** use API documentation comments to provide relevant   context, examples, and references, especially for more difficult   concepts.</span></span>

- <span data-ttu-id="7d35b-229">⛔️ **не** используйте имена идентификаторов, которые необязательно изотерических или требуют значительных знаний для чтения.</span><span class="sxs-lookup"><span data-stu-id="7d35b-229">⛔️ **DON'T** use identifier names that are unnecessarily esoteric,   or that require significant quantum algorithms knowledge to   read.</span></span>

  <span data-ttu-id="7d35b-230">*Примеры:*</span><span class="sxs-lookup"><span data-stu-id="7d35b-230">*Examples:*</span></span>
  - <span data-ttu-id="7d35b-231">Предпочитать "итерации" для усиления амплитуды "Гровер итерации".</span><span class="sxs-lookup"><span data-stu-id="7d35b-231">Prefer "amplitude amplification iteration" to "Grover   iteration."</span></span>

- <span data-ttu-id="7d35b-232">✅**Выберите операции** и имена функций, которые четко сообщают о предполагаемом действии вызываемого, а не его реализации.</span><span class="sxs-lookup"><span data-stu-id="7d35b-232">✅ **DO** choose operations and function names that clearly communicate the intended effect of a callable, and not its implementation.</span></span> <span data-ttu-id="7d35b-233">Обратите внимание, что реализацию можно и следует документировать в [комментариях к документации по API](xref:microsoft.quantum.guide.filestructure#documentation-comments).</span><span class="sxs-lookup"><span data-stu-id="7d35b-233">Note that the implementation can and should be documented in [API documentation comments](xref:microsoft.quantum.guide.filestructure#documentation-comments).</span></span>

  <span data-ttu-id="7d35b-234">*Примеры:*</span><span class="sxs-lookup"><span data-stu-id="7d35b-234">*Examples:*</span></span>
  - <span data-ttu-id="7d35b-235">Поменяйте "перекрытие оценок" на "Хадамард Test", так как в последнем случае происходит реализация предыдущего.</span><span class="sxs-lookup"><span data-stu-id="7d35b-235">Prefer "estimate overlap" to "Hadamard test," as the latter   communicates how the former is implemented.</span></span>

- <span data-ttu-id="7d35b-236">✅**Используйте слова** согласованно во всех \# API Q:</span><span class="sxs-lookup"><span data-stu-id="7d35b-236">✅ **DO** use words in a consistent fashion across all Q\# APIs:</span></span>

  - <span data-ttu-id="7d35b-237">**Команды**</span><span class="sxs-lookup"><span data-stu-id="7d35b-237">**Verbs:**</span></span>

    - <span data-ttu-id="7d35b-238">**Assert**: Убедитесь, что предположение о состоянии целевого компьютера и его Кубитс содержит, возможно, с помощью нефизических ресурсов.</span><span class="sxs-lookup"><span data-stu-id="7d35b-238">**Assert**: Check that an assumption about the state of a target machine and its qubits holds, possibly by using unphysical resources.</span></span> <span data-ttu-id="7d35b-239">Операции, использующие эту команду, всегда должны быть безопасно съемными, не влияя на функциональность библиотек и исполняемых программ.</span><span class="sxs-lookup"><span data-stu-id="7d35b-239">Operations using this verb should always be safely removable without affecting the functionality of libraries and executable programs.</span></span> <span data-ttu-id="7d35b-240">Обратите внимание, что в отличие от фактов, утверждения могут, в общем, зависеть от внешнего состояния, такого как состояние регистра кубит, среды выполнения или так далее.</span><span class="sxs-lookup"><span data-stu-id="7d35b-240">Note that unlike facts, assertions may, in general, depend on external state, such as the state of a qubit register, the run environment or so forth.</span></span> <span data-ttu-id="7d35b-241">Как зависимость от внешнего состояния является разновидностью побочного действия, утверждения должны предоставляться как операции, а не функции.</span><span class="sxs-lookup"><span data-stu-id="7d35b-241">As dependency on external state is a kind of side effect, assertions must be exposed as operations rather than functions.</span></span>

    - <span data-ttu-id="7d35b-242">**Оценка**. используя одно или несколько возможных повторных измерений, оцените классический объем из результатов измерения.</span><span class="sxs-lookup"><span data-stu-id="7d35b-242">**Estimate**: Using one or more possibly repeated   measurements, estimate a classical quantity from   measurement results.</span></span>

      <span data-ttu-id="7d35b-243">*Примеры:*</span><span class="sxs-lookup"><span data-stu-id="7d35b-243">*Examples:*</span></span>
      - @"microsoft.quantum.characterization.estimatefrequency"
      - @"microsoft.quantum.characterization.estimateoverlapbetweenstates"

    - <span data-ttu-id="7d35b-244">**Подготовка**: применение операции-такта или последовательности операций к одному или нескольким Кубитс предполагается начать в определенном начальном состоянии (обычно $ \ket{00\cdots 0} $), что приводит к развитию состояния этих Кубитс до желаемого конечного состояния.</span><span class="sxs-lookup"><span data-stu-id="7d35b-244">**Prepare**: Apply a quantum operation or sequence of operations to one or more qubits assumed to start in a particular initial state (typically $\ket{00\cdots 0}$), causing the state of those qubits to evolve to a desired end state.</span></span> <span data-ttu-id="7d35b-245">Как правило, работа с состояниями, отличными от заданного начального состояния, **может** привести к неопределенному единому преобразованию, но **должно** сохранить операцию и ее смежное "Отмена" и применить оператор No-Op.</span><span class="sxs-lookup"><span data-stu-id="7d35b-245">In general, acting on states other than the given starting state **MAY** result in an undefined unitary transformation, but **SHOULD** still preserve that an operation and its adjoint "cancel out" and apply a no-op.</span></span>

      <span data-ttu-id="7d35b-246">*Примеры:*</span><span class="sxs-lookup"><span data-stu-id="7d35b-246">*Examples:*</span></span>
      - @"microsoft.quantum.preparation.preparearbitrarystate"
      - @"microsoft.quantum.preparation.prepareuniformsuperposition"

    - <span data-ttu-id="7d35b-247">**Мера**: применение операции-такта или последовательности операций к одному или нескольким Кубитс, чтение классических данных.</span><span class="sxs-lookup"><span data-stu-id="7d35b-247">**Measure**: Apply a quantum operation or sequence of   operations to one or more qubits, reading classical data   back out.</span></span>

      <span data-ttu-id="7d35b-248">*Примеры:*</span><span class="sxs-lookup"><span data-stu-id="7d35b-248">*Examples:*</span></span>
      - @"microsoft.quantum.intrinsic.measure"
      - @"microsoft.quantum.arithmetic.measurefxp"
      - @"microsoft.quantum.arithmetic.measureinteger"

    - <span data-ttu-id="7d35b-249">**Применение**: применение операции-такта или последовательности операций к одному или нескольким Кубитс, в результате чего состояние этих Кубитс меняется в согласованном виде.</span><span class="sxs-lookup"><span data-stu-id="7d35b-249">**Apply**: Apply a quantum operation or sequence of operations to one or more qubits, causing the state of those qubits to change in a coherent fashion.</span></span> <span data-ttu-id="7d35b-250">Эта команда является наиболее общей командой в элементе Q \# , и ее **не следует** использовать, если более конкретная команда более релевантна напрямую.</span><span class="sxs-lookup"><span data-stu-id="7d35b-250">This verb is the most general verb in Q\# nomenclature, and **SHOULD NOT BE** used when a more specific verb is more directly relevant.</span></span>

  - <span data-ttu-id="7d35b-251">**Существительные**:</span><span class="sxs-lookup"><span data-stu-id="7d35b-251">**Nouns**:</span></span>

    - <span data-ttu-id="7d35b-252">**Факт**. логическое условие, которое зависит только от входных данных, а не от состояния целевого компьютера, его среды или состояния кубитса компьютера.</span><span class="sxs-lookup"><span data-stu-id="7d35b-252">**Fact**: A Boolean condition which depends only on its inputs and not on the state of a target machine, its environment, or the state of the machine's qubits.</span></span> <span data-ttu-id="7d35b-253">В отличие от утверждения, факт учитывает только *значения* , предоставленные для этого факта.</span><span class="sxs-lookup"><span data-stu-id="7d35b-253">By contrast with an assertion, a fact is only sensitive to the *values* provided to that fact.</span></span> <span data-ttu-id="7d35b-254">Пример:</span><span class="sxs-lookup"><span data-stu-id="7d35b-254">For example:</span></span>

      <span data-ttu-id="7d35b-255">*Примеры:*</span><span class="sxs-lookup"><span data-stu-id="7d35b-255">*Examples:*</span></span>
      - <span data-ttu-id="7d35b-256">@"microsoft.quantum.diagnostics.equalityfacti": представляет факт равенства для двух целочисленных значений. либо целые числа, указанные в качестве входных данных, равны друг другу, либо они не зависят от других состояний программы.</span><span class="sxs-lookup"><span data-stu-id="7d35b-256">@"microsoft.quantum.diagnostics.equalityfacti": represents an equality fact about two integer inputs; either the integers provided as input are equal to each other, or they are not, independent of any other program state.</span></span>

    - <span data-ttu-id="7d35b-257">**Параметры:** Определяемый пользователем тип, содержащий несколько именованных элементов, которые могут действовать как "необязательные аргументы" для функции или операции.</span><span class="sxs-lookup"><span data-stu-id="7d35b-257">**Options:** A UDT containing several named items that can act as "optional arguments" to a function or operation.</span></span> <span data-ttu-id="7d35b-258">Пример:</span><span class="sxs-lookup"><span data-stu-id="7d35b-258">For example:</span></span>

      <span data-ttu-id="7d35b-259">*Примеры:*</span><span class="sxs-lookup"><span data-stu-id="7d35b-259">*Examples:*</span></span>
      - <span data-ttu-id="7d35b-260">@"microsoft.quantum.machinelearning.trainingoptions"Определяемый пользователем тип включает именованные элементы для обучения, размер уменьшив и другие настраиваемые параметры для машинного обучения.</span><span class="sxs-lookup"><span data-stu-id="7d35b-260">The @"microsoft.quantum.machinelearning.trainingoptions" UDT includes named items for learning rate, minibatch size, and other configurable parameters for ML training.</span></span>

  - <span data-ttu-id="7d35b-261">**Прилагательные**:</span><span class="sxs-lookup"><span data-stu-id="7d35b-261">**Adjectives**:</span></span>

    - <span data-ttu-id="7d35b-262">⛔️ **New**: этот Прилагательный **не следует** использовать, как, чтобы избежать путаницы с его использованием в качестве глагола во многих языках программирования (например, C++, C#, Java, TypeScript, PowerShell).</span><span class="sxs-lookup"><span data-stu-id="7d35b-262">⛔️ **New**: This adjective **SHOULD NOT** be used, as to avoid confusion   with its usage as a verb in many   programming languages (e.g.: C++, C#, Java, TypeScript, PowerShell).</span></span>

  - <span data-ttu-id="7d35b-263">**Предположении:** В некоторых случаях можно использовать варианты размещения для дальнейшей неоднозначности или уточнения ролей существительных и глаголов в именах функций и операций.</span><span class="sxs-lookup"><span data-stu-id="7d35b-263">**Prepositions:** In some cases, prepositions can be used to further disambiguate or clarify the roles of nouns and verbs in function and operation names.</span></span> <span data-ttu-id="7d35b-264">Однако следует соблюдать осторожность, чтобы сделать это экономно и постоянно.</span><span class="sxs-lookup"><span data-stu-id="7d35b-264">Care should be taken to do so sparingly and consistently, however.</span></span>

    - <span data-ttu-id="7d35b-265">**Как:** Представляет, что входные и выходные данные функции представляют одни и те же сведения, но выходные данные представляют эту информацию **как** *X* , а не исходное представление.</span><span class="sxs-lookup"><span data-stu-id="7d35b-265">**As:** Represents that a function's input and output represent the same information, but that the output represents that information **as** an *X* instead of its original representation.</span></span> <span data-ttu-id="7d35b-266">Это особенно распространено для функций преобразования типов.</span><span class="sxs-lookup"><span data-stu-id="7d35b-266">This is especially common for type conversion functions.</span></span>

      <span data-ttu-id="7d35b-267">*Примеры:*</span><span class="sxs-lookup"><span data-stu-id="7d35b-267">*Examples:*</span></span>
      - <span data-ttu-id="7d35b-268">`IntAsDouble(2)` Указывает, что входные ( `2` ) и выходные ( `2.0` ) представляют качественно одинаковую информацию, но для этого используются различные \# типы данных Q.</span><span class="sxs-lookup"><span data-stu-id="7d35b-268">`IntAsDouble(2)` indicates that both the input (`2`) and the output (`2.0`)   represent qualitatively the same information, but using   different Q\# data types to do so.</span></span>

    - <span data-ttu-id="7d35b-269">**Из:** Чтобы обеспечить согласованность, эту позицию   **не следует** использовать для указания функций преобразования типов или любого другого случая **,** где подходит.</span><span class="sxs-lookup"><span data-stu-id="7d35b-269">**From:** To ensure consistency, this preposition   **SHOULD NOT** be used to indicate type conversion   functions or any other case where **As** is appropriate.</span></span>

    - <span data-ttu-id="7d35b-270">⛔️ **:** **не следует** использовать эту возможность, как во многих языках программирования, чтобы избежать путаницы с ее использованием в качестве глагола.</span><span class="sxs-lookup"><span data-stu-id="7d35b-270">⛔️ **To:** This preposition **SHOULD NOT** be used, as to   avoid confusion with its usage as a verb in many   programming languages.</span></span>
