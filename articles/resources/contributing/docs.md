---
title: Дополнение к документации по Microsoft КДК
description: Узнайте, как вносить концептуальные материалы или содержимое API в набор документации по Microsoft тактов.
author: cgranade
ms.author: chgranad
ms.date: 10/12/2018
ms.topic: contributor-guide
uid: microsoft.quantum.contributing.docs
no-loc:
- Q#
- $$v
ms.openlocfilehash: 8602705d2dd071e822e2ff58a9a44cd0684f77f1
ms.sourcegitcommit: 71605ea9cc630e84e7ef29027e1f0ea06299747e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/26/2021
ms.locfileid: "98857361"
---
# <a name="improving-documentation"></a>Улучшение документации

Документация по пакету разработки тактовой задержки принимает несколько различных форм, что позволяет разработчикам тактов получить доступ к информации.

Следуя принципам работы с [документами в качестве кода](https://www.writethedocs.org/guide/docs-as-code/), вся документация по пакету разработки такта форматируется как код и управляется с помощью Git так же, как и исходный код, используемый для создания пакета разработки тактов.
В большинстве случаев резервная документация по коду состоит из различных форм [Markdown](https://daringfireball.net/projects/markdown/), языка для написания форматированного текста в виде обычного текста, который легко использовать в командной строке, в IDE и в системе управления версиями.
Мы также используем библиотеку [масжакс](https://www.mathjax.org/) , чтобы обеспечить форматирование математики в документации с помощью языка LaTeX, как описано ниже.


С другой стороны, каждая форма документации немного различается в деталях:

- **Основная документация** состоит из набора статей, опубликованных в https://docs.microsoft.com/quantum , и которые описывают все, от основ тактовых вычислений до технических спецификаций для форматов обмена. Эти статьи написаны на [DocFX Markdown (DFM)](https://dotnet.github.io/docfx/spec/docfx_flavored_markdown.html), Markdown вариант, используемый для создания обширных наборов документации.
- **Справочник по API** — это набор страниц для каждой Q# функции, операции и определяемого пользователем типа, опубликованный в https://docs.microsoft.com/qsharp/api/ . Эти страницы задокументированы входы и операции для каждого вызова, а также примеры и ссылки на дополнительные сведения. Справочник по API автоматически извлекается из небольших DFM документов в Q# исходном коде в составе каждого выпуска.
- Файлы **readme <!----> . md** , включенные в каждый пример и Ката, описывают, как использовать этот пример или Ката, что он охватывает и как он связан с остальной частью пакета средств разработки тактов. Эти файлы пишутся с помощью [GitHub Markdown (GFM)](https://github.github.com/gfm/), более простой альтернативы DFM, который часто используется для присоединения документации непосредственно к репозиториям кода.

## <a name="contributing-to-the-conceptual-documentation"></a>Вклад в концептуальную документацию

Чтобы внести улучшения в общую документацию или документация с файлами сведений, следует начать с запроса на вытягивание в [**MicrosoftDocs/такт-куантумкатас-PR**](https://github.com/MicrosoftDocs/quantum-docs-pr/
), [**Microsoft/такт**](https://github.com/Microsoft/Quantum)или [**Microsoft/**](https://github.com/Microsoft/QuantumKatas).
Мы подробно расскажем о запросах на вытягивание, но для этого у нас есть несколько вещей, которые следует учитывать при улучшении документации:

- Читатели поставляются в документацию по пакету разработки тактов из самых широкого спектра фоновых рисунков. Все пользователи из старших учебных заведений, которые узнают о новых возможностях просмотрим факультета, выполняющего исследование тактовых вычислений, должны иметь возможность избавиться от необходимости читать документацию. В то же время вы можете не получать обширных знаний о части читателей, так как они могут быть просто запущены. Это наиболее полезно, если вы можете предоставить четкие и доступные описания или предоставить ссылки на другие ресурсы для получения дополнительных сведений.
- Наборы документации не размещаются в виде книг или документов, в том, что читатели будут поступать на то, что может показаться «средней». Например, поисковые системы могут не предлагать индекс, или же они могли бы отправить ссылку друг на друга. Постарайтесь помочь вашему читателю, всегда предоставляя понятный контекст и ссылки там, где это необходимо.
- Некоторые читатели найдут наиболее полезные абстрактные операторы и определения, а другие читатели лучше всего работают путем экстраполяции из конкретных примеров. Как общий случай, так и конкретные примеры могут помочь читателям максимально эффективно программировать такты.
- В особенности, если вы также написали задокументированный код, некоторые из них могут быть очевидны, что не все очевидны для читателя. Нет ни одного уникального способа программирования, так что независимо от того, насколько разумны или опытные читатели не могут быть, они не могут предположить, какие шаблоны проектирования вы нашли наиболее полезными для выражения идей в коде. Ясно, как читатель может использовать ваш код, чтобы предоставить этот контекст.
- Многие члены сообщества по программированию тактов — это научные судебные работы, которые распознаются главным образом посредством ссылок для их вклада в сообщество. Помимо того, чтобы помочь читателям найти дополнительные материалы, убедитесь, что они должным образом заключить такие выводы, как документы, обсуждения, записи в блоге и программные средства, которые помогут участникам, чтобы помочь пользователям улучшить сообщество.
- Сообщество по программированию тактов — это широкое и замечательное сообщество. Использование Пол-существительных в примерах третьих лиц (например, "Если пользователь..."... ") может работать с исключением, а не включать. Компания cognizant имена людей в ссылках и ссылки, а правильное включение символов, отличных от ASCII, может привести к разнообразию сообщества, показывая о его членах. Аналогичным образом, многие слова на английском языке часто используются хатефул способом, поэтому их использование в технической документации может привести к тому, что они будут нести вред отдельным читателям и сообществу в целом.

### <a name="referencing-sample-code-from-conceptual-articles"></a>Создание ссылок на примеры кода из концептуальных статей

Если вы хотите включить код из [репозитория Samples](https://github.com/Microsoft/Quantum), это можно сделать с помощью специальной команды DocFX-Flavored Markdown:

```markdown
:::code language="qsharp" source="~/quantum/samples/algorithms/chsh-game/Game.qs" range="4-8":::
```

Эта команда импортирует строки 4 – 8 [ `Game.qs` файла из `chsh-game` примера](https://github.com/microsoft/Quantum/blob/main/samples/algorithms/chsh-game/Game.qs), помечая их как Q# код для выделения синтаксиса.
С помощью этой команды можно избежать дублирования кода между концептуальными статьями и репозиторием примеров, чтобы образец кода в документации всегда был как можно более актуальным.

### <a name="contributing-image-files"></a>Файлы изображений, участвующие в файлах

**Важно**. для правильного отображения изображений в темном режиме необходимо избегать прозрачности.

- Для JPG файлов. не нужно ничего делать, так как формат jpg не поддерживает прозрачные элементы.
- Для PNG-файлов необходимо добавить белый фон или изменить значение альфа-канала на **100**. Самый простой способ сделать это в Windows — открыть файл в **Paint** и сохранить его, перезаписав исходный файл.
- Для файлов. SVG необходимо добавить белый прямоугольник на самом низком слое. Это можно сделать с помощью **Inkscape**:
  1. Откройте файл. SVG.
  1. Выберите инструмент Square Maker и нарисуйте белый прямоугольник поверх исходного рисунка.
  1. Выберите инструмент **Выбор и преобразование объектов** , щелкнув кнопку с темной стрелкой или нажав клавишу **F1**.
  1. При выделении прямоугольника щелкните элемент панели инструментов **с меньшим уровнем выделения вниз (конец)**.
  1. Настройте прямоугольник с помощью мыши или клавиш со стрелками.

## <a name="contributing-to-the-api-references"></a>Дополнение к ссылкам на API

Чтобы внести улучшения в ссылки API, очень полезно открыть запрос на вытягивание непосредственно в задокументированном коде.
Каждая функция, операция или определяемый пользователем тип поддерживает комментарий к документации (обозначенный `///` вместо `//` ).
При компиляции каждого выпуска пакета средств разработки такта эти комментарии используются для создания справочника по API в https://docs.microsoft.com/qsharp/api/ , включая сведения о входах и выходных данных каждого из вызываемых функций, предположения о каждом вызываемом методе и примеры их использования.

> [!IMPORTANT]
> Не изменяйте созданную документацию по API вручную, так как эти файлы перезаписываются с каждым новым выпуском.
> Мы предлагаем вам вклад в сообщество и хотим убедиться, что изменения продолжают помочь пользователям выпустить после выпуска.

Например, рассмотрим функцию `ControlledOnBitString<'T> (bits : Bool[], oracle : ('T => Unit is Adj + Ctl)) : ((Qubit[], 'T) => Unit is Adj + Ctl)` .
Комментарий к документации должен помочь пользователю узнать, как интерпретировать `bits` и `oracle` Какова функция.
Каждый из этих частей информации может предоставляться Q# компилятору с помощью специально названного раздела Markdown в комментарии к документации.
В качестве примера `ControlledOnBitString` можно написать нечто вроде следующего:

```qsharp
 /// # Summary
 /// Returns a unitary operation that applies an oracle on the target register if the 
 /// control register state corresponds to a specified bit mask.
 ///
 /// # Description
 /// The output of this function is an operation that can be represented by a
 /// unitary transformation $U$ such that
 /// \begin{align}
 ///     U \ket{b_0 b_1 \cdots b_{n - 1}} \ket{\psi} = \ket{b_0 b_1 \cdots b_{n-1}} \otimes
 ///     \begin{cases}
 ///         V \ket{\psi} & \textrm{if} (b_0 b_1 \cdots b_{n - 1}) = \texttt{bits} \\\\
 ///         \ket{\psi} & \textrm{otherwise}
 ///     \end{cases},
 /// \end{align}
 /// where $V$ is a unitary transformation that represents the action of the
 /// `oracle` operation.
 ///
 /// # Input
 /// ## bits
 /// The bit string to control the given unitary operation on.
 /// ## oracle
 /// The unitary operation to be applied on the target register.
 ///
 /// # Output
 /// A unitary operation that applies `oracle` on the target register if the control 
 /// register state corresponds to the bit mask `bits`.
 ///
 /// # Remarks
 /// The length of `bits` and `controlRegister` must be equal.
 ///
 /// Given a Boolean array `bits` and a unitary operation `oracle`, the output of this function
 /// is an operation that performs the following steps:
 /// * apply an `X` operation to each qubit of the control register that corresponds to `false` 
 /// element of the `bits`;
 /// * apply `Controlled oracle` to the control and target registers;
 /// * apply an `X` operation to each qubit of the control register that corresponds to `false` 
 /// element of the `bits` again to return the control register to the original state.
 ///
 /// The output of the `Controlled` functor is a special case of `ControlledOnBitString` where `bits` is equal to `[true, ..., true]`.
 ///
 /// # Example
 /// The following code snippets are equivalent:
 /// ```qsharp
 /// (ControlledOnBitString(bits, oracle))(controlRegister, targetRegister);
 /// ```
 /// and
 /// ```qsharp
 /// within {
 ///     ApplyPauliFromBitString(PauliX, false, bits, controlRegister);
 /// } apply {
 ///     Controlled oracle(controlRegister, targetRegister);
 /// }
 /// ```
 ///
 /// The following code prepares a state $\frac{1}{2}(\ket{00} - \ket{01} + \ket{10} + \ket{11})$:
 /// ```qsharp
 /// using (register = Qubit[2]) {
 ///     ApplyToEach(H, register);
 ///     (ControlledOnBitString([false], Z))(register[0..0], register[1]);
 /// }
 /// ```
 function ControlledOnBitString<'T> (bits : Bool[], oracle : ('T => Unit is Adj + Ctl)) : ((Qubit[], 'T) => Unit is Adj + Ctl)
 {
     return ControlledOnBitStringImpl(bits, oracle, _, _);
 }
```

Отображаемую версию кода, приведенную выше, можно увидеть в [документации по API для `ControlledOnBitString` функции](xref:Microsoft.Quantum.Canon.ControlledOnBitString).

В дополнение к общей практике написания документации по написанию комментариев к документации по API он помогает в уме некоторые моменты.

- Формат каждого комментария документации должен совпадать с тем, что Q# компилятор ожидает, чтобы документация отображалась правильно. Некоторые разделы, например, `/// # Remarks` позволяют использовать произвольное содержимое, а такие разделы, как, `/// # See Also` являются более узкими.
- Читатель может прочитать документацию по API на основном эталонном сайте API, сводку по каждому пространству имен или даже в интегрированной среде разработки, используя сведения о наведении указателя мыши. Проверка того, что `/// # Summary` не больше, чем предложение, помогает читателям быстро отсортировать информацию о том, нужно ли читать их дальше или искать в других местах, а также быстро просматривать сводки пространств имен.
- Ваша документация может быть хорошо занимать намного больше времени, чем сам код, но это нормально! Даже небольшой фрагмент кода может иметь неожиданные последствия для пользователей, которые не узнают контекст, в котором существует код. Предоставляя конкретные примеры и четкие объяснения, пользователи могут помочь пользователям лучше использовать код, доступный для них.

<!-- ## LaTeX Formatting ##

**TODO** -->
