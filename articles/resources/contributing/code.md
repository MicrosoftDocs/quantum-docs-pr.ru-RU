---
title: Дополнение кода к Microsoft КДК
description: Сведения о том, как внести пример и код библиотеки в Microsoft Quantum Development Kit (КДК).
author: cgranade
ms.author: chgranad
ms.date: 10/12/2018
ms.topic: article
uid: microsoft.quantum.contributing.code
ms.openlocfilehash: edc52dc4434e91258bece28812fd76b66329c6f9
ms.sourcegitcommit: 0181e7c9e98f9af30ea32d3cd8e7e5e30257a4dc
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/23/2020
ms.locfileid: "85275484"
---
# <a name="contributing-code"></a>Участие в написании кода

Помимо составления отчетов о проблемах и улучшения документации, Добавление кода в пакет разработки тактов может быть очень прямым способом помочь вашим коллегам в сообществе разработчиков тактов.
Добавив код, вы можете помочь устранить проблемы, предоставить новые примеры, упростить использование существующих библиотек или даже добавить совершенно новые функции.

В этом пошаговом окне мы подробно рассмотрим, что мы будем искать при просмотре запросов на вытягивание, чтобы помочь вашему участию.

## <a name="what-we-look-for"></a>Что мы будем искать

Идеальная публикация кода основана на существующей работе в репозитории пакета разработки такта для устранения проблем, расширения существующих функций или добавления новых функций, которые находятся в области репозитория.
Принимая участие в написании кода, он становится частью самого пакета разработки такта, поэтому новые функции будут выпущены, сохранены и разработаны так же, как и остальные компоненты пакета разработки тактов.
Таким образом, это полезно при тщательном тестировании функциональности, добавленной в публикацию, и документированной.

### <a name="unit-tests"></a>Модульные тесты

Функции Q #, операции и определяемые пользователем типы, составляющие библиотеки, такие как Canon, автоматически тестируются как часть разработки в репозитории [**Microsoft/куантумлибрариес**](https://github.com/Microsoft/QuantumLibraries/) .
Например, при открытии нового запроса на вытягивание [Azure pipelines](https://azure.microsoft.com/services/devops/pipelines/) конфигурация будет проверять, что изменения в запросе на вытягивание не нарушают существующие функциональные возможности, от которых зависит сообщество программирования тактов.

С последней версией Q # модульный тест определяется с помощью `@Test("QuantumSimulator")` атрибута. Аргумент может иметь значение "Куантумсимулатор", "Тоффолисимулатор", "Трацесимулатор" или любое полное имя, указывающее цель выполнения. Несколько атрибутов, определяющих различные цели выполнения, могут быть присоединены к одному и тому же вызываемому объекту. Некоторые из наших тестов по-прежнему используют устаревший пакет [Microsoft. тактов. xUnit](https://www.nuget.org/packages/Microsoft.Quantum.Xunit/) , который предоставляет все функции и операции Q #, которые заканчиваются на `Test` платформу [xUnit](https://xunit.github.io/) . Этот пакет больше не требуется для определения модульных тестов. 

Следующая функция используется для того, чтобы <xref:microsoft.quantum.canon.fst> <xref:microsoft.quantum.canon.snd> функции и возвращали правильные выходные данные в репрезентативном примере.
Если выходные данные `Fst` или `Snd` являются неправильными, `fail` используется инструкция, которая вызывает сбой теста.

```qsharp
@Test("QuantumSimulator")
function PairTest () : Unit {
    let pair = (12, PauliZ);

    if (Fst(pair) != 12) {
        let actual = Fst(pair);
        fail $"Expected 12, actual {actual}.";
    }

    if (Snd(pair) != PauliZ) {
        let actual = Snd(pair);
        fail $"Expected PauliZ, actual {actual}.";
    }
}
```

Более сложные условия можно проверить с помощью методик, описанных в [разделе "тестирование](xref:microsoft.quantum.libraries.diagnostics) " в руководству стандартных библиотек.
Например, следующий тест проверяет, что, `H(q); X(q); H(q);` как вызвано, <xref:microsoft.quantum.canon.applywith> выполняет то же самое, что и `Z(q)` .

```Q#
@Test("QuantumSimulator")
operation TestApplyWith() : Unit {
    let actual = ApplyWith(H, X, _);
    let expected = Z;
    AssertOperationsEqualReferenced(ApplyToEach(actual, _), ApplyToEachA(expected, _), 4);
}
```

При добавлении новых функций рекомендуется также добавить новые тесты, чтобы убедиться, что ваша публикация делает то, что он должен.
Это помогает остальным участникам сообщества поддерживать и разрабатывать свои функции, и в частности помогает другим разработчикам понять, что они могут полагаться на вашу функцию.

> [!NOTE]
> Это работает и в других случаях.
> Если у вас есть функция, которая не содержит некоторых тестов, мы можем добавить покрытие тестирования, чтобы сделать его полезным для сообщества.

Модульные тесты можно выполнять локально, с помощью обозревателя тестов Visual Studio или `dotnet test` команды, чтобы можно было проверить публикацию перед открытием запроса на вытягивание.

<!-- TODO:
### Comments and Documentation ###

### Citations and References ### -->


## <a name="when-well-reject-a-pull-request"></a>Когда мы отклоним запрос на вытягивание

Иногда мы отклоним запрос на вытягивание для вклада.
Если это произойдет, это не значит, что оно плохо, так как существует ряд причин, по которым мы не можем принять конкретную публикацию.
Возможно, чаще всего вклад в сообщество по программированию тактов является действительно хорошим, но репозитории комплекта для разработки тактов не подходят для разработки.
В таких случаях мы настоятельно рекомендуем сделать собственный репозиторий---частью надежности пакета средств разработки тактов, что позволяет легко создавать и распространять собственные библиотеки с помощью GitHub и NuGet.org, аналогично распространению библиотек Canon и химия на сегодняшний день.

В других случаях мы можем отклонить хороший вклад, просто потому, что мы еще не готовы поддерживать и разрабатывать ее.
Это может быть затруднительно, так что мы планируем, какие функции лучше использовать в качестве стратегии.
Это может быть другой случай, когда возможность выпуска функции в качестве сторонней библиотеки может быть очень осмысленной.
Кроме того, мы можем попросить помочь вам в изменении функции, чтобы она лучше соответствовала нашему плану, чтобы мы могли выполнить оптимальную работу с ней.

Кроме того, мы будем запрашивать изменения в запросе на вытягивание, если ему требуется дополнительная документация или модульные тесты, чтобы помочь нам в его использовании, или, если она достаточно велика в стиле из остальных библиотек Q #, чтобы пользователи не могли найти вашу функцию.
В этих случаях мы попытаемся предложить некоторые рекомендации по проверке кода о том, что можно добавить или изменить, чтобы упростить добавление изменений в публикацию.

Наконец, мы не можем принять вклады, которые могут нанести вред сообществу для вычисления тактовой задержки, как описано в [кодексе поведения Microsoft с открытым исходным кодом](https://opensource.microsoft.com/codeofconduct/).
Мы хотим обеспечить, чтобы вклады обслужили все сообщество вычислительных вычислений, как в текущем замечательном разнородном мире, так и в будущем, так как он становится еще более широким.
Мы ценим вашу помощь в реализации этой цели.

## <a name="next-steps"></a>Дальнейшие действия

Благодарим за помощь в создании пакета разработки такта — отличного ресурса для всего сообщества по программированию на такт!
Чтобы узнать больше, перейдите к следующему руководству по стилю Q #.

> [!div class="nextstepaction"]
> [Дополнительные сведения о рекомендациях по стилю Q #](xref:microsoft.quantum.contributing.style)

В зависимости от типа кода, который вы создаете, могут возникнуть дополнительные вещи, которые помогут сделать публикацию максимально хорошей для сообщества.

> [!div class="nextstepaction"]
> [Дополнительные сведения о участвующих примерах](xref:microsoft.quantum.contributing.samples)
